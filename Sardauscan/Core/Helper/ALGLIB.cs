using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace Sardauscan.Core.Helper
{
	#region alglib
	public partial class alglib
	{
		/********************************************************************
		Callback definitions for optimizers/fitters/solvers.
    
		Callbacks for unparameterized (general) functions:
		* ndimensional_func         calculates f(arg), stores result to func
		* ndimensional_grad         calculates func = f(arg), 
																grad[i] = df(arg)/d(arg[i])
		* ndimensional_hess         calculates func = f(arg),
																grad[i] = df(arg)/d(arg[i]),
																hess[i,j] = d2f(arg)/(d(arg[i])*d(arg[j]))
    
		Callbacks for systems of functions:
		* ndimensional_fvec         calculates vector function f(arg),
																stores result to fi
		* ndimensional_jac          calculates f[i] = fi(arg)
																jac[i,j] = df[i](arg)/d(arg[j])
                                
		Callbacks for  parameterized  functions,  i.e.  for  functions  which 
		depend on two vectors: P and Q.  Gradient  and Hessian are calculated 
		with respect to P only.
		* ndimensional_pfunc        calculates f(p,q),
																stores result to func
		* ndimensional_pgrad        calculates func = f(p,q),
																grad[i] = df(p,q)/d(p[i])
		* ndimensional_phess        calculates func = f(p,q),
																grad[i] = df(p,q)/d(p[i]),
																hess[i,j] = d2f(p,q)/(d(p[i])*d(p[j]))

		Callbacks for progress reports:
		* ndimensional_rep          reports current position of optimization algo    
    
		Callbacks for ODE solvers:
		* ndimensional_ode_rp       calculates dy/dx for given y[] and x
    
		Callbacks for integrators:
		* integrator1_func          calculates f(x) for given x
																(additional parameters xminusa and bminusx
																contain x-a and b-x)
		********************************************************************/
		public delegate void ndimensional_func(double[] arg, ref double func, object obj);
		public delegate void ndimensional_grad(double[] arg, ref double func, double[] grad, object obj);
		public delegate void ndimensional_hess(double[] arg, ref double func, double[] grad, double[,] hess, object obj);

		public delegate void ndimensional_fvec(double[] arg, double[] fi, object obj);
		public delegate void ndimensional_jac(double[] arg, double[] fi, double[,] jac, object obj);

		public delegate void ndimensional_pfunc(double[] p, double[] q, ref double func, object obj);
		public delegate void ndimensional_pgrad(double[] p, double[] q, ref double func, double[] grad, object obj);
		public delegate void ndimensional_phess(double[] p, double[] q, ref double func, double[] grad, double[,] hess, object obj);

		public delegate void ndimensional_rep(double[] arg, double func, object obj);

		public delegate void ndimensional_ode_rp(double[] y, double x, double[] dy, object obj);

		public delegate void integrator1_func(double x, double xminusa, double bminusx, ref double f, object obj);

		/********************************************************************
		Class defining a complex number with double precision.
		********************************************************************/
		public struct complex
		{
			public double x;
			public double y;

			public complex(double _x)
			{
				x = _x;
				y = 0;
			}
			public complex(double _x, double _y)
			{
				x = _x;
				y = _y;
			}
			public static implicit operator complex(double _x)
			{
				return new complex(_x);
			}
			public static bool operator ==(complex lhs, complex rhs)
			{
				return ((double)lhs.x == (double)rhs.x) & ((double)lhs.y == (double)rhs.y);
			}
			public static bool operator !=(complex lhs, complex rhs)
			{
				return ((double)lhs.x != (double)rhs.x) | ((double)lhs.y != (double)rhs.y);
			}
			public static complex operator +(complex lhs)
			{
				return lhs;
			}
			public static complex operator -(complex lhs)
			{
				return new complex(-lhs.x, -lhs.y);
			}
			public static complex operator +(complex lhs, complex rhs)
			{
				return new complex(lhs.x + rhs.x, lhs.y + rhs.y);
			}
			public static complex operator -(complex lhs, complex rhs)
			{
				return new complex(lhs.x - rhs.x, lhs.y - rhs.y);
			}
			public static complex operator *(complex lhs, complex rhs)
			{
				return new complex(lhs.x * rhs.x - lhs.y * rhs.y, lhs.x * rhs.y + lhs.y * rhs.x);
			}
			public static complex operator /(complex lhs, complex rhs)
			{
				complex result;
				double e;
				double f;
				if (System.Math.Abs(rhs.y) < System.Math.Abs(rhs.x))
				{
					e = rhs.y / rhs.x;
					f = rhs.x + rhs.y * e;
					result.x = (lhs.x + lhs.y * e) / f;
					result.y = (lhs.y - lhs.x * e) / f;
				}
				else
				{
					e = rhs.x / rhs.y;
					f = rhs.y + rhs.x * e;
					result.x = (lhs.y + lhs.x * e) / f;
					result.y = (-lhs.x + lhs.y * e) / f;
				}
				return result;
			}
			public override int GetHashCode()
			{
				return x.GetHashCode() ^ y.GetHashCode();
			}
			public override bool Equals(object obj)
			{
				if (obj is byte)
					return Equals(new complex((byte)obj));
				if (obj is sbyte)
					return Equals(new complex((sbyte)obj));
				if (obj is short)
					return Equals(new complex((short)obj));
				if (obj is ushort)
					return Equals(new complex((ushort)obj));
				if (obj is int)
					return Equals(new complex((int)obj));
				if (obj is uint)
					return Equals(new complex((uint)obj));
				if (obj is long)
					return Equals(new complex((long)obj));
				if (obj is ulong)
					return Equals(new complex((ulong)obj));
				if (obj is double)
					return Equals(new complex((double)obj));
				if (obj is double)
					return Equals(new complex((double)obj));
				if (obj is decimal)
					return Equals(new complex((double)(decimal)obj));
				return base.Equals(obj);
			}
		}

		/********************************************************************
		Class defining an ALGLIB exception
		********************************************************************/
		public class alglibexception : System.Exception
		{
			public string msg;
			public alglibexception(string s)
			{
				msg = s;
			}

		}

		/********************************************************************
		ALGLIB object, parent  class  for  all  internal  AlgoPascal  objects
		managed by ALGLIB.
    
		Any internal AlgoPascal object inherits from this class.
    
		User-visible objects inherit from alglibobject (see below).
		********************************************************************/
		public abstract class apobject
		{
			public abstract void init();
			public abstract apobject make_copy();
		}

		/********************************************************************
		ALGLIB object, parent class for all user-visible objects  managed  by
		ALGLIB.
    
		Methods:
				_deallocate()       deallocation:
														* in managed ALGLIB it does nothing
														* in native ALGLIB it clears  dynamic  memory
															being  hold  by  object  and  sets internal
															reference to null.
		********************************************************************/
		public abstract class alglibobject
		{
			public virtual void _deallocate() { }
		}

		/********************************************************************
		Deallocation of ALGLIB object:
		* in managed ALGLIB this method just sets refence to null
		* in native ALGLIB call of this method:
			1) clears dynamic memory being hold by  object  and  sets  internal
				 reference to null.
			2) sets to null variable being passed to this method
    
		IMPORTANT (1): in  native  edition  of  ALGLIB,  obj becomes unusable
									 after this call!!!  It  is  possible  to  save  a copy
									 of reference in another variable (original variable is
									 set to null), but any attempt to work with this object
									 will crash your program.
    
		IMPORTANT (2): memory ownen by object will be recycled by GC  in  any
									 case. This method just enforced IMMEDIATE deallocation.
		********************************************************************/
		public static void deallocateimmediately<T>(ref T obj) where T : alglib.alglibobject
		{
			obj._deallocate();
			obj = null;
		}

		/********************************************************************
		Allocation counter:
		* in managed ALGLIB it always returns 0 (dummy code)
		* in native ALGLIB it returns current value of the allocation counter
			(if it was activated)
		********************************************************************/
		public static long alloc_counter()
		{
			return 0;
		}

		/********************************************************************
		Activization of the allocation counter:
		* in managed ALGLIB it does nothing (dummy code)
		* in native ALGLIB it turns on allocation counting.
		********************************************************************/
		public static void alloc_counter_activate()
		{
		}

		/********************************************************************
		reverse communication structure
		********************************************************************/
		public class rcommstate : apobject
		{
			public rcommstate()
			{
				init();
			}
			public override void init()
			{
				stage = -1;
				ia = new int[0];
				ba = new bool[0];
				ra = new double[0];
				ca = new alglib.complex[0];
			}
			public override apobject make_copy()
			{
				rcommstate result = new rcommstate();
				result.stage = stage;
				result.ia = (int[])ia.Clone();
				result.ba = (bool[])ba.Clone();
				result.ra = (double[])ra.Clone();
				result.ca = (alglib.complex[])ca.Clone();
				return result;
			}
			public int stage;
			public int[] ia;
			public bool[] ba;
			public double[] ra;
			public alglib.complex[] ca;
		};

		/********************************************************************
		internal functions
		********************************************************************/
		public class ap
		{
			public static int len<T>(T[] a)
			{ return a.Length; }
			public static int rows<T>(T[,] a)
			{ return a.GetLength(0); }
			public static int cols<T>(T[,] a)
			{ return a.GetLength(1); }
			public static void swap<T>(ref T a, ref T b)
			{
				T t = a;
				a = b;
				b = t;
			}

			public static void assert(bool cond, string s)
			{
				if (!cond)
					throw new alglibexception(s);
			}

			public static void assert(bool cond)
			{
				assert(cond, "ALGLIB: assertion failed");
			}

			/****************************************************************
			returns dps (digits-of-precision) value corresponding to threshold.
			dps(0.9)  = dps(0.5f)  = dps(0.1) = 0
			dps(0.09) = dps(0.05) = dps(0.01) = 1
			and so on
			****************************************************************/
			public static int threshold2dps(double threshold)
			{
				int result = 0;
				double t;
				for (result = 0, t = 1; t / 10 > threshold * (1 + 1E-10); result++, t /= 10) ;
				return result;
			}

			/****************************************************************
			prints formatted complex
			****************************************************************/
			public static string format(complex a, int _dps)
			{
				int dps = Math.Abs(_dps);
				string fmt = _dps >= 0 ? "F" : "E";
				string fmtx = String.Format("{{0:" + fmt + "{0}}}", dps);
				string fmty = String.Format("{{0:" + fmt + "{0}}}", dps);
				string result = String.Format(fmtx, a.x) + (a.y >= 0 ? "+" : "-") + String.Format(fmty, Math.Abs(a.y)) + "i";
				result = result.Replace(',', '.');
				return result;
			}

			/****************************************************************
			prints formatted array
			****************************************************************/
			public static string format(bool[] a)
			{
				string[] result = new string[len(a)];
				int i;
				for (i = 0; i < len(a); i++)
					if (a[i])
						result[i] = "true";
					else
						result[i] = "false";
				return "{" + String.Join(",", result) + "}";
			}

			/****************************************************************
			prints formatted array
			****************************************************************/
			public static string format(int[] a)
			{
				string[] result = new string[len(a)];
				int i;
				for (i = 0; i < len(a); i++)
					result[i] = a[i].ToString();
				return "{" + String.Join(",", result) + "}";
			}

			/****************************************************************
			prints formatted array
			****************************************************************/
			public static string format(double[] a, int _dps)
			{
				int dps = Math.Abs(_dps);
				string sfmt = _dps >= 0 ? "F" : "E";
				string fmt = String.Format("{{0:" + sfmt + "{0}}}", dps);
				string[] result = new string[len(a)];
				int i;
				for (i = 0; i < len(a); i++)
				{
					result[i] = String.Format(fmt, a[i]);
					result[i] = result[i].Replace(',', '.');
				}
				return "{" + String.Join(",", result) + "}";
			}

			/****************************************************************
			prints formatted array
			****************************************************************/
			public static string format(complex[] a, int _dps)
			{
				int dps = Math.Abs(_dps);
				string fmt = _dps >= 0 ? "F" : "E";
				string fmtx = String.Format("{{0:" + fmt + "{0}}}", dps);
				string fmty = String.Format("{{0:" + fmt + "{0}}}", dps);
				string[] result = new string[len(a)];
				int i;
				for (i = 0; i < len(a); i++)
				{
					result[i] = String.Format(fmtx, a[i].x) + (a[i].y >= 0 ? "+" : "-") + String.Format(fmty, Math.Abs(a[i].y)) + "i";
					result[i] = result[i].Replace(',', '.');
				}
				return "{" + String.Join(",", result) + "}";
			}

			/****************************************************************
			prints formatted matrix
			****************************************************************/
			public static string format(bool[,] a)
			{
				int i, j, m, n;
				n = cols(a);
				m = rows(a);
				bool[] line = new bool[n];
				string[] result = new string[m];
				for (i = 0; i < m; i++)
				{
					for (j = 0; j < n; j++)
						line[j] = a[i, j];
					result[i] = format(line);
				}
				return "{" + String.Join(",", result) + "}";
			}

			/****************************************************************
			prints formatted matrix
			****************************************************************/
			public static string format(int[,] a)
			{
				int i, j, m, n;
				n = cols(a);
				m = rows(a);
				int[] line = new int[n];
				string[] result = new string[m];
				for (i = 0; i < m; i++)
				{
					for (j = 0; j < n; j++)
						line[j] = a[i, j];
					result[i] = format(line);
				}
				return "{" + String.Join(",", result) + "}";
			}

			/****************************************************************
			prints formatted matrix
			****************************************************************/
			public static string format(double[,] a, int dps)
			{
				int i, j, m, n;
				n = cols(a);
				m = rows(a);
				double[] line = new double[n];
				string[] result = new string[m];
				for (i = 0; i < m; i++)
				{
					for (j = 0; j < n; j++)
						line[j] = a[i, j];
					result[i] = format(line, dps);
				}
				return "{" + String.Join(",", result) + "}";
			}

			/****************************************************************
			prints formatted matrix
			****************************************************************/
			public static string format(complex[,] a, int dps)
			{
				int i, j, m, n;
				n = cols(a);
				m = rows(a);
				complex[] line = new complex[n];
				string[] result = new string[m];
				for (i = 0; i < m; i++)
				{
					for (j = 0; j < n; j++)
						line[j] = a[i, j];
					result[i] = format(line, dps);
				}
				return "{" + String.Join(",", result) + "}";
			}

			/****************************************************************
			checks that matrix is symmetric.
			max|A-A^T| is calculated; if it is within 1.0E-14 of max|A|,
			matrix is considered symmetric
			****************************************************************/
			public static bool issymmetric(double[,] a)
			{
				int i, j, n;
				double err, mx, v1, v2;
				if (rows(a) != cols(a))
					return false;
				n = rows(a);
				if (n == 0)
					return true;
				mx = 0;
				err = 0;
				for (i = 0; i < n; i++)
				{
					for (j = i + 1; j < n; j++)
					{
						v1 = a[i, j];
						v2 = a[j, i];
						if (!math.isfinite(v1))
							return false;
						if (!math.isfinite(v2))
							return false;
						err = Math.Max(err, Math.Abs(v1 - v2));
						mx = Math.Max(mx, Math.Abs(v1));
						mx = Math.Max(mx, Math.Abs(v2));
					}
					v1 = a[i, i];
					if (!math.isfinite(v1))
						return false;
					mx = Math.Max(mx, Math.Abs(v1));
				}
				if (mx == 0)
					return true;
				return err / mx <= 1.0E-14;
			}

			/****************************************************************
			checks that matrix is Hermitian.
			max|A-A^H| is calculated; if it is within 1.0E-14 of max|A|,
			matrix is considered Hermitian
			****************************************************************/
			public static bool ishermitian(complex[,] a)
			{
				int i, j, n;
				double err, mx;
				complex v1, v2, vt;
				if (rows(a) != cols(a))
					return false;
				n = rows(a);
				if (n == 0)
					return true;
				mx = 0;
				err = 0;
				for (i = 0; i < n; i++)
				{
					for (j = i + 1; j < n; j++)
					{
						v1 = a[i, j];
						v2 = a[j, i];
						if (!math.isfinite(v1.x))
							return false;
						if (!math.isfinite(v1.y))
							return false;
						if (!math.isfinite(v2.x))
							return false;
						if (!math.isfinite(v2.y))
							return false;
						vt.x = v1.x - v2.x;
						vt.y = v1.y + v2.y;
						err = Math.Max(err, math.abscomplex(vt));
						mx = Math.Max(mx, math.abscomplex(v1));
						mx = Math.Max(mx, math.abscomplex(v2));
					}
					v1 = a[i, i];
					if (!math.isfinite(v1.x))
						return false;
					if (!math.isfinite(v1.y))
						return false;
					err = Math.Max(err, Math.Abs(v1.y));
					mx = Math.Max(mx, math.abscomplex(v1));
				}
				if (mx == 0)
					return true;
				return err / mx <= 1.0E-14;
			}


			/****************************************************************
			Forces symmetricity by copying upper half of A to the lower one
			****************************************************************/
			public static bool forcesymmetric(double[,] a)
			{
				int i, j, n;
				if (rows(a) != cols(a))
					return false;
				n = rows(a);
				if (n == 0)
					return true;
				for (i = 0; i < n; i++)
					for (j = i + 1; j < n; j++)
						a[i, j] = a[j, i];
				return true;
			}

			/****************************************************************
			Forces Hermiticity by copying upper half of A to the lower one
			****************************************************************/
			public static bool forcehermitian(complex[,] a)
			{
				int i, j, n;
				complex v;
				if (rows(a) != cols(a))
					return false;
				n = rows(a);
				if (n == 0)
					return true;
				for (i = 0; i < n; i++)
					for (j = i + 1; j < n; j++)
					{
						v = a[j, i];
						a[i, j].x = v.x;
						a[i, j].y = -v.y;
					}
				return true;
			}
		};

		/********************************************************************
		math functions
		********************************************************************/
		public class math
		{
			//public static System.Random RndObject = new System.Random(System.DateTime.Now.Millisecond);
			public static System.Random rndobject = new System.Random(System.DateTime.Now.Millisecond + 1000 * System.DateTime.Now.Second + 60 * 1000 * System.DateTime.Now.Minute);

			public const double machineepsilon = double.Epsilon;
			public const double maxrealnumber = double.MaxValue;
			public const double minrealnumber = double.MinValue;

			public static bool isfinite(double d)
			{
				return !double.IsNaN(d) && !double.IsInfinity(d);
			}

			public static double randomreal()
			{
				double r = 0;
				lock (rndobject) { r = (double)rndobject.NextDouble(); }
				return r;
			}
			public static int randominteger(int N)
			{
				int r = 0;
				lock (rndobject) { r = rndobject.Next(N); }
				return r;
			}
			public static double sqr(double X)
			{
				return X * X;
			}
			public static double abscomplex(complex z)
			{
				double w;
				double xabs;
				double yabs;
				double v;

				xabs = System.Math.Abs(z.x);
				yabs = System.Math.Abs(z.y);
				w = xabs > yabs ? xabs : yabs;
				v = xabs < yabs ? xabs : yabs;
				if (v == 0)
					return w;
				else
				{
					double t = v / w;
					return (double)(w * System.Math.Sqrt(1 + t * t));
				}
			}
			public static complex conj(complex z)
			{
				return new complex(z.x, -z.y);
			}
			public static complex csqr(complex z)
			{
				return new complex(z.x * z.x - z.y * z.y, 2 * z.x * z.y);
			}

		}


		/********************************************************************
		serializer object (should not be used directly)
		********************************************************************/
		public class serializer
		{
			enum SMODE { DEFAULT, ALLOC, TO_STRING, FROM_STRING };
			private const int SER_ENTRIES_PER_ROW = 5;
			private const int SER_ENTRY_LENGTH = 11;

			private SMODE mode;
			private int entries_needed;
			private int entries_saved;
			private int bytes_asked;
			private int bytes_written;
			private int bytes_read;
			private char[] out_str;
			private char[] in_str;

			public serializer()
			{
				mode = SMODE.DEFAULT;
				entries_needed = 0;
				bytes_asked = 0;
			}

			public void alloc_start()
			{
				entries_needed = 0;
				bytes_asked = 0;
				mode = SMODE.ALLOC;
			}

			public void alloc_entry()
			{
				if (mode != SMODE.ALLOC)
					throw new alglib.alglibexception("ALGLIB: internal error during (un)serialization");
				entries_needed++;
			}

			private int get_alloc_size()
			{
				int rows, lastrowsize, result;

				// check and change mode
				if (mode != SMODE.ALLOC)
					throw new alglib.alglibexception("ALGLIB: internal error during (un)serialization");

				// if no entries needes (degenerate case)
				if (entries_needed == 0)
				{
					bytes_asked = 1;
					return bytes_asked;
				}

				// non-degenerate case
				rows = entries_needed / SER_ENTRIES_PER_ROW;
				lastrowsize = SER_ENTRIES_PER_ROW;
				if (entries_needed % SER_ENTRIES_PER_ROW != 0)
				{
					lastrowsize = entries_needed % SER_ENTRIES_PER_ROW;
					rows++;
				}

				// calculate result size
				result = ((rows - 1) * SER_ENTRIES_PER_ROW + lastrowsize) * SER_ENTRY_LENGTH;
				result += (rows - 1) * (SER_ENTRIES_PER_ROW - 1) + (lastrowsize - 1);
				result += rows * 2;
				bytes_asked = result;
				return result;
			}

			public void sstart_str()
			{
				int allocsize = get_alloc_size();

				// check and change mode
				if (mode != SMODE.ALLOC)
					throw new alglib.alglibexception("ALGLIB: internal error during (un)serialization");
				mode = SMODE.TO_STRING;

				// other preparations
				out_str = new char[allocsize];
				entries_saved = 0;
				bytes_written = 0;
			}

			public void ustart_str(string s)
			{
				// check and change mode
				if (mode != SMODE.DEFAULT)
					throw new alglib.alglibexception("ALGLIB: internal error during (un)serialization");
				mode = SMODE.FROM_STRING;

				in_str = s.ToCharArray();
				bytes_read = 0;
			}

			public void serialize_bool(bool v)
			{
				if (mode != SMODE.TO_STRING)
					throw new alglib.alglibexception("ALGLIB: internal error during (un)serialization");
				bool2str(v, out_str, ref bytes_written);
				entries_saved++;
				if (entries_saved % SER_ENTRIES_PER_ROW != 0)
				{
					out_str[bytes_written] = ' ';
					bytes_written++;
				}
				else
				{
					out_str[bytes_written + 0] = '\r';
					out_str[bytes_written + 1] = '\n';
					bytes_written += 2;
				}
			}

			public void serialize_int(int v)
			{
				if (mode != SMODE.TO_STRING)
					throw new alglib.alglibexception("ALGLIB: internal error during (un)serialization");
				int2str(v, out_str, ref bytes_written);
				entries_saved++;
				if (entries_saved % SER_ENTRIES_PER_ROW != 0)
				{
					out_str[bytes_written] = ' ';
					bytes_written++;
				}
				else
				{
					out_str[bytes_written + 0] = '\r';
					out_str[bytes_written + 1] = '\n';
					bytes_written += 2;
				}
			}

			public void serialize_double(double v)
			{
				if (mode != SMODE.TO_STRING)
					throw new alglib.alglibexception("ALGLIB: internal error during (un)serialization");
				double2str(v, out_str, ref bytes_written);
				entries_saved++;
				if (entries_saved % SER_ENTRIES_PER_ROW != 0)
				{
					out_str[bytes_written] = ' ';
					bytes_written++;
				}
				else
				{
					out_str[bytes_written + 0] = '\r';
					out_str[bytes_written + 1] = '\n';
					bytes_written += 2;
				}
			}

			public bool unserialize_bool()
			{
				if (mode != SMODE.FROM_STRING)
					throw new alglib.alglibexception("ALGLIB: internal error during (un)serialization");
				return str2bool(in_str, ref bytes_read);
			}

			public int unserialize_int()
			{
				if (mode != SMODE.FROM_STRING)
					throw new alglib.alglibexception("ALGLIB: internal error during (un)serialization");
				return str2int(in_str, ref bytes_read);
			}

			public double unserialize_double()
			{
				if (mode != SMODE.FROM_STRING)
					throw new alglib.alglibexception("ALGLIB: internal error during (un)serialization");
				return str2double(in_str, ref bytes_read);
			}

			public void stop()
			{
			}

			public string get_string()
			{
				return new string(out_str, 0, bytes_written);
			}


			/************************************************************************
			This function converts six-bit value (from 0 to 63)  to  character  (only
			digits, lowercase and uppercase letters, minus and underscore are used).

			If v is negative or greater than 63, this function returns '?'.
			************************************************************************/
			private static char[] _sixbits2char_tbl = new char[64]{ 
                '0', '1', '2', '3', '4', '5', '6', '7',
                '8', '9', 'A', 'B', 'C', 'D', 'E', 'F',
                'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N',
                'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V',
                'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 
                'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 
                'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 
                'u', 'v', 'w', 'x', 'y', 'z', '-', '_' };
			private static char sixbits2char(int v)
			{
				if (v < 0 || v > 63)
					return '?';
				return _sixbits2char_tbl[v];
			}

			/************************************************************************
			This function converts character to six-bit value (from 0 to 63).

			This function is inverse of ae_sixbits2char()
			If c is not correct character, this function returns -1.
			************************************************************************/
			private static int[] _char2sixbits_tbl = new int[128] {
            -1, -1, -1, -1, -1, -1, -1, -1,
            -1, -1, -1, -1, -1, -1, -1, -1,
            -1, -1, -1, -1, -1, -1, -1, -1,
            -1, -1, -1, -1, -1, -1, -1, -1,
            -1, -1, -1, -1, -1, -1, -1, -1,
            -1, -1, -1, -1, -1, 62, -1, -1,
             0,  1,  2,  3,  4,  5,  6,  7,
             8,  9, -1, -1, -1, -1, -1, -1,
            -1, 10, 11, 12, 13, 14, 15, 16,
            17, 18, 19, 20, 21, 22, 23, 24,
            25, 26, 27, 28, 29, 30, 31, 32,
            33, 34, 35, -1, -1, -1, -1, 63,
            -1, 36, 37, 38, 39, 40, 41, 42,
            43, 44, 45, 46, 47, 48, 49, 50,
            51, 52, 53, 54, 55, 56, 57, 58,
            59, 60, 61, -1, -1, -1, -1, -1 };
			private static int char2sixbits(char c)
			{
				return (c >= 0 && c < 127) ? _char2sixbits_tbl[c] : -1;
			}

			/************************************************************************
			This function converts three bytes (24 bits) to four six-bit values 
			(24 bits again).

			src         array
			src_offs    offset of three-bytes chunk
			dst         array for ints
			dst_offs    offset of four-ints chunk
			************************************************************************/
			private static void threebytes2foursixbits(byte[] src, int src_offs, int[] dst, int dst_offs)
			{
				dst[dst_offs + 0] = src[src_offs + 0] & 0x3F;
				dst[dst_offs + 1] = (src[src_offs + 0] >> 6) | ((src[src_offs + 1] & 0x0F) << 2);
				dst[dst_offs + 2] = (src[src_offs + 1] >> 4) | ((src[src_offs + 2] & 0x03) << 4);
				dst[dst_offs + 3] = src[src_offs + 2] >> 2;
			}

			/************************************************************************
			This function converts four six-bit values (24 bits) to three bytes
			(24 bits again).

			src         pointer to four ints
			src_offs    offset of the chunk
			dst         pointer to three bytes
			dst_offs    offset of the chunk
			************************************************************************/
			private static void foursixbits2threebytes(int[] src, int src_offs, byte[] dst, int dst_offs)
			{
				dst[dst_offs + 0] = (byte)(src[src_offs + 0] | ((src[src_offs + 1] & 0x03) << 6));
				dst[dst_offs + 1] = (byte)((src[src_offs + 1] >> 2) | ((src[src_offs + 2] & 0x0F) << 4));
				dst[dst_offs + 2] = (byte)((src[src_offs + 2] >> 4) | (src[src_offs + 3] << 2));
			}

			/************************************************************************
			This function serializes boolean value into buffer

			v           boolean value to be serialized
			buf         buffer, at least 11 characters wide
			offs        offset in the buffer
        
			after return from this function, offs points to the char's past the value
			being read.
			************************************************************************/
			private static void bool2str(bool v, char[] buf, ref int offs)
			{
				char c = v ? '1' : '0';
				int i;
				for (i = 0; i < SER_ENTRY_LENGTH; i++)
					buf[offs + i] = c;
				offs += SER_ENTRY_LENGTH;
			}

			/************************************************************************
			This function unserializes boolean value from buffer

			buf         buffer which contains value; leading spaces/tabs/newlines are 
									ignored, traling spaces/tabs/newlines are treated as  end  of
									the boolean value.
			offs        offset in the buffer
        
			after return from this function, offs points to the char's past the value
			being read.

			This function raises an error in case unexpected symbol is found
			************************************************************************/
			private static bool str2bool(char[] buf, ref int offs)
			{
				bool was0, was1;
				string emsg = "ALGLIB: unable to read boolean value from stream";

				was0 = false;
				was1 = false;
				while (buf[offs] == ' ' || buf[offs] == '\t' || buf[offs] == '\n' || buf[offs] == '\r')
					offs++;
				while (buf[offs] != ' ' && buf[offs] != '\t' && buf[offs] != '\n' && buf[offs] != '\r' && buf[offs] != 0)
				{
					if (buf[offs] == '0')
					{
						was0 = true;
						offs++;
						continue;
					}
					if (buf[offs] == '1')
					{
						was1 = true;
						offs++;
						continue;
					}
					throw new alglib.alglibexception(emsg);
				}
				if ((!was0) && (!was1))
					throw new alglib.alglibexception(emsg);
				if (was0 && was1)
					throw new alglib.alglibexception(emsg);
				return was1 ? true : false;
			}

			/************************************************************************
			This function serializes integer value into buffer

			v           integer value to be serialized
			buf         buffer, at least 11 characters wide 
			offs        offset in the buffer
        
			after return from this function, offs points to the char's past the value
			being read.

			This function raises an error in case unexpected symbol is found
			************************************************************************/
			private static void int2str(int v, char[] buf, ref int offs)
			{
				int i;
				byte[] _bytes = System.BitConverter.GetBytes((int)v);
				byte[] bytes = new byte[9];
				int[] sixbits = new int[12];
				byte c;

				//
				// copy v to array of bytes, sign extending it and 
				// converting to little endian order. Additionally, 
				// we set 9th byte to zero in order to simplify 
				// conversion to six-bit representation
				//
				if (!System.BitConverter.IsLittleEndian)
					System.Array.Reverse(_bytes);
				c = v < 0 ? (byte)0xFF : (byte)0x00;
				for (i = 0; i < sizeof(int); i++)
					bytes[i] = _bytes[i];
				for (i = sizeof(int); i < 8; i++)
					bytes[i] = c;
				bytes[8] = 0;

				//
				// convert to six-bit representation, output
				//
				// NOTE: last 12th element of sixbits is always zero, we do not output it
				//
				threebytes2foursixbits(bytes, 0, sixbits, 0);
				threebytes2foursixbits(bytes, 3, sixbits, 4);
				threebytes2foursixbits(bytes, 6, sixbits, 8);
				for (i = 0; i < SER_ENTRY_LENGTH; i++)
					buf[offs + i] = sixbits2char(sixbits[i]);
				offs += SER_ENTRY_LENGTH;
			}

			/************************************************************************
			This function unserializes integer value from string

			buf         buffer which contains value; leading spaces/tabs/newlines are 
									ignored, traling spaces/tabs/newlines are treated as  end  of
									the integer value.
			offs        offset in the buffer
        
			after return from this function, offs points to the char's past the value
			being read.

			This function raises an error in case unexpected symbol is found
			************************************************************************/
			private static int str2int(char[] buf, ref int offs)
			{
				string emsg = "ALGLIB: unable to read integer value from stream";
				string emsg3264 = "ALGLIB: unable to read integer value from stream (value does not fit into 32 bits)";
				int[] sixbits = new int[12];
				byte[] bytes = new byte[9];
				byte[] _bytes = new byte[sizeof(int)];
				int sixbitsread, i;
				byte c;

				// 
				// 1. skip leading spaces
				// 2. read and decode six-bit digits
				// 3. set trailing digits to zeros
				// 4. convert to little endian 64-bit integer representation
				// 5. check that we fit into int
				// 6. convert to big endian representation, if needed
				//
				sixbitsread = 0;
				while (buf[offs] == ' ' || buf[offs] == '\t' || buf[offs] == '\n' || buf[offs] == '\r')
					offs++;
				while (buf[offs] != ' ' && buf[offs] != '\t' && buf[offs] != '\n' && buf[offs] != '\r' && buf[offs] != 0)
				{
					int d;
					d = char2sixbits(buf[offs]);
					if (d < 0 || sixbitsread >= SER_ENTRY_LENGTH)
						throw new alglib.alglibexception(emsg);
					sixbits[sixbitsread] = d;
					sixbitsread++;
					offs++;
				}
				if (sixbitsread == 0)
					throw new alglib.alglibexception(emsg);
				for (i = sixbitsread; i < 12; i++)
					sixbits[i] = 0;
				foursixbits2threebytes(sixbits, 0, bytes, 0);
				foursixbits2threebytes(sixbits, 4, bytes, 3);
				foursixbits2threebytes(sixbits, 8, bytes, 6);
				c = (bytes[sizeof(int) - 1] & 0x80) != 0 ? (byte)0xFF : (byte)0x00;
				for (i = sizeof(int); i < 8; i++)
					if (bytes[i] != c)
						throw new alglib.alglibexception(emsg3264);
				for (i = 0; i < sizeof(int); i++)
					_bytes[i] = bytes[i];
				if (!System.BitConverter.IsLittleEndian)
					System.Array.Reverse(_bytes);
				return System.BitConverter.ToInt32(_bytes, 0);
			}


			/************************************************************************
			This function serializes double value into buffer

			v           double value to be serialized
			buf         buffer, at least 11 characters wide 
			offs        offset in the buffer
        
			after return from this function, offs points to the char's past the value
			being read.
			************************************************************************/
			private static void double2str(double v, char[] buf, ref int offs)
			{
				int i;
				int[] sixbits = new int[12];
				byte[] bytes = new byte[9];

				//
				// handle special quantities
				//
				if (double.IsNaN(v))
				{
					buf[offs + 0] = '.';
					buf[offs + 1] = 'n';
					buf[offs + 2] = 'a';
					buf[offs + 3] = 'n';
					buf[offs + 4] = '_';
					buf[offs + 5] = '_';
					buf[offs + 6] = '_';
					buf[offs + 7] = '_';
					buf[offs + 8] = '_';
					buf[offs + 9] = '_';
					buf[offs + 10] = '_';
					offs += SER_ENTRY_LENGTH;
					return;
				}
				if (double.IsPositiveInfinity(v))
				{
					buf[offs + 0] = '.';
					buf[offs + 1] = 'p';
					buf[offs + 2] = 'o';
					buf[offs + 3] = 's';
					buf[offs + 4] = 'i';
					buf[offs + 5] = 'n';
					buf[offs + 6] = 'f';
					buf[offs + 7] = '_';
					buf[offs + 8] = '_';
					buf[offs + 9] = '_';
					buf[offs + 10] = '_';
					offs += SER_ENTRY_LENGTH;
					return;
				}
				if (double.IsNegativeInfinity(v))
				{
					buf[offs + 0] = '.';
					buf[offs + 1] = 'n';
					buf[offs + 2] = 'e';
					buf[offs + 3] = 'g';
					buf[offs + 4] = 'i';
					buf[offs + 5] = 'n';
					buf[offs + 6] = 'f';
					buf[offs + 7] = '_';
					buf[offs + 8] = '_';
					buf[offs + 9] = '_';
					buf[offs + 10] = '_';
					offs += SER_ENTRY_LENGTH;
					return;
				}

				//
				// process general case:
				// 1. copy v to array of chars
				// 2. set 9th byte to zero in order to simplify conversion to six-bit representation
				// 3. convert to little endian (if needed)
				// 4. convert to six-bit representation
				//    (last 12th element of sixbits is always zero, we do not output it)
				//
				byte[] _bytes = System.BitConverter.GetBytes((double)v);
				if (!System.BitConverter.IsLittleEndian)
					System.Array.Reverse(_bytes);
				for (i = 0; i < sizeof(double); i++)
					bytes[i] = _bytes[i];
				for (i = sizeof(double); i < 9; i++)
					bytes[i] = 0;
				threebytes2foursixbits(bytes, 0, sixbits, 0);
				threebytes2foursixbits(bytes, 3, sixbits, 4);
				threebytes2foursixbits(bytes, 6, sixbits, 8);
				for (i = 0; i < SER_ENTRY_LENGTH; i++)
					buf[offs + i] = sixbits2char(sixbits[i]);
				offs += SER_ENTRY_LENGTH;
			}

			/************************************************************************
			This function unserializes double value from string

			buf         buffer which contains value; leading spaces/tabs/newlines are 
									ignored, traling spaces/tabs/newlines are treated as  end  of
									the double value.
			offs        offset in the buffer
        
			after return from this function, offs points to the char's past the value
			being read.

			This function raises an error in case unexpected symbol is found
			************************************************************************/
			private static double str2double(char[] buf, ref int offs)
			{
				string emsg = "ALGLIB: unable to read double value from stream";
				int[] sixbits = new int[12];
				byte[] bytes = new byte[9];
				byte[] _bytes = new byte[sizeof(double)];
				int sixbitsread, i;


				// 
				// skip leading spaces
				//
				while (buf[offs] == ' ' || buf[offs] == '\t' || buf[offs] == '\n' || buf[offs] == '\r')
					offs++;


				//
				// Handle special cases
				//
				if (buf[offs] == '.')
				{
					string s = new string(buf, offs, SER_ENTRY_LENGTH);
					if (s == ".nan_______")
					{
						offs += SER_ENTRY_LENGTH;
						return double.NaN;
					}
					if (s == ".posinf____")
					{
						offs += SER_ENTRY_LENGTH;
						return double.PositiveInfinity;
					}
					if (s == ".neginf____")
					{
						offs += SER_ENTRY_LENGTH;
						return double.NegativeInfinity;
					}
					throw new alglib.alglibexception(emsg);
				}

				// 
				// General case:
				// 1. read and decode six-bit digits
				// 2. check that all 11 digits were read
				// 3. set last 12th digit to zero (needed for simplicity of conversion)
				// 4. convert to 8 bytes
				// 5. convert to big endian representation, if needed
				//
				sixbitsread = 0;
				while (buf[offs] != ' ' && buf[offs] != '\t' && buf[offs] != '\n' && buf[offs] != '\r' && buf[offs] != 0)
				{
					int d;
					d = char2sixbits(buf[offs]);
					if (d < 0 || sixbitsread >= SER_ENTRY_LENGTH)
						throw new alglib.alglibexception(emsg);
					sixbits[sixbitsread] = d;
					sixbitsread++;
					offs++;
				}
				if (sixbitsread != SER_ENTRY_LENGTH)
					throw new alglib.alglibexception(emsg);
				sixbits[SER_ENTRY_LENGTH] = 0;
				foursixbits2threebytes(sixbits, 0, bytes, 0);
				foursixbits2threebytes(sixbits, 4, bytes, 3);
				foursixbits2threebytes(sixbits, 8, bytes, 6);
				for (i = 0; i < sizeof(double); i++)
					_bytes[i] = bytes[i];
				if (!System.BitConverter.IsLittleEndian)
					System.Array.Reverse(_bytes);
				return (double)(System.BitConverter.ToDouble(_bytes, 0));
			}
		}

		/*
		 * Part of alglib.smp class which are shared with GPL version of ALGLIB
		 */
		public partial class smp
		{
#pragma warning disable 420
			public const int AE_LOCK_CYCLES = 512;
			public const int AE_LOCK_TESTS_BEFORE_YIELD = 16;

			/*
			 * This variable is used to perform spin-wait loops in a platform-independent manner
			 * (loops which should work same way on Mono and Microsoft NET). You SHOULD NEVER
			 * change this field - it must be zero during all program life.
			 */
			public static volatile int never_change_it = 0;

			/*************************************************************************
			Lock.

			This class provides lightweight spin lock
			*************************************************************************/
			public class ae_lock
			{
				public volatile int is_locked;
			}

			/********************************************************************
			Shared pool: data structure used to provide thread-safe access to pool
			of temporary variables.
			********************************************************************/
			public class sharedpoolentry
			{
				public apobject obj;
				public sharedpoolentry next_entry;
			}
			public class shared_pool : apobject
			{
				/* lock object which protects pool */
				public ae_lock pool_lock;

				/* seed object (used to create new instances of temporaries) */
				public volatile apobject seed_object;

				/*
				 * list of recycled OBJECTS:
				 * 1. entries in this list store pointers to recycled objects
				 * 2. every time we retrieve object, we retrieve first entry from this list,
				 *    move it to recycled_entries and return its obj field to caller/
				 */
				public volatile sharedpoolentry recycled_objects;

				/* 
				 * list of recycled ENTRIES:
				 * 1. this list holds entries which are not used to store recycled objects;
				 *    every time recycled object is retrieved, its entry is moved to this list.
				 * 2. every time object is recycled, we try to fetch entry for him from this list
				 *    before allocating it with malloc()
				 */
				public volatile sharedpoolentry recycled_entries;

				/* enumeration pointer, points to current recycled object*/
				public volatile sharedpoolentry enumeration_counter;

				/* constructor */
				public shared_pool()
				{
					ae_init_lock(ref pool_lock);
				}

				/* initializer - creation of empty pool */
				public override void init()
				{
					seed_object = null;
					recycled_objects = null;
					recycled_entries = null;
					enumeration_counter = null;
				}

				/* copy constructor (it is NOT thread-safe) */
				public override apobject make_copy()
				{
					sharedpoolentry ptr, buf;
					shared_pool result = new shared_pool();

					/* create lock */
					ae_init_lock(ref result.pool_lock);

					/* copy seed object */
					if (seed_object != null)
						result.seed_object = seed_object.make_copy();

					/*
					 * copy recycled objects:
					 * 1. copy to temporary list (objects are inserted to beginning, order is reversed)
					 * 2. copy temporary list to output list (order is restored back to normal)
					 */
					buf = null;
					for (ptr = recycled_objects; ptr != null; ptr = ptr.next_entry)
					{
						sharedpoolentry tmp = new sharedpoolentry();
						tmp.obj = ptr.obj.make_copy();
						tmp.next_entry = buf;
						buf = tmp;
					}
					result.recycled_objects = null;
					for (ptr = buf; ptr != null; )
					{
						sharedpoolentry next_ptr = ptr.next_entry;
						ptr.next_entry = result.recycled_objects;
						result.recycled_objects = ptr;
						ptr = next_ptr;
					}

					/* recycled entries are not copied because they do not store any information */
					result.recycled_entries = null;

					/* enumeration counter is reset on copying */
					result.enumeration_counter = null;

					return result;
				}
			}


			/************************************************************************
			This function performs given number of spin-wait iterations
			************************************************************************/
			public static void ae_spin_wait(int cnt)
			{
				/*
				 * these strange operations with ae_never_change_it are necessary to
				 * prevent compiler optimization of the loop.
				 */
				int i;

				/* very unlikely because no one will wait for such amount of cycles */
				if (cnt > 0x12345678)
					never_change_it = cnt % 10;

				/* spin wait, test condition which will never be true */
				for (i = 0; i < cnt; i++)
					if (never_change_it > 0)
						never_change_it--;
			}


			/************************************************************************
			This function causes the calling thread to relinquish the CPU. The thread
			is moved to the end of the queue and some other thread gets to run.
			************************************************************************/
			public static void ae_yield()
			{
				System.Threading.Thread.Sleep(0);
			}

			/************************************************************************
			This function initializes ae_lock structure and sets lock in a free mode.
			************************************************************************/
			public static void ae_init_lock(ref ae_lock obj)
			{
				obj = new ae_lock();
				obj.is_locked = 0;
			}


			/************************************************************************
			This function acquires lock. In case lock is busy, we perform several
			iterations inside tight loop before trying again.
			************************************************************************/
			public static void ae_acquire_lock(ae_lock obj)
			{
				int cnt = 0;
				for (; ; )
				{
					if (System.Threading.Interlocked.CompareExchange(ref obj.is_locked, 1, 0) == 0)
						return;
					ae_spin_wait(AE_LOCK_CYCLES);
					cnt++;
					if (cnt % AE_LOCK_TESTS_BEFORE_YIELD == 0)
						ae_yield();
				}
			}


			/************************************************************************
			This function releases lock.
			************************************************************************/
			public static void ae_release_lock(ae_lock obj)
			{
				System.Threading.Interlocked.Exchange(ref obj.is_locked, 0);
			}


			/************************************************************************
			This function frees ae_lock structure.
			************************************************************************/
			public static void ae_free_lock(ref ae_lock obj)
			{
				obj = null;
			}


			/************************************************************************
			This function returns True, if internal seed object was set.  It  returns
			False for un-seeded pool.

			dst                 destination pool (initialized by constructor function)

			NOTE: this function is NOT thread-safe. It does not acquire pool lock, so
						you should NOT call it when lock can be used by another thread.
			************************************************************************/
			public static bool ae_shared_pool_is_initialized(shared_pool dst)
			{
				return dst.seed_object != null;
			}


			/************************************************************************
			This function sets internal seed object. All objects owned by the pool
			(current seed object, recycled objects) are automatically freed.

			dst                 destination pool (initialized by constructor function)
			seed_object         new seed object

			NOTE: this function is NOT thread-safe. It does not acquire pool lock, so
						you should NOT call it when lock can be used by another thread.
			************************************************************************/
			public static void ae_shared_pool_set_seed(shared_pool dst, alglib.apobject seed_object)
			{
				dst.seed_object = seed_object.make_copy();
				dst.recycled_objects = null;
				dst.enumeration_counter = null;
			}


			/************************************************************************
			This  function  retrieves  a  copy  of  the seed object from the pool and
			stores it to target variable.

			pool                pool
			obj                 target variable
        
			NOTE: this function IS thread-safe.  It  acquires  pool  lock  during its
						operation and can be used simultaneously from several threads.
			************************************************************************/
			public static void ae_shared_pool_retrieve<T>(shared_pool pool, ref T obj) where T : alglib.apobject
			{
				alglib.apobject new_obj;

				/* assert that pool was seeded */
				alglib.ap.assert(pool.seed_object != null, "ALGLIB: shared pool is not seeded, PoolRetrieve() failed");

				/* acquire lock */
				ae_acquire_lock(pool.pool_lock);

				/* try to reuse recycled objects */
				if (pool.recycled_objects != null)
				{
					/* retrieve entry/object from list of recycled objects */
					sharedpoolentry result = pool.recycled_objects;
					pool.recycled_objects = pool.recycled_objects.next_entry;
					new_obj = result.obj;
					result.obj = null;

					/* move entry to list of recycled entries */
					result.next_entry = pool.recycled_entries;
					pool.recycled_entries = result;

					/* release lock */
					ae_release_lock(pool.pool_lock);

					/* assign object to smart pointer */
					obj = (T)new_obj;

					return;
				}

				/*
				 * release lock; we do not need it anymore because
				 * copy constructor does not modify source variable.
				 */
				ae_release_lock(pool.pool_lock);

				/* create new object from seed */
				new_obj = pool.seed_object.make_copy();

				/* assign object to pointer and return */
				obj = (T)new_obj;
			}


			/************************************************************************
			This  function  recycles object owned by the source variable by moving it
			to internal storage of the shared pool.

			Source  variable  must  own  the  object,  i.e.  be  the only place where
			reference  to  object  is  stored.  After  call  to  this function source
			variable becomes NULL.

			pool                pool
			obj                 source variable

			NOTE: this function IS thread-safe.  It  acquires  pool  lock  during its
						operation and can be used simultaneously from several threads.
			************************************************************************/
			public static void ae_shared_pool_recycle<T>(shared_pool pool, ref T obj) where T : alglib.apobject
			{
				sharedpoolentry new_entry;

				/* assert that pool was seeded */
				alglib.ap.assert(pool.seed_object != null, "ALGLIB: shared pool is not seeded, PoolRecycle() failed");

				/* assert that pointer non-null */
				alglib.ap.assert(obj != null, "ALGLIB: obj in ae_shared_pool_recycle() is NULL");

				/* acquire lock */
				ae_acquire_lock(pool.pool_lock);

				/* acquire shared pool entry (reuse one from recycled_entries or malloc new one) */
				if (pool.recycled_entries != null)
				{
					/* reuse previously allocated entry */
					new_entry = pool.recycled_entries;
					pool.recycled_entries = new_entry.next_entry;
				}
				else
				{
					/*
					 * Allocate memory for new entry.
					 *
					 * NOTE: we release pool lock during allocation because new() may raise
					 *       exception and we do not want our pool to be left in the locked state.
					 */
					ae_release_lock(pool.pool_lock);
					new_entry = new sharedpoolentry();
					ae_acquire_lock(pool.pool_lock);
				}

				/* add object to the list of recycled objects */
				new_entry.obj = obj;
				new_entry.next_entry = pool.recycled_objects;
				pool.recycled_objects = new_entry;

				/* release lock object */
				ae_release_lock(pool.pool_lock);

				/* release source pointer */
				obj = null;
			}


			/************************************************************************
			This function clears internal list of  recycled  objects,  but  does  not
			change seed object managed by the pool.

			pool                pool

			NOTE: this function is NOT thread-safe. It does not acquire pool lock, so
						you should NOT call it when lock can be used by another thread.
			************************************************************************/
			public static void ae_shared_pool_clear_recycled(shared_pool pool)
			{
				pool.recycled_objects = null;
			}


			/************************************************************************
			This function allows to enumerate recycled elements of the  shared  pool.
			It stores reference to the first recycled object in the smart pointer.

			IMPORTANT:
			* in case target variable owns non-NULL value, it is rewritten
			* recycled object IS NOT removed from pool
			* target variable DOES NOT become owner of the new value; you can use
				reference to recycled object, but you do not own it.
			* this function IS NOT thread-safe
			* you SHOULD NOT modify shared pool during enumeration (although you  can
				modify state of the objects retrieved from pool)
			* in case there is no recycled objects in the pool, NULL is stored to obj
			* in case pool is not seeded, NULL is stored to obj

			pool                pool
			obj                 reference
			************************************************************************/
			public static void ae_shared_pool_first_recycled<T>(shared_pool pool, ref T obj) where T : alglib.apobject
			{
				/* modify internal enumeration counter */
				pool.enumeration_counter = pool.recycled_objects;

				/* exit on empty list */
				if (pool.enumeration_counter == null)
				{
					obj = null;
					return;
				}

				/* assign object to smart pointer */
				obj = (T)pool.enumeration_counter.obj;
			}


			/************************************************************************
			This function allows to enumerate recycled elements of the  shared  pool.
			It stores pointer to the next recycled object in the smart pointer.

			IMPORTANT:
			* in case target variable owns non-NULL value, it is rewritten
			* recycled object IS NOT removed from pool
			* target pointer DOES NOT become owner of the new value
			* this function IS NOT thread-safe
			* you SHOULD NOT modify shared pool during enumeration (although you  can
				modify state of the objects retrieved from pool)
			* in case there is no recycled objects left in the pool, NULL is stored.
			* in case pool is not seeded, NULL is stored.

			pool                pool
			obj                 target variable
			************************************************************************/
			public static void ae_shared_pool_next_recycled<T>(shared_pool pool, ref T obj) where T : alglib.apobject
			{
				/* exit on end of list */
				if (pool.enumeration_counter == null)
				{
					obj = null;
					return;
				}

				/* modify internal enumeration counter */
				pool.enumeration_counter = pool.enumeration_counter.next_entry;

				/* exit on empty list */
				if (pool.enumeration_counter == null)
				{
					obj = null;
					return;
				}

				/* assign object to smart pointer */
				obj = (T)pool.enumeration_counter.obj;
			}


			/************************************************************************
			This function clears internal list of recycled objects and  seed  object.
			However, pool still can be used (after initialization with another seed).

			pool                pool
			state               ALGLIB environment state

			NOTE: this function is NOT thread-safe. It does not acquire pool lock, so
						you should NOT call it when lock can be used by another thread.
			************************************************************************/
			public static void ae_shared_pool_reset(shared_pool pool)
			{
				pool.seed_object = null;
				pool.recycled_objects = null;
				pool.enumeration_counter = null;
			}
		}
	}
	public partial class alglib
	{
		public partial class smp
		{
			public static int cores_count = 1;
			public static volatile int cores_to_use = 0;
		}
		public class smpselftests
		{
			public static bool runtests()
			{
				return true;
			}
		}
		public static void setnworkers(int nworkers)
		{
			alglib.smp.cores_to_use = nworkers;
		}
	}

	public partial class alglib
	{


		/*************************************************************************
		Cache-oblivous complex "copy-and-transpose"

		Input parameters:
				M   -   number of rows
				N   -   number of columns
				A   -   source matrix, MxN submatrix is copied and transposed
				IA  -   submatrix offset (row index)
				JA  -   submatrix offset (column index)
				B   -   destination matrix, must be large enough to store result
				IB  -   submatrix offset (row index)
				JB  -   submatrix offset (column index)
		*************************************************************************/
		public static void cmatrixtranspose(int m, int n, complex[,] a, int ia, int ja, ref complex[,] b, int ib, int jb)
		{

			ablas.cmatrixtranspose(m, n, a, ia, ja, ref b, ib, jb);
			return;
		}

		/*************************************************************************
		Cache-oblivous real "copy-and-transpose"

		Input parameters:
				M   -   number of rows
				N   -   number of columns
				A   -   source matrix, MxN submatrix is copied and transposed
				IA  -   submatrix offset (row index)
				JA  -   submatrix offset (column index)
				B   -   destination matrix, must be large enough to store result
				IB  -   submatrix offset (row index)
				JB  -   submatrix offset (column index)
		*************************************************************************/
		public static void rmatrixtranspose(int m, int n, double[,] a, int ia, int ja, ref double[,] b, int ib, int jb)
		{

			ablas.rmatrixtranspose(m, n, a, ia, ja, ref b, ib, jb);
			return;
		}

		/*************************************************************************
		This code enforces symmetricy of the matrix by copying Upper part to lower
		one (or vice versa).

		INPUT PARAMETERS:
				A   -   matrix
				N   -   number of rows/columns
				IsUpper - whether we want to copy upper triangle to lower one (True)
								or vice versa (False).
		*************************************************************************/
		public static void rmatrixenforcesymmetricity(ref double[,] a, int n, bool isupper)
		{

			ablas.rmatrixenforcesymmetricity(a, n, isupper);
			return;
		}

		/*************************************************************************
		Copy

		Input parameters:
				M   -   number of rows
				N   -   number of columns
				A   -   source matrix, MxN submatrix is copied and transposed
				IA  -   submatrix offset (row index)
				JA  -   submatrix offset (column index)
				B   -   destination matrix, must be large enough to store result
				IB  -   submatrix offset (row index)
				JB  -   submatrix offset (column index)
		*************************************************************************/
		public static void cmatrixcopy(int m, int n, complex[,] a, int ia, int ja, ref complex[,] b, int ib, int jb)
		{

			ablas.cmatrixcopy(m, n, a, ia, ja, ref b, ib, jb);
			return;
		}

		/*************************************************************************
		Copy

		Input parameters:
				M   -   number of rows
				N   -   number of columns
				A   -   source matrix, MxN submatrix is copied and transposed
				IA  -   submatrix offset (row index)
				JA  -   submatrix offset (column index)
				B   -   destination matrix, must be large enough to store result
				IB  -   submatrix offset (row index)
				JB  -   submatrix offset (column index)
		*************************************************************************/
		public static void rmatrixcopy(int m, int n, double[,] a, int ia, int ja, ref double[,] b, int ib, int jb)
		{

			ablas.rmatrixcopy(m, n, a, ia, ja, ref b, ib, jb);
			return;
		}

		/*************************************************************************
		Rank-1 correction: A := A + u*v'

		INPUT PARAMETERS:
				M   -   number of rows
				N   -   number of columns
				A   -   target matrix, MxN submatrix is updated
				IA  -   submatrix offset (row index)
				JA  -   submatrix offset (column index)
				U   -   vector #1
				IU  -   subvector offset
				V   -   vector #2
				IV  -   subvector offset
		*************************************************************************/
		public static void cmatrixrank1(int m, int n, ref complex[,] a, int ia, int ja, ref complex[] u, int iu, ref complex[] v, int iv)
		{

			ablas.cmatrixrank1(m, n, ref a, ia, ja, ref u, iu, ref v, iv);
			return;
		}

		/*************************************************************************
		Rank-1 correction: A := A + u*v'

		INPUT PARAMETERS:
				M   -   number of rows
				N   -   number of columns
				A   -   target matrix, MxN submatrix is updated
				IA  -   submatrix offset (row index)
				JA  -   submatrix offset (column index)
				U   -   vector #1
				IU  -   subvector offset
				V   -   vector #2
				IV  -   subvector offset
		*************************************************************************/
		public static void rmatrixrank1(int m, int n, ref double[,] a, int ia, int ja, ref double[] u, int iu, ref double[] v, int iv)
		{

			ablas.rmatrixrank1(m, n, ref a, ia, ja, ref u, iu, ref v, iv);
			return;
		}

		/*************************************************************************
		Matrix-vector product: y := op(A)*x

		INPUT PARAMETERS:
				M   -   number of rows of op(A)
								M>=0
				N   -   number of columns of op(A)
								N>=0
				A   -   target matrix
				IA  -   submatrix offset (row index)
				JA  -   submatrix offset (column index)
				OpA -   operation type:
								* OpA=0     =>  op(A) = A
								* OpA=1     =>  op(A) = A^T
								* OpA=2     =>  op(A) = A^H
				X   -   input vector
				IX  -   subvector offset
				IY  -   subvector offset
				Y   -   preallocated matrix, must be large enough to store result

		OUTPUT PARAMETERS:
				Y   -   vector which stores result

		if M=0, then subroutine does nothing.
		if N=0, Y is filled by zeros.


			-- ALGLIB routine --

				 28.01.2010
				 Bochkanov Sergey
		*************************************************************************/
		public static void cmatrixmv(int m, int n, complex[,] a, int ia, int ja, int opa, complex[] x, int ix, ref complex[] y, int iy)
		{

			ablas.cmatrixmv(m, n, a, ia, ja, opa, x, ix, ref y, iy);
			return;
		}

		/*************************************************************************
		Matrix-vector product: y := op(A)*x

		INPUT PARAMETERS:
				M   -   number of rows of op(A)
				N   -   number of columns of op(A)
				A   -   target matrix
				IA  -   submatrix offset (row index)
				JA  -   submatrix offset (column index)
				OpA -   operation type:
								* OpA=0     =>  op(A) = A
								* OpA=1     =>  op(A) = A^T
				X   -   input vector
				IX  -   subvector offset
				IY  -   subvector offset
				Y   -   preallocated matrix, must be large enough to store result

		OUTPUT PARAMETERS:
				Y   -   vector which stores result

		if M=0, then subroutine does nothing.
		if N=0, Y is filled by zeros.


			-- ALGLIB routine --

				 28.01.2010
				 Bochkanov Sergey
		*************************************************************************/
		public static void rmatrixmv(int m, int n, double[,] a, int ia, int ja, int opa, double[] x, int ix, ref double[] y, int iy)
		{

			ablas.rmatrixmv(m, n, a, ia, ja, opa, x, ix, ref y, iy);
			return;
		}

		/*************************************************************************

		*************************************************************************/
		public static void cmatrixrighttrsm(int m, int n, complex[,] a, int i1, int j1, bool isupper, bool isunit, int optype, ref complex[,] x, int i2, int j2)
		{

			ablas.cmatrixrighttrsm(m, n, a, i1, j1, isupper, isunit, optype, x, i2, j2);
			return;
		}


		public static void smp_cmatrixrighttrsm(int m, int n, complex[,] a, int i1, int j1, bool isupper, bool isunit, int optype, ref complex[,] x, int i2, int j2)
		{

			ablas._pexec_cmatrixrighttrsm(m, n, a, i1, j1, isupper, isunit, optype, x, i2, j2);
			return;
		}

		/*************************************************************************

		*************************************************************************/
		public static void cmatrixlefttrsm(int m, int n, complex[,] a, int i1, int j1, bool isupper, bool isunit, int optype, ref complex[,] x, int i2, int j2)
		{

			ablas.cmatrixlefttrsm(m, n, a, i1, j1, isupper, isunit, optype, x, i2, j2);
			return;
		}


		public static void smp_cmatrixlefttrsm(int m, int n, complex[,] a, int i1, int j1, bool isupper, bool isunit, int optype, ref complex[,] x, int i2, int j2)
		{

			ablas._pexec_cmatrixlefttrsm(m, n, a, i1, j1, isupper, isunit, optype, x, i2, j2);
			return;
		}

		/*************************************************************************

		*************************************************************************/
		public static void rmatrixrighttrsm(int m, int n, double[,] a, int i1, int j1, bool isupper, bool isunit, int optype, ref double[,] x, int i2, int j2)
		{

			ablas.rmatrixrighttrsm(m, n, a, i1, j1, isupper, isunit, optype, x, i2, j2);
			return;
		}


		public static void smp_rmatrixrighttrsm(int m, int n, double[,] a, int i1, int j1, bool isupper, bool isunit, int optype, ref double[,] x, int i2, int j2)
		{

			ablas._pexec_rmatrixrighttrsm(m, n, a, i1, j1, isupper, isunit, optype, x, i2, j2);
			return;
		}

		/*************************************************************************

		*************************************************************************/
		public static void rmatrixlefttrsm(int m, int n, double[,] a, int i1, int j1, bool isupper, bool isunit, int optype, ref double[,] x, int i2, int j2)
		{

			ablas.rmatrixlefttrsm(m, n, a, i1, j1, isupper, isunit, optype, x, i2, j2);
			return;
		}


		public static void smp_rmatrixlefttrsm(int m, int n, double[,] a, int i1, int j1, bool isupper, bool isunit, int optype, ref double[,] x, int i2, int j2)
		{

			ablas._pexec_rmatrixlefttrsm(m, n, a, i1, j1, isupper, isunit, optype, x, i2, j2);
			return;
		}

		/*************************************************************************

		*************************************************************************/
		public static void cmatrixsyrk(int n, int k, double alpha, complex[,] a, int ia, int ja, int optypea, double beta, ref complex[,] c, int ic, int jc, bool isupper)
		{

			ablas.cmatrixsyrk(n, k, alpha, a, ia, ja, optypea, beta, c, ic, jc, isupper);
			return;
		}


		public static void smp_cmatrixsyrk(int n, int k, double alpha, complex[,] a, int ia, int ja, int optypea, double beta, ref complex[,] c, int ic, int jc, bool isupper)
		{

			ablas._pexec_cmatrixsyrk(n, k, alpha, a, ia, ja, optypea, beta, c, ic, jc, isupper);
			return;
		}

		/*************************************************************************

		*************************************************************************/
		public static void rmatrixsyrk(int n, int k, double alpha, double[,] a, int ia, int ja, int optypea, double beta, ref double[,] c, int ic, int jc, bool isupper)
		{

			ablas.rmatrixsyrk(n, k, alpha, a, ia, ja, optypea, beta, c, ic, jc, isupper);
			return;
		}


		public static void smp_rmatrixsyrk(int n, int k, double alpha, double[,] a, int ia, int ja, int optypea, double beta, ref double[,] c, int ic, int jc, bool isupper)
		{

			ablas._pexec_rmatrixsyrk(n, k, alpha, a, ia, ja, optypea, beta, c, ic, jc, isupper);
			return;
		}

		/*************************************************************************

		*************************************************************************/
		public static void cmatrixgemm(int m, int n, int k, complex alpha, complex[,] a, int ia, int ja, int optypea, complex[,] b, int ib, int jb, int optypeb, complex beta, ref complex[,] c, int ic, int jc)
		{

			ablas.cmatrixgemm(m, n, k, alpha, a, ia, ja, optypea, b, ib, jb, optypeb, beta, c, ic, jc);
			return;
		}


		public static void smp_cmatrixgemm(int m, int n, int k, complex alpha, complex[,] a, int ia, int ja, int optypea, complex[,] b, int ib, int jb, int optypeb, complex beta, ref complex[,] c, int ic, int jc)
		{

			ablas._pexec_cmatrixgemm(m, n, k, alpha, a, ia, ja, optypea, b, ib, jb, optypeb, beta, c, ic, jc);
			return;
		}

		/*************************************************************************

		*************************************************************************/
		public static void rmatrixgemm(int m, int n, int k, double alpha, double[,] a, int ia, int ja, int optypea, double[,] b, int ib, int jb, int optypeb, double beta, ref double[,] c, int ic, int jc)
		{

			ablas.rmatrixgemm(m, n, k, alpha, a, ia, ja, optypea, b, ib, jb, optypeb, beta, c, ic, jc);
			return;
		}


		public static void smp_rmatrixgemm(int m, int n, int k, double alpha, double[,] a, int ia, int ja, int optypea, double[,] b, int ib, int jb, int optypeb, double beta, ref double[,] c, int ic, int jc)
		{

			ablas._pexec_rmatrixgemm(m, n, k, alpha, a, ia, ja, optypea, b, ib, jb, optypeb, beta, c, ic, jc);
			return;
		}

	}
	public partial class alglib
	{


		/*************************************************************************
		QR decomposition of a rectangular matrix of size MxN

		Input parameters:
				A   -   matrix A whose indexes range within [0..M-1, 0..N-1].
				M   -   number of rows in matrix A.
				N   -   number of columns in matrix A.

		Output parameters:
				A   -   matrices Q and R in compact form (see below).
				Tau -   array of scalar factors which are used to form
								matrix Q. Array whose index ranges within [0.. Min(M-1,N-1)].

		Matrix A is represented as A = QR, where Q is an orthogonal matrix of size
		MxM, R - upper triangular (or upper trapezoid) matrix of size M x N.

		The elements of matrix R are located on and above the main diagonal of
		matrix A. The elements which are located in Tau array and below the main
		diagonal of matrix A are used to form matrix Q as follows:

		Matrix Q is represented as a product of elementary reflections

		Q = H(0)*H(2)*...*H(k-1),

		where k = min(m,n), and each H(i) is in the form

		H(i) = 1 - tau * v * (v^T)

		where tau is a scalar stored in Tau[I]; v - real vector,
		so that v(0:i-1) = 0, v(i) = 1, v(i+1:m-1) stored in A(i+1:m-1,i).

			-- ALGLIB routine --
				 17.02.2010
				 Bochkanov Sergey
		*************************************************************************/
		public static void rmatrixqr(ref double[,] a, int m, int n, out double[] tau)
		{
			tau = new double[0];
			ortfac.rmatrixqr(ref a, m, n, ref tau);
			return;
		}

		/*************************************************************************
		LQ decomposition of a rectangular matrix of size MxN

		Input parameters:
				A   -   matrix A whose indexes range within [0..M-1, 0..N-1].
				M   -   number of rows in matrix A.
				N   -   number of columns in matrix A.

		Output parameters:
				A   -   matrices L and Q in compact form (see below)
				Tau -   array of scalar factors which are used to form
								matrix Q. Array whose index ranges within [0..Min(M,N)-1].

		Matrix A is represented as A = LQ, where Q is an orthogonal matrix of size
		MxM, L - lower triangular (or lower trapezoid) matrix of size M x N.

		The elements of matrix L are located on and below  the  main  diagonal  of
		matrix A. The elements which are located in Tau array and above  the  main
		diagonal of matrix A are used to form matrix Q as follows:

		Matrix Q is represented as a product of elementary reflections

		Q = H(k-1)*H(k-2)*...*H(1)*H(0),

		where k = min(m,n), and each H(i) is of the form

		H(i) = 1 - tau * v * (v^T)

		where tau is a scalar stored in Tau[I]; v - real vector, so that v(0:i-1)=0,
		v(i) = 1, v(i+1:n-1) stored in A(i,i+1:n-1).

			-- ALGLIB routine --
				 17.02.2010
				 Bochkanov Sergey
		*************************************************************************/
		public static void rmatrixlq(ref double[,] a, int m, int n, out double[] tau)
		{
			tau = new double[0];
			ortfac.rmatrixlq(ref a, m, n, ref tau);
			return;
		}

		/*************************************************************************
		QR decomposition of a rectangular complex matrix of size MxN

		Input parameters:
				A   -   matrix A whose indexes range within [0..M-1, 0..N-1]
				M   -   number of rows in matrix A.
				N   -   number of columns in matrix A.

		Output parameters:
				A   -   matrices Q and R in compact form
				Tau -   array of scalar factors which are used to form matrix Q. Array
								whose indexes range within [0.. Min(M,N)-1]

		Matrix A is represented as A = QR, where Q is an orthogonal matrix of size
		MxM, R - upper triangular (or upper trapezoid) matrix of size MxN.

			-- LAPACK routine (version 3.0) --
				 Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
				 Courant Institute, Argonne National Lab, and Rice University
				 September 30, 1994
		*************************************************************************/
		public static void cmatrixqr(ref complex[,] a, int m, int n, out complex[] tau)
		{
			tau = new complex[0];
			ortfac.cmatrixqr(ref a, m, n, ref tau);
			return;
		}

		/*************************************************************************
		LQ decomposition of a rectangular complex matrix of size MxN

		Input parameters:
				A   -   matrix A whose indexes range within [0..M-1, 0..N-1]
				M   -   number of rows in matrix A.
				N   -   number of columns in matrix A.

		Output parameters:
				A   -   matrices Q and L in compact form
				Tau -   array of scalar factors which are used to form matrix Q. Array
								whose indexes range within [0.. Min(M,N)-1]

		Matrix A is represented as A = LQ, where Q is an orthogonal matrix of size
		MxM, L - lower triangular (or lower trapezoid) matrix of size MxN.

			-- LAPACK routine (version 3.0) --
				 Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
				 Courant Institute, Argonne National Lab, and Rice University
				 September 30, 1994
		*************************************************************************/
		public static void cmatrixlq(ref complex[,] a, int m, int n, out complex[] tau)
		{
			tau = new complex[0];
			ortfac.cmatrixlq(ref a, m, n, ref tau);
			return;
		}

		/*************************************************************************
		Partial unpacking of matrix Q from the QR decomposition of a matrix A

		Input parameters:
				A       -   matrices Q and R in compact form.
										Output of RMatrixQR subroutine.
				M       -   number of rows in given matrix A. M>=0.
				N       -   number of columns in given matrix A. N>=0.
				Tau     -   scalar factors which are used to form Q.
										Output of the RMatrixQR subroutine.
				QColumns -  required number of columns of matrix Q. M>=QColumns>=0.

		Output parameters:
				Q       -   first QColumns columns of matrix Q.
										Array whose indexes range within [0..M-1, 0..QColumns-1].
										If QColumns=0, the array remains unchanged.

			-- ALGLIB routine --
				 17.02.2010
				 Bochkanov Sergey
		*************************************************************************/
		public static void rmatrixqrunpackq(double[,] a, int m, int n, double[] tau, int qcolumns, out double[,] q)
		{
			q = new double[0, 0];
			ortfac.rmatrixqrunpackq(a, m, n, tau, qcolumns, ref q);
			return;
		}

		/*************************************************************************
		Unpacking of matrix R from the QR decomposition of a matrix A

		Input parameters:
				A       -   matrices Q and R in compact form.
										Output of RMatrixQR subroutine.
				M       -   number of rows in given matrix A. M>=0.
				N       -   number of columns in given matrix A. N>=0.

		Output parameters:
				R       -   matrix R, array[0..M-1, 0..N-1].

			-- ALGLIB routine --
				 17.02.2010
				 Bochkanov Sergey
		*************************************************************************/
		public static void rmatrixqrunpackr(double[,] a, int m, int n, out double[,] r)
		{
			r = new double[0, 0];
			ortfac.rmatrixqrunpackr(a, m, n, ref r);
			return;
		}

		/*************************************************************************
		Partial unpacking of matrix Q from the LQ decomposition of a matrix A

		Input parameters:
				A       -   matrices L and Q in compact form.
										Output of RMatrixLQ subroutine.
				M       -   number of rows in given matrix A. M>=0.
				N       -   number of columns in given matrix A. N>=0.
				Tau     -   scalar factors which are used to form Q.
										Output of the RMatrixLQ subroutine.
				QRows   -   required number of rows in matrix Q. N>=QRows>=0.

		Output parameters:
				Q       -   first QRows rows of matrix Q. Array whose indexes range
										within [0..QRows-1, 0..N-1]. If QRows=0, the array remains
										unchanged.

			-- ALGLIB routine --
				 17.02.2010
				 Bochkanov Sergey
		*************************************************************************/
		public static void rmatrixlqunpackq(double[,] a, int m, int n, double[] tau, int qrows, out double[,] q)
		{
			q = new double[0, 0];
			ortfac.rmatrixlqunpackq(a, m, n, tau, qrows, ref q);
			return;
		}

		/*************************************************************************
		Unpacking of matrix L from the LQ decomposition of a matrix A

		Input parameters:
				A       -   matrices Q and L in compact form.
										Output of RMatrixLQ subroutine.
				M       -   number of rows in given matrix A. M>=0.
				N       -   number of columns in given matrix A. N>=0.

		Output parameters:
				L       -   matrix L, array[0..M-1, 0..N-1].

			-- ALGLIB routine --
				 17.02.2010
				 Bochkanov Sergey
		*************************************************************************/
		public static void rmatrixlqunpackl(double[,] a, int m, int n, out double[,] l)
		{
			l = new double[0, 0];
			ortfac.rmatrixlqunpackl(a, m, n, ref l);
			return;
		}

		/*************************************************************************
		Partial unpacking of matrix Q from QR decomposition of a complex matrix A.

		Input parameters:
				A           -   matrices Q and R in compact form.
												Output of CMatrixQR subroutine .
				M           -   number of rows in matrix A. M>=0.
				N           -   number of columns in matrix A. N>=0.
				Tau         -   scalar factors which are used to form Q.
												Output of CMatrixQR subroutine .
				QColumns    -   required number of columns in matrix Q. M>=QColumns>=0.

		Output parameters:
				Q           -   first QColumns columns of matrix Q.
												Array whose index ranges within [0..M-1, 0..QColumns-1].
												If QColumns=0, array isn't changed.

			-- ALGLIB routine --
				 17.02.2010
				 Bochkanov Sergey
		*************************************************************************/
		public static void cmatrixqrunpackq(complex[,] a, int m, int n, complex[] tau, int qcolumns, out complex[,] q)
		{
			q = new complex[0, 0];
			ortfac.cmatrixqrunpackq(a, m, n, tau, qcolumns, ref q);
			return;
		}

		/*************************************************************************
		Unpacking of matrix R from the QR decomposition of a matrix A

		Input parameters:
				A       -   matrices Q and R in compact form.
										Output of CMatrixQR subroutine.
				M       -   number of rows in given matrix A. M>=0.
				N       -   number of columns in given matrix A. N>=0.

		Output parameters:
				R       -   matrix R, array[0..M-1, 0..N-1].

			-- ALGLIB routine --
				 17.02.2010
				 Bochkanov Sergey
		*************************************************************************/
		public static void cmatrixqrunpackr(complex[,] a, int m, int n, out complex[,] r)
		{
			r = new complex[0, 0];
			ortfac.cmatrixqrunpackr(a, m, n, ref r);
			return;
		}

		/*************************************************************************
		Partial unpacking of matrix Q from LQ decomposition of a complex matrix A.

		Input parameters:
				A           -   matrices Q and R in compact form.
												Output of CMatrixLQ subroutine .
				M           -   number of rows in matrix A. M>=0.
				N           -   number of columns in matrix A. N>=0.
				Tau         -   scalar factors which are used to form Q.
												Output of CMatrixLQ subroutine .
				QRows       -   required number of rows in matrix Q. N>=QColumns>=0.

		Output parameters:
				Q           -   first QRows rows of matrix Q.
												Array whose index ranges within [0..QRows-1, 0..N-1].
												If QRows=0, array isn't changed.

			-- ALGLIB routine --
				 17.02.2010
				 Bochkanov Sergey
		*************************************************************************/
		public static void cmatrixlqunpackq(complex[,] a, int m, int n, complex[] tau, int qrows, out complex[,] q)
		{
			q = new complex[0, 0];
			ortfac.cmatrixlqunpackq(a, m, n, tau, qrows, ref q);
			return;
		}

		/*************************************************************************
		Unpacking of matrix L from the LQ decomposition of a matrix A

		Input parameters:
				A       -   matrices Q and L in compact form.
										Output of CMatrixLQ subroutine.
				M       -   number of rows in given matrix A. M>=0.
				N       -   number of columns in given matrix A. N>=0.

		Output parameters:
				L       -   matrix L, array[0..M-1, 0..N-1].

			-- ALGLIB routine --
				 17.02.2010
				 Bochkanov Sergey
		*************************************************************************/
		public static void cmatrixlqunpackl(complex[,] a, int m, int n, out complex[,] l)
		{
			l = new complex[0, 0];
			ortfac.cmatrixlqunpackl(a, m, n, ref l);
			return;
		}

		/*************************************************************************
		Reduction of a rectangular matrix to  bidiagonal form

		The algorithm reduces the rectangular matrix A to  bidiagonal form by
		orthogonal transformations P and Q: A = Q*B*P.

		Input parameters:
				A       -   source matrix. array[0..M-1, 0..N-1]
				M       -   number of rows in matrix A.
				N       -   number of columns in matrix A.

		Output parameters:
				A       -   matrices Q, B, P in compact form (see below).
				TauQ    -   scalar factors which are used to form matrix Q.
				TauP    -   scalar factors which are used to form matrix P.

		The main diagonal and one of the  secondary  diagonals  of  matrix  A  are
		replaced with bidiagonal  matrix  B.  Other  elements  contain  elementary
		reflections which form MxM matrix Q and NxN matrix P, respectively.

		If M>=N, B is the upper  bidiagonal  MxN  matrix  and  is  stored  in  the
		corresponding  elements  of  matrix  A.  Matrix  Q  is  represented  as  a
		product   of   elementary   reflections   Q = H(0)*H(1)*...*H(n-1),  where
		H(i) = 1-tau*v*v'. Here tau is a scalar which is stored  in  TauQ[i],  and
		vector v has the following  structure:  v(0:i-1)=0, v(i)=1, v(i+1:m-1)  is
		stored   in   elements   A(i+1:m-1,i).   Matrix   P  is  as  follows:  P =
		G(0)*G(1)*...*G(n-2), where G(i) = 1 - tau*u*u'. Tau is stored in TauP[i],
		u(0:i)=0, u(i+1)=1, u(i+2:n-1) is stored in elements A(i,i+2:n-1).

		If M<N, B is the  lower  bidiagonal  MxN  matrix  and  is  stored  in  the
		corresponding   elements  of  matrix  A.  Q = H(0)*H(1)*...*H(m-2),  where
		H(i) = 1 - tau*v*v', tau is stored in TauQ, v(0:i)=0, v(i+1)=1, v(i+2:m-1)
		is    stored    in   elements   A(i+2:m-1,i).    P = G(0)*G(1)*...*G(m-1),
		G(i) = 1-tau*u*u', tau is stored in  TauP,  u(0:i-1)=0, u(i)=1, u(i+1:n-1)
		is stored in A(i,i+1:n-1).

		EXAMPLE:

		m=6, n=5 (m > n):               m=5, n=6 (m < n):

		(  d   e   u1  u1  u1 )         (  d   u1  u1  u1  u1  u1 )
		(  v1  d   e   u2  u2 )         (  e   d   u2  u2  u2  u2 )
		(  v1  v2  d   e   u3 )         (  v1  e   d   u3  u3  u3 )
		(  v1  v2  v3  d   e  )         (  v1  v2  e   d   u4  u4 )
		(  v1  v2  v3  v4  d  )         (  v1  v2  v3  e   d   u5 )
		(  v1  v2  v3  v4  v5 )

		Here vi and ui are vectors which form H(i) and G(i), and d and e -
		are the diagonal and off-diagonal elements of matrix B.

			-- LAPACK routine (version 3.0) --
				 Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
				 Courant Institute, Argonne National Lab, and Rice University
				 September 30, 1994.
				 Sergey Bochkanov, ALGLIB project, translation from FORTRAN to
				 pseudocode, 2007-2010.
		*************************************************************************/
		public static void rmatrixbd(ref double[,] a, int m, int n, out double[] tauq, out double[] taup)
		{
			tauq = new double[0];
			taup = new double[0];
			ortfac.rmatrixbd(ref a, m, n, ref tauq, ref taup);
			return;
		}

		/*************************************************************************
		Unpacking matrix Q which reduces a matrix to bidiagonal form.

		Input parameters:
				QP          -   matrices Q and P in compact form.
												Output of ToBidiagonal subroutine.
				M           -   number of rows in matrix A.
				N           -   number of columns in matrix A.
				TAUQ        -   scalar factors which are used to form Q.
												Output of ToBidiagonal subroutine.
				QColumns    -   required number of columns in matrix Q.
												M>=QColumns>=0.

		Output parameters:
				Q           -   first QColumns columns of matrix Q.
												Array[0..M-1, 0..QColumns-1]
												If QColumns=0, the array is not modified.

			-- ALGLIB --
				 2005-2010
				 Bochkanov Sergey
		*************************************************************************/
		public static void rmatrixbdunpackq(double[,] qp, int m, int n, double[] tauq, int qcolumns, out double[,] q)
		{
			q = new double[0, 0];
			ortfac.rmatrixbdunpackq(qp, m, n, tauq, qcolumns, ref q);
			return;
		}

		/*************************************************************************
		Multiplication by matrix Q which reduces matrix A to  bidiagonal form.

		The algorithm allows pre- or post-multiply by Q or Q'.

		Input parameters:
				QP          -   matrices Q and P in compact form.
												Output of ToBidiagonal subroutine.
				M           -   number of rows in matrix A.
				N           -   number of columns in matrix A.
				TAUQ        -   scalar factors which are used to form Q.
												Output of ToBidiagonal subroutine.
				Z           -   multiplied matrix.
												array[0..ZRows-1,0..ZColumns-1]
				ZRows       -   number of rows in matrix Z. If FromTheRight=False,
												ZRows=M, otherwise ZRows can be arbitrary.
				ZColumns    -   number of columns in matrix Z. If FromTheRight=True,
												ZColumns=M, otherwise ZColumns can be arbitrary.
				FromTheRight -  pre- or post-multiply.
				DoTranspose -   multiply by Q or Q'.

		Output parameters:
				Z           -   product of Z and Q.
												Array[0..ZRows-1,0..ZColumns-1]
												If ZRows=0 or ZColumns=0, the array is not modified.

			-- ALGLIB --
				 2005-2010
				 Bochkanov Sergey
		*************************************************************************/
		public static void rmatrixbdmultiplybyq(double[,] qp, int m, int n, double[] tauq, ref double[,] z, int zrows, int zcolumns, bool fromtheright, bool dotranspose)
		{

			ortfac.rmatrixbdmultiplybyq(qp, m, n, tauq, ref z, zrows, zcolumns, fromtheright, dotranspose);
			return;
		}

		/*************************************************************************
		Unpacking matrix P which reduces matrix A to bidiagonal form.
		The subroutine returns transposed matrix P.

		Input parameters:
				QP      -   matrices Q and P in compact form.
										Output of ToBidiagonal subroutine.
				M       -   number of rows in matrix A.
				N       -   number of columns in matrix A.
				TAUP    -   scalar factors which are used to form P.
										Output of ToBidiagonal subroutine.
				PTRows  -   required number of rows of matrix P^T. N >= PTRows >= 0.

		Output parameters:
				PT      -   first PTRows columns of matrix P^T
										Array[0..PTRows-1, 0..N-1]
										If PTRows=0, the array is not modified.

			-- ALGLIB --
				 2005-2010
				 Bochkanov Sergey
		*************************************************************************/
		public static void rmatrixbdunpackpt(double[,] qp, int m, int n, double[] taup, int ptrows, out double[,] pt)
		{
			pt = new double[0, 0];
			ortfac.rmatrixbdunpackpt(qp, m, n, taup, ptrows, ref pt);
			return;
		}

		/*************************************************************************
		Multiplication by matrix P which reduces matrix A to  bidiagonal form.

		The algorithm allows pre- or post-multiply by P or P'.

		Input parameters:
				QP          -   matrices Q and P in compact form.
												Output of RMatrixBD subroutine.
				M           -   number of rows in matrix A.
				N           -   number of columns in matrix A.
				TAUP        -   scalar factors which are used to form P.
												Output of RMatrixBD subroutine.
				Z           -   multiplied matrix.
												Array whose indexes range within [0..ZRows-1,0..ZColumns-1].
				ZRows       -   number of rows in matrix Z. If FromTheRight=False,
												ZRows=N, otherwise ZRows can be arbitrary.
				ZColumns    -   number of columns in matrix Z. If FromTheRight=True,
												ZColumns=N, otherwise ZColumns can be arbitrary.
				FromTheRight -  pre- or post-multiply.
				DoTranspose -   multiply by P or P'.

		Output parameters:
				Z - product of Z and P.
										Array whose indexes range within [0..ZRows-1,0..ZColumns-1].
										If ZRows=0 or ZColumns=0, the array is not modified.

			-- ALGLIB --
				 2005-2010
				 Bochkanov Sergey
		*************************************************************************/
		public static void rmatrixbdmultiplybyp(double[,] qp, int m, int n, double[] taup, ref double[,] z, int zrows, int zcolumns, bool fromtheright, bool dotranspose)
		{

			ortfac.rmatrixbdmultiplybyp(qp, m, n, taup, ref z, zrows, zcolumns, fromtheright, dotranspose);
			return;
		}

		/*************************************************************************
		Unpacking of the main and secondary diagonals of bidiagonal decomposition
		of matrix A.

		Input parameters:
				B   -   output of RMatrixBD subroutine.
				M   -   number of rows in matrix B.
				N   -   number of columns in matrix B.

		Output parameters:
				IsUpper -   True, if the matrix is upper bidiagonal.
										otherwise IsUpper is False.
				D       -   the main diagonal.
										Array whose index ranges within [0..Min(M,N)-1].
				E       -   the secondary diagonal (upper or lower, depending on
										the value of IsUpper).
										Array index ranges within [0..Min(M,N)-1], the last
										element is not used.

			-- ALGLIB --
				 2005-2010
				 Bochkanov Sergey
		*************************************************************************/
		public static void rmatrixbdunpackdiagonals(double[,] b, int m, int n, out bool isupper, out double[] d, out double[] e)
		{
			isupper = false;
			d = new double[0];
			e = new double[0];
			ortfac.rmatrixbdunpackdiagonals(b, m, n, ref isupper, ref d, ref e);
			return;
		}

		/*************************************************************************
		Reduction of a square matrix to  upper Hessenberg form: Q'*A*Q = H,
		where Q is an orthogonal matrix, H - Hessenberg matrix.

		Input parameters:
				A       -   matrix A with elements [0..N-1, 0..N-1]
				N       -   size of matrix A.

		Output parameters:
				A       -   matrices Q and P in  compact form (see below).
				Tau     -   array of scalar factors which are used to form matrix Q.
										Array whose index ranges within [0..N-2]

		Matrix H is located on the main diagonal, on the lower secondary  diagonal
		and above the main diagonal of matrix A. The elements which are used to
		form matrix Q are situated in array Tau and below the lower secondary
		diagonal of matrix A as follows:

		Matrix Q is represented as a product of elementary reflections

		Q = H(0)*H(2)*...*H(n-2),

		where each H(i) is given by

		H(i) = 1 - tau * v * (v^T)

		where tau is a scalar stored in Tau[I]; v - is a real vector,
		so that v(0:i) = 0, v(i+1) = 1, v(i+2:n-1) stored in A(i+2:n-1,i).

			-- LAPACK routine (version 3.0) --
				 Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
				 Courant Institute, Argonne National Lab, and Rice University
				 October 31, 1992
		*************************************************************************/
		public static void rmatrixhessenberg(ref double[,] a, int n, out double[] tau)
		{
			tau = new double[0];
			ortfac.rmatrixhessenberg(ref a, n, ref tau);
			return;
		}

		/*************************************************************************
		Unpacking matrix Q which reduces matrix A to upper Hessenberg form

		Input parameters:
				A   -   output of RMatrixHessenberg subroutine.
				N   -   size of matrix A.
				Tau -   scalar factors which are used to form Q.
								Output of RMatrixHessenberg subroutine.

		Output parameters:
				Q   -   matrix Q.
								Array whose indexes range within [0..N-1, 0..N-1].

			-- ALGLIB --
				 2005-2010
				 Bochkanov Sergey
		*************************************************************************/
		public static void rmatrixhessenbergunpackq(double[,] a, int n, double[] tau, out double[,] q)
		{
			q = new double[0, 0];
			ortfac.rmatrixhessenbergunpackq(a, n, tau, ref q);
			return;
		}

		/*************************************************************************
		Unpacking matrix H (the result of matrix A reduction to upper Hessenberg form)

		Input parameters:
				A   -   output of RMatrixHessenberg subroutine.
				N   -   size of matrix A.

		Output parameters:
				H   -   matrix H. Array whose indexes range within [0..N-1, 0..N-1].

			-- ALGLIB --
				 2005-2010
				 Bochkanov Sergey
		*************************************************************************/
		public static void rmatrixhessenbergunpackh(double[,] a, int n, out double[,] h)
		{
			h = new double[0, 0];
			ortfac.rmatrixhessenbergunpackh(a, n, ref h);
			return;
		}

		/*************************************************************************
		Reduction of a symmetric matrix which is given by its higher or lower
		triangular part to a tridiagonal matrix using orthogonal similarity
		transformation: Q'*A*Q=T.

		Input parameters:
				A       -   matrix to be transformed
										array with elements [0..N-1, 0..N-1].
				N       -   size of matrix A.
				IsUpper -   storage format. If IsUpper = True, then matrix A is given
										by its upper triangle, and the lower triangle is not used
										and not modified by the algorithm, and vice versa
										if IsUpper = False.

		Output parameters:
				A       -   matrices T and Q in  compact form (see lower)
				Tau     -   array of factors which are forming matrices H(i)
										array with elements [0..N-2].
				D       -   main diagonal of symmetric matrix T.
										array with elements [0..N-1].
				E       -   secondary diagonal of symmetric matrix T.
										array with elements [0..N-2].


			If IsUpper=True, the matrix Q is represented as a product of elementary
			reflectors

				 Q = H(n-2) . . . H(2) H(0).

			Each H(i) has the form

				 H(i) = I - tau * v * v'

			where tau is a real scalar, and v is a real vector with
			v(i+1:n-1) = 0, v(i) = 1, v(0:i-1) is stored on exit in
			A(0:i-1,i+1), and tau in TAU(i).

			If IsUpper=False, the matrix Q is represented as a product of elementary
			reflectors

				 Q = H(0) H(2) . . . H(n-2).

			Each H(i) has the form

				 H(i) = I - tau * v * v'

			where tau is a real scalar, and v is a real vector with
			v(0:i) = 0, v(i+1) = 1, v(i+2:n-1) is stored on exit in A(i+2:n-1,i),
			and tau in TAU(i).

			The contents of A on exit are illustrated by the following examples
			with n = 5:

			if UPLO = 'U':                       if UPLO = 'L':

				(  d   e   v1  v2  v3 )              (  d                  )
				(      d   e   v2  v3 )              (  e   d              )
				(          d   e   v3 )              (  v0  e   d          )
				(              d   e  )              (  v0  v1  e   d      )
				(                  d  )              (  v0  v1  v2  e   d  )

			where d and e denote diagonal and off-diagonal elements of T, and vi
			denotes an element of the vector defining H(i).

			-- LAPACK routine (version 3.0) --
				 Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
				 Courant Institute, Argonne National Lab, and Rice University
				 October 31, 1992
		*************************************************************************/
		public static void smatrixtd(ref double[,] a, int n, bool isupper, out double[] tau, out double[] d, out double[] e)
		{
			tau = new double[0];
			d = new double[0];
			e = new double[0];
			ortfac.smatrixtd(ref a, n, isupper, ref tau, ref d, ref e);
			return;
		}

		/*************************************************************************
		Unpacking matrix Q which reduces symmetric matrix to a tridiagonal
		form.

		Input parameters:
				A       -   the result of a SMatrixTD subroutine
				N       -   size of matrix A.
				IsUpper -   storage format (a parameter of SMatrixTD subroutine)
				Tau     -   the result of a SMatrixTD subroutine

		Output parameters:
				Q       -   transformation matrix.
										array with elements [0..N-1, 0..N-1].

			-- ALGLIB --
				 Copyright 2005-2010 by Bochkanov Sergey
		*************************************************************************/
		public static void smatrixtdunpackq(double[,] a, int n, bool isupper, double[] tau, out double[,] q)
		{
			q = new double[0, 0];
			ortfac.smatrixtdunpackq(a, n, isupper, tau, ref q);
			return;
		}

		/*************************************************************************
		Reduction of a Hermitian matrix which is given  by  its  higher  or  lower
		triangular part to a real  tridiagonal  matrix  using  unitary  similarity
		transformation: Q'*A*Q = T.

		Input parameters:
				A       -   matrix to be transformed
										array with elements [0..N-1, 0..N-1].
				N       -   size of matrix A.
				IsUpper -   storage format. If IsUpper = True, then matrix A is  given
										by its upper triangle, and the lower triangle is not  used
										and not modified by the algorithm, and vice versa
										if IsUpper = False.

		Output parameters:
				A       -   matrices T and Q in  compact form (see lower)
				Tau     -   array of factors which are forming matrices H(i)
										array with elements [0..N-2].
				D       -   main diagonal of real symmetric matrix T.
										array with elements [0..N-1].
				E       -   secondary diagonal of real symmetric matrix T.
										array with elements [0..N-2].


			If IsUpper=True, the matrix Q is represented as a product of elementary
			reflectors

				 Q = H(n-2) . . . H(2) H(0).

			Each H(i) has the form

				 H(i) = I - tau * v * v'

			where tau is a complex scalar, and v is a complex vector with
			v(i+1:n-1) = 0, v(i) = 1, v(0:i-1) is stored on exit in
			A(0:i-1,i+1), and tau in TAU(i).

			If IsUpper=False, the matrix Q is represented as a product of elementary
			reflectors

				 Q = H(0) H(2) . . . H(n-2).

			Each H(i) has the form

				 H(i) = I - tau * v * v'

			where tau is a complex scalar, and v is a complex vector with
			v(0:i) = 0, v(i+1) = 1, v(i+2:n-1) is stored on exit in A(i+2:n-1,i),
			and tau in TAU(i).

			The contents of A on exit are illustrated by the following examples
			with n = 5:

			if UPLO = 'U':                       if UPLO = 'L':

				(  d   e   v1  v2  v3 )              (  d                  )
				(      d   e   v2  v3 )              (  e   d              )
				(          d   e   v3 )              (  v0  e   d          )
				(              d   e  )              (  v0  v1  e   d      )
				(                  d  )              (  v0  v1  v2  e   d  )

		where d and e denote diagonal and off-diagonal elements of T, and vi
		denotes an element of the vector defining H(i).

			-- LAPACK routine (version 3.0) --
				 Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
				 Courant Institute, Argonne National Lab, and Rice University
				 October 31, 1992
		*************************************************************************/
		public static void hmatrixtd(ref complex[,] a, int n, bool isupper, out complex[] tau, out double[] d, out double[] e)
		{
			tau = new complex[0];
			d = new double[0];
			e = new double[0];
			ortfac.hmatrixtd(ref a, n, isupper, ref tau, ref d, ref e);
			return;
		}

		/*************************************************************************
		Unpacking matrix Q which reduces a Hermitian matrix to a real  tridiagonal
		form.

		Input parameters:
				A       -   the result of a HMatrixTD subroutine
				N       -   size of matrix A.
				IsUpper -   storage format (a parameter of HMatrixTD subroutine)
				Tau     -   the result of a HMatrixTD subroutine

		Output parameters:
				Q       -   transformation matrix.
										array with elements [0..N-1, 0..N-1].

			-- ALGLIB --
				 Copyright 2005-2010 by Bochkanov Sergey
		*************************************************************************/
		public static void hmatrixtdunpackq(complex[,] a, int n, bool isupper, complex[] tau, out complex[,] q)
		{
			q = new complex[0, 0];
			ortfac.hmatrixtdunpackq(a, n, isupper, tau, ref q);
			return;
		}

	}
	public partial class alglib
	{


		/*************************************************************************
		Singular value decomposition of a bidiagonal matrix (extended algorithm)

		The algorithm performs the singular value decomposition  of  a  bidiagonal
		matrix B (upper or lower) representing it as B = Q*S*P^T, where Q and  P -
		orthogonal matrices, S - diagonal matrix with non-negative elements on the
		main diagonal, in descending order.

		The  algorithm  finds  singular  values.  In  addition,  the algorithm can
		calculate  matrices  Q  and P (more precisely, not the matrices, but their
		product  with  given  matrices U and VT - U*Q and (P^T)*VT)).  Of  course,
		matrices U and VT can be of any type, including identity. Furthermore, the
		algorithm can calculate Q'*C (this product is calculated more  effectively
		than U*Q,  because  this calculation operates with rows instead  of matrix
		columns).

		The feature of the algorithm is its ability to find  all  singular  values
		including those which are arbitrarily close to 0  with  relative  accuracy
		close to  machine precision. If the parameter IsFractionalAccuracyRequired
		is set to True, all singular values will have high relative accuracy close
		to machine precision. If the parameter is set to False, only  the  biggest
		singular value will have relative accuracy  close  to  machine  precision.
		The absolute error of other singular values is equal to the absolute error
		of the biggest singular value.

		Input parameters:
				D       -   main diagonal of matrix B.
										Array whose index ranges within [0..N-1].
				E       -   superdiagonal (or subdiagonal) of matrix B.
										Array whose index ranges within [0..N-2].
				N       -   size of matrix B.
				IsUpper -   True, if the matrix is upper bidiagonal.
				IsFractionalAccuracyRequired -
										THIS PARAMETER IS IGNORED SINCE ALGLIB 3.5.0
										SINGULAR VALUES ARE ALWAYS SEARCHED WITH HIGH ACCURACY.
				U       -   matrix to be multiplied by Q.
										Array whose indexes range within [0..NRU-1, 0..N-1].
										The matrix can be bigger, in that case only the  submatrix
										[0..NRU-1, 0..N-1] will be multiplied by Q.
				NRU     -   number of rows in matrix U.
				C       -   matrix to be multiplied by Q'.
										Array whose indexes range within [0..N-1, 0..NCC-1].
										The matrix can be bigger, in that case only the  submatrix
										[0..N-1, 0..NCC-1] will be multiplied by Q'.
				NCC     -   number of columns in matrix C.
				VT      -   matrix to be multiplied by P^T.
										Array whose indexes range within [0..N-1, 0..NCVT-1].
										The matrix can be bigger, in that case only the  submatrix
										[0..N-1, 0..NCVT-1] will be multiplied by P^T.
				NCVT    -   number of columns in matrix VT.

		Output parameters:
				D       -   singular values of matrix B in descending order.
				U       -   if NRU>0, contains matrix U*Q.
				VT      -   if NCVT>0, contains matrix (P^T)*VT.
				C       -   if NCC>0, contains matrix Q'*C.

		Result:
				True, if the algorithm has converged.
				False, if the algorithm hasn't converged (rare case).

		Additional information:
				The type of convergence is controlled by the internal  parameter  TOL.
				If the parameter is greater than 0, the singular values will have
				relative accuracy TOL. If TOL<0, the singular values will have
				absolute accuracy ABS(TOL)*norm(B).
				By default, |TOL| falls within the range of 10*Epsilon and 100*Epsilon,
				where Epsilon is the machine precision. It is not  recommended  to  use
				TOL less than 10*Epsilon since this will  considerably  slow  down  the
				algorithm and may not lead to error decreasing.
		History:
				* 31 March, 2007.
						changed MAXITR from 6 to 12.

			-- LAPACK routine (version 3.0) --
				 Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
				 Courant Institute, Argonne National Lab, and Rice University
				 October 31, 1999.
		*************************************************************************/
		public static bool rmatrixbdsvd(ref double[] d, double[] e, int n, bool isupper, bool isfractionalaccuracyrequired, ref double[,] u, int nru, ref double[,] c, int ncc, ref double[,] vt, int ncvt)
		{

			bool result = bdsvd.rmatrixbdsvd(ref d, e, n, isupper, isfractionalaccuracyrequired, ref u, nru, ref c, ncc, ref vt, ncvt);
			return result;
		}

	}
	public partial class alglib
	{


		/*************************************************************************
		Singular value decomposition of a rectangular matrix.

		The algorithm calculates the singular value decomposition of a matrix of
		size MxN: A = U * S * V^T

		The algorithm finds the singular values and, optionally, matrices U and V^T.
		The algorithm can find both first min(M,N) columns of matrix U and rows of
		matrix V^T (singular vectors), and matrices U and V^T wholly (of sizes MxM
		and NxN respectively).

		Take into account that the subroutine does not return matrix V but V^T.

		Input parameters:
				A           -   matrix to be decomposed.
												Array whose indexes range within [0..M-1, 0..N-1].
				M           -   number of rows in matrix A.
				N           -   number of columns in matrix A.
				UNeeded     -   0, 1 or 2. See the description of the parameter U.
				VTNeeded    -   0, 1 or 2. See the description of the parameter VT.
				AdditionalMemory -
												If the parameter:
												 * equals 0, the algorithm doesn’t use additional
													 memory (lower requirements, lower performance).
												 * equals 1, the algorithm uses additional
													 memory of size min(M,N)*min(M,N) of real numbers.
													 It often speeds up the algorithm.
												 * equals 2, the algorithm uses additional
													 memory of size M*min(M,N) of real numbers.
													 It allows to get a maximum performance.
												The recommended value of the parameter is 2.

		Output parameters:
				W           -   contains singular values in descending order.
				U           -   if UNeeded=0, U isn't changed, the left singular vectors
												are not calculated.
												if Uneeded=1, U contains left singular vectors (first
												min(M,N) columns of matrix U). Array whose indexes range
												within [0..M-1, 0..Min(M,N)-1].
												if UNeeded=2, U contains matrix U wholly. Array whose
												indexes range within [0..M-1, 0..M-1].
				VT          -   if VTNeeded=0, VT isn’t changed, the right singular vectors
												are not calculated.
												if VTNeeded=1, VT contains right singular vectors (first
												min(M,N) rows of matrix V^T). Array whose indexes range
												within [0..min(M,N)-1, 0..N-1].
												if VTNeeded=2, VT contains matrix V^T wholly. Array whose
												indexes range within [0..N-1, 0..N-1].

			-- ALGLIB --
				 Copyright 2005 by Bochkanov Sergey
		*************************************************************************/
		public static bool rmatrixsvd(double[,] a, int m, int n, int uneeded, int vtneeded, int additionalmemory, out double[] w, out double[,] u, out double[,] vt)
		{
			w = new double[0];
			u = new double[0, 0];
			vt = new double[0, 0];
			bool result = svd.rmatrixsvd(a, m, n, uneeded, vtneeded, additionalmemory, ref w, ref u, ref vt);
			return result;
		}

	}
	public partial class alglib
	{


		/*************************************************************************
		Finding the eigenvalues and eigenvectors of a symmetric matrix

		The algorithm finds eigen pairs of a symmetric matrix by reducing it to
		tridiagonal form and using the QL/QR algorithm.

		Input parameters:
				A       -   symmetric matrix which is given by its upper or lower
										triangular part.
										Array whose indexes range within [0..N-1, 0..N-1].
				N       -   size of matrix A.
				ZNeeded -   flag controlling whether the eigenvectors are needed or not.
										If ZNeeded is equal to:
										 * 0, the eigenvectors are not returned;
										 * 1, the eigenvectors are returned.
				IsUpper -   storage format.

		Output parameters:
				D       -   eigenvalues in ascending order.
										Array whose index ranges within [0..N-1].
				Z       -   if ZNeeded is equal to:
										 * 0, Z hasn’t changed;
										 * 1, Z contains the eigenvectors.
										Array whose indexes range within [0..N-1, 0..N-1].
										The eigenvectors are stored in the matrix columns.

		Result:
				True, if the algorithm has converged.
				False, if the algorithm hasn't converged (rare case).

			-- ALGLIB --
				 Copyright 2005-2008 by Bochkanov Sergey
		*************************************************************************/
		public static bool smatrixevd(double[,] a, int n, int zneeded, bool isupper, out double[] d, out double[,] z)
		{
			d = new double[0];
			z = new double[0, 0];
			bool result = evd.smatrixevd(a, n, zneeded, isupper, ref d, ref z);
			return result;
		}

		/*************************************************************************
		Subroutine for finding the eigenvalues (and eigenvectors) of  a  symmetric
		matrix  in  a  given half open interval (A, B] by using  a  bisection  and
		inverse iteration

		Input parameters:
				A       -   symmetric matrix which is given by its upper or lower
										triangular part. Array [0..N-1, 0..N-1].
				N       -   size of matrix A.
				ZNeeded -   flag controlling whether the eigenvectors are needed or not.
										If ZNeeded is equal to:
										 * 0, the eigenvectors are not returned;
										 * 1, the eigenvectors are returned.
				IsUpperA -  storage format of matrix A.
				B1, B2 -    half open interval (B1, B2] to search eigenvalues in.

		Output parameters:
				M       -   number of eigenvalues found in a given half-interval (M>=0).
				W       -   array of the eigenvalues found.
										Array whose index ranges within [0..M-1].
				Z       -   if ZNeeded is equal to:
										 * 0, Z hasn’t changed;
										 * 1, Z contains eigenvectors.
										Array whose indexes range within [0..N-1, 0..M-1].
										The eigenvectors are stored in the matrix columns.

		Result:
				True, if successful. M contains the number of eigenvalues in the given
				half-interval (could be equal to 0), W contains the eigenvalues,
				Z contains the eigenvectors (if needed).

				False, if the bisection method subroutine wasn't able to find the
				eigenvalues in the given interval or if the inverse iteration subroutine
				wasn't able to find all the corresponding eigenvectors.
				In that case, the eigenvalues and eigenvectors are not returned,
				M is equal to 0.

			-- ALGLIB --
				 Copyright 07.01.2006 by Bochkanov Sergey
		*************************************************************************/
		public static bool smatrixevdr(double[,] a, int n, int zneeded, bool isupper, double b1, double b2, out int m, out double[] w, out double[,] z)
		{
			m = 0;
			w = new double[0];
			z = new double[0, 0];
			bool result = evd.smatrixevdr(a, n, zneeded, isupper, b1, b2, ref m, ref w, ref z);
			return result;
		}

		/*************************************************************************
		Subroutine for finding the eigenvalues and  eigenvectors  of  a  symmetric
		matrix with given indexes by using bisection and inverse iteration methods.

		Input parameters:
				A       -   symmetric matrix which is given by its upper or lower
										triangular part. Array whose indexes range within [0..N-1, 0..N-1].
				N       -   size of matrix A.
				ZNeeded -   flag controlling whether the eigenvectors are needed or not.
										If ZNeeded is equal to:
										 * 0, the eigenvectors are not returned;
										 * 1, the eigenvectors are returned.
				IsUpperA -  storage format of matrix A.
				I1, I2 -    index interval for searching (from I1 to I2).
										0 <= I1 <= I2 <= N-1.

		Output parameters:
				W       -   array of the eigenvalues found.
										Array whose index ranges within [0..I2-I1].
				Z       -   if ZNeeded is equal to:
										 * 0, Z hasn’t changed;
										 * 1, Z contains eigenvectors.
										Array whose indexes range within [0..N-1, 0..I2-I1].
										In that case, the eigenvectors are stored in the matrix columns.

		Result:
				True, if successful. W contains the eigenvalues, Z contains the
				eigenvectors (if needed).

				False, if the bisection method subroutine wasn't able to find the
				eigenvalues in the given interval or if the inverse iteration subroutine
				wasn't able to find all the corresponding eigenvectors.
				In that case, the eigenvalues and eigenvectors are not returned.

			-- ALGLIB --
				 Copyright 07.01.2006 by Bochkanov Sergey
		*************************************************************************/
		public static bool smatrixevdi(double[,] a, int n, int zneeded, bool isupper, int i1, int i2, out double[] w, out double[,] z)
		{
			w = new double[0];
			z = new double[0, 0];
			bool result = evd.smatrixevdi(a, n, zneeded, isupper, i1, i2, ref w, ref z);
			return result;
		}

		/*************************************************************************
		Finding the eigenvalues and eigenvectors of a Hermitian matrix

		The algorithm finds eigen pairs of a Hermitian matrix by  reducing  it  to
		real tridiagonal form and using the QL/QR algorithm.

		Input parameters:
				A       -   Hermitian matrix which is given  by  its  upper  or  lower
										triangular part.
										Array whose indexes range within [0..N-1, 0..N-1].
				N       -   size of matrix A.
				IsUpper -   storage format.
				ZNeeded -   flag controlling whether the eigenvectors  are  needed  or
										not. If ZNeeded is equal to:
										 * 0, the eigenvectors are not returned;
										 * 1, the eigenvectors are returned.

		Output parameters:
				D       -   eigenvalues in ascending order.
										Array whose index ranges within [0..N-1].
				Z       -   if ZNeeded is equal to:
										 * 0, Z hasn’t changed;
										 * 1, Z contains the eigenvectors.
										Array whose indexes range within [0..N-1, 0..N-1].
										The eigenvectors are stored in the matrix columns.

		Result:
				True, if the algorithm has converged.
				False, if the algorithm hasn't converged (rare case).

		Note:
				eigenvectors of Hermitian matrix are defined up to  multiplication  by
				a complex number L, such that |L|=1.

			-- ALGLIB --
				 Copyright 2005, 23 March 2007 by Bochkanov Sergey
		*************************************************************************/
		public static bool hmatrixevd(complex[,] a, int n, int zneeded, bool isupper, out double[] d, out complex[,] z)
		{
			d = new double[0];
			z = new complex[0, 0];
			bool result = evd.hmatrixevd(a, n, zneeded, isupper, ref d, ref z);
			return result;
		}

		/*************************************************************************
		Subroutine for finding the eigenvalues (and eigenvectors) of  a  Hermitian
		matrix  in  a  given half-interval (A, B] by using a bisection and inverse
		iteration

		Input parameters:
				A       -   Hermitian matrix which is given  by  its  upper  or  lower
										triangular  part.  Array  whose   indexes   range   within
										[0..N-1, 0..N-1].
				N       -   size of matrix A.
				ZNeeded -   flag controlling whether the eigenvectors  are  needed  or
										not. If ZNeeded is equal to:
										 * 0, the eigenvectors are not returned;
										 * 1, the eigenvectors are returned.
				IsUpperA -  storage format of matrix A.
				B1, B2 -    half-interval (B1, B2] to search eigenvalues in.

		Output parameters:
				M       -   number of eigenvalues found in a given half-interval, M>=0
				W       -   array of the eigenvalues found.
										Array whose index ranges within [0..M-1].
				Z       -   if ZNeeded is equal to:
										 * 0, Z hasn’t changed;
										 * 1, Z contains eigenvectors.
										Array whose indexes range within [0..N-1, 0..M-1].
										The eigenvectors are stored in the matrix columns.

		Result:
				True, if successful. M contains the number of eigenvalues in the given
				half-interval (could be equal to 0), W contains the eigenvalues,
				Z contains the eigenvectors (if needed).

				False, if the bisection method subroutine  wasn't  able  to  find  the
				eigenvalues  in  the  given  interval  or  if  the  inverse  iteration
				subroutine  wasn't  able  to  find all the corresponding eigenvectors.
				In that case, the eigenvalues and eigenvectors are not returned, M  is
				equal to 0.

		Note:
				eigen vectors of Hermitian matrix are defined up to multiplication  by
				a complex number L, such as |L|=1.

			-- ALGLIB --
				 Copyright 07.01.2006, 24.03.2007 by Bochkanov Sergey.
		*************************************************************************/
		public static bool hmatrixevdr(complex[,] a, int n, int zneeded, bool isupper, double b1, double b2, out int m, out double[] w, out complex[,] z)
		{
			m = 0;
			w = new double[0];
			z = new complex[0, 0];
			bool result = evd.hmatrixevdr(a, n, zneeded, isupper, b1, b2, ref m, ref w, ref z);
			return result;
		}

		/*************************************************************************
		Subroutine for finding the eigenvalues and  eigenvectors  of  a  Hermitian
		matrix with given indexes by using bisection and inverse iteration methods

		Input parameters:
				A       -   Hermitian matrix which is given  by  its  upper  or  lower
										triangular part.
										Array whose indexes range within [0..N-1, 0..N-1].
				N       -   size of matrix A.
				ZNeeded -   flag controlling whether the eigenvectors  are  needed  or
										not. If ZNeeded is equal to:
										 * 0, the eigenvectors are not returned;
										 * 1, the eigenvectors are returned.
				IsUpperA -  storage format of matrix A.
				I1, I2 -    index interval for searching (from I1 to I2).
										0 <= I1 <= I2 <= N-1.

		Output parameters:
				W       -   array of the eigenvalues found.
										Array whose index ranges within [0..I2-I1].
				Z       -   if ZNeeded is equal to:
										 * 0, Z hasn’t changed;
										 * 1, Z contains eigenvectors.
										Array whose indexes range within [0..N-1, 0..I2-I1].
										In  that  case,  the eigenvectors are stored in the matrix
										columns.

		Result:
				True, if successful. W contains the eigenvalues, Z contains the
				eigenvectors (if needed).

				False, if the bisection method subroutine  wasn't  able  to  find  the
				eigenvalues  in  the  given  interval  or  if  the  inverse  iteration
				subroutine wasn't able to find  all  the  corresponding  eigenvectors.
				In that case, the eigenvalues and eigenvectors are not returned.

		Note:
				eigen vectors of Hermitian matrix are defined up to multiplication  by
				a complex number L, such as |L|=1.

			-- ALGLIB --
				 Copyright 07.01.2006, 24.03.2007 by Bochkanov Sergey.
		*************************************************************************/
		public static bool hmatrixevdi(complex[,] a, int n, int zneeded, bool isupper, int i1, int i2, out double[] w, out complex[,] z)
		{
			w = new double[0];
			z = new complex[0, 0];
			bool result = evd.hmatrixevdi(a, n, zneeded, isupper, i1, i2, ref w, ref z);
			return result;
		}

		/*************************************************************************
		Finding the eigenvalues and eigenvectors of a tridiagonal symmetric matrix

		The algorithm finds the eigen pairs of a tridiagonal symmetric matrix by
		using an QL/QR algorithm with implicit shifts.

		Input parameters:
				D       -   the main diagonal of a tridiagonal matrix.
										Array whose index ranges within [0..N-1].
				E       -   the secondary diagonal of a tridiagonal matrix.
										Array whose index ranges within [0..N-2].
				N       -   size of matrix A.
				ZNeeded -   flag controlling whether the eigenvectors are needed or not.
										If ZNeeded is equal to:
										 * 0, the eigenvectors are not needed;
										 * 1, the eigenvectors of a tridiagonal matrix
											 are multiplied by the square matrix Z. It is used if the
											 tridiagonal matrix is obtained by the similarity
											 transformation of a symmetric matrix;
										 * 2, the eigenvectors of a tridiagonal matrix replace the
											 square matrix Z;
										 * 3, matrix Z contains the first row of the eigenvectors
											 matrix.
				Z       -   if ZNeeded=1, Z contains the square matrix by which the
										eigenvectors are multiplied.
										Array whose indexes range within [0..N-1, 0..N-1].

		Output parameters:
				D       -   eigenvalues in ascending order.
										Array whose index ranges within [0..N-1].
				Z       -   if ZNeeded is equal to:
										 * 0, Z hasn’t changed;
										 * 1, Z contains the product of a given matrix (from the left)
											 and the eigenvectors matrix (from the right);
										 * 2, Z contains the eigenvectors.
										 * 3, Z contains the first row of the eigenvectors matrix.
										If ZNeeded<3, Z is the array whose indexes range within [0..N-1, 0..N-1].
										In that case, the eigenvectors are stored in the matrix columns.
										If ZNeeded=3, Z is the array whose indexes range within [0..0, 0..N-1].

		Result:
				True, if the algorithm has converged.
				False, if the algorithm hasn't converged.

			-- LAPACK routine (version 3.0) --
				 Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
				 Courant Institute, Argonne National Lab, and Rice University
				 September 30, 1994
		*************************************************************************/
		public static bool smatrixtdevd(ref double[] d, double[] e, int n, int zneeded, ref double[,] z)
		{

			bool result = evd.smatrixtdevd(ref d, e, n, zneeded, ref z);
			return result;
		}

		/*************************************************************************
		Subroutine for finding the tridiagonal matrix eigenvalues/vectors in a
		given half-interval (A, B] by using bisection and inverse iteration.

		Input parameters:
				D       -   the main diagonal of a tridiagonal matrix.
										Array whose index ranges within [0..N-1].
				E       -   the secondary diagonal of a tridiagonal matrix.
										Array whose index ranges within [0..N-2].
				N       -   size of matrix, N>=0.
				ZNeeded -   flag controlling whether the eigenvectors are needed or not.
										If ZNeeded is equal to:
										 * 0, the eigenvectors are not needed;
										 * 1, the eigenvectors of a tridiagonal matrix are multiplied
											 by the square matrix Z. It is used if the tridiagonal
											 matrix is obtained by the similarity transformation
											 of a symmetric matrix.
										 * 2, the eigenvectors of a tridiagonal matrix replace matrix Z.
				A, B    -   half-interval (A, B] to search eigenvalues in.
				Z       -   if ZNeeded is equal to:
										 * 0, Z isn't used and remains unchanged;
										 * 1, Z contains the square matrix (array whose indexes range
											 within [0..N-1, 0..N-1]) which reduces the given symmetric
											 matrix to tridiagonal form;
										 * 2, Z isn't used (but changed on the exit).

		Output parameters:
				D       -   array of the eigenvalues found.
										Array whose index ranges within [0..M-1].
				M       -   number of eigenvalues found in the given half-interval (M>=0).
				Z       -   if ZNeeded is equal to:
										 * 0, doesn't contain any information;
										 * 1, contains the product of a given NxN matrix Z (from the
											 left) and NxM matrix of the eigenvectors found (from the
											 right). Array whose indexes range within [0..N-1, 0..M-1].
										 * 2, contains the matrix of the eigenvectors found.
											 Array whose indexes range within [0..N-1, 0..M-1].

		Result:

				True, if successful. In that case, M contains the number of eigenvalues
				in the given half-interval (could be equal to 0), D contains the eigenvalues,
				Z contains the eigenvectors (if needed).
				It should be noted that the subroutine changes the size of arrays D and Z.

				False, if the bisection method subroutine wasn't able to find the
				eigenvalues in the given interval or if the inverse iteration subroutine
				wasn't able to find all the corresponding eigenvectors. In that case,
				the eigenvalues and eigenvectors are not returned, M is equal to 0.

			-- ALGLIB --
				 Copyright 31.03.2008 by Bochkanov Sergey
		*************************************************************************/
		public static bool smatrixtdevdr(ref double[] d, double[] e, int n, int zneeded, double a, double b, out int m, ref double[,] z)
		{
			m = 0;
			bool result = evd.smatrixtdevdr(ref d, e, n, zneeded, a, b, ref m, ref z);
			return result;
		}

		/*************************************************************************
		Subroutine for finding tridiagonal matrix eigenvalues/vectors with given
		indexes (in ascending order) by using the bisection and inverse iteraion.

		Input parameters:
				D       -   the main diagonal of a tridiagonal matrix.
										Array whose index ranges within [0..N-1].
				E       -   the secondary diagonal of a tridiagonal matrix.
										Array whose index ranges within [0..N-2].
				N       -   size of matrix. N>=0.
				ZNeeded -   flag controlling whether the eigenvectors are needed or not.
										If ZNeeded is equal to:
										 * 0, the eigenvectors are not needed;
										 * 1, the eigenvectors of a tridiagonal matrix are multiplied
											 by the square matrix Z. It is used if the
											 tridiagonal matrix is obtained by the similarity transformation
											 of a symmetric matrix.
										 * 2, the eigenvectors of a tridiagonal matrix replace
											 matrix Z.
				I1, I2  -   index interval for searching (from I1 to I2).
										0 <= I1 <= I2 <= N-1.
				Z       -   if ZNeeded is equal to:
										 * 0, Z isn't used and remains unchanged;
										 * 1, Z contains the square matrix (array whose indexes range within [0..N-1, 0..N-1])
											 which reduces the given symmetric matrix to  tridiagonal form;
										 * 2, Z isn't used (but changed on the exit).

		Output parameters:
				D       -   array of the eigenvalues found.
										Array whose index ranges within [0..I2-I1].
				Z       -   if ZNeeded is equal to:
										 * 0, doesn't contain any information;
										 * 1, contains the product of a given NxN matrix Z (from the left) and
											 Nx(I2-I1) matrix of the eigenvectors found (from the right).
											 Array whose indexes range within [0..N-1, 0..I2-I1].
										 * 2, contains the matrix of the eigenvalues found.
											 Array whose indexes range within [0..N-1, 0..I2-I1].


		Result:

				True, if successful. In that case, D contains the eigenvalues,
				Z contains the eigenvectors (if needed).
				It should be noted that the subroutine changes the size of arrays D and Z.

				False, if the bisection method subroutine wasn't able to find the eigenvalues
				in the given interval or if the inverse iteration subroutine wasn't able
				to find all the corresponding eigenvectors. In that case, the eigenvalues
				and eigenvectors are not returned.

			-- ALGLIB --
				 Copyright 25.12.2005 by Bochkanov Sergey
		*************************************************************************/
		public static bool smatrixtdevdi(ref double[] d, double[] e, int n, int zneeded, int i1, int i2, ref double[,] z)
		{

			bool result = evd.smatrixtdevdi(ref d, e, n, zneeded, i1, i2, ref z);
			return result;
		}

		/*************************************************************************
		Finding eigenvalues and eigenvectors of a general matrix

		The algorithm finds eigenvalues and eigenvectors of a general matrix by
		using the QR algorithm with multiple shifts. The algorithm can find
		eigenvalues and both left and right eigenvectors.

		The right eigenvector is a vector x such that A*x = w*x, and the left
		eigenvector is a vector y such that y'*A = w*y' (here y' implies a complex
		conjugate transposition of vector y).

		Input parameters:
				A       -   matrix. Array whose indexes range within [0..N-1, 0..N-1].
				N       -   size of matrix A.
				VNeeded -   flag controlling whether eigenvectors are needed or not.
										If VNeeded is equal to:
										 * 0, eigenvectors are not returned;
										 * 1, right eigenvectors are returned;
										 * 2, left eigenvectors are returned;
										 * 3, both left and right eigenvectors are returned.

		Output parameters:
				WR      -   real parts of eigenvalues.
										Array whose index ranges within [0..N-1].
				WR      -   imaginary parts of eigenvalues.
										Array whose index ranges within [0..N-1].
				VL, VR  -   arrays of left and right eigenvectors (if they are needed).
										If WI[i]=0, the respective eigenvalue is a real number,
										and it corresponds to the column number I of matrices VL/VR.
										If WI[i]>0, we have a pair of complex conjugate numbers with
										positive and negative imaginary parts:
												the first eigenvalue WR[i] + sqrt(-1)*WI[i];
												the second eigenvalue WR[i+1] + sqrt(-1)*WI[i+1];
												WI[i]>0
												WI[i+1] = -WI[i] < 0
										In that case, the eigenvector  corresponding to the first
										eigenvalue is located in i and i+1 columns of matrices
										VL/VR (the column number i contains the real part, and the
										column number i+1 contains the imaginary part), and the vector
										corresponding to the second eigenvalue is a complex conjugate to
										the first vector.
										Arrays whose indexes range within [0..N-1, 0..N-1].

		Result:
				True, if the algorithm has converged.
				False, if the algorithm has not converged.

		Note 1:
				Some users may ask the following question: what if WI[N-1]>0?
				WI[N] must contain an eigenvalue which is complex conjugate to the
				N-th eigenvalue, but the array has only size N?
				The answer is as follows: such a situation cannot occur because the
				algorithm finds a pairs of eigenvalues, therefore, if WI[i]>0, I is
				strictly less than N-1.

		Note 2:
				The algorithm performance depends on the value of the internal parameter
				NS of the InternalSchurDecomposition subroutine which defines the number
				of shifts in the QR algorithm (similarly to the block width in block-matrix
				algorithms of linear algebra). If you require maximum performance
				on your machine, it is recommended to adjust this parameter manually.


		See also the InternalTREVC subroutine.

		The algorithm is based on the LAPACK 3.0 library.
		*************************************************************************/
		public static bool rmatrixevd(double[,] a, int n, int vneeded, out double[] wr, out double[] wi, out double[,] vl, out double[,] vr)
		{
			wr = new double[0];
			wi = new double[0];
			vl = new double[0, 0];
			vr = new double[0, 0];
			bool result = evd.rmatrixevd(a, n, vneeded, ref wr, ref wi, ref vl, ref vr);
			return result;
		}

	}
	public partial class alglib
	{


		/*************************************************************************
		Generation of a random uniformly distributed (Haar) orthogonal matrix

		INPUT PARAMETERS:
				N   -   matrix size, N>=1

		OUTPUT PARAMETERS:
				A   -   orthogonal NxN matrix, array[0..N-1,0..N-1]

			-- ALGLIB routine --
				 04.12.2009
				 Bochkanov Sergey
		*************************************************************************/
		public static void rmatrixrndorthogonal(int n, out double[,] a)
		{
			a = new double[0, 0];
			matgen.rmatrixrndorthogonal(n, ref a);
			return;
		}

		/*************************************************************************
		Generation of random NxN matrix with given condition number and norm2(A)=1

		INPUT PARAMETERS:
				N   -   matrix size
				C   -   condition number (in 2-norm)

		OUTPUT PARAMETERS:
				A   -   random matrix with norm2(A)=1 and cond(A)=C

			-- ALGLIB routine --
				 04.12.2009
				 Bochkanov Sergey
		*************************************************************************/
		public static void rmatrixrndcond(int n, double c, out double[,] a)
		{
			a = new double[0, 0];
			matgen.rmatrixrndcond(n, c, ref a);
			return;
		}

		/*************************************************************************
		Generation of a random Haar distributed orthogonal complex matrix

		INPUT PARAMETERS:
				N   -   matrix size, N>=1

		OUTPUT PARAMETERS:
				A   -   orthogonal NxN matrix, array[0..N-1,0..N-1]

			-- ALGLIB routine --
				 04.12.2009
				 Bochkanov Sergey
		*************************************************************************/
		public static void cmatrixrndorthogonal(int n, out complex[,] a)
		{
			a = new complex[0, 0];
			matgen.cmatrixrndorthogonal(n, ref a);
			return;
		}

		/*************************************************************************
		Generation of random NxN complex matrix with given condition number C and
		norm2(A)=1

		INPUT PARAMETERS:
				N   -   matrix size
				C   -   condition number (in 2-norm)

		OUTPUT PARAMETERS:
				A   -   random matrix with norm2(A)=1 and cond(A)=C

			-- ALGLIB routine --
				 04.12.2009
				 Bochkanov Sergey
		*************************************************************************/
		public static void cmatrixrndcond(int n, double c, out complex[,] a)
		{
			a = new complex[0, 0];
			matgen.cmatrixrndcond(n, c, ref a);
			return;
		}

		/*************************************************************************
		Generation of random NxN symmetric matrix with given condition number  and
		norm2(A)=1

		INPUT PARAMETERS:
				N   -   matrix size
				C   -   condition number (in 2-norm)

		OUTPUT PARAMETERS:
				A   -   random matrix with norm2(A)=1 and cond(A)=C

			-- ALGLIB routine --
				 04.12.2009
				 Bochkanov Sergey
		*************************************************************************/
		public static void smatrixrndcond(int n, double c, out double[,] a)
		{
			a = new double[0, 0];
			matgen.smatrixrndcond(n, c, ref a);
			return;
		}

		/*************************************************************************
		Generation of random NxN symmetric positive definite matrix with given
		condition number and norm2(A)=1

		INPUT PARAMETERS:
				N   -   matrix size
				C   -   condition number (in 2-norm)

		OUTPUT PARAMETERS:
				A   -   random SPD matrix with norm2(A)=1 and cond(A)=C

			-- ALGLIB routine --
				 04.12.2009
				 Bochkanov Sergey
		*************************************************************************/
		public static void spdmatrixrndcond(int n, double c, out double[,] a)
		{
			a = new double[0, 0];
			matgen.spdmatrixrndcond(n, c, ref a);
			return;
		}

		/*************************************************************************
		Generation of random NxN Hermitian matrix with given condition number  and
		norm2(A)=1

		INPUT PARAMETERS:
				N   -   matrix size
				C   -   condition number (in 2-norm)

		OUTPUT PARAMETERS:
				A   -   random matrix with norm2(A)=1 and cond(A)=C

			-- ALGLIB routine --
				 04.12.2009
				 Bochkanov Sergey
		*************************************************************************/
		public static void hmatrixrndcond(int n, double c, out complex[,] a)
		{
			a = new complex[0, 0];
			matgen.hmatrixrndcond(n, c, ref a);
			return;
		}

		/*************************************************************************
		Generation of random NxN Hermitian positive definite matrix with given
		condition number and norm2(A)=1

		INPUT PARAMETERS:
				N   -   matrix size
				C   -   condition number (in 2-norm)

		OUTPUT PARAMETERS:
				A   -   random HPD matrix with norm2(A)=1 and cond(A)=C

			-- ALGLIB routine --
				 04.12.2009
				 Bochkanov Sergey
		*************************************************************************/
		public static void hpdmatrixrndcond(int n, double c, out complex[,] a)
		{
			a = new complex[0, 0];
			matgen.hpdmatrixrndcond(n, c, ref a);
			return;
		}

		/*************************************************************************
		Multiplication of MxN matrix by NxN random Haar distributed orthogonal matrix

		INPUT PARAMETERS:
				A   -   matrix, array[0..M-1, 0..N-1]
				M, N-   matrix size

		OUTPUT PARAMETERS:
				A   -   A*Q, where Q is random NxN orthogonal matrix

			-- ALGLIB routine --
				 04.12.2009
				 Bochkanov Sergey
		*************************************************************************/
		public static void rmatrixrndorthogonalfromtheright(ref double[,] a, int m, int n)
		{

			matgen.rmatrixrndorthogonalfromtheright(ref a, m, n);
			return;
		}

		/*************************************************************************
		Multiplication of MxN matrix by MxM random Haar distributed orthogonal matrix

		INPUT PARAMETERS:
				A   -   matrix, array[0..M-1, 0..N-1]
				M, N-   matrix size

		OUTPUT PARAMETERS:
				A   -   Q*A, where Q is random MxM orthogonal matrix

			-- ALGLIB routine --
				 04.12.2009
				 Bochkanov Sergey
		*************************************************************************/
		public static void rmatrixrndorthogonalfromtheleft(ref double[,] a, int m, int n)
		{

			matgen.rmatrixrndorthogonalfromtheleft(ref a, m, n);
			return;
		}

		/*************************************************************************
		Multiplication of MxN complex matrix by NxN random Haar distributed
		complex orthogonal matrix

		INPUT PARAMETERS:
				A   -   matrix, array[0..M-1, 0..N-1]
				M, N-   matrix size

		OUTPUT PARAMETERS:
				A   -   A*Q, where Q is random NxN orthogonal matrix

			-- ALGLIB routine --
				 04.12.2009
				 Bochkanov Sergey
		*************************************************************************/
		public static void cmatrixrndorthogonalfromtheright(ref complex[,] a, int m, int n)
		{

			matgen.cmatrixrndorthogonalfromtheright(ref a, m, n);
			return;
		}

		/*************************************************************************
		Multiplication of MxN complex matrix by MxM random Haar distributed
		complex orthogonal matrix

		INPUT PARAMETERS:
				A   -   matrix, array[0..M-1, 0..N-1]
				M, N-   matrix size

		OUTPUT PARAMETERS:
				A   -   Q*A, where Q is random MxM orthogonal matrix

			-- ALGLIB routine --
				 04.12.2009
				 Bochkanov Sergey
		*************************************************************************/
		public static void cmatrixrndorthogonalfromtheleft(ref complex[,] a, int m, int n)
		{

			matgen.cmatrixrndorthogonalfromtheleft(ref a, m, n);
			return;
		}

		/*************************************************************************
		Symmetric multiplication of NxN matrix by random Haar distributed
		orthogonal  matrix

		INPUT PARAMETERS:
				A   -   matrix, array[0..N-1, 0..N-1]
				N   -   matrix size

		OUTPUT PARAMETERS:
				A   -   Q'*A*Q, where Q is random NxN orthogonal matrix

			-- ALGLIB routine --
				 04.12.2009
				 Bochkanov Sergey
		*************************************************************************/
		public static void smatrixrndmultiply(ref double[,] a, int n)
		{

			matgen.smatrixrndmultiply(ref a, n);
			return;
		}

		/*************************************************************************
		Hermitian multiplication of NxN matrix by random Haar distributed
		complex orthogonal matrix

		INPUT PARAMETERS:
				A   -   matrix, array[0..N-1, 0..N-1]
				N   -   matrix size

		OUTPUT PARAMETERS:
				A   -   Q^H*A*Q, where Q is random NxN orthogonal matrix

			-- ALGLIB routine --
				 04.12.2009
				 Bochkanov Sergey
		*************************************************************************/
		public static void hmatrixrndmultiply(ref complex[,] a, int n)
		{

			matgen.hmatrixrndmultiply(ref a, n);
			return;
		}

	}
	public partial class alglib
	{


		/*************************************************************************
		LU decomposition of a general real matrix with row pivoting

		A is represented as A = P*L*U, where:
		* L is lower unitriangular matrix
		* U is upper triangular matrix
		* P = P0*P1*...*PK, K=min(M,N)-1,
			Pi - permutation matrix for I and Pivots[I]

		This is cache-oblivous implementation of LU decomposition.
		It is optimized for square matrices. As for rectangular matrices:
		* best case - M>>N
		* worst case - N>>M, small M, large N, matrix does not fit in CPU cache

		INPUT PARAMETERS:
				A       -   array[0..M-1, 0..N-1].
				M       -   number of rows in matrix A.
				N       -   number of columns in matrix A.


		OUTPUT PARAMETERS:
				A       -   matrices L and U in compact form:
										* L is stored under main diagonal
										* U is stored on and above main diagonal
				Pivots  -   permutation matrix in compact form.
										array[0..Min(M-1,N-1)].

			-- ALGLIB routine --
				 10.01.2010
				 Bochkanov Sergey
		*************************************************************************/
		public static void rmatrixlu(ref double[,] a, int m, int n, out int[] pivots)
		{
			pivots = new int[0];
			trfac.rmatrixlu(ref a, m, n, ref pivots);
			return;
		}

		/*************************************************************************
		LU decomposition of a general complex matrix with row pivoting

		A is represented as A = P*L*U, where:
		* L is lower unitriangular matrix
		* U is upper triangular matrix
		* P = P0*P1*...*PK, K=min(M,N)-1,
			Pi - permutation matrix for I and Pivots[I]

		This is cache-oblivous implementation of LU decomposition. It is optimized
		for square matrices. As for rectangular matrices:
		* best case - M>>N
		* worst case - N>>M, small M, large N, matrix does not fit in CPU cache

		INPUT PARAMETERS:
				A       -   array[0..M-1, 0..N-1].
				M       -   number of rows in matrix A.
				N       -   number of columns in matrix A.


		OUTPUT PARAMETERS:
				A       -   matrices L and U in compact form:
										* L is stored under main diagonal
										* U is stored on and above main diagonal
				Pivots  -   permutation matrix in compact form.
										array[0..Min(M-1,N-1)].

			-- ALGLIB routine --
				 10.01.2010
				 Bochkanov Sergey
		*************************************************************************/
		public static void cmatrixlu(ref complex[,] a, int m, int n, out int[] pivots)
		{
			pivots = new int[0];
			trfac.cmatrixlu(ref a, m, n, ref pivots);
			return;
		}

		/*************************************************************************
		Cache-oblivious Cholesky decomposition

		The algorithm computes Cholesky decomposition  of  a  Hermitian  positive-
		definite matrix. The result of an algorithm is a representation  of  A  as
		A=U'*U  or A=L*L' (here X' detones conj(X^T)).

		INPUT PARAMETERS:
				A       -   upper or lower triangle of a factorized matrix.
										array with elements [0..N-1, 0..N-1].
				N       -   size of matrix A.
				IsUpper -   if IsUpper=True, then A contains an upper triangle of
										a symmetric matrix, otherwise A contains a lower one.

		OUTPUT PARAMETERS:
				A       -   the result of factorization. If IsUpper=True, then
										the upper triangle contains matrix U, so that A = U'*U,
										and the elements below the main diagonal are not modified.
										Similarly, if IsUpper = False.

		RESULT:
				If  the  matrix  is  positive-definite,  the  function  returns  True.
				Otherwise, the function returns False. Contents of A is not determined
				in such case.

			-- ALGLIB routine --
				 15.12.2009
				 Bochkanov Sergey
		*************************************************************************/
		public static bool hpdmatrixcholesky(ref complex[,] a, int n, bool isupper)
		{

			bool result = trfac.hpdmatrixcholesky(ref a, n, isupper);
			return result;
		}

		/*************************************************************************
		Cache-oblivious Cholesky decomposition

		The algorithm computes Cholesky decomposition  of  a  symmetric  positive-
		definite matrix. The result of an algorithm is a representation  of  A  as
		A=U^T*U  or A=L*L^T

		INPUT PARAMETERS:
				A       -   upper or lower triangle of a factorized matrix.
										array with elements [0..N-1, 0..N-1].
				N       -   size of matrix A.
				IsUpper -   if IsUpper=True, then A contains an upper triangle of
										a symmetric matrix, otherwise A contains a lower one.

		OUTPUT PARAMETERS:
				A       -   the result of factorization. If IsUpper=True, then
										the upper triangle contains matrix U, so that A = U^T*U,
										and the elements below the main diagonal are not modified.
										Similarly, if IsUpper = False.

		RESULT:
				If  the  matrix  is  positive-definite,  the  function  returns  True.
				Otherwise, the function returns False. Contents of A is not determined
				in such case.

			-- ALGLIB routine --
				 15.12.2009
				 Bochkanov Sergey
		*************************************************************************/
		public static bool spdmatrixcholesky(ref double[,] a, int n, bool isupper)
		{

			bool result = trfac.spdmatrixcholesky(ref a, n, isupper);
			return result;
		}

	}
	public partial class alglib
	{


		/*************************************************************************
		Estimate of a matrix condition number (1-norm)

		The algorithm calculates a lower bound of the condition number. In this case,
		the algorithm does not return a lower bound of the condition number, but an
		inverse number (to avoid an overflow in case of a singular matrix).

		Input parameters:
				A   -   matrix. Array whose indexes range within [0..N-1, 0..N-1].
				N   -   size of matrix A.

		Result: 1/LowerBound(cond(A))

		NOTE:
				if k(A) is very large, then matrix is  assumed  degenerate,  k(A)=INF,
				0.0f is returned in such cases.
		*************************************************************************/
		public static double rmatrixrcond1(double[,] a, int n)
		{

			double result = rcond.rmatrixrcond1(a, n);
			return result;
		}

		/*************************************************************************
		Estimate of a matrix condition number (infinity-norm).

		The algorithm calculates a lower bound of the condition number. In this case,
		the algorithm does not return a lower bound of the condition number, but an
		inverse number (to avoid an overflow in case of a singular matrix).

		Input parameters:
				A   -   matrix. Array whose indexes range within [0..N-1, 0..N-1].
				N   -   size of matrix A.

		Result: 1/LowerBound(cond(A))

		NOTE:
				if k(A) is very large, then matrix is  assumed  degenerate,  k(A)=INF,
				0.0f is returned in such cases.
		*************************************************************************/
		public static double rmatrixrcondinf(double[,] a, int n)
		{

			double result = rcond.rmatrixrcondinf(a, n);
			return result;
		}

		/*************************************************************************
		Condition number estimate of a symmetric positive definite matrix.

		The algorithm calculates a lower bound of the condition number. In this case,
		the algorithm does not return a lower bound of the condition number, but an
		inverse number (to avoid an overflow in case of a singular matrix).

		It should be noted that 1-norm and inf-norm of condition numbers of symmetric
		matrices are equal, so the algorithm doesn't take into account the
		differences between these types of norms.

		Input parameters:
				A       -   symmetric positive definite matrix which is given by its
										upper or lower triangle depending on the value of
										IsUpper. Array with elements [0..N-1, 0..N-1].
				N       -   size of matrix A.
				IsUpper -   storage format.

		Result:
				1/LowerBound(cond(A)), if matrix A is positive definite,
			 -1, if matrix A is not positive definite, and its condition number
				could not be found by this algorithm.

		NOTE:
				if k(A) is very large, then matrix is  assumed  degenerate,  k(A)=INF,
				0.0f is returned in such cases.
		*************************************************************************/
		public static double spdmatrixrcond(double[,] a, int n, bool isupper)
		{

			double result = rcond.spdmatrixrcond(a, n, isupper);
			return result;
		}

		/*************************************************************************
		Triangular matrix: estimate of a condition number (1-norm)

		The algorithm calculates a lower bound of the condition number. In this case,
		the algorithm does not return a lower bound of the condition number, but an
		inverse number (to avoid an overflow in case of a singular matrix).

		Input parameters:
				A       -   matrix. Array[0..N-1, 0..N-1].
				N       -   size of A.
				IsUpper -   True, if the matrix is upper triangular.
				IsUnit  -   True, if the matrix has a unit diagonal.

		Result: 1/LowerBound(cond(A))

		NOTE:
				if k(A) is very large, then matrix is  assumed  degenerate,  k(A)=INF,
				0.0f is returned in such cases.
		*************************************************************************/
		public static double rmatrixtrrcond1(double[,] a, int n, bool isupper, bool isunit)
		{

			double result = rcond.rmatrixtrrcond1(a, n, isupper, isunit);
			return result;
		}

		/*************************************************************************
		Triangular matrix: estimate of a matrix condition number (infinity-norm).

		The algorithm calculates a lower bound of the condition number. In this case,
		the algorithm does not return a lower bound of the condition number, but an
		inverse number (to avoid an overflow in case of a singular matrix).

		Input parameters:
				A   -   matrix. Array whose indexes range within [0..N-1, 0..N-1].
				N   -   size of matrix A.
				IsUpper -   True, if the matrix is upper triangular.
				IsUnit  -   True, if the matrix has a unit diagonal.

		Result: 1/LowerBound(cond(A))

		NOTE:
				if k(A) is very large, then matrix is  assumed  degenerate,  k(A)=INF,
				0.0f is returned in such cases.
		*************************************************************************/
		public static double rmatrixtrrcondinf(double[,] a, int n, bool isupper, bool isunit)
		{

			double result = rcond.rmatrixtrrcondinf(a, n, isupper, isunit);
			return result;
		}

		/*************************************************************************
		Condition number estimate of a Hermitian positive definite matrix.

		The algorithm calculates a lower bound of the condition number. In this case,
		the algorithm does not return a lower bound of the condition number, but an
		inverse number (to avoid an overflow in case of a singular matrix).

		It should be noted that 1-norm and inf-norm of condition numbers of symmetric
		matrices are equal, so the algorithm doesn't take into account the
		differences between these types of norms.

		Input parameters:
				A       -   Hermitian positive definite matrix which is given by its
										upper or lower triangle depending on the value of
										IsUpper. Array with elements [0..N-1, 0..N-1].
				N       -   size of matrix A.
				IsUpper -   storage format.

		Result:
				1/LowerBound(cond(A)), if matrix A is positive definite,
			 -1, if matrix A is not positive definite, and its condition number
				could not be found by this algorithm.

		NOTE:
				if k(A) is very large, then matrix is  assumed  degenerate,  k(A)=INF,
				0.0f is returned in such cases.
		*************************************************************************/
		public static double hpdmatrixrcond(complex[,] a, int n, bool isupper)
		{

			double result = rcond.hpdmatrixrcond(a, n, isupper);
			return result;
		}

		/*************************************************************************
		Estimate of a matrix condition number (1-norm)

		The algorithm calculates a lower bound of the condition number. In this case,
		the algorithm does not return a lower bound of the condition number, but an
		inverse number (to avoid an overflow in case of a singular matrix).

		Input parameters:
				A   -   matrix. Array whose indexes range within [0..N-1, 0..N-1].
				N   -   size of matrix A.

		Result: 1/LowerBound(cond(A))

		NOTE:
				if k(A) is very large, then matrix is  assumed  degenerate,  k(A)=INF,
				0.0f is returned in such cases.
		*************************************************************************/
		public static double cmatrixrcond1(complex[,] a, int n)
		{

			double result = rcond.cmatrixrcond1(a, n);
			return result;
		}

		/*************************************************************************
		Estimate of a matrix condition number (infinity-norm).

		The algorithm calculates a lower bound of the condition number. In this case,
		the algorithm does not return a lower bound of the condition number, but an
		inverse number (to avoid an overflow in case of a singular matrix).

		Input parameters:
				A   -   matrix. Array whose indexes range within [0..N-1, 0..N-1].
				N   -   size of matrix A.

		Result: 1/LowerBound(cond(A))

		NOTE:
				if k(A) is very large, then matrix is  assumed  degenerate,  k(A)=INF,
				0.0f is returned in such cases.
		*************************************************************************/
		public static double cmatrixrcondinf(complex[,] a, int n)
		{

			double result = rcond.cmatrixrcondinf(a, n);
			return result;
		}

		/*************************************************************************
		Estimate of the condition number of a matrix given by its LU decomposition (1-norm)

		The algorithm calculates a lower bound of the condition number. In this case,
		the algorithm does not return a lower bound of the condition number, but an
		inverse number (to avoid an overflow in case of a singular matrix).

		Input parameters:
				LUA         -   LU decomposition of a matrix in compact form. Output of
												the RMatrixLU subroutine.
				N           -   size of matrix A.

		Result: 1/LowerBound(cond(A))

		NOTE:
				if k(A) is very large, then matrix is  assumed  degenerate,  k(A)=INF,
				0.0f is returned in such cases.
		*************************************************************************/
		public static double rmatrixlurcond1(double[,] lua, int n)
		{

			double result = rcond.rmatrixlurcond1(lua, n);
			return result;
		}

		/*************************************************************************
		Estimate of the condition number of a matrix given by its LU decomposition
		(infinity norm).

		The algorithm calculates a lower bound of the condition number. In this case,
		the algorithm does not return a lower bound of the condition number, but an
		inverse number (to avoid an overflow in case of a singular matrix).

		Input parameters:
				LUA     -   LU decomposition of a matrix in compact form. Output of
										the RMatrixLU subroutine.
				N       -   size of matrix A.

		Result: 1/LowerBound(cond(A))

		NOTE:
				if k(A) is very large, then matrix is  assumed  degenerate,  k(A)=INF,
				0.0f is returned in such cases.
		*************************************************************************/
		public static double rmatrixlurcondinf(double[,] lua, int n)
		{

			double result = rcond.rmatrixlurcondinf(lua, n);
			return result;
		}

		/*************************************************************************
		Condition number estimate of a symmetric positive definite matrix given by
		Cholesky decomposition.

		The algorithm calculates a lower bound of the condition number. In this
		case, the algorithm does not return a lower bound of the condition number,
		but an inverse number (to avoid an overflow in case of a singular matrix).

		It should be noted that 1-norm and inf-norm condition numbers of symmetric
		matrices are equal, so the algorithm doesn't take into account the
		differences between these types of norms.

		Input parameters:
				CD  - Cholesky decomposition of matrix A,
							output of SMatrixCholesky subroutine.
				N   - size of matrix A.

		Result: 1/LowerBound(cond(A))

		NOTE:
				if k(A) is very large, then matrix is  assumed  degenerate,  k(A)=INF,
				0.0f is returned in such cases.
		*************************************************************************/
		public static double spdmatrixcholeskyrcond(double[,] a, int n, bool isupper)
		{

			double result = rcond.spdmatrixcholeskyrcond(a, n, isupper);
			return result;
		}

		/*************************************************************************
		Condition number estimate of a Hermitian positive definite matrix given by
		Cholesky decomposition.

		The algorithm calculates a lower bound of the condition number. In this
		case, the algorithm does not return a lower bound of the condition number,
		but an inverse number (to avoid an overflow in case of a singular matrix).

		It should be noted that 1-norm and inf-norm condition numbers of symmetric
		matrices are equal, so the algorithm doesn't take into account the
		differences between these types of norms.

		Input parameters:
				CD  - Cholesky decomposition of matrix A,
							output of SMatrixCholesky subroutine.
				N   - size of matrix A.

		Result: 1/LowerBound(cond(A))

		NOTE:
				if k(A) is very large, then matrix is  assumed  degenerate,  k(A)=INF,
				0.0f is returned in such cases.
		*************************************************************************/
		public static double hpdmatrixcholeskyrcond(complex[,] a, int n, bool isupper)
		{

			double result = rcond.hpdmatrixcholeskyrcond(a, n, isupper);
			return result;
		}

		/*************************************************************************
		Estimate of the condition number of a matrix given by its LU decomposition (1-norm)

		The algorithm calculates a lower bound of the condition number. In this case,
		the algorithm does not return a lower bound of the condition number, but an
		inverse number (to avoid an overflow in case of a singular matrix).

		Input parameters:
				LUA         -   LU decomposition of a matrix in compact form. Output of
												the CMatrixLU subroutine.
				N           -   size of matrix A.

		Result: 1/LowerBound(cond(A))

		NOTE:
				if k(A) is very large, then matrix is  assumed  degenerate,  k(A)=INF,
				0.0f is returned in such cases.
		*************************************************************************/
		public static double cmatrixlurcond1(complex[,] lua, int n)
		{

			double result = rcond.cmatrixlurcond1(lua, n);
			return result;
		}

		/*************************************************************************
		Estimate of the condition number of a matrix given by its LU decomposition
		(infinity norm).

		The algorithm calculates a lower bound of the condition number. In this case,
		the algorithm does not return a lower bound of the condition number, but an
		inverse number (to avoid an overflow in case of a singular matrix).

		Input parameters:
				LUA     -   LU decomposition of a matrix in compact form. Output of
										the CMatrixLU subroutine.
				N       -   size of matrix A.

		Result: 1/LowerBound(cond(A))

		NOTE:
				if k(A) is very large, then matrix is  assumed  degenerate,  k(A)=INF,
				0.0f is returned in such cases.
		*************************************************************************/
		public static double cmatrixlurcondinf(complex[,] lua, int n)
		{

			double result = rcond.cmatrixlurcondinf(lua, n);
			return result;
		}

		/*************************************************************************
		Triangular matrix: estimate of a condition number (1-norm)

		The algorithm calculates a lower bound of the condition number. In this case,
		the algorithm does not return a lower bound of the condition number, but an
		inverse number (to avoid an overflow in case of a singular matrix).

		Input parameters:
				A       -   matrix. Array[0..N-1, 0..N-1].
				N       -   size of A.
				IsUpper -   True, if the matrix is upper triangular.
				IsUnit  -   True, if the matrix has a unit diagonal.

		Result: 1/LowerBound(cond(A))

		NOTE:
				if k(A) is very large, then matrix is  assumed  degenerate,  k(A)=INF,
				0.0f is returned in such cases.
		*************************************************************************/
		public static double cmatrixtrrcond1(complex[,] a, int n, bool isupper, bool isunit)
		{

			double result = rcond.cmatrixtrrcond1(a, n, isupper, isunit);
			return result;
		}

		/*************************************************************************
		Triangular matrix: estimate of a matrix condition number (infinity-norm).

		The algorithm calculates a lower bound of the condition number. In this case,
		the algorithm does not return a lower bound of the condition number, but an
		inverse number (to avoid an overflow in case of a singular matrix).

		Input parameters:
				A   -   matrix. Array whose indexes range within [0..N-1, 0..N-1].
				N   -   size of matrix A.
				IsUpper -   True, if the matrix is upper triangular.
				IsUnit  -   True, if the matrix has a unit diagonal.

		Result: 1/LowerBound(cond(A))

		NOTE:
				if k(A) is very large, then matrix is  assumed  degenerate,  k(A)=INF,
				0.0f is returned in such cases.
		*************************************************************************/
		public static double cmatrixtrrcondinf(complex[,] a, int n, bool isupper, bool isunit)
		{

			double result = rcond.cmatrixtrrcondinf(a, n, isupper, isunit);
			return result;
		}

	}
	public partial class alglib
	{


		/*************************************************************************
		Matrix inverse report:
		* R1    reciprocal of condition number in 1-norm
		* RInf  reciprocal of condition number in inf-norm
		*************************************************************************/
		public class matinvreport : alglibobject
		{
			//
			// Public declarations
			//
			public double r1 { get { return _innerobj.r1; } set { _innerobj.r1 = value; } }
			public double rinf { get { return _innerobj.rinf; } set { _innerobj.rinf = value; } }

			public matinvreport()
			{
				_innerobj = new matinv.matinvreport();
			}

			//
			// Although some of declarations below are public, you should not use them
			// They are intended for internal use only
			//
			private matinv.matinvreport _innerobj;
			public matinv.matinvreport innerobj { get { return _innerobj; } }
			public matinvreport(matinv.matinvreport obj)
			{
				_innerobj = obj;
			}
		}

		/*************************************************************************
		Inversion of a matrix given by its LU decomposition.

		INPUT PARAMETERS:
				A       -   LU decomposition of the matrix
										(output of RMatrixLU subroutine).
				Pivots  -   table of permutations
										(the output of RMatrixLU subroutine).
				N       -   size of matrix A (optional) :
										* if given, only principal NxN submatrix is processed  and
											overwritten. other elements are unchanged.
										* if not given,  size  is  automatically  determined  from
											matrix size (A must be square matrix)

		OUTPUT PARAMETERS:
				Info    -   return code:
										* -3    A is singular, or VERY close to singular.
														it is filled by zeros in such cases.
										*  1    task is solved (but matrix A may be ill-conditioned,
														check R1/RInf parameters for condition numbers).
				Rep     -   solver report, see below for more info
				A       -   inverse of matrix A.
										Array whose indexes range within [0..N-1, 0..N-1].

		SOLVER REPORT

		Subroutine sets following fields of the Rep structure:
		* R1        reciprocal of condition number: 1/cond(A), 1-norm.
		* RInf      reciprocal of condition number: 1/cond(A), inf-norm.

			-- ALGLIB routine --
				 05.02.2010
				 Bochkanov Sergey
		*************************************************************************/
		public static void rmatrixluinverse(ref double[,] a, int[] pivots, int n, out int info, out matinvreport rep)
		{
			info = 0;
			rep = new matinvreport();
			matinv.rmatrixluinverse(ref a, pivots, n, ref info, rep.innerobj);
			return;
		}
		public static void rmatrixluinverse(ref double[,] a, int[] pivots, out int info, out matinvreport rep)
		{
			int n;
			if ((ap.cols(a) != ap.rows(a)) || (ap.cols(a) != ap.len(pivots)))
				throw new alglibexception("Error while calling 'rmatrixluinverse': looks like one of arguments has wrong size");
			info = 0;
			rep = new matinvreport();
			n = ap.cols(a);
			matinv.rmatrixluinverse(ref a, pivots, n, ref info, rep.innerobj);

			return;
		}

		/*************************************************************************
		Inversion of a general matrix.

		Input parameters:
				A       -   matrix.
				N       -   size of matrix A (optional) :
										* if given, only principal NxN submatrix is processed  and
											overwritten. other elements are unchanged.
										* if not given,  size  is  automatically  determined  from
											matrix size (A must be square matrix)

		Output parameters:
				Info    -   return code, same as in RMatrixLUInverse
				Rep     -   solver report, same as in RMatrixLUInverse
				A       -   inverse of matrix A, same as in RMatrixLUInverse

		Result:
				True, if the matrix is not singular.
				False, if the matrix is singular.

			-- ALGLIB --
				 Copyright 2005-2010 by Bochkanov Sergey
		*************************************************************************/
		public static void rmatrixinverse(ref double[,] a, int n, out int info, out matinvreport rep)
		{
			info = 0;
			rep = new matinvreport();
			matinv.rmatrixinverse(ref a, n, ref info, rep.innerobj);
			return;
		}
		public static void rmatrixinverse(ref double[,] a, out int info, out matinvreport rep)
		{
			int n;
			if ((ap.cols(a) != ap.rows(a)))
				throw new alglibexception("Error while calling 'rmatrixinverse': looks like one of arguments has wrong size");
			info = 0;
			rep = new matinvreport();
			n = ap.cols(a);
			matinv.rmatrixinverse(ref a, n, ref info, rep.innerobj);

			return;
		}

		/*************************************************************************
		Inversion of a matrix given by its LU decomposition.

		INPUT PARAMETERS:
				A       -   LU decomposition of the matrix
										(output of CMatrixLU subroutine).
				Pivots  -   table of permutations
										(the output of CMatrixLU subroutine).
				N       -   size of matrix A (optional) :
										* if given, only principal NxN submatrix is processed  and
											overwritten. other elements are unchanged.
										* if not given,  size  is  automatically  determined  from
											matrix size (A must be square matrix)

		OUTPUT PARAMETERS:
				Info    -   return code, same as in RMatrixLUInverse
				Rep     -   solver report, same as in RMatrixLUInverse
				A       -   inverse of matrix A, same as in RMatrixLUInverse

			-- ALGLIB routine --
				 05.02.2010
				 Bochkanov Sergey
		*************************************************************************/
		public static void cmatrixluinverse(ref complex[,] a, int[] pivots, int n, out int info, out matinvreport rep)
		{
			info = 0;
			rep = new matinvreport();
			matinv.cmatrixluinverse(ref a, pivots, n, ref info, rep.innerobj);
			return;
		}
		public static void cmatrixluinverse(ref complex[,] a, int[] pivots, out int info, out matinvreport rep)
		{
			int n;
			if ((ap.cols(a) != ap.rows(a)) || (ap.cols(a) != ap.len(pivots)))
				throw new alglibexception("Error while calling 'cmatrixluinverse': looks like one of arguments has wrong size");
			info = 0;
			rep = new matinvreport();
			n = ap.cols(a);
			matinv.cmatrixluinverse(ref a, pivots, n, ref info, rep.innerobj);

			return;
		}

		/*************************************************************************
		Inversion of a general matrix.

		Input parameters:
				A       -   matrix
				N       -   size of matrix A (optional) :
										* if given, only principal NxN submatrix is processed  and
											overwritten. other elements are unchanged.
										* if not given,  size  is  automatically  determined  from
											matrix size (A must be square matrix)

		Output parameters:
				Info    -   return code, same as in RMatrixLUInverse
				Rep     -   solver report, same as in RMatrixLUInverse
				A       -   inverse of matrix A, same as in RMatrixLUInverse

			-- ALGLIB --
				 Copyright 2005 by Bochkanov Sergey
		*************************************************************************/
		public static void cmatrixinverse(ref complex[,] a, int n, out int info, out matinvreport rep)
		{
			info = 0;
			rep = new matinvreport();
			matinv.cmatrixinverse(ref a, n, ref info, rep.innerobj);
			return;
		}
		public static void cmatrixinverse(ref complex[,] a, out int info, out matinvreport rep)
		{
			int n;
			if ((ap.cols(a) != ap.rows(a)))
				throw new alglibexception("Error while calling 'cmatrixinverse': looks like one of arguments has wrong size");
			info = 0;
			rep = new matinvreport();
			n = ap.cols(a);
			matinv.cmatrixinverse(ref a, n, ref info, rep.innerobj);

			return;
		}

		/*************************************************************************
		Inversion of a symmetric positive definite matrix which is given
		by Cholesky decomposition.

		Input parameters:
				A       -   Cholesky decomposition of the matrix to be inverted:
										A=U’*U or A = L*L'.
										Output of  SPDMatrixCholesky subroutine.
				N       -   size of matrix A (optional) :
										* if given, only principal NxN submatrix is processed  and
											overwritten. other elements are unchanged.
										* if not given,  size  is  automatically  determined  from
											matrix size (A must be square matrix)
				IsUpper -   storage type (optional):
										* if True, symmetric  matrix  A  is  given  by  its  upper
											triangle, and the lower triangle isn’t  used/changed  by
											function
										* if False,  symmetric matrix  A  is  given  by  its lower
											triangle, and the  upper triangle isn’t used/changed  by
											function
										* if not given, lower half is used.

		Output parameters:
				Info    -   return code, same as in RMatrixLUInverse
				Rep     -   solver report, same as in RMatrixLUInverse
				A       -   inverse of matrix A, same as in RMatrixLUInverse

			-- ALGLIB routine --
				 10.02.2010
				 Bochkanov Sergey
		*************************************************************************/
		public static void spdmatrixcholeskyinverse(ref double[,] a, int n, bool isupper, out int info, out matinvreport rep)
		{
			info = 0;
			rep = new matinvreport();
			matinv.spdmatrixcholeskyinverse(ref a, n, isupper, ref info, rep.innerobj);
			return;
		}
		public static void spdmatrixcholeskyinverse(ref double[,] a, out int info, out matinvreport rep)
		{
			int n;
			bool isupper;
			if ((ap.cols(a) != ap.rows(a)))
				throw new alglibexception("Error while calling 'spdmatrixcholeskyinverse': looks like one of arguments has wrong size");
			info = 0;
			rep = new matinvreport();
			n = ap.cols(a);
			isupper = false;
			matinv.spdmatrixcholeskyinverse(ref a, n, isupper, ref info, rep.innerobj);

			return;
		}

		/*************************************************************************
		Inversion of a symmetric positive definite matrix.

		Given an upper or lower triangle of a symmetric positive definite matrix,
		the algorithm generates matrix A^-1 and saves the upper or lower triangle
		depending on the input.

		Input parameters:
				A       -   matrix to be inverted (upper or lower triangle).
										Array with elements [0..N-1,0..N-1].
				N       -   size of matrix A (optional) :
										* if given, only principal NxN submatrix is processed  and
											overwritten. other elements are unchanged.
										* if not given,  size  is  automatically  determined  from
											matrix size (A must be square matrix)
				IsUpper -   storage type (optional):
										* if True, symmetric  matrix  A  is  given  by  its  upper
											triangle, and the lower triangle isn’t  used/changed  by
											function
										* if False,  symmetric matrix  A  is  given  by  its lower
											triangle, and the  upper triangle isn’t used/changed  by
											function
										* if not given,  both lower and upper  triangles  must  be
											filled.

		Output parameters:
				Info    -   return code, same as in RMatrixLUInverse
				Rep     -   solver report, same as in RMatrixLUInverse
				A       -   inverse of matrix A, same as in RMatrixLUInverse

			-- ALGLIB routine --
				 10.02.2010
				 Bochkanov Sergey
		*************************************************************************/
		public static void spdmatrixinverse(ref double[,] a, int n, bool isupper, out int info, out matinvreport rep)
		{
			info = 0;
			rep = new matinvreport();
			matinv.spdmatrixinverse(ref a, n, isupper, ref info, rep.innerobj);
			return;
		}
		public static void spdmatrixinverse(ref double[,] a, out int info, out matinvreport rep)
		{
			int n;
			bool isupper;
			if ((ap.cols(a) != ap.rows(a)))
				throw new alglibexception("Error while calling 'spdmatrixinverse': looks like one of arguments has wrong size");
			if (!alglib.ap.issymmetric(a))
				throw new alglibexception("'a' parameter is not symmetric matrix");
			info = 0;
			rep = new matinvreport();
			n = ap.cols(a);
			isupper = false;
			matinv.spdmatrixinverse(ref a, n, isupper, ref info, rep.innerobj);
			if (!alglib.ap.forcesymmetric(a))
				throw new alglibexception("Internal error while forcing symmetricity of 'a' parameter");
			return;
		}

		/*************************************************************************
		Inversion of a Hermitian positive definite matrix which is given
		by Cholesky decomposition.

		Input parameters:
				A       -   Cholesky decomposition of the matrix to be inverted:
										A=U’*U or A = L*L'.
										Output of  HPDMatrixCholesky subroutine.
				N       -   size of matrix A (optional) :
										* if given, only principal NxN submatrix is processed  and
											overwritten. other elements are unchanged.
										* if not given,  size  is  automatically  determined  from
											matrix size (A must be square matrix)
				IsUpper -   storage type (optional):
										* if True, symmetric  matrix  A  is  given  by  its  upper
											triangle, and the lower triangle isn’t  used/changed  by
											function
										* if False,  symmetric matrix  A  is  given  by  its lower
											triangle, and the  upper triangle isn’t used/changed  by
											function
										* if not given, lower half is used.

		Output parameters:
				Info    -   return code, same as in RMatrixLUInverse
				Rep     -   solver report, same as in RMatrixLUInverse
				A       -   inverse of matrix A, same as in RMatrixLUInverse

			-- ALGLIB routine --
				 10.02.2010
				 Bochkanov Sergey
		*************************************************************************/
		public static void hpdmatrixcholeskyinverse(ref complex[,] a, int n, bool isupper, out int info, out matinvreport rep)
		{
			info = 0;
			rep = new matinvreport();
			matinv.hpdmatrixcholeskyinverse(ref a, n, isupper, ref info, rep.innerobj);
			return;
		}
		public static void hpdmatrixcholeskyinverse(ref complex[,] a, out int info, out matinvreport rep)
		{
			int n;
			bool isupper;
			if ((ap.cols(a) != ap.rows(a)))
				throw new alglibexception("Error while calling 'hpdmatrixcholeskyinverse': looks like one of arguments has wrong size");
			info = 0;
			rep = new matinvreport();
			n = ap.cols(a);
			isupper = false;
			matinv.hpdmatrixcholeskyinverse(ref a, n, isupper, ref info, rep.innerobj);

			return;
		}

		/*************************************************************************
		Inversion of a Hermitian positive definite matrix.

		Given an upper or lower triangle of a Hermitian positive definite matrix,
		the algorithm generates matrix A^-1 and saves the upper or lower triangle
		depending on the input.

		Input parameters:
				A       -   matrix to be inverted (upper or lower triangle).
										Array with elements [0..N-1,0..N-1].
				N       -   size of matrix A (optional) :
										* if given, only principal NxN submatrix is processed  and
											overwritten. other elements are unchanged.
										* if not given,  size  is  automatically  determined  from
											matrix size (A must be square matrix)
				IsUpper -   storage type (optional):
										* if True, symmetric  matrix  A  is  given  by  its  upper
											triangle, and the lower triangle isn’t  used/changed  by
											function
										* if False,  symmetric matrix  A  is  given  by  its lower
											triangle, and the  upper triangle isn’t used/changed  by
											function
										* if not given,  both lower and upper  triangles  must  be
											filled.

		Output parameters:
				Info    -   return code, same as in RMatrixLUInverse
				Rep     -   solver report, same as in RMatrixLUInverse
				A       -   inverse of matrix A, same as in RMatrixLUInverse

			-- ALGLIB routine --
				 10.02.2010
				 Bochkanov Sergey
		*************************************************************************/
		public static void hpdmatrixinverse(ref complex[,] a, int n, bool isupper, out int info, out matinvreport rep)
		{
			info = 0;
			rep = new matinvreport();
			matinv.hpdmatrixinverse(ref a, n, isupper, ref info, rep.innerobj);
			return;
		}
		public static void hpdmatrixinverse(ref complex[,] a, out int info, out matinvreport rep)
		{
			int n;
			bool isupper;
			if ((ap.cols(a) != ap.rows(a)))
				throw new alglibexception("Error while calling 'hpdmatrixinverse': looks like one of arguments has wrong size");
			if (!alglib.ap.ishermitian(a))
				throw new alglibexception("'a' parameter is not Hermitian matrix");
			info = 0;
			rep = new matinvreport();
			n = ap.cols(a);
			isupper = false;
			matinv.hpdmatrixinverse(ref a, n, isupper, ref info, rep.innerobj);
			if (!alglib.ap.forcehermitian(a))
				throw new alglibexception("Internal error while forcing Hermitian properties of 'a' parameter");
			return;
		}

		/*************************************************************************
		Triangular matrix inverse (real)

		The subroutine inverts the following types of matrices:
				* upper triangular
				* upper triangular with unit diagonal
				* lower triangular
				* lower triangular with unit diagonal

		In case of an upper (lower) triangular matrix,  the  inverse  matrix  will
		also be upper (lower) triangular, and after the end of the algorithm,  the
		inverse matrix replaces the source matrix. The elements  below (above) the
		main diagonal are not changed by the algorithm.

		If  the matrix  has a unit diagonal, the inverse matrix also  has  a  unit
		diagonal, and the diagonal elements are not passed to the algorithm.

		Input parameters:
				A       -   matrix, array[0..N-1, 0..N-1].
				N       -   size of matrix A (optional) :
										* if given, only principal NxN submatrix is processed  and
											overwritten. other elements are unchanged.
										* if not given,  size  is  automatically  determined  from
											matrix size (A must be square matrix)
				IsUpper -   True, if the matrix is upper triangular.
				IsUnit  -   diagonal type (optional):
										* if True, matrix has unit diagonal (a[i,i] are NOT used)
										* if False, matrix diagonal is arbitrary
										* if not given, False is assumed

		Output parameters:
				Info    -   same as for RMatrixLUInverse
				Rep     -   same as for RMatrixLUInverse
				A       -   same as for RMatrixLUInverse.

			-- ALGLIB --
				 Copyright 05.02.2010 by Bochkanov Sergey
		*************************************************************************/
		public static void rmatrixtrinverse(ref double[,] a, int n, bool isupper, bool isunit, out int info, out matinvreport rep)
		{
			info = 0;
			rep = new matinvreport();
			matinv.rmatrixtrinverse(ref a, n, isupper, isunit, ref info, rep.innerobj);
			return;
		}
		public static void rmatrixtrinverse(ref double[,] a, bool isupper, out int info, out matinvreport rep)
		{
			int n;
			bool isunit;
			if ((ap.cols(a) != ap.rows(a)))
				throw new alglibexception("Error while calling 'rmatrixtrinverse': looks like one of arguments has wrong size");
			info = 0;
			rep = new matinvreport();
			n = ap.cols(a);
			isunit = false;
			matinv.rmatrixtrinverse(ref a, n, isupper, isunit, ref info, rep.innerobj);

			return;
		}

		/*************************************************************************
		Triangular matrix inverse (complex)

		The subroutine inverts the following types of matrices:
				* upper triangular
				* upper triangular with unit diagonal
				* lower triangular
				* lower triangular with unit diagonal

		In case of an upper (lower) triangular matrix,  the  inverse  matrix  will
		also be upper (lower) triangular, and after the end of the algorithm,  the
		inverse matrix replaces the source matrix. The elements  below (above) the
		main diagonal are not changed by the algorithm.

		If  the matrix  has a unit diagonal, the inverse matrix also  has  a  unit
		diagonal, and the diagonal elements are not passed to the algorithm.

		Input parameters:
				A       -   matrix, array[0..N-1, 0..N-1].
				N       -   size of matrix A (optional) :
										* if given, only principal NxN submatrix is processed  and
											overwritten. other elements are unchanged.
										* if not given,  size  is  automatically  determined  from
											matrix size (A must be square matrix)
				IsUpper -   True, if the matrix is upper triangular.
				IsUnit  -   diagonal type (optional):
										* if True, matrix has unit diagonal (a[i,i] are NOT used)
										* if False, matrix diagonal is arbitrary
										* if not given, False is assumed

		Output parameters:
				Info    -   same as for RMatrixLUInverse
				Rep     -   same as for RMatrixLUInverse
				A       -   same as for RMatrixLUInverse.

			-- ALGLIB --
				 Copyright 05.02.2010 by Bochkanov Sergey
		*************************************************************************/
		public static void cmatrixtrinverse(ref complex[,] a, int n, bool isupper, bool isunit, out int info, out matinvreport rep)
		{
			info = 0;
			rep = new matinvreport();
			matinv.cmatrixtrinverse(ref a, n, isupper, isunit, ref info, rep.innerobj);
			return;
		}
		public static void cmatrixtrinverse(ref complex[,] a, bool isupper, out int info, out matinvreport rep)
		{
			int n;
			bool isunit;
			if ((ap.cols(a) != ap.rows(a)))
				throw new alglibexception("Error while calling 'cmatrixtrinverse': looks like one of arguments has wrong size");
			info = 0;
			rep = new matinvreport();
			n = ap.cols(a);
			isunit = false;
			matinv.cmatrixtrinverse(ref a, n, isupper, isunit, ref info, rep.innerobj);

			return;
		}

	}
	public partial class alglib
	{


		/*************************************************************************
		Sparse matrix

		You should use ALGLIB functions to work with sparse matrix.
		Never try to access its fields directly!
		*************************************************************************/
		public class sparsematrix : alglibobject
		{
			//
			// Public declarations
			//

			public sparsematrix()
			{
				_innerobj = new sparse.sparsematrix();
			}

			//
			// Although some of declarations below are public, you should not use them
			// They are intended for internal use only
			//
			private sparse.sparsematrix _innerobj;
			public sparse.sparsematrix innerobj { get { return _innerobj; } }
			public sparsematrix(sparse.sparsematrix obj)
			{
				_innerobj = obj;
			}
		}

		/*************************************************************************
		This function creates sparse matrix in a Hash-Table format.

		This function creates Hast-Table matrix, which can be  converted  to  CRS
		format after its initialization is over. Typical  usage  scenario  for  a
		sparse matrix is:
		1. creation in a Hash-Table format
		2. insertion of the matrix elements
		3. conversion to the CRS representation
		4. matrix is passed to some linear algebra algorithm

		Some  information  about  different matrix formats can be found below, in
		the "NOTES" section.

		INPUT PARAMETERS
				M           -   number of rows in a matrix, M>=1
				N           -   number of columns in a matrix, N>=1
				K           -   K>=0, expected number of non-zero elements in a matrix.
												K can be inexact approximation, can be less than actual
												number  of  elements  (table will grow when needed) or
												even zero).
												It is important to understand that although hash-table
												may grow automatically, it is better to  provide  good
												estimate of data size.

		OUTPUT PARAMETERS
				S           -   sparse M*N matrix in Hash-Table representation.
												All elements of the matrix are zero.

		NOTE 1.

		Sparse matrices can be stored using either Hash-Table  representation  or
		Compressed  Row  Storage  representation. Hast-table is better suited for
		querying   and   dynamic   operations   (thus,  it  is  used  for  matrix
		initialization), but it is inefficient when you want to make some  linear
		algebra operations.

		From the other side, CRS is better suited for linear algebra  operations,
		but initialization is less convenient - you have to tell row sizes at the
		initialization,  and  you  can  fill matrix only row by row, from left to
		right. CRS is also very inefficient when you want to find matrix  element
		by its index.

		Thus,  Hash-Table  representation   does   not   support  linear  algebra
		operations, while CRS format does not support modification of the  table.
		Tables below outline information about these two formats:

				OPERATIONS WITH MATRIX      HASH        CRS
				create                      +           +
				read element                +           +
				modify element              +
				add value to element        +
				A*x  (dense vector)                     +
				A'*x (dense vector)                     +
				A*X  (dense matrix)                     +
				A'*X (dense matrix)                     +

		NOTE 2.

		Hash-tables use memory inefficiently, and they have to keep  some  amount
		of the "spare memory" in order to have good performance. Hash  table  for
		matrix with K non-zero elements will  need  C*K*(8+2*sizeof(int))  bytes,
		where C is a small constant, about 1.5-2 in magnitude.

		CRS storage, from the other side, is  more  memory-efficient,  and  needs
		just K*(8+sizeof(int))+M*sizeof(int) bytes, where M is a number  of  rows
		in a matrix.

		When you convert from the Hash-Table to CRS  representation, all unneeded
		memory will be freed.

			-- ALGLIB PROJECT --
				 Copyright 14.10.2011 by Bochkanov Sergey
		*************************************************************************/
		public static void sparsecreate(int m, int n, int k, out sparsematrix s)
		{
			s = new sparsematrix();
			sparse.sparsecreate(m, n, k, s.innerobj);
			return;
		}
		public static void sparsecreate(int m, int n, out sparsematrix s)
		{
			int k;

			s = new sparsematrix();
			k = 0;
			sparse.sparsecreate(m, n, k, s.innerobj);

			return;
		}

		/*************************************************************************
		This function creates sparse matrix in a CRS format (expert function for
		situations when you are running out of memory).

		This function creates CRS matrix. Typical usage scenario for a CRS matrix
		is:
		1. creation (you have to tell number of non-zero elements at each row  at
			 this moment)
		2. insertion of the matrix elements (row by row, from left to right)
		3. matrix is passed to some linear algebra algorithm

		This function is a memory-efficient alternative to SparseCreate(), but it
		is more complex because it requires you to know in advance how large your
		matrix is. Some  information about  different matrix formats can be found
		below, in the "NOTES" section.

		INPUT PARAMETERS
				M           -   number of rows in a matrix, M>=1
				N           -   number of columns in a matrix, N>=1
				NER         -   number of elements at each row, array[M], NER[I]>=0

		OUTPUT PARAMETERS
				S           -   sparse M*N matrix in CRS representation.
												You have to fill ALL non-zero elements by calling
												SparseSet() BEFORE you try to use this matrix.

		NOTE 1.

		Sparse matrices can be stored using either Hash-Table  representation  or
		Compressed  Row  Storage  representation. Hast-table is better suited for
		querying   and   dynamic   operations   (thus,  it  is  used  for  matrix
		initialization), but it is inefficient when you want to make some  linear
		algebra operations.

		From the other side, CRS is better suited for linear algebra  operations,
		but initialization is less convenient - you have to tell row sizes at the
		initialization,  and  you  can  fill matrix only row by row, from left to
		right. CRS is also very inefficient when you want to find matrix  element
		by its index.

		Thus,  Hash-Table  representation   does   not   support  linear  algebra
		operations, while CRS format does not support modification of the  table.
		Tables below outline information about these two formats:

				OPERATIONS WITH MATRIX      HASH        CRS
				create                      +           +
				read element                +           +
				modify element              +
				add value to element        +
				A*x  (dense vector)                     +
				A'*x (dense vector)                     +
				A*X  (dense matrix)                     +
				A'*X (dense matrix)                     +

		NOTE 2.

		Hash-tables use memory inefficiently, and they have to keep  some  amount
		of the "spare memory" in order to have good performance. Hash  table  for
		matrix with K non-zero elements will  need  C*K*(8+2*sizeof(int))  bytes,
		where C is a small constant, about 1.5-2 in magnitude.

		CRS storage, from the other side, is  more  memory-efficient,  and  needs
		just K*(8+sizeof(int))+M*sizeof(int) bytes, where M is a number  of  rows
		in a matrix.

		When you convert from the Hash-Table to CRS  representation, all unneeded
		memory will be freed.

			-- ALGLIB PROJECT --
				 Copyright 14.10.2011 by Bochkanov Sergey
		*************************************************************************/
		public static void sparsecreatecrs(int m, int n, int[] ner, out sparsematrix s)
		{
			s = new sparsematrix();
			sparse.sparsecreatecrs(m, n, ner, s.innerobj);
			return;
		}

		/*************************************************************************
		This function copies S0 to S1.

		NOTE:  this  function  does  not verify its arguments, it just copies all
		fields of the structure.

			-- ALGLIB PROJECT --
				 Copyright 14.10.2011 by Bochkanov Sergey
		*************************************************************************/
		public static void sparsecopy(sparsematrix s0, out sparsematrix s1)
		{
			s1 = new sparsematrix();
			sparse.sparsecopy(s0.innerobj, s1.innerobj);
			return;
		}

		/*************************************************************************
		This function adds value to S[i,j] - element of the sparse matrix. Matrix
		must be in a Hash-Table mode.

		In case S[i,j] already exists in the table, V i added to  its  value.  In
		case  S[i,j]  is  non-existent,  it  is  inserted  in  the  table.  Table
		automatically grows when necessary.

		INPUT PARAMETERS
				S           -   sparse M*N matrix in Hash-Table representation.
												Exception will be thrown for CRS matrix.
				I           -   row index of the element to modify, 0<=I<M
				J           -   column index of the element to modify, 0<=J<N
				V           -   value to add, must be finite number

		OUTPUT PARAMETERS
				S           -   modified matrix

		NOTE 1:  when  S[i,j]  is exactly zero after modification, it is  deleted
		from the table.

			-- ALGLIB PROJECT --
				 Copyright 14.10.2011 by Bochkanov Sergey
		*************************************************************************/
		public static void sparseadd(sparsematrix s, int i, int j, double v)
		{

			sparse.sparseadd(s.innerobj, i, j, v);
			return;
		}

		/*************************************************************************
		This function modifies S[i,j] - element of the sparse matrix.

		For Hash-based storage format:
		* new value can be zero or non-zero.  In case new value of S[i,j] is zero,
			this element is deleted from the table.
		* this  function  has  no  effect when called with zero V for non-existent
			element.

		For CRS-bases storage format:
		* new value MUST be non-zero. Exception will be thrown for zero V.
		* elements must be initialized in correct order -  from top row to bottom,
			within row - from left to right.

		INPUT PARAMETERS
				S           -   sparse M*N matrix in Hash-Table or CRS representation.
				I           -   row index of the element to modify, 0<=I<M
				J           -   column index of the element to modify, 0<=J<N
				V           -   value to set, must be finite number, can be zero

		OUTPUT PARAMETERS
				S           -   modified matrix

			-- ALGLIB PROJECT --
				 Copyright 14.10.2011 by Bochkanov Sergey
		*************************************************************************/
		public static void sparseset(sparsematrix s, int i, int j, double v)
		{

			sparse.sparseset(s.innerobj, i, j, v);
			return;
		}

		/*************************************************************************
		This function returns S[i,j] - element of the sparse matrix.  Matrix  can
		be in any mode (Hash-Table or CRS), but this function is  less  efficient
		for CRS matrices.  Hash-Table  matrices can  find element  in O(1)  time,
		while  CRS  matrices  need O(log(RS)) time, where RS is an number of non-
		zero elements in a row.

		INPUT PARAMETERS
				S           -   sparse M*N matrix in Hash-Table representation.
												Exception will be thrown for CRS matrix.
				I           -   row index of the element to modify, 0<=I<M
				J           -   column index of the element to modify, 0<=J<N

		RESULT
				value of S[I,J] or zero (in case no element with such index is found)

			-- ALGLIB PROJECT --
				 Copyright 14.10.2011 by Bochkanov Sergey
		*************************************************************************/
		public static double sparseget(sparsematrix s, int i, int j)
		{

			double result = sparse.sparseget(s.innerobj, i, j);
			return result;
		}

		/*************************************************************************
		This function returns I-th diagonal element of the sparse matrix.

		Matrix can be in any mode (Hash-Table or CRS storage), but this  function
		is most efficient for CRS matrices - it requires less than 50 CPU  cycles
		to extract diagonal element. For Hash-Table matrices we still  have  O(1)
		query time, but function is many times slower.

		INPUT PARAMETERS
				S           -   sparse M*N matrix in Hash-Table representation.
												Exception will be thrown for CRS matrix.
				I           -   index of the element to modify, 0<=I<min(M,N)

		RESULT
				value of S[I,I] or zero (in case no element with such index is found)

			-- ALGLIB PROJECT --
				 Copyright 14.10.2011 by Bochkanov Sergey
		*************************************************************************/
		public static double sparsegetdiagonal(sparsematrix s, int i)
		{

			double result = sparse.sparsegetdiagonal(s.innerobj, i);
			return result;
		}

		/*************************************************************************
		This function converts matrix to CRS format.

		Some  algorithms  (linear  algebra ones, for example) require matrices in
		CRS format.

		INPUT PARAMETERS
				S           -   sparse M*N matrix in any format

		OUTPUT PARAMETERS
				S           -   matrix in CRS format

		NOTE:  this  function  has  no  effect  when  called with matrix which is
		already in CRS mode.

			-- ALGLIB PROJECT --
				 Copyright 14.10.2011 by Bochkanov Sergey
		*************************************************************************/
		public static void sparseconverttocrs(sparsematrix s)
		{

			sparse.sparseconverttocrs(s.innerobj);
			return;
		}

		/*************************************************************************
		This function calculates matrix-vector product  S*x.  Matrix  S  must  be
		stored in CRS format (exception will be thrown otherwise).

		INPUT PARAMETERS
				S           -   sparse M*N matrix in CRS format (you MUST convert  it
												to CRS before calling this function).
				X           -   array[N], input vector. For  performance  reasons  we
												make only quick checks - we check that array size  is
												at least N, but we do not check for NAN's or INF's.
				Y           -   output buffer, possibly preallocated. In case  buffer
												size is too small to store  result,  this  buffer  is
												automatically resized.

		OUTPUT PARAMETERS
				Y           -   array[M], S*x

		NOTE: this function throws exception when called for non-CRS matrix.  You
		must convert your matrix  with  SparseConvertToCRS()  before  using  this
		function.

			-- ALGLIB PROJECT --
				 Copyright 14.10.2011 by Bochkanov Sergey
		*************************************************************************/
		public static void sparsemv(sparsematrix s, double[] x, ref double[] y)
		{

			sparse.sparsemv(s.innerobj, x, ref y);
			return;
		}

		/*************************************************************************
		This function calculates matrix-vector product  S^T*x. Matrix S  must  be
		stored in CRS format (exception will be thrown otherwise).

		INPUT PARAMETERS
				S           -   sparse M*N matrix in CRS format (you MUST convert  it
												to CRS before calling this function).
				X           -   array[M], input vector. For  performance  reasons  we
												make only quick checks - we check that array size  is
												at least M, but we do not check for NAN's or INF's.
				Y           -   output buffer, possibly preallocated. In case  buffer
												size is too small to store  result,  this  buffer  is
												automatically resized.

		OUTPUT PARAMETERS
				Y           -   array[N], S^T*x

		NOTE: this function throws exception when called for non-CRS matrix.  You
		must convert your matrix  with  SparseConvertToCRS()  before  using  this
		function.

			-- ALGLIB PROJECT --
				 Copyright 14.10.2011 by Bochkanov Sergey
		*************************************************************************/
		public static void sparsemtv(sparsematrix s, double[] x, ref double[] y)
		{

			sparse.sparsemtv(s.innerobj, x, ref y);
			return;
		}

		/*************************************************************************
		This function simultaneously calculates two matrix-vector products:
				S*x and S^T*x.
		S must be square (non-rectangular) matrix stored in CRS format (exception
		will be thrown otherwise).

		INPUT PARAMETERS
				S           -   sparse N*N matrix in CRS format (you MUST convert  it
												to CRS before calling this function).
				X           -   array[N], input vector. For  performance  reasons  we
												make only quick checks - we check that array size  is
												at least N, but we do not check for NAN's or INF's.
				Y0          -   output buffer, possibly preallocated. In case  buffer
												size is too small to store  result,  this  buffer  is
												automatically resized.
				Y1          -   output buffer, possibly preallocated. In case  buffer
												size is too small to store  result,  this  buffer  is
												automatically resized.

		OUTPUT PARAMETERS
				Y0          -   array[N], S*x
				Y1          -   array[N], S^T*x

		NOTE: this function throws exception when called for non-CRS matrix.  You
		must convert your matrix  with  SparseConvertToCRS()  before  using  this
		function. It also throws exception when S is non-square.

			-- ALGLIB PROJECT --
				 Copyright 14.10.2011 by Bochkanov Sergey
		*************************************************************************/
		public static void sparsemv2(sparsematrix s, double[] x, ref double[] y0, ref double[] y1)
		{

			sparse.sparsemv2(s.innerobj, x, ref y0, ref y1);
			return;
		}

		/*************************************************************************
		This function calculates matrix-vector product  S*x, when S is  symmetric
		matrix.  Matrix  S  must  be stored in  CRS  format  (exception  will  be
		thrown otherwise).

		INPUT PARAMETERS
				S           -   sparse M*M matrix in CRS format (you MUST convert  it
												to CRS before calling this function).
				IsUpper     -   whether upper or lower triangle of S is given:
												* if upper triangle is given,  only   S[i,j] for j>=i
													are used, and lower triangle is ignored (it can  be
													empty - these elements are not referenced at all).
												* if lower triangle is given,  only   S[i,j] for j<=i
													are used, and upper triangle is ignored.
				X           -   array[N], input vector. For  performance  reasons  we
												make only quick checks - we check that array size  is
												at least N, but we do not check for NAN's or INF's.
				Y           -   output buffer, possibly preallocated. In case  buffer
												size is too small to store  result,  this  buffer  is
												automatically resized.

		OUTPUT PARAMETERS
				Y           -   array[M], S*x

		NOTE: this function throws exception when called for non-CRS matrix.  You
		must convert your matrix  with  SparseConvertToCRS()  before  using  this
		function.

			-- ALGLIB PROJECT --
				 Copyright 14.10.2011 by Bochkanov Sergey
		*************************************************************************/
		public static void sparsesmv(sparsematrix s, bool isupper, double[] x, ref double[] y)
		{

			sparse.sparsesmv(s.innerobj, isupper, x, ref y);
			return;
		}

		/*************************************************************************
		This function calculates matrix-matrix product  S*A.  Matrix  S  must  be
		stored in CRS format (exception will be thrown otherwise).

		INPUT PARAMETERS
				S           -   sparse M*N matrix in CRS format (you MUST convert  it
												to CRS before calling this function).
				A           -   array[N][K], input dense matrix. For  performance reasons
												we make only quick checks - we check that array size
												is at least N, but we do not check for NAN's or INF's.
				K           -   number of columns of matrix (A).
				B           -   output buffer, possibly preallocated. In case  buffer
												size is too small to store  result,  this  buffer  is
												automatically resized.

		OUTPUT PARAMETERS
				B           -   array[M][K], S*A

		NOTE: this function throws exception when called for non-CRS matrix.  You
		must convert your matrix  with  SparseConvertToCRS()  before  using  this
		function.

			-- ALGLIB PROJECT --
				 Copyright 14.10.2011 by Bochkanov Sergey
		*************************************************************************/
		public static void sparsemm(sparsematrix s, double[,] a, int k, ref double[,] b)
		{

			sparse.sparsemm(s.innerobj, a, k, ref b);
			return;
		}

		/*************************************************************************
		This function calculates matrix-matrix product  S^T*A. Matrix S  must  be
		stored in CRS format (exception will be thrown otherwise).

		INPUT PARAMETERS
				S           -   sparse M*N matrix in CRS format (you MUST convert  it
												to CRS before calling this function).
				A           -   array[M][K], input dense matrix. For performance reasons
												we make only quick checks - we check that array size  is
												at least M, but we do not check for NAN's or INF's.
				K           -   number of columns of matrix (A).
				B           -   output buffer, possibly preallocated. In case  buffer
												size is too small to store  result,  this  buffer  is
												automatically resized.

		OUTPUT PARAMETERS
				B           -   array[N][K], S^T*A

		NOTE: this function throws exception when called for non-CRS matrix.  You
		must convert your matrix  with  SparseConvertToCRS()  before  using  this
		function.

			-- ALGLIB PROJECT --
				 Copyright 14.10.2011 by Bochkanov Sergey
		*************************************************************************/
		public static void sparsemtm(sparsematrix s, double[,] a, int k, ref double[,] b)
		{

			sparse.sparsemtm(s.innerobj, a, k, ref b);
			return;
		}

		/*************************************************************************
		This function simultaneously calculates two matrix-matrix products:
				S*A and S^T*A.
		S must be square (non-rectangular) matrix stored in CRS format (exception
		will be thrown otherwise).

		INPUT PARAMETERS
				S           -   sparse N*N matrix in CRS format (you MUST convert  it
												to CRS before calling this function).
				A           -   array[N][K], input dense matrix. For performance reasons
												we make only quick checks - we check that array size  is
												at least N, but we do not check for NAN's or INF's.
				K           -   number of columns of matrix (A).
				B0          -   output buffer, possibly preallocated. In case  buffer
												size is too small to store  result,  this  buffer  is
												automatically resized.
				B1          -   output buffer, possibly preallocated. In case  buffer
												size is too small to store  result,  this  buffer  is
												automatically resized.

		OUTPUT PARAMETERS
				B0          -   array[N][K], S*A
				B1          -   array[N][K], S^T*A

		NOTE: this function throws exception when called for non-CRS matrix.  You
		must convert your matrix  with  SparseConvertToCRS()  before  using  this
		function. It also throws exception when S is non-square.

			-- ALGLIB PROJECT --
				 Copyright 14.10.2011 by Bochkanov Sergey
		*************************************************************************/
		public static void sparsemm2(sparsematrix s, double[,] a, int k, ref double[,] b0, ref double[,] b1)
		{

			sparse.sparsemm2(s.innerobj, a, k, ref b0, ref b1);
			return;
		}

		/*************************************************************************
		This function calculates matrix-matrix product  S*A, when S  is  symmetric
		matrix.  Matrix  S  must  be stored  in  CRS  format  (exception  will  be
		thrown otherwise).

		INPUT PARAMETERS
				S           -   sparse M*M matrix in CRS format (you MUST convert  it
												to CRS before calling this function).
				IsUpper     -   whether upper or lower triangle of S is given:
												* if upper triangle is given,  only   S[i,j] for j>=i
													are used, and lower triangle is ignored (it can  be
													empty - these elements are not referenced at all).
												* if lower triangle is given,  only   S[i,j] for j<=i
													are used, and upper triangle is ignored.
				A           -   array[N][K], input dense matrix. For performance reasons
												we make only quick checks - we check that array size is
												at least N, but we do not check for NAN's or INF's.
				K           -   number of columns of matrix (A).
				B           -   output buffer, possibly preallocated. In case  buffer
												size is too small to store  result,  this  buffer  is
												automatically resized.

		OUTPUT PARAMETERS
				B           -   array[M][K], S*A

		NOTE: this function throws exception when called for non-CRS matrix.  You
		must convert your matrix  with  SparseConvertToCRS()  before  using  this
		function.

			-- ALGLIB PROJECT --
				 Copyright 14.10.2011 by Bochkanov Sergey
		*************************************************************************/
		public static void sparsesmm(sparsematrix s, bool isupper, double[,] a, int k, ref double[,] b)
		{

			sparse.sparsesmm(s.innerobj, isupper, a, k, ref b);
			return;
		}

		/*************************************************************************
		This procedure resizes Hash-Table matrix. It can be called when you  have
		deleted too many elements from the matrix, and you want to  free unneeded
		memory.

			-- ALGLIB PROJECT --
				 Copyright 14.10.2011 by Bochkanov Sergey
		*************************************************************************/
		public static void sparseresizematrix(sparsematrix s)
		{

			sparse.sparseresizematrix(s.innerobj);
			return;
		}

		/*************************************************************************
		This  function  is  used  to enumerate all elements of the sparse matrix.
		Before  first  call  user  initializes  T0 and T1 counters by zero. These
		counters are used to remember current position in a  matrix;  after  each
		call they are updated by the function.

		Subsequent calls to this function return non-zero elements of the  sparse
		matrix, one by one. If you enumerate CRS matrix, matrix is traversed from
		left to right, from top to bottom. In case you enumerate matrix stored as
		Hash table, elements are returned in random order.

		EXAMPLE
				> T0=0
				> T1=0
				> while SparseEnumerate(S,T0,T1,I,J,V) do
				>     ....do something with I,J,V

		INPUT PARAMETERS
				S           -   sparse M*N matrix in Hash-Table or CRS representation.
				T0          -   internal counter
				T1          -   internal counter

		OUTPUT PARAMETERS
				T0          -   new value of the internal counter
				T1          -   new value of the internal counter
				I           -   row index of non-zero element, 0<=I<M.
				J           -   column index of non-zero element, 0<=J<N
				V           -   value of the T-th element

		RESULT
				True in case of success (next non-zero element was retrieved)
				False in case all non-zero elements were enumerated

			-- ALGLIB PROJECT --
				 Copyright 14.03.2012 by Bochkanov Sergey
		*************************************************************************/
		public static bool sparseenumerate(sparsematrix s, ref int t0, ref int t1, out int i, out int j, out double v)
		{
			i = 0;
			j = 0;
			v = 0;
			bool result = sparse.sparseenumerate(s.innerobj, ref t0, ref t1, ref i, ref j, ref v);
			return result;
		}

		/*************************************************************************
		This function rewrites existing (non-zero) element. It  returns  True   if
		element  exists  or  False,  when  it  is  called for non-existing  (zero)
		element.

		The purpose of this function is to provide convenient thread-safe  way  to
		modify  sparse  matrix.  Such  modification  (already  existing element is
		rewritten) is guaranteed to be thread-safe without any synchronization, as
		long as different threads modify different elements.

		INPUT PARAMETERS
				S           -   sparse M*N matrix in Hash-Table or CRS representation.
				I           -   row index of non-zero element to modify, 0<=I<M
				J           -   column index of non-zero element to modify, 0<=J<N
				V           -   value to rewrite, must be finite number

		OUTPUT PARAMETERS
				S           -   modified matrix
		RESULT
				True in case when element exists
				False in case when element doesn't exist or it is zero

			-- ALGLIB PROJECT --
				 Copyright 14.03.2012 by Bochkanov Sergey
		*************************************************************************/
		public static bool sparserewriteexisting(sparsematrix s, int i, int j, double v)
		{

			bool result = sparse.sparserewriteexisting(s.innerobj, i, j, v);
			return result;
		}

		/*************************************************************************
		This function returns I-th row of the sparse matrix stored in CRS format.

		NOTE: when  incorrect  I  (outside  of  [0,M-1]) or  matrix (non-CRS)  are
					passed, this function throws exception.

		INPUT PARAMETERS:
				S           -   sparse M*N matrix in CRS format
				I           -   row index, 0<=I<M
				IRow        -   output buffer, can be  preallocated.  In  case  buffer
												size  is  too  small  to  store  I-th   row,   it   is
												automatically reallocated.

		OUTPUT PARAMETERS:
				IRow        -   array[M], I-th row.


			-- ALGLIB PROJECT --
				 Copyright 20.07.2012 by Bochkanov Sergey
		*************************************************************************/
		public static void sparsegetrow(sparsematrix s, int i, ref double[] irow)
		{

			sparse.sparsegetrow(s.innerobj, i, ref irow);
			return;
		}

		/*************************************************************************
		This function performs in-place conversion from CRS format to  Hash  table
		storage.

		INPUT PARAMETERS
				S           -   sparse matrix in CRS format.

		OUTPUT PARAMETERS
				S           -   sparse matrix in Hash table format.

		NOTE:  this  function  has  no  effect  when  called with matrix which is
		already in Hash table mode.

			-- ALGLIB PROJECT --
				 Copyright 20.07.2012 by Bochkanov Sergey
		*************************************************************************/
		public static void sparseconverttohash(sparsematrix s)
		{

			sparse.sparseconverttohash(s.innerobj);
			return;
		}

		/*************************************************************************
		This  function  performs  out-of-place  conversion  to  Hash table storage
		format. S0 is copied to S1 and converted on-the-fly.

		INPUT PARAMETERS
				S0          -   sparse matrix in any format.

		OUTPUT PARAMETERS
				S1          -   sparse matrix in Hash table format.

		NOTE: if S0 is stored as Hash-table, it is just copied without conversion.

			-- ALGLIB PROJECT --
				 Copyright 20.07.2012 by Bochkanov Sergey
		*************************************************************************/
		public static void sparsecopytohash(sparsematrix s0, out sparsematrix s1)
		{
			s1 = new sparsematrix();
			sparse.sparsecopytohash(s0.innerobj, s1.innerobj);
			return;
		}

		/*************************************************************************
		This  function  performs  out-of-place  conversion  to  CRS format.  S0 is
		copied to S1 and converted on-the-fly.

		INPUT PARAMETERS
				S0          -   sparse matrix in any format.

		OUTPUT PARAMETERS
				S1          -   sparse matrix in CRS format.

		NOTE: if S0 is stored as CRS, it is just copied without conversion.

			-- ALGLIB PROJECT --
				 Copyright 20.07.2012 by Bochkanov Sergey
		*************************************************************************/
		public static void sparsecopytocrs(sparsematrix s0, out sparsematrix s1)
		{
			s1 = new sparsematrix();
			sparse.sparsecopytocrs(s0.innerobj, s1.innerobj);
			return;
		}

		/*************************************************************************
		This function returns type of the matrix storage format.

		INPUT PARAMETERS:
				S           -   sparse matrix.

		RESULT:
				sparse storage format used by matrix:
						0   -   Hash-table
						1   -   CRS-format

		NOTE: future  versions  of  ALGLIB  may  include additional sparse storage
					formats.


			-- ALGLIB PROJECT --
				 Copyright 20.07.2012 by Bochkanov Sergey
		*************************************************************************/
		public static int sparsegetmatrixtype(sparsematrix s)
		{

			int result = sparse.sparsegetmatrixtype(s.innerobj);
			return result;
		}

		/*************************************************************************
		This function checks matrix storage format and returns True when matrix is
		stored using Hash table representation.

		INPUT PARAMETERS:
				S   -   sparse matrix.

		RESULT:
				True if matrix type is Hash table
				False if matrix type is not Hash table

			-- ALGLIB PROJECT --
				 Copyright 20.07.2012 by Bochkanov Sergey
		*************************************************************************/
		public static bool sparseishash(sparsematrix s)
		{

			bool result = sparse.sparseishash(s.innerobj);
			return result;
		}

		/*************************************************************************
		This function checks matrix storage format and returns True when matrix is
		stored using CRS representation.

		INPUT PARAMETERS:
				S   -   sparse matrix.

		RESULT:
				True if matrix type is CRS
				False if matrix type is not CRS

			-- ALGLIB PROJECT --
				 Copyright 20.07.2012 by Bochkanov Sergey
		*************************************************************************/
		public static bool sparseiscrs(sparsematrix s)
		{

			bool result = sparse.sparseiscrs(s.innerobj);
			return result;
		}

		/*************************************************************************
		The function frees all memory occupied by  sparse  matrix.  Sparse  matrix
		structure becomes unusable after this call.

		OUTPUT PARAMETERS
				S   -   sparse matrix to delete

			-- ALGLIB PROJECT --
				 Copyright 24.07.2012 by Bochkanov Sergey
		*************************************************************************/
		public static void sparsefree(out sparsematrix s)
		{
			s = new sparsematrix();
			sparse.sparsefree(s.innerobj);
			return;
		}

		/*************************************************************************
		The function returns number of rows of a sparse matrix.

		RESULT: number of rows of a sparse matrix.

			-- ALGLIB PROJECT --
				 Copyright 23.08.2012 by Bochkanov Sergey
		*************************************************************************/
		public static int sparsegetnrows(sparsematrix s)
		{

			int result = sparse.sparsegetnrows(s.innerobj);
			return result;
		}

		/*************************************************************************
		The function returns number of columns of a sparse matrix.

		RESULT: number of columns of a sparse matrix.

			-- ALGLIB PROJECT --
				 Copyright 23.08.2012 by Bochkanov Sergey
		*************************************************************************/
		public static int sparsegetncols(sparsematrix s)
		{

			int result = sparse.sparsegetncols(s.innerobj);
			return result;
		}

	}
	public partial class alglib
	{



	}
	public partial class alglib
	{


		/*************************************************************************
		This object stores state of the iterative norm estimation algorithm.

		You should use ALGLIB functions to work with this object.
		*************************************************************************/
		public class normestimatorstate : alglibobject
		{
			//
			// Public declarations
			//

			public normestimatorstate()
			{
				_innerobj = new normestimator.normestimatorstate();
			}

			//
			// Although some of declarations below are public, you should not use them
			// They are intended for internal use only
			//
			private normestimator.normestimatorstate _innerobj;
			public normestimator.normestimatorstate innerobj { get { return _innerobj; } }
			public normestimatorstate(normestimator.normestimatorstate obj)
			{
				_innerobj = obj;
			}
		}

		/*************************************************************************
		This procedure initializes matrix norm estimator.

		USAGE:
		1. User initializes algorithm state with NormEstimatorCreate() call
		2. User calls NormEstimatorEstimateSparse() (or NormEstimatorIteration())
		3. User calls NormEstimatorResults() to get solution.

		INPUT PARAMETERS:
				M       -   number of rows in the matrix being estimated, M>0
				N       -   number of columns in the matrix being estimated, N>0
				NStart  -   number of random starting vectors
										recommended value - at least 5.
				NIts    -   number of iterations to do with best starting vector
										recommended value - at least 5.

		OUTPUT PARAMETERS:
				State   -   structure which stores algorithm state


		NOTE: this algorithm is effectively deterministic, i.e. it always  returns
		same result when repeatedly called for the same matrix. In fact, algorithm
		uses randomized starting vectors, but internal  random  numbers  generator
		always generates same sequence of the random values (it is a  feature, not
		bug).

		Algorithm can be made non-deterministic with NormEstimatorSetSeed(0) call.

			-- ALGLIB --
				 Copyright 06.12.2011 by Bochkanov Sergey
		*************************************************************************/
		public static void normestimatorcreate(int m, int n, int nstart, int nits, out normestimatorstate state)
		{
			state = new normestimatorstate();
			normestimator.normestimatorcreate(m, n, nstart, nits, state.innerobj);
			return;
		}

		/*************************************************************************
		This function changes seed value used by algorithm. In some cases we  need
		deterministic processing, i.e. subsequent calls must return equal results,
		in other cases we need non-deterministic algorithm which returns different
		results for the same matrix on every pass.

		Setting zero seed will lead to non-deterministic algorithm, while non-zero
		value will make our algorithm deterministic.

		INPUT PARAMETERS:
				State       -   norm estimator state, must be initialized with a  call
												to NormEstimatorCreate()
				SeedVal     -   seed value, >=0. Zero value = non-deterministic algo.

			-- ALGLIB --
				 Copyright 06.12.2011 by Bochkanov Sergey
		*************************************************************************/
		public static void normestimatorsetseed(normestimatorstate state, int seedval)
		{

			normestimator.normestimatorsetseed(state.innerobj, seedval);
			return;
		}

		/*************************************************************************
		This function estimates norm of the sparse M*N matrix A.

		INPUT PARAMETERS:
				State       -   norm estimator state, must be initialized with a  call
												to NormEstimatorCreate()
				A           -   sparse M*N matrix, must be converted to CRS format
												prior to calling this function.

		After this function  is  over  you can call NormEstimatorResults() to get
		estimate of the norm(A).

			-- ALGLIB --
				 Copyright 06.12.2011 by Bochkanov Sergey
		*************************************************************************/
		public static void normestimatorestimatesparse(normestimatorstate state, sparsematrix a)
		{

			normestimator.normestimatorestimatesparse(state.innerobj, a.innerobj);
			return;
		}

		/*************************************************************************
		Matrix norm estimation results

		INPUT PARAMETERS:
				State   -   algorithm state

		OUTPUT PARAMETERS:
				Nrm     -   estimate of the matrix norm, Nrm>=0

			-- ALGLIB --
				 Copyright 06.12.2011 by Bochkanov Sergey
		*************************************************************************/
		public static void normestimatorresults(normestimatorstate state, out double nrm)
		{
			nrm = 0;
			normestimator.normestimatorresults(state.innerobj, ref nrm);
			return;
		}

	}
	public partial class alglib
	{


		/*************************************************************************
		Determinant calculation of the matrix given by its LU decomposition.

		Input parameters:
				A       -   LU decomposition of the matrix (output of
										RMatrixLU subroutine).
				Pivots  -   table of permutations which were made during
										the LU decomposition.
										Output of RMatrixLU subroutine.
				N       -   (optional) size of matrix A:
										* if given, only principal NxN submatrix is processed and
											overwritten. other elements are unchanged.
										* if not given, automatically determined from matrix size
											(A must be square matrix)

		Result: matrix determinant.

			-- ALGLIB --
				 Copyright 2005 by Bochkanov Sergey
		*************************************************************************/
		public static double rmatrixludet(double[,] a, int[] pivots, int n)
		{

			double result = matdet.rmatrixludet(a, pivots, n);
			return result;
		}
		public static double rmatrixludet(double[,] a, int[] pivots)
		{
			int n;
			if ((ap.rows(a) != ap.cols(a)) || (ap.rows(a) != ap.len(pivots)))
				throw new alglibexception("Error while calling 'rmatrixludet': looks like one of arguments has wrong size");

			n = ap.rows(a);
			double result = matdet.rmatrixludet(a, pivots, n);

			return result;
		}

		/*************************************************************************
		Calculation of the determinant of a general matrix

		Input parameters:
				A       -   matrix, array[0..N-1, 0..N-1]
				N       -   (optional) size of matrix A:
										* if given, only principal NxN submatrix is processed and
											overwritten. other elements are unchanged.
										* if not given, automatically determined from matrix size
											(A must be square matrix)

		Result: determinant of matrix A.

			-- ALGLIB --
				 Copyright 2005 by Bochkanov Sergey
		*************************************************************************/
		public static double rmatrixdet(double[,] a, int n)
		{

			double result = matdet.rmatrixdet(a, n);
			return result;
		}
		public static double rmatrixdet(double[,] a)
		{
			int n;
			if ((ap.rows(a) != ap.cols(a)))
				throw new alglibexception("Error while calling 'rmatrixdet': looks like one of arguments has wrong size");

			n = ap.rows(a);
			double result = matdet.rmatrixdet(a, n);

			return result;
		}

		/*************************************************************************
		Determinant calculation of the matrix given by its LU decomposition.

		Input parameters:
				A       -   LU decomposition of the matrix (output of
										RMatrixLU subroutine).
				Pivots  -   table of permutations which were made during
										the LU decomposition.
										Output of RMatrixLU subroutine.
				N       -   (optional) size of matrix A:
										* if given, only principal NxN submatrix is processed and
											overwritten. other elements are unchanged.
										* if not given, automatically determined from matrix size
											(A must be square matrix)

		Result: matrix determinant.

			-- ALGLIB --
				 Copyright 2005 by Bochkanov Sergey
		*************************************************************************/
		public static complex cmatrixludet(complex[,] a, int[] pivots, int n)
		{

			complex result = matdet.cmatrixludet(a, pivots, n);
			return result;
		}
		public static complex cmatrixludet(complex[,] a, int[] pivots)
		{
			int n;
			if ((ap.rows(a) != ap.cols(a)) || (ap.rows(a) != ap.len(pivots)))
				throw new alglibexception("Error while calling 'cmatrixludet': looks like one of arguments has wrong size");

			n = ap.rows(a);
			complex result = matdet.cmatrixludet(a, pivots, n);

			return result;
		}

		/*************************************************************************
		Calculation of the determinant of a general matrix

		Input parameters:
				A       -   matrix, array[0..N-1, 0..N-1]
				N       -   (optional) size of matrix A:
										* if given, only principal NxN submatrix is processed and
											overwritten. other elements are unchanged.
										* if not given, automatically determined from matrix size
											(A must be square matrix)

		Result: determinant of matrix A.

			-- ALGLIB --
				 Copyright 2005 by Bochkanov Sergey
		*************************************************************************/
		public static complex cmatrixdet(complex[,] a, int n)
		{

			complex result = matdet.cmatrixdet(a, n);
			return result;
		}
		public static complex cmatrixdet(complex[,] a)
		{
			int n;
			if ((ap.rows(a) != ap.cols(a)))
				throw new alglibexception("Error while calling 'cmatrixdet': looks like one of arguments has wrong size");

			n = ap.rows(a);
			complex result = matdet.cmatrixdet(a, n);

			return result;
		}

		/*************************************************************************
		Determinant calculation of the matrix given by the Cholesky decomposition.

		Input parameters:
				A       -   Cholesky decomposition,
										output of SMatrixCholesky subroutine.
				N       -   (optional) size of matrix A:
										* if given, only principal NxN submatrix is processed and
											overwritten. other elements are unchanged.
										* if not given, automatically determined from matrix size
											(A must be square matrix)

		As the determinant is equal to the product of squares of diagonal elements,
		it’s not necessary to specify which triangle - lower or upper - the matrix
		is stored in.

		Result:
				matrix determinant.

			-- ALGLIB --
				 Copyright 2005-2008 by Bochkanov Sergey
		*************************************************************************/
		public static double spdmatrixcholeskydet(double[,] a, int n)
		{

			double result = matdet.spdmatrixcholeskydet(a, n);
			return result;
		}
		public static double spdmatrixcholeskydet(double[,] a)
		{
			int n;
			if ((ap.rows(a) != ap.cols(a)))
				throw new alglibexception("Error while calling 'spdmatrixcholeskydet': looks like one of arguments has wrong size");

			n = ap.rows(a);
			double result = matdet.spdmatrixcholeskydet(a, n);

			return result;
		}

		/*************************************************************************
		Determinant calculation of the symmetric positive definite matrix.

		Input parameters:
				A       -   matrix. Array with elements [0..N-1, 0..N-1].
				N       -   (optional) size of matrix A:
										* if given, only principal NxN submatrix is processed and
											overwritten. other elements are unchanged.
										* if not given, automatically determined from matrix size
											(A must be square matrix)
				IsUpper -   (optional) storage type:
										* if True, symmetric matrix  A  is  given  by  its  upper
											triangle, and the lower triangle isn’t used/changed  by
											function
										* if False, symmetric matrix  A  is  given  by  its lower
											triangle, and the upper triangle isn’t used/changed  by
											function
										* if not given, both lower and upper  triangles  must  be
											filled.

		Result:
				determinant of matrix A.
				If matrix A is not positive definite, exception is thrown.

			-- ALGLIB --
				 Copyright 2005-2008 by Bochkanov Sergey
		*************************************************************************/
		public static double spdmatrixdet(double[,] a, int n, bool isupper)
		{

			double result = matdet.spdmatrixdet(a, n, isupper);
			return result;
		}
		public static double spdmatrixdet(double[,] a)
		{
			int n;
			bool isupper;
			if ((ap.rows(a) != ap.cols(a)))
				throw new alglibexception("Error while calling 'spdmatrixdet': looks like one of arguments has wrong size");
			if (!alglib.ap.issymmetric(a))
				throw new alglibexception("'a' parameter is not symmetric matrix");

			n = ap.rows(a);
			isupper = false;
			double result = matdet.spdmatrixdet(a, n, isupper);

			return result;
		}

	}
	public partial class alglib
	{


		/*************************************************************************
		Algorithm for solving the following generalized symmetric positive-definite
		eigenproblem:
				A*x = lambda*B*x (1) or
				A*B*x = lambda*x (2) or
				B*A*x = lambda*x (3).
		where A is a symmetric matrix, B - symmetric positive-definite matrix.
		The problem is solved by reducing it to an ordinary  symmetric  eigenvalue
		problem.

		Input parameters:
				A           -   symmetric matrix which is given by its upper or lower
												triangular part.
												Array whose indexes range within [0..N-1, 0..N-1].
				N           -   size of matrices A and B.
				IsUpperA    -   storage format of matrix A.
				B           -   symmetric positive-definite matrix which is given by
												its upper or lower triangular part.
												Array whose indexes range within [0..N-1, 0..N-1].
				IsUpperB    -   storage format of matrix B.
				ZNeeded     -   if ZNeeded is equal to:
												 * 0, the eigenvectors are not returned;
												 * 1, the eigenvectors are returned.
				ProblemType -   if ProblemType is equal to:
												 * 1, the following problem is solved: A*x = lambda*B*x;
												 * 2, the following problem is solved: A*B*x = lambda*x;
												 * 3, the following problem is solved: B*A*x = lambda*x.

		Output parameters:
				D           -   eigenvalues in ascending order.
												Array whose index ranges within [0..N-1].
				Z           -   if ZNeeded is equal to:
												 * 0, Z hasn’t changed;
												 * 1, Z contains eigenvectors.
												Array whose indexes range within [0..N-1, 0..N-1].
												The eigenvectors are stored in matrix columns. It should
												be noted that the eigenvectors in such problems do not
												form an orthogonal system.

		Result:
				True, if the problem was solved successfully.
				False, if the error occurred during the Cholesky decomposition of matrix
				B (the matrix isn’t positive-definite) or during the work of the iterative
				algorithm for solving the symmetric eigenproblem.

		See also the GeneralizedSymmetricDefiniteEVDReduce subroutine.

			-- ALGLIB --
				 Copyright 1.28.2006 by Bochkanov Sergey
		*************************************************************************/
		public static bool smatrixgevd(double[,] a, int n, bool isuppera, double[,] b, bool isupperb, int zneeded, int problemtype, out double[] d, out double[,] z)
		{
			d = new double[0];
			z = new double[0, 0];
			bool result = spdgevd.smatrixgevd(a, n, isuppera, b, isupperb, zneeded, problemtype, ref d, ref z);
			return result;
		}

		/*************************************************************************
		Algorithm for reduction of the following generalized symmetric positive-
		definite eigenvalue problem:
				A*x = lambda*B*x (1) or
				A*B*x = lambda*x (2) or
				B*A*x = lambda*x (3)
		to the symmetric eigenvalues problem C*y = lambda*y (eigenvalues of this and
		the given problems are the same, and the eigenvectors of the given problem
		could be obtained by multiplying the obtained eigenvectors by the
		transformation matrix x = R*y).

		Here A is a symmetric matrix, B - symmetric positive-definite matrix.

		Input parameters:
				A           -   symmetric matrix which is given by its upper or lower
												triangular part.
												Array whose indexes range within [0..N-1, 0..N-1].
				N           -   size of matrices A and B.
				IsUpperA    -   storage format of matrix A.
				B           -   symmetric positive-definite matrix which is given by
												its upper or lower triangular part.
												Array whose indexes range within [0..N-1, 0..N-1].
				IsUpperB    -   storage format of matrix B.
				ProblemType -   if ProblemType is equal to:
												 * 1, the following problem is solved: A*x = lambda*B*x;
												 * 2, the following problem is solved: A*B*x = lambda*x;
												 * 3, the following problem is solved: B*A*x = lambda*x.

		Output parameters:
				A           -   symmetric matrix which is given by its upper or lower
												triangle depending on IsUpperA. Contains matrix C.
												Array whose indexes range within [0..N-1, 0..N-1].
				R           -   upper triangular or low triangular transformation matrix
												which is used to obtain the eigenvectors of a given problem
												as the product of eigenvectors of C (from the right) and
												matrix R (from the left). If the matrix is upper
												triangular, the elements below the main diagonal
												are equal to 0 (and vice versa). Thus, we can perform
												the multiplication without taking into account the
												internal structure (which is an easier though less
												effective way).
												Array whose indexes range within [0..N-1, 0..N-1].
				IsUpperR    -   type of matrix R (upper or lower triangular).

		Result:
				True, if the problem was reduced successfully.
				False, if the error occurred during the Cholesky decomposition of
						matrix B (the matrix is not positive-definite).

			-- ALGLIB --
				 Copyright 1.28.2006 by Bochkanov Sergey
		*************************************************************************/
		public static bool smatrixgevdreduce(ref double[,] a, int n, bool isuppera, double[,] b, bool isupperb, int problemtype, out double[,] r, out bool isupperr)
		{
			r = new double[0, 0];
			isupperr = false;
			bool result = spdgevd.smatrixgevdreduce(ref a, n, isuppera, b, isupperb, problemtype, ref r, ref isupperr);
			return result;
		}

	}
	public partial class alglib
	{


		/*************************************************************************
		Inverse matrix update by the Sherman-Morrison formula

		The algorithm updates matrix A^-1 when adding a number to an element
		of matrix A.

		Input parameters:
				InvA    -   inverse of matrix A.
										Array whose indexes range within [0..N-1, 0..N-1].
				N       -   size of matrix A.
				UpdRow  -   row where the element to be updated is stored.
				UpdColumn - column where the element to be updated is stored.
				UpdVal  -   a number to be added to the element.


		Output parameters:
				InvA    -   inverse of modified matrix A.

			-- ALGLIB --
				 Copyright 2005 by Bochkanov Sergey
		*************************************************************************/
		public static void rmatrixinvupdatesimple(ref double[,] inva, int n, int updrow, int updcolumn, double updval)
		{

			inverseupdate.rmatrixinvupdatesimple(ref inva, n, updrow, updcolumn, updval);
			return;
		}

		/*************************************************************************
		Inverse matrix update by the Sherman-Morrison formula

		The algorithm updates matrix A^-1 when adding a vector to a row
		of matrix A.

		Input parameters:
				InvA    -   inverse of matrix A.
										Array whose indexes range within [0..N-1, 0..N-1].
				N       -   size of matrix A.
				UpdRow  -   the row of A whose vector V was added.
										0 <= Row <= N-1
				V       -   the vector to be added to a row.
										Array whose index ranges within [0..N-1].

		Output parameters:
				InvA    -   inverse of modified matrix A.

			-- ALGLIB --
				 Copyright 2005 by Bochkanov Sergey
		*************************************************************************/
		public static void rmatrixinvupdaterow(ref double[,] inva, int n, int updrow, double[] v)
		{

			inverseupdate.rmatrixinvupdaterow(ref inva, n, updrow, v);
			return;
		}

		/*************************************************************************
		Inverse matrix update by the Sherman-Morrison formula

		The algorithm updates matrix A^-1 when adding a vector to a column
		of matrix A.

		Input parameters:
				InvA        -   inverse of matrix A.
												Array whose indexes range within [0..N-1, 0..N-1].
				N           -   size of matrix A.
				UpdColumn   -   the column of A whose vector U was added.
												0 <= UpdColumn <= N-1
				U           -   the vector to be added to a column.
												Array whose index ranges within [0..N-1].

		Output parameters:
				InvA        -   inverse of modified matrix A.

			-- ALGLIB --
				 Copyright 2005 by Bochkanov Sergey
		*************************************************************************/
		public static void rmatrixinvupdatecolumn(ref double[,] inva, int n, int updcolumn, double[] u)
		{

			inverseupdate.rmatrixinvupdatecolumn(ref inva, n, updcolumn, u);
			return;
		}

		/*************************************************************************
		Inverse matrix update by the Sherman-Morrison formula

		The algorithm computes the inverse of matrix A+u*v’ by using the given matrix
		A^-1 and the vectors u and v.

		Input parameters:
				InvA    -   inverse of matrix A.
										Array whose indexes range within [0..N-1, 0..N-1].
				N       -   size of matrix A.
				U       -   the vector modifying the matrix.
										Array whose index ranges within [0..N-1].
				V       -   the vector modifying the matrix.
										Array whose index ranges within [0..N-1].

		Output parameters:
				InvA - inverse of matrix A + u*v'.

			-- ALGLIB --
				 Copyright 2005 by Bochkanov Sergey
		*************************************************************************/
		public static void rmatrixinvupdateuv(ref double[,] inva, int n, double[] u, double[] v)
		{

			inverseupdate.rmatrixinvupdateuv(ref inva, n, u, v);
			return;
		}

	}
	public partial class alglib
	{


		/*************************************************************************
		Subroutine performing the Schur decomposition of a general matrix by using
		the QR algorithm with multiple shifts.

		The source matrix A is represented as S'*A*S = T, where S is an orthogonal
		matrix (Schur vectors), T - upper quasi-triangular matrix (with blocks of
		sizes 1x1 and 2x2 on the main diagonal).

		Input parameters:
				A   -   matrix to be decomposed.
								Array whose indexes range within [0..N-1, 0..N-1].
				N   -   size of A, N>=0.


		Output parameters:
				A   -   contains matrix T.
								Array whose indexes range within [0..N-1, 0..N-1].
				S   -   contains Schur vectors.
								Array whose indexes range within [0..N-1, 0..N-1].

		Note 1:
				The block structure of matrix T can be easily recognized: since all
				the elements below the blocks are zeros, the elements a[i+1,i] which
				are equal to 0 show the block border.

		Note 2:
				The algorithm performance depends on the value of the internal parameter
				NS of the InternalSchurDecomposition subroutine which defines the number
				of shifts in the QR algorithm (similarly to the block width in block-matrix
				algorithms in linear algebra). If you require maximum performance on
				your machine, it is recommended to adjust this parameter manually.

		Result:
				True,
						if the algorithm has converged and parameters A and S contain the result.
				False,
						if the algorithm has not converged.

		Algorithm implemented on the basis of the DHSEQR subroutine (LAPACK 3.0 library).
		*************************************************************************/
		public static bool rmatrixschur(ref double[,] a, int n, out double[,] s)
		{
			s = new double[0, 0];
			bool result = schur.rmatrixschur(ref a, n, ref s);
			return result;
		}

	}
	public partial class alglib
	{
		public class ablas
		{
			public const int rgemmparallelsize = 64;
			public const int cgemmparallelsize = 64;


			/*************************************************************************
			Splits matrix length in two parts, left part should match ABLAS block size

			INPUT PARAMETERS
					A   -   real matrix, is passed to ensure that we didn't split
									complex matrix using real splitting subroutine.
									matrix itself is not changed.
					N   -   length, N>0

			OUTPUT PARAMETERS
					N1  -   length
					N2  -   length

			N1+N2=N, N1>=N2, N2 may be zero

				-- ALGLIB routine --
					 15.12.2009
					 Bochkanov Sergey
			*************************************************************************/
			public static void ablassplitlength(double[,] a,
					int n,
					ref int n1,
					ref int n2)
			{
				n1 = 0;
				n2 = 0;

				if (n > ablasblocksize(a))
				{
					ablasinternalsplitlength(n, ablasblocksize(a), ref n1, ref n2);
				}
				else
				{
					ablasinternalsplitlength(n, ablasmicroblocksize(), ref n1, ref n2);
				}
			}


			/*************************************************************************
			Complex ABLASSplitLength

				-- ALGLIB routine --
					 15.12.2009
					 Bochkanov Sergey
			*************************************************************************/
			public static void ablascomplexsplitlength(complex[,] a,
					int n,
					ref int n1,
					ref int n2)
			{
				n1 = 0;
				n2 = 0;

				if (n > ablascomplexblocksize(a))
				{
					ablasinternalsplitlength(n, ablascomplexblocksize(a), ref n1, ref n2);
				}
				else
				{
					ablasinternalsplitlength(n, ablasmicroblocksize(), ref n1, ref n2);
				}
			}


			/*************************************************************************
			Returns block size - subdivision size where  cache-oblivious  soubroutines
			switch to the optimized kernel.

			INPUT PARAMETERS
					A   -   real matrix, is passed to ensure that we didn't split
									complex matrix using real splitting subroutine.
									matrix itself is not changed.

				-- ALGLIB routine --
					 15.12.2009
					 Bochkanov Sergey
			*************************************************************************/
			public static int ablasblocksize(double[,] a)
			{
				int result = 0;

				result = 32;
				return result;
			}


			/*************************************************************************
			Block size for complex subroutines.

				-- ALGLIB routine --
					 15.12.2009
					 Bochkanov Sergey
			*************************************************************************/
			public static int ablascomplexblocksize(complex[,] a)
			{
				int result = 0;

				result = 24;
				return result;
			}


			/*************************************************************************
			Microblock size

				-- ALGLIB routine --
					 15.12.2009
					 Bochkanov Sergey
			*************************************************************************/
			public static int ablasmicroblocksize()
			{
				int result = 0;

				result = 8;
				return result;
			}


			/*************************************************************************
			Cache-oblivous complex "copy-and-transpose"

			Input parameters:
					M   -   number of rows
					N   -   number of columns
					A   -   source matrix, MxN submatrix is copied and transposed
					IA  -   submatrix offset (row index)
					JA  -   submatrix offset (column index)
					B   -   destination matrix, must be large enough to store result
					IB  -   submatrix offset (row index)
					JB  -   submatrix offset (column index)
			*************************************************************************/
			public static void cmatrixtranspose(int m,
					int n,
					complex[,] a,
					int ia,
					int ja,
					ref complex[,] b,
					int ib,
					int jb)
			{
				int i = 0;
				int s1 = 0;
				int s2 = 0;
				int i_ = 0;
				int i1_ = 0;

				if (m <= 2 * ablascomplexblocksize(a) && n <= 2 * ablascomplexblocksize(a))
				{

					//
					// base case
					//
					for (i = 0; i <= m - 1; i++)
					{
						i1_ = (ja) - (ib);
						for (i_ = ib; i_ <= ib + n - 1; i_++)
						{
							b[i_, jb + i] = a[ia + i, i_ + i1_];
						}
					}
				}
				else
				{

					//
					// Cache-oblivious recursion
					//
					if (m > n)
					{
						ablascomplexsplitlength(a, m, ref s1, ref s2);
						cmatrixtranspose(s1, n, a, ia, ja, ref b, ib, jb);
						cmatrixtranspose(s2, n, a, ia + s1, ja, ref b, ib, jb + s1);
					}
					else
					{
						ablascomplexsplitlength(a, n, ref s1, ref s2);
						cmatrixtranspose(m, s1, a, ia, ja, ref b, ib, jb);
						cmatrixtranspose(m, s2, a, ia, ja + s1, ref b, ib + s1, jb);
					}
				}
			}


			/*************************************************************************
			Cache-oblivous real "copy-and-transpose"

			Input parameters:
					M   -   number of rows
					N   -   number of columns
					A   -   source matrix, MxN submatrix is copied and transposed
					IA  -   submatrix offset (row index)
					JA  -   submatrix offset (column index)
					B   -   destination matrix, must be large enough to store result
					IB  -   submatrix offset (row index)
					JB  -   submatrix offset (column index)
			*************************************************************************/
			public static void rmatrixtranspose(int m,
					int n,
					double[,] a,
					int ia,
					int ja,
					ref double[,] b,
					int ib,
					int jb)
			{
				int i = 0;
				int s1 = 0;
				int s2 = 0;
				int i_ = 0;
				int i1_ = 0;

				if (m <= 2 * ablasblocksize(a) && n <= 2 * ablasblocksize(a))
				{

					//
					// base case
					//
					for (i = 0; i <= m - 1; i++)
					{
						i1_ = (ja) - (ib);
						for (i_ = ib; i_ <= ib + n - 1; i_++)
						{
							b[i_, jb + i] = a[ia + i, i_ + i1_];
						}
					}
				}
				else
				{

					//
					// Cache-oblivious recursion
					//
					if (m > n)
					{
						ablassplitlength(a, m, ref s1, ref s2);
						rmatrixtranspose(s1, n, a, ia, ja, ref b, ib, jb);
						rmatrixtranspose(s2, n, a, ia + s1, ja, ref b, ib, jb + s1);
					}
					else
					{
						ablassplitlength(a, n, ref s1, ref s2);
						rmatrixtranspose(m, s1, a, ia, ja, ref b, ib, jb);
						rmatrixtranspose(m, s2, a, ia, ja + s1, ref b, ib + s1, jb);
					}
				}
			}


			/*************************************************************************
			This code enforces symmetricy of the matrix by copying Upper part to lower
			one (or vice versa).

			INPUT PARAMETERS:
					A   -   matrix
					N   -   number of rows/columns
					IsUpper - whether we want to copy upper triangle to lower one (True)
									or vice versa (False).
			*************************************************************************/
			public static void rmatrixenforcesymmetricity(double[,] a,
					int n,
					bool isupper)
			{
				int i = 0;
				int j = 0;

				if (isupper)
				{
					for (i = 0; i <= n - 1; i++)
					{
						for (j = i + 1; j <= n - 1; j++)
						{
							a[j, i] = a[i, j];
						}
					}
				}
				else
				{
					for (i = 0; i <= n - 1; i++)
					{
						for (j = i + 1; j <= n - 1; j++)
						{
							a[i, j] = a[j, i];
						}
					}
				}
			}


			/*************************************************************************
			Copy

			Input parameters:
					M   -   number of rows
					N   -   number of columns
					A   -   source matrix, MxN submatrix is copied and transposed
					IA  -   submatrix offset (row index)
					JA  -   submatrix offset (column index)
					B   -   destination matrix, must be large enough to store result
					IB  -   submatrix offset (row index)
					JB  -   submatrix offset (column index)
			*************************************************************************/
			public static void cmatrixcopy(int m,
					int n,
					complex[,] a,
					int ia,
					int ja,
					ref complex[,] b,
					int ib,
					int jb)
			{
				int i = 0;
				int i_ = 0;
				int i1_ = 0;

				if (m == 0 || n == 0)
				{
					return;
				}
				for (i = 0; i <= m - 1; i++)
				{
					i1_ = (ja) - (jb);
					for (i_ = jb; i_ <= jb + n - 1; i_++)
					{
						b[ib + i, i_] = a[ia + i, i_ + i1_];
					}
				}
			}


			/*************************************************************************
			Copy

			Input parameters:
					M   -   number of rows
					N   -   number of columns
					A   -   source matrix, MxN submatrix is copied and transposed
					IA  -   submatrix offset (row index)
					JA  -   submatrix offset (column index)
					B   -   destination matrix, must be large enough to store result
					IB  -   submatrix offset (row index)
					JB  -   submatrix offset (column index)
			*************************************************************************/
			public static void rmatrixcopy(int m,
					int n,
					double[,] a,
					int ia,
					int ja,
					ref double[,] b,
					int ib,
					int jb)
			{
				int i = 0;
				int i_ = 0;
				int i1_ = 0;

				if (m == 0 || n == 0)
				{
					return;
				}
				for (i = 0; i <= m - 1; i++)
				{
					i1_ = (ja) - (jb);
					for (i_ = jb; i_ <= jb + n - 1; i_++)
					{
						b[ib + i, i_] = a[ia + i, i_ + i1_];
					}
				}
			}


			/*************************************************************************
			Rank-1 correction: A := A + u*v'

			INPUT PARAMETERS:
					M   -   number of rows
					N   -   number of columns
					A   -   target matrix, MxN submatrix is updated
					IA  -   submatrix offset (row index)
					JA  -   submatrix offset (column index)
					U   -   vector #1
					IU  -   subvector offset
					V   -   vector #2
					IV  -   subvector offset
			*************************************************************************/
			public static void cmatrixrank1(int m,
					int n,
					ref complex[,] a,
					int ia,
					int ja,
					ref complex[] u,
					int iu,
					ref complex[] v,
					int iv)
			{
				int i = 0;
				complex s = 0;
				int i_ = 0;
				int i1_ = 0;

				if (m == 0 || n == 0)
				{
					return;
				}
				if (ablasf.cmatrixrank1f(m, n, ref a, ia, ja, ref u, iu, ref v, iv))
				{
					return;
				}
				for (i = 0; i <= m - 1; i++)
				{
					s = u[iu + i];
					i1_ = (iv) - (ja);
					for (i_ = ja; i_ <= ja + n - 1; i_++)
					{
						a[ia + i, i_] = a[ia + i, i_] + s * v[i_ + i1_];
					}
				}
			}


			/*************************************************************************
			Rank-1 correction: A := A + u*v'

			INPUT PARAMETERS:
					M   -   number of rows
					N   -   number of columns
					A   -   target matrix, MxN submatrix is updated
					IA  -   submatrix offset (row index)
					JA  -   submatrix offset (column index)
					U   -   vector #1
					IU  -   subvector offset
					V   -   vector #2
					IV  -   subvector offset
			*************************************************************************/
			public static void rmatrixrank1(int m,
					int n,
					ref double[,] a,
					int ia,
					int ja,
					ref double[] u,
					int iu,
					ref double[] v,
					int iv)
			{
				int i = 0;
				double s = 0;
				int i_ = 0;
				int i1_ = 0;

				if (m == 0 || n == 0)
				{
					return;
				}
				if (ablasf.rmatrixrank1f(m, n, ref a, ia, ja, ref u, iu, ref v, iv))
				{
					return;
				}
				for (i = 0; i <= m - 1; i++)
				{
					s = u[iu + i];
					i1_ = (iv) - (ja);
					for (i_ = ja; i_ <= ja + n - 1; i_++)
					{
						a[ia + i, i_] = a[ia + i, i_] + s * v[i_ + i1_];
					}
				}
			}


			/*************************************************************************
			Matrix-vector product: y := op(A)*x

			INPUT PARAMETERS:
					M   -   number of rows of op(A)
									M>=0
					N   -   number of columns of op(A)
									N>=0
					A   -   target matrix
					IA  -   submatrix offset (row index)
					JA  -   submatrix offset (column index)
					OpA -   operation type:
									* OpA=0     =>  op(A) = A
									* OpA=1     =>  op(A) = A^T
									* OpA=2     =>  op(A) = A^H
					X   -   input vector
					IX  -   subvector offset
					IY  -   subvector offset
					Y   -   preallocated matrix, must be large enough to store result

			OUTPUT PARAMETERS:
					Y   -   vector which stores result

			if M=0, then subroutine does nothing.
			if N=0, Y is filled by zeros.


				-- ALGLIB routine --

					 28.01.2010
					 Bochkanov Sergey
			*************************************************************************/
			public static void cmatrixmv(int m,
					int n,
					complex[,] a,
					int ia,
					int ja,
					int opa,
					complex[] x,
					int ix,
					ref complex[] y,
					int iy)
			{
				int i = 0;
				complex v = 0;
				int i_ = 0;
				int i1_ = 0;

				if (m == 0)
				{
					return;
				}
				if (n == 0)
				{
					for (i = 0; i <= m - 1; i++)
					{
						y[iy + i] = 0;
					}
					return;
				}
				if (ablasf.cmatrixmvf(m, n, a, ia, ja, opa, x, ix, ref y, iy))
				{
					return;
				}
				if (opa == 0)
				{

					//
					// y = A*x
					//
					for (i = 0; i <= m - 1; i++)
					{
						i1_ = (ix) - (ja);
						v = 0.0f;
						for (i_ = ja; i_ <= ja + n - 1; i_++)
						{
							v += a[ia + i, i_] * x[i_ + i1_];
						}
						y[iy + i] = v;
					}
					return;
				}
				if (opa == 1)
				{

					//
					// y = A^T*x
					//
					for (i = 0; i <= m - 1; i++)
					{
						y[iy + i] = 0;
					}
					for (i = 0; i <= n - 1; i++)
					{
						v = x[ix + i];
						i1_ = (ja) - (iy);
						for (i_ = iy; i_ <= iy + m - 1; i_++)
						{
							y[i_] = y[i_] + v * a[ia + i, i_ + i1_];
						}
					}
					return;
				}
				if (opa == 2)
				{

					//
					// y = A^H*x
					//
					for (i = 0; i <= m - 1; i++)
					{
						y[iy + i] = 0;
					}
					for (i = 0; i <= n - 1; i++)
					{
						v = x[ix + i];
						i1_ = (ja) - (iy);
						for (i_ = iy; i_ <= iy + m - 1; i_++)
						{
							y[i_] = y[i_] + v * math.conj(a[ia + i, i_ + i1_]);
						}
					}
					return;
				}
			}


			/*************************************************************************
			Matrix-vector product: y := op(A)*x

			INPUT PARAMETERS:
					M   -   number of rows of op(A)
					N   -   number of columns of op(A)
					A   -   target matrix
					IA  -   submatrix offset (row index)
					JA  -   submatrix offset (column index)
					OpA -   operation type:
									* OpA=0     =>  op(A) = A
									* OpA=1     =>  op(A) = A^T
					X   -   input vector
					IX  -   subvector offset
					IY  -   subvector offset
					Y   -   preallocated matrix, must be large enough to store result

			OUTPUT PARAMETERS:
					Y   -   vector which stores result

			if M=0, then subroutine does nothing.
			if N=0, Y is filled by zeros.


				-- ALGLIB routine --

					 28.01.2010
					 Bochkanov Sergey
			*************************************************************************/
			public static void rmatrixmv(int m,
					int n,
					double[,] a,
					int ia,
					int ja,
					int opa,
					double[] x,
					int ix,
					ref double[] y,
					int iy)
			{
				int i = 0;
				double v = 0;
				int i_ = 0;
				int i1_ = 0;

				if (m == 0)
				{
					return;
				}
				if (n == 0)
				{
					for (i = 0; i <= m - 1; i++)
					{
						y[iy + i] = 0;
					}
					return;
				}
				if (ablasf.rmatrixmvf(m, n, a, ia, ja, opa, x, ix, ref y, iy))
				{
					return;
				}
				if (opa == 0)
				{

					//
					// y = A*x
					//
					for (i = 0; i <= m - 1; i++)
					{
						i1_ = (ix) - (ja);
						v = 0.0f;
						for (i_ = ja; i_ <= ja + n - 1; i_++)
						{
							v += a[ia + i, i_] * x[i_ + i1_];
						}
						y[iy + i] = v;
					}
					return;
				}
				if (opa == 1)
				{

					//
					// y = A^T*x
					//
					for (i = 0; i <= m - 1; i++)
					{
						y[iy + i] = 0;
					}
					for (i = 0; i <= n - 1; i++)
					{
						v = x[ix + i];
						i1_ = (ja) - (iy);
						for (i_ = iy; i_ <= iy + m - 1; i_++)
						{
							y[i_] = y[i_] + v * a[ia + i, i_ + i1_];
						}
					}
					return;
				}
			}


			public static void cmatrixrighttrsm(int m,
					int n,
					complex[,] a,
					int i1,
					int j1,
					bool isupper,
					bool isunit,
					int optype,
					complex[,] x,
					int i2,
					int j2)
			{
				int s1 = 0;
				int s2 = 0;
				int bs = 0;

				bs = ablascomplexblocksize(a);
				if (m <= bs && n <= bs)
				{
					cmatrixrighttrsm2(m, n, a, i1, j1, isupper, isunit, optype, x, i2, j2);
					return;
				}
				if (m >= n)
				{

					//
					// Split X: X*A = (X1 X2)^T*A
					//
					ablascomplexsplitlength(a, m, ref s1, ref s2);
					cmatrixrighttrsm(s1, n, a, i1, j1, isupper, isunit, optype, x, i2, j2);
					cmatrixrighttrsm(s2, n, a, i1, j1, isupper, isunit, optype, x, i2 + s1, j2);
					return;
				}
				else
				{

					//
					// Split A:
					//               (A1  A12)
					// X*op(A) = X*op(       )
					//               (     A2)
					//
					// Different variants depending on
					// IsUpper/OpType combinations
					//
					ablascomplexsplitlength(a, n, ref s1, ref s2);
					if (isupper && optype == 0)
					{

						//
						//                  (A1  A12)-1
						// X*A^-1 = (X1 X2)*(       )
						//                  (     A2)
						//
						cmatrixrighttrsm(m, s1, a, i1, j1, isupper, isunit, optype, x, i2, j2);
						cmatrixgemm(m, s2, s1, -1.0f, x, i2, j2, 0, a, i1, j1 + s1, 0, 1.0f, x, i2, j2 + s1);
						cmatrixrighttrsm(m, s2, a, i1 + s1, j1 + s1, isupper, isunit, optype, x, i2, j2 + s1);
						return;
					}
					if (isupper && optype != 0)
					{

						//
						//                  (A1'     )-1
						// X*A^-1 = (X1 X2)*(        )
						//                  (A12' A2')
						//
						cmatrixrighttrsm(m, s2, a, i1 + s1, j1 + s1, isupper, isunit, optype, x, i2, j2 + s1);
						cmatrixgemm(m, s1, s2, -1.0f, x, i2, j2 + s1, 0, a, i1, j1 + s1, optype, 1.0f, x, i2, j2);
						cmatrixrighttrsm(m, s1, a, i1, j1, isupper, isunit, optype, x, i2, j2);
						return;
					}
					if (!isupper && optype == 0)
					{

						//
						//                  (A1     )-1
						// X*A^-1 = (X1 X2)*(       )
						//                  (A21  A2)
						//
						cmatrixrighttrsm(m, s2, a, i1 + s1, j1 + s1, isupper, isunit, optype, x, i2, j2 + s1);
						cmatrixgemm(m, s1, s2, -1.0f, x, i2, j2 + s1, 0, a, i1 + s1, j1, 0, 1.0f, x, i2, j2);
						cmatrixrighttrsm(m, s1, a, i1, j1, isupper, isunit, optype, x, i2, j2);
						return;
					}
					if (!isupper && optype != 0)
					{

						//
						//                  (A1' A21')-1
						// X*A^-1 = (X1 X2)*(        )
						//                  (     A2')
						//
						cmatrixrighttrsm(m, s1, a, i1, j1, isupper, isunit, optype, x, i2, j2);
						cmatrixgemm(m, s2, s1, -1.0f, x, i2, j2, 0, a, i1 + s1, j1, optype, 1.0f, x, i2, j2 + s1);
						cmatrixrighttrsm(m, s2, a, i1 + s1, j1 + s1, isupper, isunit, optype, x, i2, j2 + s1);
						return;
					}
				}
			}


			/*************************************************************************
			Single-threaded stub. HPC ALGLIB replaces it by multithreaded code.
			*************************************************************************/
			public static void _pexec_cmatrixrighttrsm(int m,
					int n,
					complex[,] a,
					int i1,
					int j1,
					bool isupper,
					bool isunit,
					int optype,
					complex[,] x,
					int i2,
					int j2)
			{
				cmatrixrighttrsm(m, n, a, i1, j1, isupper, isunit, optype, x, i2, j2);
			}


			public static void cmatrixlefttrsm(int m,
					int n,
					complex[,] a,
					int i1,
					int j1,
					bool isupper,
					bool isunit,
					int optype,
					complex[,] x,
					int i2,
					int j2)
			{
				int s1 = 0;
				int s2 = 0;
				int bs = 0;

				bs = ablascomplexblocksize(a);
				if (m <= bs && n <= bs)
				{
					cmatrixlefttrsm2(m, n, a, i1, j1, isupper, isunit, optype, x, i2, j2);
					return;
				}
				if (n >= m)
				{

					//
					// Split X: op(A)^-1*X = op(A)^-1*(X1 X2)
					//
					ablascomplexsplitlength(x, n, ref s1, ref s2);
					cmatrixlefttrsm(m, s1, a, i1, j1, isupper, isunit, optype, x, i2, j2);
					cmatrixlefttrsm(m, s2, a, i1, j1, isupper, isunit, optype, x, i2, j2 + s1);
					return;
				}
				else
				{

					//
					// Split A
					//
					ablascomplexsplitlength(a, m, ref s1, ref s2);
					if (isupper && optype == 0)
					{

						//
						//           (A1  A12)-1  ( X1 )
						// A^-1*X* = (       )   *(    )
						//           (     A2)    ( X2 )
						//
						cmatrixlefttrsm(s2, n, a, i1 + s1, j1 + s1, isupper, isunit, optype, x, i2 + s1, j2);
						cmatrixgemm(s1, n, s2, -1.0f, a, i1, j1 + s1, 0, x, i2 + s1, j2, 0, 1.0f, x, i2, j2);
						cmatrixlefttrsm(s1, n, a, i1, j1, isupper, isunit, optype, x, i2, j2);
						return;
					}
					if (isupper && optype != 0)
					{

						//
						//          (A1'     )-1 ( X1 )
						// A^-1*X = (        )  *(    )
						//          (A12' A2')   ( X2 )
						//
						cmatrixlefttrsm(s1, n, a, i1, j1, isupper, isunit, optype, x, i2, j2);
						cmatrixgemm(s2, n, s1, -1.0f, a, i1, j1 + s1, optype, x, i2, j2, 0, 1.0f, x, i2 + s1, j2);
						cmatrixlefttrsm(s2, n, a, i1 + s1, j1 + s1, isupper, isunit, optype, x, i2 + s1, j2);
						return;
					}
					if (!isupper && optype == 0)
					{

						//
						//          (A1     )-1 ( X1 )
						// A^-1*X = (       )  *(    )
						//          (A21  A2)   ( X2 )
						//
						cmatrixlefttrsm(s1, n, a, i1, j1, isupper, isunit, optype, x, i2, j2);
						cmatrixgemm(s2, n, s1, -1.0f, a, i1 + s1, j1, 0, x, i2, j2, 0, 1.0f, x, i2 + s1, j2);
						cmatrixlefttrsm(s2, n, a, i1 + s1, j1 + s1, isupper, isunit, optype, x, i2 + s1, j2);
						return;
					}
					if (!isupper && optype != 0)
					{

						//
						//          (A1' A21')-1 ( X1 )
						// A^-1*X = (        )  *(    )
						//          (     A2')   ( X2 )
						//
						cmatrixlefttrsm(s2, n, a, i1 + s1, j1 + s1, isupper, isunit, optype, x, i2 + s1, j2);
						cmatrixgemm(s1, n, s2, -1.0f, a, i1 + s1, j1, optype, x, i2 + s1, j2, 0, 1.0f, x, i2, j2);
						cmatrixlefttrsm(s1, n, a, i1, j1, isupper, isunit, optype, x, i2, j2);
						return;
					}
				}
			}


			/*************************************************************************
			Single-threaded stub. HPC ALGLIB replaces it by multithreaded code.
			*************************************************************************/
			public static void _pexec_cmatrixlefttrsm(int m,
					int n,
					complex[,] a,
					int i1,
					int j1,
					bool isupper,
					bool isunit,
					int optype,
					complex[,] x,
					int i2,
					int j2)
			{
				cmatrixlefttrsm(m, n, a, i1, j1, isupper, isunit, optype, x, i2, j2);
			}


			public static void rmatrixrighttrsm(int m,
					int n,
					double[,] a,
					int i1,
					int j1,
					bool isupper,
					bool isunit,
					int optype,
					double[,] x,
					int i2,
					int j2)
			{
				int s1 = 0;
				int s2 = 0;
				int bs = 0;

				bs = ablasblocksize(a);
				if (m <= bs && n <= bs)
				{
					rmatrixrighttrsm2(m, n, a, i1, j1, isupper, isunit, optype, x, i2, j2);
					return;
				}
				if (m >= n)
				{

					//
					// Split X: X*A = (X1 X2)^T*A
					//
					ablassplitlength(a, m, ref s1, ref s2);
					rmatrixrighttrsm(s1, n, a, i1, j1, isupper, isunit, optype, x, i2, j2);
					rmatrixrighttrsm(s2, n, a, i1, j1, isupper, isunit, optype, x, i2 + s1, j2);
					return;
				}
				else
				{

					//
					// Split A:
					//               (A1  A12)
					// X*op(A) = X*op(       )
					//               (     A2)
					//
					// Different variants depending on
					// IsUpper/OpType combinations
					//
					ablassplitlength(a, n, ref s1, ref s2);
					if (isupper && optype == 0)
					{

						//
						//                  (A1  A12)-1
						// X*A^-1 = (X1 X2)*(       )
						//                  (     A2)
						//
						rmatrixrighttrsm(m, s1, a, i1, j1, isupper, isunit, optype, x, i2, j2);
						rmatrixgemm(m, s2, s1, -1.0f, x, i2, j2, 0, a, i1, j1 + s1, 0, 1.0f, x, i2, j2 + s1);
						rmatrixrighttrsm(m, s2, a, i1 + s1, j1 + s1, isupper, isunit, optype, x, i2, j2 + s1);
						return;
					}
					if (isupper && optype != 0)
					{

						//
						//                  (A1'     )-1
						// X*A^-1 = (X1 X2)*(        )
						//                  (A12' A2')
						//
						rmatrixrighttrsm(m, s2, a, i1 + s1, j1 + s1, isupper, isunit, optype, x, i2, j2 + s1);
						rmatrixgemm(m, s1, s2, -1.0f, x, i2, j2 + s1, 0, a, i1, j1 + s1, optype, 1.0f, x, i2, j2);
						rmatrixrighttrsm(m, s1, a, i1, j1, isupper, isunit, optype, x, i2, j2);
						return;
					}
					if (!isupper && optype == 0)
					{

						//
						//                  (A1     )-1
						// X*A^-1 = (X1 X2)*(       )
						//                  (A21  A2)
						//
						rmatrixrighttrsm(m, s2, a, i1 + s1, j1 + s1, isupper, isunit, optype, x, i2, j2 + s1);
						rmatrixgemm(m, s1, s2, -1.0f, x, i2, j2 + s1, 0, a, i1 + s1, j1, 0, 1.0f, x, i2, j2);
						rmatrixrighttrsm(m, s1, a, i1, j1, isupper, isunit, optype, x, i2, j2);
						return;
					}
					if (!isupper && optype != 0)
					{

						//
						//                  (A1' A21')-1
						// X*A^-1 = (X1 X2)*(        )
						//                  (     A2')
						//
						rmatrixrighttrsm(m, s1, a, i1, j1, isupper, isunit, optype, x, i2, j2);
						rmatrixgemm(m, s2, s1, -1.0f, x, i2, j2, 0, a, i1 + s1, j1, optype, 1.0f, x, i2, j2 + s1);
						rmatrixrighttrsm(m, s2, a, i1 + s1, j1 + s1, isupper, isunit, optype, x, i2, j2 + s1);
						return;
					}
				}
			}


			/*************************************************************************
			Single-threaded stub. HPC ALGLIB replaces it by multithreaded code.
			*************************************************************************/
			public static void _pexec_rmatrixrighttrsm(int m,
					int n,
					double[,] a,
					int i1,
					int j1,
					bool isupper,
					bool isunit,
					int optype,
					double[,] x,
					int i2,
					int j2)
			{
				rmatrixrighttrsm(m, n, a, i1, j1, isupper, isunit, optype, x, i2, j2);
			}


			public static void rmatrixlefttrsm(int m,
					int n,
					double[,] a,
					int i1,
					int j1,
					bool isupper,
					bool isunit,
					int optype,
					double[,] x,
					int i2,
					int j2)
			{
				int s1 = 0;
				int s2 = 0;
				int bs = 0;

				bs = ablasblocksize(a);
				if (m <= bs && n <= bs)
				{
					rmatrixlefttrsm2(m, n, a, i1, j1, isupper, isunit, optype, x, i2, j2);
					return;
				}
				if (n >= m)
				{

					//
					// Split X: op(A)^-1*X = op(A)^-1*(X1 X2)
					//
					ablassplitlength(x, n, ref s1, ref s2);
					rmatrixlefttrsm(m, s1, a, i1, j1, isupper, isunit, optype, x, i2, j2);
					rmatrixlefttrsm(m, s2, a, i1, j1, isupper, isunit, optype, x, i2, j2 + s1);
				}
				else
				{

					//
					// Split A
					//
					ablassplitlength(a, m, ref s1, ref s2);
					if (isupper && optype == 0)
					{

						//
						//           (A1  A12)-1  ( X1 )
						// A^-1*X* = (       )   *(    )
						//           (     A2)    ( X2 )
						//
						rmatrixlefttrsm(s2, n, a, i1 + s1, j1 + s1, isupper, isunit, optype, x, i2 + s1, j2);
						rmatrixgemm(s1, n, s2, -1.0f, a, i1, j1 + s1, 0, x, i2 + s1, j2, 0, 1.0f, x, i2, j2);
						rmatrixlefttrsm(s1, n, a, i1, j1, isupper, isunit, optype, x, i2, j2);
						return;
					}
					if (isupper && optype != 0)
					{

						//
						//          (A1'     )-1 ( X1 )
						// A^-1*X = (        )  *(    )
						//          (A12' A2')   ( X2 )
						//
						rmatrixlefttrsm(s1, n, a, i1, j1, isupper, isunit, optype, x, i2, j2);
						rmatrixgemm(s2, n, s1, -1.0f, a, i1, j1 + s1, optype, x, i2, j2, 0, 1.0f, x, i2 + s1, j2);
						rmatrixlefttrsm(s2, n, a, i1 + s1, j1 + s1, isupper, isunit, optype, x, i2 + s1, j2);
						return;
					}
					if (!isupper && optype == 0)
					{

						//
						//          (A1     )-1 ( X1 )
						// A^-1*X = (       )  *(    )
						//          (A21  A2)   ( X2 )
						//
						rmatrixlefttrsm(s1, n, a, i1, j1, isupper, isunit, optype, x, i2, j2);
						rmatrixgemm(s2, n, s1, -1.0f, a, i1 + s1, j1, 0, x, i2, j2, 0, 1.0f, x, i2 + s1, j2);
						rmatrixlefttrsm(s2, n, a, i1 + s1, j1 + s1, isupper, isunit, optype, x, i2 + s1, j2);
						return;
					}
					if (!isupper && optype != 0)
					{

						//
						//          (A1' A21')-1 ( X1 )
						// A^-1*X = (        )  *(    )
						//          (     A2')   ( X2 )
						//
						rmatrixlefttrsm(s2, n, a, i1 + s1, j1 + s1, isupper, isunit, optype, x, i2 + s1, j2);
						rmatrixgemm(s1, n, s2, -1.0f, a, i1 + s1, j1, optype, x, i2 + s1, j2, 0, 1.0f, x, i2, j2);
						rmatrixlefttrsm(s1, n, a, i1, j1, isupper, isunit, optype, x, i2, j2);
						return;
					}
				}
			}


			/*************************************************************************
			Single-threaded stub. HPC ALGLIB replaces it by multithreaded code.
			*************************************************************************/
			public static void _pexec_rmatrixlefttrsm(int m,
					int n,
					double[,] a,
					int i1,
					int j1,
					bool isupper,
					bool isunit,
					int optype,
					double[,] x,
					int i2,
					int j2)
			{
				rmatrixlefttrsm(m, n, a, i1, j1, isupper, isunit, optype, x, i2, j2);
			}


			public static void cmatrixsyrk(int n,
					int k,
					double alpha,
					complex[,] a,
					int ia,
					int ja,
					int optypea,
					double beta,
					complex[,] c,
					int ic,
					int jc,
					bool isupper)
			{
				int s1 = 0;
				int s2 = 0;
				int bs = 0;

				bs = ablascomplexblocksize(a);
				if (n <= bs && k <= bs)
				{
					cmatrixsyrk2(n, k, alpha, a, ia, ja, optypea, beta, c, ic, jc, isupper);
					return;
				}
				if (k >= n)
				{

					//
					// Split K
					//
					ablascomplexsplitlength(a, k, ref s1, ref s2);
					if (optypea == 0)
					{
						cmatrixsyrk(n, s1, alpha, a, ia, ja, optypea, beta, c, ic, jc, isupper);
						cmatrixsyrk(n, s2, alpha, a, ia, ja + s1, optypea, 1.0f, c, ic, jc, isupper);
					}
					else
					{
						cmatrixsyrk(n, s1, alpha, a, ia, ja, optypea, beta, c, ic, jc, isupper);
						cmatrixsyrk(n, s2, alpha, a, ia + s1, ja, optypea, 1.0f, c, ic, jc, isupper);
					}
				}
				else
				{

					//
					// Split N
					//
					ablascomplexsplitlength(a, n, ref s1, ref s2);
					if (optypea == 0 && isupper)
					{
						cmatrixsyrk(s1, k, alpha, a, ia, ja, optypea, beta, c, ic, jc, isupper);
						cmatrixgemm(s1, s2, k, alpha, a, ia, ja, 0, a, ia + s1, ja, 2, beta, c, ic, jc + s1);
						cmatrixsyrk(s2, k, alpha, a, ia + s1, ja, optypea, beta, c, ic + s1, jc + s1, isupper);
						return;
					}
					if (optypea == 0 && !isupper)
					{
						cmatrixsyrk(s1, k, alpha, a, ia, ja, optypea, beta, c, ic, jc, isupper);
						cmatrixgemm(s2, s1, k, alpha, a, ia + s1, ja, 0, a, ia, ja, 2, beta, c, ic + s1, jc);
						cmatrixsyrk(s2, k, alpha, a, ia + s1, ja, optypea, beta, c, ic + s1, jc + s1, isupper);
						return;
					}
					if (optypea != 0 && isupper)
					{
						cmatrixsyrk(s1, k, alpha, a, ia, ja, optypea, beta, c, ic, jc, isupper);
						cmatrixgemm(s1, s2, k, alpha, a, ia, ja, 2, a, ia, ja + s1, 0, beta, c, ic, jc + s1);
						cmatrixsyrk(s2, k, alpha, a, ia, ja + s1, optypea, beta, c, ic + s1, jc + s1, isupper);
						return;
					}
					if (optypea != 0 && !isupper)
					{
						cmatrixsyrk(s1, k, alpha, a, ia, ja, optypea, beta, c, ic, jc, isupper);
						cmatrixgemm(s2, s1, k, alpha, a, ia, ja + s1, 2, a, ia, ja, 0, beta, c, ic + s1, jc);
						cmatrixsyrk(s2, k, alpha, a, ia, ja + s1, optypea, beta, c, ic + s1, jc + s1, isupper);
						return;
					}
				}
			}


			/*************************************************************************
			Single-threaded stub. HPC ALGLIB replaces it by multithreaded code.
			*************************************************************************/
			public static void _pexec_cmatrixsyrk(int n,
					int k,
					double alpha,
					complex[,] a,
					int ia,
					int ja,
					int optypea,
					double beta,
					complex[,] c,
					int ic,
					int jc,
					bool isupper)
			{
				cmatrixsyrk(n, k, alpha, a, ia, ja, optypea, beta, c, ic, jc, isupper);
			}


			public static void rmatrixsyrk(int n,
					int k,
					double alpha,
					double[,] a,
					int ia,
					int ja,
					int optypea,
					double beta,
					double[,] c,
					int ic,
					int jc,
					bool isupper)
			{
				int s1 = 0;
				int s2 = 0;
				int bs = 0;

				bs = ablasblocksize(a);

				//
				// Use MKL or generic basecase code
				//
				if (ablasmkl.rmatrixsyrkmkl(n, k, alpha, a, ia, ja, optypea, beta, c, ic, jc, isupper))
				{
					return;
				}
				if (n <= bs && k <= bs)
				{
					rmatrixsyrk2(n, k, alpha, a, ia, ja, optypea, beta, c, ic, jc, isupper);
					return;
				}

				//
				// Recursive subdivision of the problem
				//
				if (k >= n)
				{

					//
					// Split K
					//
					ablassplitlength(a, k, ref s1, ref s2);
					if (optypea == 0)
					{
						rmatrixsyrk(n, s1, alpha, a, ia, ja, optypea, beta, c, ic, jc, isupper);
						rmatrixsyrk(n, s2, alpha, a, ia, ja + s1, optypea, 1.0f, c, ic, jc, isupper);
					}
					else
					{
						rmatrixsyrk(n, s1, alpha, a, ia, ja, optypea, beta, c, ic, jc, isupper);
						rmatrixsyrk(n, s2, alpha, a, ia + s1, ja, optypea, 1.0f, c, ic, jc, isupper);
					}
				}
				else
				{

					//
					// Split N
					//
					ablassplitlength(a, n, ref s1, ref s2);
					if (optypea == 0 && isupper)
					{
						rmatrixsyrk(s1, k, alpha, a, ia, ja, optypea, beta, c, ic, jc, isupper);
						rmatrixgemm(s1, s2, k, alpha, a, ia, ja, 0, a, ia + s1, ja, 1, beta, c, ic, jc + s1);
						rmatrixsyrk(s2, k, alpha, a, ia + s1, ja, optypea, beta, c, ic + s1, jc + s1, isupper);
						return;
					}
					if (optypea == 0 && !isupper)
					{
						rmatrixsyrk(s1, k, alpha, a, ia, ja, optypea, beta, c, ic, jc, isupper);
						rmatrixgemm(s2, s1, k, alpha, a, ia + s1, ja, 0, a, ia, ja, 1, beta, c, ic + s1, jc);
						rmatrixsyrk(s2, k, alpha, a, ia + s1, ja, optypea, beta, c, ic + s1, jc + s1, isupper);
						return;
					}
					if (optypea != 0 && isupper)
					{
						rmatrixsyrk(s1, k, alpha, a, ia, ja, optypea, beta, c, ic, jc, isupper);
						rmatrixgemm(s1, s2, k, alpha, a, ia, ja, 1, a, ia, ja + s1, 0, beta, c, ic, jc + s1);
						rmatrixsyrk(s2, k, alpha, a, ia, ja + s1, optypea, beta, c, ic + s1, jc + s1, isupper);
						return;
					}
					if (optypea != 0 && !isupper)
					{
						rmatrixsyrk(s1, k, alpha, a, ia, ja, optypea, beta, c, ic, jc, isupper);
						rmatrixgemm(s2, s1, k, alpha, a, ia, ja + s1, 1, a, ia, ja, 0, beta, c, ic + s1, jc);
						rmatrixsyrk(s2, k, alpha, a, ia, ja + s1, optypea, beta, c, ic + s1, jc + s1, isupper);
						return;
					}
				}
			}


			/*************************************************************************
			Single-threaded stub. HPC ALGLIB replaces it by multithreaded code.
			*************************************************************************/
			public static void _pexec_rmatrixsyrk(int n,
					int k,
					double alpha,
					double[,] a,
					int ia,
					int ja,
					int optypea,
					double beta,
					double[,] c,
					int ic,
					int jc,
					bool isupper)
			{
				rmatrixsyrk(n, k, alpha, a, ia, ja, optypea, beta, c, ic, jc, isupper);
			}


			public static void cmatrixgemm(int m,
					int n,
					int k,
					complex alpha,
					complex[,] a,
					int ia,
					int ja,
					int optypea,
					complex[,] b,
					int ib,
					int jb,
					int optypeb,
					complex beta,
					complex[,] c,
					int ic,
					int jc)
			{
				int s1 = 0;
				int s2 = 0;
				int bs = 0;

				bs = ablascomplexblocksize(a);
				if ((m <= bs && n <= bs) && k <= bs)
				{
					ablasf.cmatrixgemmk(m, n, k, alpha, a, ia, ja, optypea, b, ib, jb, optypeb, beta, c, ic, jc);
					return;
				}

				//
				// SMP support is turned on when M or N are larger than some boundary value.
				// Magnitude of K is not taken into account because splitting on K does not
				// allow us to spawn child tasks.
				//

				//
				// Recursive algorithm: parallel splitting on M/N
				//
				if (m >= n && m >= k)
				{

					//
					// A*B = (A1 A2)^T*B
					//
					ablascomplexsplitlength(a, m, ref s1, ref s2);
					cmatrixgemm(s1, n, k, alpha, a, ia, ja, optypea, b, ib, jb, optypeb, beta, c, ic, jc);
					if (optypea == 0)
					{
						cmatrixgemm(s2, n, k, alpha, a, ia + s1, ja, optypea, b, ib, jb, optypeb, beta, c, ic + s1, jc);
					}
					else
					{
						cmatrixgemm(s2, n, k, alpha, a, ia, ja + s1, optypea, b, ib, jb, optypeb, beta, c, ic + s1, jc);
					}
					return;
				}
				if (n >= m && n >= k)
				{

					//
					// A*B = A*(B1 B2)
					//
					ablascomplexsplitlength(a, n, ref s1, ref s2);
					if (optypeb == 0)
					{
						cmatrixgemm(m, s1, k, alpha, a, ia, ja, optypea, b, ib, jb, optypeb, beta, c, ic, jc);
						cmatrixgemm(m, s2, k, alpha, a, ia, ja, optypea, b, ib, jb + s1, optypeb, beta, c, ic, jc + s1);
					}
					else
					{
						cmatrixgemm(m, s1, k, alpha, a, ia, ja, optypea, b, ib, jb, optypeb, beta, c, ic, jc);
						cmatrixgemm(m, s2, k, alpha, a, ia, ja, optypea, b, ib + s1, jb, optypeb, beta, c, ic, jc + s1);
					}
					return;
				}

				//
				// Recursive algorithm: serial splitting on K
				//

				//
				// A*B = (A1 A2)*(B1 B2)^T
				//
				ablascomplexsplitlength(a, k, ref s1, ref s2);
				if (optypea == 0 && optypeb == 0)
				{
					cmatrixgemm(m, n, s1, alpha, a, ia, ja, optypea, b, ib, jb, optypeb, beta, c, ic, jc);
					cmatrixgemm(m, n, s2, alpha, a, ia, ja + s1, optypea, b, ib + s1, jb, optypeb, 1.0f, c, ic, jc);
				}
				if (optypea == 0 && optypeb != 0)
				{
					cmatrixgemm(m, n, s1, alpha, a, ia, ja, optypea, b, ib, jb, optypeb, beta, c, ic, jc);
					cmatrixgemm(m, n, s2, alpha, a, ia, ja + s1, optypea, b, ib, jb + s1, optypeb, 1.0f, c, ic, jc);
				}
				if (optypea != 0 && optypeb == 0)
				{
					cmatrixgemm(m, n, s1, alpha, a, ia, ja, optypea, b, ib, jb, optypeb, beta, c, ic, jc);
					cmatrixgemm(m, n, s2, alpha, a, ia + s1, ja, optypea, b, ib + s1, jb, optypeb, 1.0f, c, ic, jc);
				}
				if (optypea != 0 && optypeb != 0)
				{
					cmatrixgemm(m, n, s1, alpha, a, ia, ja, optypea, b, ib, jb, optypeb, beta, c, ic, jc);
					cmatrixgemm(m, n, s2, alpha, a, ia + s1, ja, optypea, b, ib, jb + s1, optypeb, 1.0f, c, ic, jc);
				}
				return;
			}


			/*************************************************************************
			Single-threaded stub. HPC ALGLIB replaces it by multithreaded code.
			*************************************************************************/
			public static void _pexec_cmatrixgemm(int m,
					int n,
					int k,
					complex alpha,
					complex[,] a,
					int ia,
					int ja,
					int optypea,
					complex[,] b,
					int ib,
					int jb,
					int optypeb,
					complex beta,
					complex[,] c,
					int ic,
					int jc)
			{
				cmatrixgemm(m, n, k, alpha, a, ia, ja, optypea, b, ib, jb, optypeb, beta, c, ic, jc);
			}


			public static void rmatrixgemm(int m,
					int n,
					int k,
					double alpha,
					double[,] a,
					int ia,
					int ja,
					int optypea,
					double[,] b,
					int ib,
					int jb,
					int optypeb,
					double beta,
					double[,] c,
					int ic,
					int jc)
			{
				int s1 = 0;
				int s2 = 0;
				int bs = 0;

				bs = ablasblocksize(a);

				//
				// Check input sizes for correctness
				//
				alglib.ap.assert(optypea == 0 || optypea == 1, "RMatrixGEMM: incorrect OpTypeA (must be 0 or 1)");
				alglib.ap.assert(optypeb == 0 || optypeb == 1, "RMatrixGEMM: incorrect OpTypeB (must be 0 or 1)");
				alglib.ap.assert(ic + m <= alglib.ap.rows(c), "RMatrixGEMM: incorect size of output matrix C");
				alglib.ap.assert(jc + n <= alglib.ap.cols(c), "RMatrixGEMM: incorect size of output matrix C");

				//
				// Use MKL or ALGLIB basecase code
				//
				if (ablasmkl.rmatrixgemmmkl(m, n, k, alpha, a, ia, ja, optypea, b, ib, jb, optypeb, beta, c, ic, jc))
				{
					return;
				}
				if ((m <= bs && n <= bs) && k <= bs)
				{
					ablasf.rmatrixgemmk(m, n, k, alpha, a, ia, ja, optypea, b, ib, jb, optypeb, beta, c, ic, jc);
					return;
				}

				//
				// SMP support is turned on when M or N are larger than some boundary value.
				// Magnitude of K is not taken into account because splitting on K does not
				// allow us to spawn child tasks.
				//

				//
				// Recursive algorithm: split on M or N
				//
				if (m >= n && m >= k)
				{

					//
					// A*B = (A1 A2)^T*B
					//
					ablassplitlength(a, m, ref s1, ref s2);
					if (optypea == 0)
					{
						rmatrixgemm(s1, n, k, alpha, a, ia, ja, optypea, b, ib, jb, optypeb, beta, c, ic, jc);
						rmatrixgemm(s2, n, k, alpha, a, ia + s1, ja, optypea, b, ib, jb, optypeb, beta, c, ic + s1, jc);
					}
					else
					{
						rmatrixgemm(s1, n, k, alpha, a, ia, ja, optypea, b, ib, jb, optypeb, beta, c, ic, jc);
						rmatrixgemm(s2, n, k, alpha, a, ia, ja + s1, optypea, b, ib, jb, optypeb, beta, c, ic + s1, jc);
					}
					return;
				}
				if (n >= m && n >= k)
				{

					//
					// A*B = A*(B1 B2)
					//
					ablassplitlength(a, n, ref s1, ref s2);
					if (optypeb == 0)
					{
						rmatrixgemm(m, s1, k, alpha, a, ia, ja, optypea, b, ib, jb, optypeb, beta, c, ic, jc);
						rmatrixgemm(m, s2, k, alpha, a, ia, ja, optypea, b, ib, jb + s1, optypeb, beta, c, ic, jc + s1);
					}
					else
					{
						rmatrixgemm(m, s1, k, alpha, a, ia, ja, optypea, b, ib, jb, optypeb, beta, c, ic, jc);
						rmatrixgemm(m, s2, k, alpha, a, ia, ja, optypea, b, ib + s1, jb, optypeb, beta, c, ic, jc + s1);
					}
					return;
				}

				//
				// Recursive algorithm: split on K
				//

				//
				// A*B = (A1 A2)*(B1 B2)^T
				//
				ablassplitlength(a, k, ref s1, ref s2);
				if (optypea == 0 && optypeb == 0)
				{
					rmatrixgemm(m, n, s1, alpha, a, ia, ja, optypea, b, ib, jb, optypeb, beta, c, ic, jc);
					rmatrixgemm(m, n, s2, alpha, a, ia, ja + s1, optypea, b, ib + s1, jb, optypeb, 1.0f, c, ic, jc);
				}
				if (optypea == 0 && optypeb != 0)
				{
					rmatrixgemm(m, n, s1, alpha, a, ia, ja, optypea, b, ib, jb, optypeb, beta, c, ic, jc);
					rmatrixgemm(m, n, s2, alpha, a, ia, ja + s1, optypea, b, ib, jb + s1, optypeb, 1.0f, c, ic, jc);
				}
				if (optypea != 0 && optypeb == 0)
				{
					rmatrixgemm(m, n, s1, alpha, a, ia, ja, optypea, b, ib, jb, optypeb, beta, c, ic, jc);
					rmatrixgemm(m, n, s2, alpha, a, ia + s1, ja, optypea, b, ib + s1, jb, optypeb, 1.0f, c, ic, jc);
				}
				if (optypea != 0 && optypeb != 0)
				{
					rmatrixgemm(m, n, s1, alpha, a, ia, ja, optypea, b, ib, jb, optypeb, beta, c, ic, jc);
					rmatrixgemm(m, n, s2, alpha, a, ia + s1, ja, optypea, b, ib, jb + s1, optypeb, 1.0f, c, ic, jc);
				}
				return;
			}


			/*************************************************************************
			Single-threaded stub. HPC ALGLIB replaces it by multithreaded code.
			*************************************************************************/
			public static void _pexec_rmatrixgemm(int m,
					int n,
					int k,
					double alpha,
					double[,] a,
					int ia,
					int ja,
					int optypea,
					double[,] b,
					int ib,
					int jb,
					int optypeb,
					double beta,
					double[,] c,
					int ic,
					int jc)
			{
				rmatrixgemm(m, n, k, alpha, a, ia, ja, optypea, b, ib, jb, optypeb, beta, c, ic, jc);
			}


			/*************************************************************************
			Complex ABLASSplitLength

				-- ALGLIB routine --
					 15.12.2009
					 Bochkanov Sergey
			*************************************************************************/
			private static void ablasinternalsplitlength(int n,
					int nb,
					ref int n1,
					ref int n2)
			{
				int r = 0;

				n1 = 0;
				n2 = 0;

				if (n <= nb)
				{

					//
					// Block size, no further splitting
					//
					n1 = n;
					n2 = 0;
				}
				else
				{

					//
					// Greater than block size
					//
					if (n % nb != 0)
					{

						//
						// Split remainder
						//
						n2 = n % nb;
						n1 = n - n2;
					}
					else
					{

						//
						// Split on block boundaries
						//
						n2 = n / 2;
						n1 = n - n2;
						if (n1 % nb == 0)
						{
							return;
						}
						r = nb - n1 % nb;
						n1 = n1 + r;
						n2 = n2 - r;
					}
				}
			}


			/*************************************************************************
			Level 2 variant of CMatrixRightTRSM
			*************************************************************************/
			private static void cmatrixrighttrsm2(int m,
					int n,
					complex[,] a,
					int i1,
					int j1,
					bool isupper,
					bool isunit,
					int optype,
					complex[,] x,
					int i2,
					int j2)
			{
				int i = 0;
				int j = 0;
				complex vc = 0;
				complex vd = 0;
				int i_ = 0;
				int i1_ = 0;


				//
				// Special case
				//
				if (n * m == 0)
				{
					return;
				}

				//
				// Try to call fast TRSM
				//
				if (ablasf.cmatrixrighttrsmf(m, n, a, i1, j1, isupper, isunit, optype, x, i2, j2))
				{
					return;
				}

				//
				// General case
				//
				if (isupper)
				{

					//
					// Upper triangular matrix
					//
					if (optype == 0)
					{

						//
						// X*A^(-1)
						//
						for (i = 0; i <= m - 1; i++)
						{
							for (j = 0; j <= n - 1; j++)
							{
								if (isunit)
								{
									vd = 1;
								}
								else
								{
									vd = a[i1 + j, j1 + j];
								}
								x[i2 + i, j2 + j] = x[i2 + i, j2 + j] / vd;
								if (j < n - 1)
								{
									vc = x[i2 + i, j2 + j];
									i1_ = (j1 + j + 1) - (j2 + j + 1);
									for (i_ = j2 + j + 1; i_ <= j2 + n - 1; i_++)
									{
										x[i2 + i, i_] = x[i2 + i, i_] - vc * a[i1 + j, i_ + i1_];
									}
								}
							}
						}
						return;
					}
					if (optype == 1)
					{

						//
						// X*A^(-T)
						//
						for (i = 0; i <= m - 1; i++)
						{
							for (j = n - 1; j >= 0; j--)
							{
								vc = 0;
								vd = 1;
								if (j < n - 1)
								{
									i1_ = (j1 + j + 1) - (j2 + j + 1);
									vc = 0.0f;
									for (i_ = j2 + j + 1; i_ <= j2 + n - 1; i_++)
									{
										vc += x[i2 + i, i_] * a[i1 + j, i_ + i1_];
									}
								}
								if (!isunit)
								{
									vd = a[i1 + j, j1 + j];
								}
								x[i2 + i, j2 + j] = (x[i2 + i, j2 + j] - vc) / vd;
							}
						}
						return;
					}
					if (optype == 2)
					{

						//
						// X*A^(-H)
						//
						for (i = 0; i <= m - 1; i++)
						{
							for (j = n - 1; j >= 0; j--)
							{
								vc = 0;
								vd = 1;
								if (j < n - 1)
								{
									i1_ = (j1 + j + 1) - (j2 + j + 1);
									vc = 0.0f;
									for (i_ = j2 + j + 1; i_ <= j2 + n - 1; i_++)
									{
										vc += x[i2 + i, i_] * math.conj(a[i1 + j, i_ + i1_]);
									}
								}
								if (!isunit)
								{
									vd = math.conj(a[i1 + j, j1 + j]);
								}
								x[i2 + i, j2 + j] = (x[i2 + i, j2 + j] - vc) / vd;
							}
						}
						return;
					}
				}
				else
				{

					//
					// Lower triangular matrix
					//
					if (optype == 0)
					{

						//
						// X*A^(-1)
						//
						for (i = 0; i <= m - 1; i++)
						{
							for (j = n - 1; j >= 0; j--)
							{
								if (isunit)
								{
									vd = 1;
								}
								else
								{
									vd = a[i1 + j, j1 + j];
								}
								x[i2 + i, j2 + j] = x[i2 + i, j2 + j] / vd;
								if (j > 0)
								{
									vc = x[i2 + i, j2 + j];
									i1_ = (j1) - (j2);
									for (i_ = j2; i_ <= j2 + j - 1; i_++)
									{
										x[i2 + i, i_] = x[i2 + i, i_] - vc * a[i1 + j, i_ + i1_];
									}
								}
							}
						}
						return;
					}
					if (optype == 1)
					{

						//
						// X*A^(-T)
						//
						for (i = 0; i <= m - 1; i++)
						{
							for (j = 0; j <= n - 1; j++)
							{
								vc = 0;
								vd = 1;
								if (j > 0)
								{
									i1_ = (j1) - (j2);
									vc = 0.0f;
									for (i_ = j2; i_ <= j2 + j - 1; i_++)
									{
										vc += x[i2 + i, i_] * a[i1 + j, i_ + i1_];
									}
								}
								if (!isunit)
								{
									vd = a[i1 + j, j1 + j];
								}
								x[i2 + i, j2 + j] = (x[i2 + i, j2 + j] - vc) / vd;
							}
						}
						return;
					}
					if (optype == 2)
					{

						//
						// X*A^(-H)
						//
						for (i = 0; i <= m - 1; i++)
						{
							for (j = 0; j <= n - 1; j++)
							{
								vc = 0;
								vd = 1;
								if (j > 0)
								{
									i1_ = (j1) - (j2);
									vc = 0.0f;
									for (i_ = j2; i_ <= j2 + j - 1; i_++)
									{
										vc += x[i2 + i, i_] * math.conj(a[i1 + j, i_ + i1_]);
									}
								}
								if (!isunit)
								{
									vd = math.conj(a[i1 + j, j1 + j]);
								}
								x[i2 + i, j2 + j] = (x[i2 + i, j2 + j] - vc) / vd;
							}
						}
						return;
					}
				}
			}


			/*************************************************************************
			Level-2 subroutine
			*************************************************************************/
			private static void cmatrixlefttrsm2(int m,
					int n,
					complex[,] a,
					int i1,
					int j1,
					bool isupper,
					bool isunit,
					int optype,
					complex[,] x,
					int i2,
					int j2)
			{
				int i = 0;
				int j = 0;
				complex vc = 0;
				complex vd = 0;
				int i_ = 0;


				//
				// Special case
				//
				if (n * m == 0)
				{
					return;
				}

				//
				// Try to call fast TRSM
				//
				if (ablasf.cmatrixlefttrsmf(m, n, a, i1, j1, isupper, isunit, optype, x, i2, j2))
				{
					return;
				}

				//
				// General case
				//
				if (isupper)
				{

					//
					// Upper triangular matrix
					//
					if (optype == 0)
					{

						//
						// A^(-1)*X
						//
						for (i = m - 1; i >= 0; i--)
						{
							for (j = i + 1; j <= m - 1; j++)
							{
								vc = a[i1 + i, j1 + j];
								for (i_ = j2; i_ <= j2 + n - 1; i_++)
								{
									x[i2 + i, i_] = x[i2 + i, i_] - vc * x[i2 + j, i_];
								}
							}
							if (!isunit)
							{
								vd = 1 / a[i1 + i, j1 + i];
								for (i_ = j2; i_ <= j2 + n - 1; i_++)
								{
									x[i2 + i, i_] = vd * x[i2 + i, i_];
								}
							}
						}
						return;
					}
					if (optype == 1)
					{

						//
						// A^(-T)*X
						//
						for (i = 0; i <= m - 1; i++)
						{
							if (isunit)
							{
								vd = 1;
							}
							else
							{
								vd = 1 / a[i1 + i, j1 + i];
							}
							for (i_ = j2; i_ <= j2 + n - 1; i_++)
							{
								x[i2 + i, i_] = vd * x[i2 + i, i_];
							}
							for (j = i + 1; j <= m - 1; j++)
							{
								vc = a[i1 + i, j1 + j];
								for (i_ = j2; i_ <= j2 + n - 1; i_++)
								{
									x[i2 + j, i_] = x[i2 + j, i_] - vc * x[i2 + i, i_];
								}
							}
						}
						return;
					}
					if (optype == 2)
					{

						//
						// A^(-H)*X
						//
						for (i = 0; i <= m - 1; i++)
						{
							if (isunit)
							{
								vd = 1;
							}
							else
							{
								vd = 1 / math.conj(a[i1 + i, j1 + i]);
							}
							for (i_ = j2; i_ <= j2 + n - 1; i_++)
							{
								x[i2 + i, i_] = vd * x[i2 + i, i_];
							}
							for (j = i + 1; j <= m - 1; j++)
							{
								vc = math.conj(a[i1 + i, j1 + j]);
								for (i_ = j2; i_ <= j2 + n - 1; i_++)
								{
									x[i2 + j, i_] = x[i2 + j, i_] - vc * x[i2 + i, i_];
								}
							}
						}
						return;
					}
				}
				else
				{

					//
					// Lower triangular matrix
					//
					if (optype == 0)
					{

						//
						// A^(-1)*X
						//
						for (i = 0; i <= m - 1; i++)
						{
							for (j = 0; j <= i - 1; j++)
							{
								vc = a[i1 + i, j1 + j];
								for (i_ = j2; i_ <= j2 + n - 1; i_++)
								{
									x[i2 + i, i_] = x[i2 + i, i_] - vc * x[i2 + j, i_];
								}
							}
							if (isunit)
							{
								vd = 1;
							}
							else
							{
								vd = 1 / a[i1 + j, j1 + j];
							}
							for (i_ = j2; i_ <= j2 + n - 1; i_++)
							{
								x[i2 + i, i_] = vd * x[i2 + i, i_];
							}
						}
						return;
					}
					if (optype == 1)
					{

						//
						// A^(-T)*X
						//
						for (i = m - 1; i >= 0; i--)
						{
							if (isunit)
							{
								vd = 1;
							}
							else
							{
								vd = 1 / a[i1 + i, j1 + i];
							}
							for (i_ = j2; i_ <= j2 + n - 1; i_++)
							{
								x[i2 + i, i_] = vd * x[i2 + i, i_];
							}
							for (j = i - 1; j >= 0; j--)
							{
								vc = a[i1 + i, j1 + j];
								for (i_ = j2; i_ <= j2 + n - 1; i_++)
								{
									x[i2 + j, i_] = x[i2 + j, i_] - vc * x[i2 + i, i_];
								}
							}
						}
						return;
					}
					if (optype == 2)
					{

						//
						// A^(-H)*X
						//
						for (i = m - 1; i >= 0; i--)
						{
							if (isunit)
							{
								vd = 1;
							}
							else
							{
								vd = 1 / math.conj(a[i1 + i, j1 + i]);
							}
							for (i_ = j2; i_ <= j2 + n - 1; i_++)
							{
								x[i2 + i, i_] = vd * x[i2 + i, i_];
							}
							for (j = i - 1; j >= 0; j--)
							{
								vc = math.conj(a[i1 + i, j1 + j]);
								for (i_ = j2; i_ <= j2 + n - 1; i_++)
								{
									x[i2 + j, i_] = x[i2 + j, i_] - vc * x[i2 + i, i_];
								}
							}
						}
						return;
					}
				}
			}


			/*************************************************************************
			Level 2 subroutine

				-- ALGLIB routine --
					 15.12.2009
					 Bochkanov Sergey
			*************************************************************************/
			private static void rmatrixrighttrsm2(int m,
					int n,
					double[,] a,
					int i1,
					int j1,
					bool isupper,
					bool isunit,
					int optype,
					double[,] x,
					int i2,
					int j2)
			{
				int i = 0;
				int j = 0;
				double vr = 0;
				double vd = 0;
				int i_ = 0;
				int i1_ = 0;


				//
				// Special case
				//
				if (n * m == 0)
				{
					return;
				}

				//
				// Try to use "fast" code
				//
				if (ablasf.rmatrixrighttrsmf(m, n, a, i1, j1, isupper, isunit, optype, x, i2, j2))
				{
					return;
				}

				//
				// General case
				//
				if (isupper)
				{

					//
					// Upper triangular matrix
					//
					if (optype == 0)
					{

						//
						// X*A^(-1)
						//
						for (i = 0; i <= m - 1; i++)
						{
							for (j = 0; j <= n - 1; j++)
							{
								if (isunit)
								{
									vd = 1;
								}
								else
								{
									vd = a[i1 + j, j1 + j];
								}
								x[i2 + i, j2 + j] = x[i2 + i, j2 + j] / vd;
								if (j < n - 1)
								{
									vr = x[i2 + i, j2 + j];
									i1_ = (j1 + j + 1) - (j2 + j + 1);
									for (i_ = j2 + j + 1; i_ <= j2 + n - 1; i_++)
									{
										x[i2 + i, i_] = x[i2 + i, i_] - vr * a[i1 + j, i_ + i1_];
									}
								}
							}
						}
						return;
					}
					if (optype == 1)
					{

						//
						// X*A^(-T)
						//
						for (i = 0; i <= m - 1; i++)
						{
							for (j = n - 1; j >= 0; j--)
							{
								vr = 0;
								vd = 1;
								if (j < n - 1)
								{
									i1_ = (j1 + j + 1) - (j2 + j + 1);
									vr = 0.0f;
									for (i_ = j2 + j + 1; i_ <= j2 + n - 1; i_++)
									{
										vr += x[i2 + i, i_] * a[i1 + j, i_ + i1_];
									}
								}
								if (!isunit)
								{
									vd = a[i1 + j, j1 + j];
								}
								x[i2 + i, j2 + j] = (x[i2 + i, j2 + j] - vr) / vd;
							}
						}
						return;
					}
				}
				else
				{

					//
					// Lower triangular matrix
					//
					if (optype == 0)
					{

						//
						// X*A^(-1)
						//
						for (i = 0; i <= m - 1; i++)
						{
							for (j = n - 1; j >= 0; j--)
							{
								if (isunit)
								{
									vd = 1;
								}
								else
								{
									vd = a[i1 + j, j1 + j];
								}
								x[i2 + i, j2 + j] = x[i2 + i, j2 + j] / vd;
								if (j > 0)
								{
									vr = x[i2 + i, j2 + j];
									i1_ = (j1) - (j2);
									for (i_ = j2; i_ <= j2 + j - 1; i_++)
									{
										x[i2 + i, i_] = x[i2 + i, i_] - vr * a[i1 + j, i_ + i1_];
									}
								}
							}
						}
						return;
					}
					if (optype == 1)
					{

						//
						// X*A^(-T)
						//
						for (i = 0; i <= m - 1; i++)
						{
							for (j = 0; j <= n - 1; j++)
							{
								vr = 0;
								vd = 1;
								if (j > 0)
								{
									i1_ = (j1) - (j2);
									vr = 0.0f;
									for (i_ = j2; i_ <= j2 + j - 1; i_++)
									{
										vr += x[i2 + i, i_] * a[i1 + j, i_ + i1_];
									}
								}
								if (!isunit)
								{
									vd = a[i1 + j, j1 + j];
								}
								x[i2 + i, j2 + j] = (x[i2 + i, j2 + j] - vr) / vd;
							}
						}
						return;
					}
				}
			}


			/*************************************************************************
			Level 2 subroutine
			*************************************************************************/
			private static void rmatrixlefttrsm2(int m,
					int n,
					double[,] a,
					int i1,
					int j1,
					bool isupper,
					bool isunit,
					int optype,
					double[,] x,
					int i2,
					int j2)
			{
				int i = 0;
				int j = 0;
				double vr = 0;
				double vd = 0;
				int i_ = 0;


				//
				// Special case
				//
				if (n == 0 || m == 0)
				{
					return;
				}

				//
				// Try fast code
				//
				if (ablasf.rmatrixlefttrsmf(m, n, a, i1, j1, isupper, isunit, optype, x, i2, j2))
				{
					return;
				}

				//
				// General case
				//
				if (isupper)
				{

					//
					// Upper triangular matrix
					//
					if (optype == 0)
					{

						//
						// A^(-1)*X
						//
						for (i = m - 1; i >= 0; i--)
						{
							for (j = i + 1; j <= m - 1; j++)
							{
								vr = a[i1 + i, j1 + j];
								for (i_ = j2; i_ <= j2 + n - 1; i_++)
								{
									x[i2 + i, i_] = x[i2 + i, i_] - vr * x[i2 + j, i_];
								}
							}
							if (!isunit)
							{
								vd = 1 / a[i1 + i, j1 + i];
								for (i_ = j2; i_ <= j2 + n - 1; i_++)
								{
									x[i2 + i, i_] = vd * x[i2 + i, i_];
								}
							}
						}
						return;
					}
					if (optype == 1)
					{

						//
						// A^(-T)*X
						//
						for (i = 0; i <= m - 1; i++)
						{
							if (isunit)
							{
								vd = 1;
							}
							else
							{
								vd = 1 / a[i1 + i, j1 + i];
							}
							for (i_ = j2; i_ <= j2 + n - 1; i_++)
							{
								x[i2 + i, i_] = vd * x[i2 + i, i_];
							}
							for (j = i + 1; j <= m - 1; j++)
							{
								vr = a[i1 + i, j1 + j];
								for (i_ = j2; i_ <= j2 + n - 1; i_++)
								{
									x[i2 + j, i_] = x[i2 + j, i_] - vr * x[i2 + i, i_];
								}
							}
						}
						return;
					}
				}
				else
				{

					//
					// Lower triangular matrix
					//
					if (optype == 0)
					{

						//
						// A^(-1)*X
						//
						for (i = 0; i <= m - 1; i++)
						{
							for (j = 0; j <= i - 1; j++)
							{
								vr = a[i1 + i, j1 + j];
								for (i_ = j2; i_ <= j2 + n - 1; i_++)
								{
									x[i2 + i, i_] = x[i2 + i, i_] - vr * x[i2 + j, i_];
								}
							}
							if (isunit)
							{
								vd = 1;
							}
							else
							{
								vd = 1 / a[i1 + j, j1 + j];
							}
							for (i_ = j2; i_ <= j2 + n - 1; i_++)
							{
								x[i2 + i, i_] = vd * x[i2 + i, i_];
							}
						}
						return;
					}
					if (optype == 1)
					{

						//
						// A^(-T)*X
						//
						for (i = m - 1; i >= 0; i--)
						{
							if (isunit)
							{
								vd = 1;
							}
							else
							{
								vd = 1 / a[i1 + i, j1 + i];
							}
							for (i_ = j2; i_ <= j2 + n - 1; i_++)
							{
								x[i2 + i, i_] = vd * x[i2 + i, i_];
							}
							for (j = i - 1; j >= 0; j--)
							{
								vr = a[i1 + i, j1 + j];
								for (i_ = j2; i_ <= j2 + n - 1; i_++)
								{
									x[i2 + j, i_] = x[i2 + j, i_] - vr * x[i2 + i, i_];
								}
							}
						}
						return;
					}
				}
			}


			/*************************************************************************
			Level 2 subroutine
			*************************************************************************/
			private static void cmatrixsyrk2(int n,
					int k,
					double alpha,
					complex[,] a,
					int ia,
					int ja,
					int optypea,
					double beta,
					complex[,] c,
					int ic,
					int jc,
					bool isupper)
			{
				int i = 0;
				int j = 0;
				int j1 = 0;
				int j2 = 0;
				complex v = 0;
				int i_ = 0;
				int i1_ = 0;


				//
				// Fast exit (nothing to be done)
				//
				if (((double)(alpha) == (double)(0) || k == 0) && (double)(beta) == (double)(1))
				{
					return;
				}

				//
				// Try to call fast SYRK
				//
				if (ablasf.cmatrixsyrkf(n, k, alpha, a, ia, ja, optypea, beta, c, ic, jc, isupper))
				{
					return;
				}

				//
				// SYRK
				//
				if (optypea == 0)
				{

					//
					// C=alpha*A*A^H+beta*C
					//
					for (i = 0; i <= n - 1; i++)
					{
						if (isupper)
						{
							j1 = i;
							j2 = n - 1;
						}
						else
						{
							j1 = 0;
							j2 = i;
						}
						for (j = j1; j <= j2; j++)
						{
							if ((double)(alpha) != (double)(0) && k > 0)
							{
								v = 0.0f;
								for (i_ = ja; i_ <= ja + k - 1; i_++)
								{
									v += a[ia + i, i_] * math.conj(a[ia + j, i_]);
								}
							}
							else
							{
								v = 0;
							}
							if ((double)(beta) == (double)(0))
							{
								c[ic + i, jc + j] = alpha * v;
							}
							else
							{
								c[ic + i, jc + j] = beta * c[ic + i, jc + j] + alpha * v;
							}
						}
					}
					return;
				}
				else
				{

					//
					// C=alpha*A^H*A+beta*C
					//
					for (i = 0; i <= n - 1; i++)
					{
						if (isupper)
						{
							j1 = i;
							j2 = n - 1;
						}
						else
						{
							j1 = 0;
							j2 = i;
						}
						if ((double)(beta) == (double)(0))
						{
							for (j = j1; j <= j2; j++)
							{
								c[ic + i, jc + j] = 0;
							}
						}
						else
						{
							for (i_ = jc + j1; i_ <= jc + j2; i_++)
							{
								c[ic + i, i_] = beta * c[ic + i, i_];
							}
						}
					}
					for (i = 0; i <= k - 1; i++)
					{
						for (j = 0; j <= n - 1; j++)
						{
							if (isupper)
							{
								j1 = j;
								j2 = n - 1;
							}
							else
							{
								j1 = 0;
								j2 = j;
							}
							v = alpha * math.conj(a[ia + i, ja + j]);
							i1_ = (ja + j1) - (jc + j1);
							for (i_ = jc + j1; i_ <= jc + j2; i_++)
							{
								c[ic + j, i_] = c[ic + j, i_] + v * a[ia + i, i_ + i1_];
							}
						}
					}
					return;
				}
			}


			/*************************************************************************
			Level 2 subrotuine
			*************************************************************************/
			private static void rmatrixsyrk2(int n,
					int k,
					double alpha,
					double[,] a,
					int ia,
					int ja,
					int optypea,
					double beta,
					double[,] c,
					int ic,
					int jc,
					bool isupper)
			{
				int i = 0;
				int j = 0;
				int j1 = 0;
				int j2 = 0;
				double v = 0;
				int i_ = 0;
				int i1_ = 0;


				//
				// Fast exit (nothing to be done)
				//
				if (((double)(alpha) == (double)(0) || k == 0) && (double)(beta) == (double)(1))
				{
					return;
				}

				//
				// Try to call fast SYRK
				//
				if (ablasf.rmatrixsyrkf(n, k, alpha, a, ia, ja, optypea, beta, c, ic, jc, isupper))
				{
					return;
				}

				//
				// SYRK
				//
				if (optypea == 0)
				{

					//
					// C=alpha*A*A^H+beta*C
					//
					for (i = 0; i <= n - 1; i++)
					{
						if (isupper)
						{
							j1 = i;
							j2 = n - 1;
						}
						else
						{
							j1 = 0;
							j2 = i;
						}
						for (j = j1; j <= j2; j++)
						{
							if ((double)(alpha) != (double)(0) && k > 0)
							{
								v = 0.0f;
								for (i_ = ja; i_ <= ja + k - 1; i_++)
								{
									v += a[ia + i, i_] * a[ia + j, i_];
								}
							}
							else
							{
								v = 0;
							}
							if ((double)(beta) == (double)(0))
							{
								c[ic + i, jc + j] = alpha * v;
							}
							else
							{
								c[ic + i, jc + j] = beta * c[ic + i, jc + j] + alpha * v;
							}
						}
					}
					return;
				}
				else
				{

					//
					// C=alpha*A^H*A+beta*C
					//
					for (i = 0; i <= n - 1; i++)
					{
						if (isupper)
						{
							j1 = i;
							j2 = n - 1;
						}
						else
						{
							j1 = 0;
							j2 = i;
						}
						if ((double)(beta) == (double)(0))
						{
							for (j = j1; j <= j2; j++)
							{
								c[ic + i, jc + j] = 0;
							}
						}
						else
						{
							for (i_ = jc + j1; i_ <= jc + j2; i_++)
							{
								c[ic + i, i_] = beta * c[ic + i, i_];
							}
						}
					}
					for (i = 0; i <= k - 1; i++)
					{
						for (j = 0; j <= n - 1; j++)
						{
							if (isupper)
							{
								j1 = j;
								j2 = n - 1;
							}
							else
							{
								j1 = 0;
								j2 = j;
							}
							v = alpha * a[ia + i, ja + j];
							i1_ = (ja + j1) - (jc + j1);
							for (i_ = jc + j1; i_ <= jc + j2; i_++)
							{
								c[ic + j, i_] = c[ic + j, i_] + v * a[ia + i, i_ + i1_];
							}
						}
					}
					return;
				}
			}


		}
		public class ortfac
		{
			/*************************************************************************
			QR decomposition of a rectangular matrix of size MxN

			Input parameters:
					A   -   matrix A whose indexes range within [0..M-1, 0..N-1].
					M   -   number of rows in matrix A.
					N   -   number of columns in matrix A.

			Output parameters:
					A   -   matrices Q and R in compact form (see below).
					Tau -   array of scalar factors which are used to form
									matrix Q. Array whose index ranges within [0.. Min(M-1,N-1)].

			Matrix A is represented as A = QR, where Q is an orthogonal matrix of size
			MxM, R - upper triangular (or upper trapezoid) matrix of size M x N.

			The elements of matrix R are located on and above the main diagonal of
			matrix A. The elements which are located in Tau array and below the main
			diagonal of matrix A are used to form matrix Q as follows:

			Matrix Q is represented as a product of elementary reflections

			Q = H(0)*H(2)*...*H(k-1),

			where k = min(m,n), and each H(i) is in the form

			H(i) = 1 - tau * v * (v^T)

			where tau is a scalar stored in Tau[I]; v - real vector,
			so that v(0:i-1) = 0, v(i) = 1, v(i+1:m-1) stored in A(i+1:m-1,i).

				-- ALGLIB routine --
					 17.02.2010
					 Bochkanov Sergey
			*************************************************************************/
			public static void rmatrixqr(ref double[,] a,
					int m,
					int n,
					ref double[] tau)
			{
				double[] work = new double[0];
				double[] t = new double[0];
				double[] taubuf = new double[0];
				int minmn = 0;
				double[,] tmpa = new double[0, 0];
				double[,] tmpt = new double[0, 0];
				double[,] tmpr = new double[0, 0];
				int blockstart = 0;
				int blocksize = 0;
				int rowscount = 0;
				int i = 0;
				int i_ = 0;
				int i1_ = 0;

				tau = new double[0];

				if (m <= 0 || n <= 0)
				{
					return;
				}
				minmn = Math.Min(m, n);
				work = new double[Math.Max(m, n) + 1];
				t = new double[Math.Max(m, n) + 1];
				tau = new double[minmn];
				taubuf = new double[minmn];
				tmpa = new double[m, ablas.ablasblocksize(a)];
				tmpt = new double[ablas.ablasblocksize(a), 2 * ablas.ablasblocksize(a)];
				tmpr = new double[2 * ablas.ablasblocksize(a), n];

				//
				// Blocked code
				//
				blockstart = 0;
				while (blockstart != minmn)
				{

					//
					// Determine block size
					//
					blocksize = minmn - blockstart;
					if (blocksize > ablas.ablasblocksize(a))
					{
						blocksize = ablas.ablasblocksize(a);
					}
					rowscount = m - blockstart;

					//
					// QR decomposition of submatrix.
					// Matrix is copied to temporary storage to solve
					// some TLB issues arising from non-contiguous memory
					// access pattern.
					//
					ablas.rmatrixcopy(rowscount, blocksize, a, blockstart, blockstart, ref tmpa, 0, 0);
					rmatrixqrbasecase(ref tmpa, rowscount, blocksize, ref work, ref t, ref taubuf);
					ablas.rmatrixcopy(rowscount, blocksize, tmpa, 0, 0, ref a, blockstart, blockstart);
					i1_ = (0) - (blockstart);
					for (i_ = blockstart; i_ <= blockstart + blocksize - 1; i_++)
					{
						tau[i_] = taubuf[i_ + i1_];
					}

					//
					// Update the rest, choose between:
					// a) Level 2 algorithm (when the rest of the matrix is small enough)
					// b) blocked algorithm, see algorithm 5 from  'A storage efficient WY
					//    representation for products of Householder transformations',
					//    by R. Schreiber and C. Van Loan.
					//
					if (blockstart + blocksize <= n - 1)
					{
						if (n - blockstart - blocksize >= 2 * ablas.ablasblocksize(a) || rowscount >= 4 * ablas.ablasblocksize(a))
						{

							//
							// Prepare block reflector
							//
							rmatrixblockreflector(ref tmpa, ref taubuf, true, rowscount, blocksize, ref tmpt, ref work);

							//
							// Multiply the rest of A by Q'.
							//
							// Q  = E + Y*T*Y'  = E + TmpA*TmpT*TmpA'
							// Q' = E + Y*T'*Y' = E + TmpA*TmpT'*TmpA'
							//
							ablas.rmatrixgemm(blocksize, n - blockstart - blocksize, rowscount, 1.0f, tmpa, 0, 0, 1, a, blockstart, blockstart + blocksize, 0, 0.0f, tmpr, 0, 0);
							ablas.rmatrixgemm(blocksize, n - blockstart - blocksize, blocksize, 1.0f, tmpt, 0, 0, 1, tmpr, 0, 0, 0, 0.0f, tmpr, blocksize, 0);
							ablas.rmatrixgemm(rowscount, n - blockstart - blocksize, blocksize, 1.0f, tmpa, 0, 0, 0, tmpr, blocksize, 0, 0, 1.0f, a, blockstart, blockstart + blocksize);
						}
						else
						{

							//
							// Level 2 algorithm
							//
							for (i = 0; i <= blocksize - 1; i++)
							{
								i1_ = (i) - (1);
								for (i_ = 1; i_ <= rowscount - i; i_++)
								{
									t[i_] = tmpa[i_ + i1_, i];
								}
								t[1] = 1;
								reflections.applyreflectionfromtheleft(ref a, taubuf[i], t, blockstart + i, m - 1, blockstart + blocksize, n - 1, ref work);
							}
						}
					}

					//
					// Advance
					//
					blockstart = blockstart + blocksize;
				}
			}


			/*************************************************************************
			LQ decomposition of a rectangular matrix of size MxN

			Input parameters:
					A   -   matrix A whose indexes range within [0..M-1, 0..N-1].
					M   -   number of rows in matrix A.
					N   -   number of columns in matrix A.

			Output parameters:
					A   -   matrices L and Q in compact form (see below)
					Tau -   array of scalar factors which are used to form
									matrix Q. Array whose index ranges within [0..Min(M,N)-1].

			Matrix A is represented as A = LQ, where Q is an orthogonal matrix of size
			MxM, L - lower triangular (or lower trapezoid) matrix of size M x N.

			The elements of matrix L are located on and below  the  main  diagonal  of
			matrix A. The elements which are located in Tau array and above  the  main
			diagonal of matrix A are used to form matrix Q as follows:

			Matrix Q is represented as a product of elementary reflections

			Q = H(k-1)*H(k-2)*...*H(1)*H(0),

			where k = min(m,n), and each H(i) is of the form

			H(i) = 1 - tau * v * (v^T)

			where tau is a scalar stored in Tau[I]; v - real vector, so that v(0:i-1)=0,
			v(i) = 1, v(i+1:n-1) stored in A(i,i+1:n-1).

				-- ALGLIB routine --
					 17.02.2010
					 Bochkanov Sergey
			*************************************************************************/
			public static void rmatrixlq(ref double[,] a,
					int m,
					int n,
					ref double[] tau)
			{
				double[] work = new double[0];
				double[] t = new double[0];
				double[] taubuf = new double[0];
				int minmn = 0;
				double[,] tmpa = new double[0, 0];
				double[,] tmpt = new double[0, 0];
				double[,] tmpr = new double[0, 0];
				int blockstart = 0;
				int blocksize = 0;
				int columnscount = 0;
				int i = 0;
				int i_ = 0;
				int i1_ = 0;

				tau = new double[0];

				if (m <= 0 || n <= 0)
				{
					return;
				}
				minmn = Math.Min(m, n);
				work = new double[Math.Max(m, n) + 1];
				t = new double[Math.Max(m, n) + 1];
				tau = new double[minmn];
				taubuf = new double[minmn];
				tmpa = new double[ablas.ablasblocksize(a), n];
				tmpt = new double[ablas.ablasblocksize(a), 2 * ablas.ablasblocksize(a)];
				tmpr = new double[m, 2 * ablas.ablasblocksize(a)];

				//
				// Blocked code
				//
				blockstart = 0;
				while (blockstart != minmn)
				{

					//
					// Determine block size
					//
					blocksize = minmn - blockstart;
					if (blocksize > ablas.ablasblocksize(a))
					{
						blocksize = ablas.ablasblocksize(a);
					}
					columnscount = n - blockstart;

					//
					// LQ decomposition of submatrix.
					// Matrix is copied to temporary storage to solve
					// some TLB issues arising from non-contiguous memory
					// access pattern.
					//
					ablas.rmatrixcopy(blocksize, columnscount, a, blockstart, blockstart, ref tmpa, 0, 0);
					rmatrixlqbasecase(ref tmpa, blocksize, columnscount, ref work, ref t, ref taubuf);
					ablas.rmatrixcopy(blocksize, columnscount, tmpa, 0, 0, ref a, blockstart, blockstart);
					i1_ = (0) - (blockstart);
					for (i_ = blockstart; i_ <= blockstart + blocksize - 1; i_++)
					{
						tau[i_] = taubuf[i_ + i1_];
					}

					//
					// Update the rest, choose between:
					// a) Level 2 algorithm (when the rest of the matrix is small enough)
					// b) blocked algorithm, see algorithm 5 from  'A storage efficient WY
					//    representation for products of Householder transformations',
					//    by R. Schreiber and C. Van Loan.
					//
					if (blockstart + blocksize <= m - 1)
					{
						if (m - blockstart - blocksize >= 2 * ablas.ablasblocksize(a))
						{

							//
							// Prepare block reflector
							//
							rmatrixblockreflector(ref tmpa, ref taubuf, false, columnscount, blocksize, ref tmpt, ref work);

							//
							// Multiply the rest of A by Q.
							//
							// Q  = E + Y*T*Y'  = E + TmpA'*TmpT*TmpA
							//
							ablas.rmatrixgemm(m - blockstart - blocksize, blocksize, columnscount, 1.0f, a, blockstart + blocksize, blockstart, 0, tmpa, 0, 0, 1, 0.0f, tmpr, 0, 0);
							ablas.rmatrixgemm(m - blockstart - blocksize, blocksize, blocksize, 1.0f, tmpr, 0, 0, 0, tmpt, 0, 0, 0, 0.0f, tmpr, 0, blocksize);
							ablas.rmatrixgemm(m - blockstart - blocksize, columnscount, blocksize, 1.0f, tmpr, 0, blocksize, 0, tmpa, 0, 0, 0, 1.0f, a, blockstart + blocksize, blockstart);
						}
						else
						{

							//
							// Level 2 algorithm
							//
							for (i = 0; i <= blocksize - 1; i++)
							{
								i1_ = (i) - (1);
								for (i_ = 1; i_ <= columnscount - i; i_++)
								{
									t[i_] = tmpa[i, i_ + i1_];
								}
								t[1] = 1;
								reflections.applyreflectionfromtheright(ref a, taubuf[i], t, blockstart + blocksize, m - 1, blockstart + i, n - 1, ref work);
							}
						}
					}

					//
					// Advance
					//
					blockstart = blockstart + blocksize;
				}
			}


			/*************************************************************************
			QR decomposition of a rectangular complex matrix of size MxN

			Input parameters:
					A   -   matrix A whose indexes range within [0..M-1, 0..N-1]
					M   -   number of rows in matrix A.
					N   -   number of columns in matrix A.

			Output parameters:
					A   -   matrices Q and R in compact form
					Tau -   array of scalar factors which are used to form matrix Q. Array
									whose indexes range within [0.. Min(M,N)-1]

			Matrix A is represented as A = QR, where Q is an orthogonal matrix of size
			MxM, R - upper triangular (or upper trapezoid) matrix of size MxN.

				-- LAPACK routine (version 3.0) --
					 Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
					 Courant Institute, Argonne National Lab, and Rice University
					 September 30, 1994
			*************************************************************************/
			public static void cmatrixqr(ref complex[,] a,
					int m,
					int n,
					ref complex[] tau)
			{
				complex[] work = new complex[0];
				complex[] t = new complex[0];
				complex[] taubuf = new complex[0];
				int minmn = 0;
				complex[,] tmpa = new complex[0, 0];
				complex[,] tmpt = new complex[0, 0];
				complex[,] tmpr = new complex[0, 0];
				int blockstart = 0;
				int blocksize = 0;
				int rowscount = 0;
				int i = 0;
				int i_ = 0;
				int i1_ = 0;

				tau = new complex[0];

				if (m <= 0 || n <= 0)
				{
					return;
				}
				minmn = Math.Min(m, n);
				work = new complex[Math.Max(m, n) + 1];
				t = new complex[Math.Max(m, n) + 1];
				tau = new complex[minmn];
				taubuf = new complex[minmn];
				tmpa = new complex[m, ablas.ablascomplexblocksize(a)];
				tmpt = new complex[ablas.ablascomplexblocksize(a), ablas.ablascomplexblocksize(a)];
				tmpr = new complex[2 * ablas.ablascomplexblocksize(a), n];

				//
				// Blocked code
				//
				blockstart = 0;
				while (blockstart != minmn)
				{

					//
					// Determine block size
					//
					blocksize = minmn - blockstart;
					if (blocksize > ablas.ablascomplexblocksize(a))
					{
						blocksize = ablas.ablascomplexblocksize(a);
					}
					rowscount = m - blockstart;

					//
					// QR decomposition of submatrix.
					// Matrix is copied to temporary storage to solve
					// some TLB issues arising from non-contiguous memory
					// access pattern.
					//
					ablas.cmatrixcopy(rowscount, blocksize, a, blockstart, blockstart, ref tmpa, 0, 0);
					cmatrixqrbasecase(ref tmpa, rowscount, blocksize, ref work, ref t, ref taubuf);
					ablas.cmatrixcopy(rowscount, blocksize, tmpa, 0, 0, ref a, blockstart, blockstart);
					i1_ = (0) - (blockstart);
					for (i_ = blockstart; i_ <= blockstart + blocksize - 1; i_++)
					{
						tau[i_] = taubuf[i_ + i1_];
					}

					//
					// Update the rest, choose between:
					// a) Level 2 algorithm (when the rest of the matrix is small enough)
					// b) blocked algorithm, see algorithm 5 from  'A storage efficient WY
					//    representation for products of Householder transformations',
					//    by R. Schreiber and C. Van Loan.
					//
					if (blockstart + blocksize <= n - 1)
					{
						if (n - blockstart - blocksize >= 2 * ablas.ablascomplexblocksize(a))
						{

							//
							// Prepare block reflector
							//
							cmatrixblockreflector(ref tmpa, ref taubuf, true, rowscount, blocksize, ref tmpt, ref work);

							//
							// Multiply the rest of A by Q'.
							//
							// Q  = E + Y*T*Y'  = E + TmpA*TmpT*TmpA'
							// Q' = E + Y*T'*Y' = E + TmpA*TmpT'*TmpA'
							//
							ablas.cmatrixgemm(blocksize, n - blockstart - blocksize, rowscount, 1.0f, tmpa, 0, 0, 2, a, blockstart, blockstart + blocksize, 0, 0.0f, tmpr, 0, 0);
							ablas.cmatrixgemm(blocksize, n - blockstart - blocksize, blocksize, 1.0f, tmpt, 0, 0, 2, tmpr, 0, 0, 0, 0.0f, tmpr, blocksize, 0);
							ablas.cmatrixgemm(rowscount, n - blockstart - blocksize, blocksize, 1.0f, tmpa, 0, 0, 0, tmpr, blocksize, 0, 0, 1.0f, a, blockstart, blockstart + blocksize);
						}
						else
						{

							//
							// Level 2 algorithm
							//
							for (i = 0; i <= blocksize - 1; i++)
							{
								i1_ = (i) - (1);
								for (i_ = 1; i_ <= rowscount - i; i_++)
								{
									t[i_] = tmpa[i_ + i1_, i];
								}
								t[1] = 1;
								creflections.complexapplyreflectionfromtheleft(ref a, math.conj(taubuf[i]), t, blockstart + i, m - 1, blockstart + blocksize, n - 1, ref work);
							}
						}
					}

					//
					// Advance
					//
					blockstart = blockstart + blocksize;
				}
			}


			/*************************************************************************
			LQ decomposition of a rectangular complex matrix of size MxN

			Input parameters:
					A   -   matrix A whose indexes range within [0..M-1, 0..N-1]
					M   -   number of rows in matrix A.
					N   -   number of columns in matrix A.

			Output parameters:
					A   -   matrices Q and L in compact form
					Tau -   array of scalar factors which are used to form matrix Q. Array
									whose indexes range within [0.. Min(M,N)-1]

			Matrix A is represented as A = LQ, where Q is an orthogonal matrix of size
			MxM, L - lower triangular (or lower trapezoid) matrix of size MxN.

				-- LAPACK routine (version 3.0) --
					 Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
					 Courant Institute, Argonne National Lab, and Rice University
					 September 30, 1994
			*************************************************************************/
			public static void cmatrixlq(ref complex[,] a,
					int m,
					int n,
					ref complex[] tau)
			{
				complex[] work = new complex[0];
				complex[] t = new complex[0];
				complex[] taubuf = new complex[0];
				int minmn = 0;
				complex[,] tmpa = new complex[0, 0];
				complex[,] tmpt = new complex[0, 0];
				complex[,] tmpr = new complex[0, 0];
				int blockstart = 0;
				int blocksize = 0;
				int columnscount = 0;
				int i = 0;
				int i_ = 0;
				int i1_ = 0;

				tau = new complex[0];

				if (m <= 0 || n <= 0)
				{
					return;
				}
				minmn = Math.Min(m, n);
				work = new complex[Math.Max(m, n) + 1];
				t = new complex[Math.Max(m, n) + 1];
				tau = new complex[minmn];
				taubuf = new complex[minmn];
				tmpa = new complex[ablas.ablascomplexblocksize(a), n];
				tmpt = new complex[ablas.ablascomplexblocksize(a), ablas.ablascomplexblocksize(a)];
				tmpr = new complex[m, 2 * ablas.ablascomplexblocksize(a)];

				//
				// Blocked code
				//
				blockstart = 0;
				while (blockstart != minmn)
				{

					//
					// Determine block size
					//
					blocksize = minmn - blockstart;
					if (blocksize > ablas.ablascomplexblocksize(a))
					{
						blocksize = ablas.ablascomplexblocksize(a);
					}
					columnscount = n - blockstart;

					//
					// LQ decomposition of submatrix.
					// Matrix is copied to temporary storage to solve
					// some TLB issues arising from non-contiguous memory
					// access pattern.
					//
					ablas.cmatrixcopy(blocksize, columnscount, a, blockstart, blockstart, ref tmpa, 0, 0);
					cmatrixlqbasecase(ref tmpa, blocksize, columnscount, ref work, ref t, ref taubuf);
					ablas.cmatrixcopy(blocksize, columnscount, tmpa, 0, 0, ref a, blockstart, blockstart);
					i1_ = (0) - (blockstart);
					for (i_ = blockstart; i_ <= blockstart + blocksize - 1; i_++)
					{
						tau[i_] = taubuf[i_ + i1_];
					}

					//
					// Update the rest, choose between:
					// a) Level 2 algorithm (when the rest of the matrix is small enough)
					// b) blocked algorithm, see algorithm 5 from  'A storage efficient WY
					//    representation for products of Householder transformations',
					//    by R. Schreiber and C. Van Loan.
					//
					if (blockstart + blocksize <= m - 1)
					{
						if (m - blockstart - blocksize >= 2 * ablas.ablascomplexblocksize(a))
						{

							//
							// Prepare block reflector
							//
							cmatrixblockreflector(ref tmpa, ref taubuf, false, columnscount, blocksize, ref tmpt, ref work);

							//
							// Multiply the rest of A by Q.
							//
							// Q  = E + Y*T*Y'  = E + TmpA'*TmpT*TmpA
							//
							ablas.cmatrixgemm(m - blockstart - blocksize, blocksize, columnscount, 1.0f, a, blockstart + blocksize, blockstart, 0, tmpa, 0, 0, 2, 0.0f, tmpr, 0, 0);
							ablas.cmatrixgemm(m - blockstart - blocksize, blocksize, blocksize, 1.0f, tmpr, 0, 0, 0, tmpt, 0, 0, 0, 0.0f, tmpr, 0, blocksize);
							ablas.cmatrixgemm(m - blockstart - blocksize, columnscount, blocksize, 1.0f, tmpr, 0, blocksize, 0, tmpa, 0, 0, 0, 1.0f, a, blockstart + blocksize, blockstart);
						}
						else
						{

							//
							// Level 2 algorithm
							//
							for (i = 0; i <= blocksize - 1; i++)
							{
								i1_ = (i) - (1);
								for (i_ = 1; i_ <= columnscount - i; i_++)
								{
									t[i_] = math.conj(tmpa[i, i_ + i1_]);
								}
								t[1] = 1;
								creflections.complexapplyreflectionfromtheright(ref a, taubuf[i], ref t, blockstart + blocksize, m - 1, blockstart + i, n - 1, ref work);
							}
						}
					}

					//
					// Advance
					//
					blockstart = blockstart + blocksize;
				}
			}


			/*************************************************************************
			Partial unpacking of matrix Q from the QR decomposition of a matrix A

			Input parameters:
					A       -   matrices Q and R in compact form.
											Output of RMatrixQR subroutine.
					M       -   number of rows in given matrix A. M>=0.
					N       -   number of columns in given matrix A. N>=0.
					Tau     -   scalar factors which are used to form Q.
											Output of the RMatrixQR subroutine.
					QColumns -  required number of columns of matrix Q. M>=QColumns>=0.

			Output parameters:
					Q       -   first QColumns columns of matrix Q.
											Array whose indexes range within [0..M-1, 0..QColumns-1].
											If QColumns=0, the array remains unchanged.

				-- ALGLIB routine --
					 17.02.2010
					 Bochkanov Sergey
			*************************************************************************/
			public static void rmatrixqrunpackq(double[,] a,
					int m,
					int n,
					double[] tau,
					int qcolumns,
					ref double[,] q)
			{
				double[] work = new double[0];
				double[] t = new double[0];
				double[] taubuf = new double[0];
				int minmn = 0;
				int refcnt = 0;
				double[,] tmpa = new double[0, 0];
				double[,] tmpt = new double[0, 0];
				double[,] tmpr = new double[0, 0];
				int blockstart = 0;
				int blocksize = 0;
				int rowscount = 0;
				int i = 0;
				int j = 0;
				int i_ = 0;
				int i1_ = 0;

				q = new double[0, 0];

				alglib.ap.assert(qcolumns <= m, "UnpackQFromQR: QColumns>M!");
				if ((m <= 0 || n <= 0) || qcolumns <= 0)
				{
					return;
				}

				//
				// init
				//
				minmn = Math.Min(m, n);
				refcnt = Math.Min(minmn, qcolumns);
				q = new double[m, qcolumns];
				for (i = 0; i <= m - 1; i++)
				{
					for (j = 0; j <= qcolumns - 1; j++)
					{
						if (i == j)
						{
							q[i, j] = 1;
						}
						else
						{
							q[i, j] = 0;
						}
					}
				}
				work = new double[Math.Max(m, qcolumns) + 1];
				t = new double[Math.Max(m, qcolumns) + 1];
				taubuf = new double[minmn];
				tmpa = new double[m, ablas.ablasblocksize(a)];
				tmpt = new double[ablas.ablasblocksize(a), 2 * ablas.ablasblocksize(a)];
				tmpr = new double[2 * ablas.ablasblocksize(a), qcolumns];

				//
				// Blocked code
				//
				blockstart = ablas.ablasblocksize(a) * (refcnt / ablas.ablasblocksize(a));
				blocksize = refcnt - blockstart;
				while (blockstart >= 0)
				{
					rowscount = m - blockstart;
					if (blocksize > 0)
					{

						//
						// Copy current block
						//
						ablas.rmatrixcopy(rowscount, blocksize, a, blockstart, blockstart, ref tmpa, 0, 0);
						i1_ = (blockstart) - (0);
						for (i_ = 0; i_ <= blocksize - 1; i_++)
						{
							taubuf[i_] = tau[i_ + i1_];
						}

						//
						// Update, choose between:
						// a) Level 2 algorithm (when the rest of the matrix is small enough)
						// b) blocked algorithm, see algorithm 5 from  'A storage efficient WY
						//    representation for products of Householder transformations',
						//    by R. Schreiber and C. Van Loan.
						//
						if (qcolumns >= 2 * ablas.ablasblocksize(a))
						{

							//
							// Prepare block reflector
							//
							rmatrixblockreflector(ref tmpa, ref taubuf, true, rowscount, blocksize, ref tmpt, ref work);

							//
							// Multiply matrix by Q.
							//
							// Q  = E + Y*T*Y'  = E + TmpA*TmpT*TmpA'
							//
							ablas.rmatrixgemm(blocksize, qcolumns, rowscount, 1.0f, tmpa, 0, 0, 1, q, blockstart, 0, 0, 0.0f, tmpr, 0, 0);
							ablas.rmatrixgemm(blocksize, qcolumns, blocksize, 1.0f, tmpt, 0, 0, 0, tmpr, 0, 0, 0, 0.0f, tmpr, blocksize, 0);
							ablas.rmatrixgemm(rowscount, qcolumns, blocksize, 1.0f, tmpa, 0, 0, 0, tmpr, blocksize, 0, 0, 1.0f, q, blockstart, 0);
						}
						else
						{

							//
							// Level 2 algorithm
							//
							for (i = blocksize - 1; i >= 0; i--)
							{
								i1_ = (i) - (1);
								for (i_ = 1; i_ <= rowscount - i; i_++)
								{
									t[i_] = tmpa[i_ + i1_, i];
								}
								t[1] = 1;
								reflections.applyreflectionfromtheleft(ref q, taubuf[i], t, blockstart + i, m - 1, 0, qcolumns - 1, ref work);
							}
						}
					}

					//
					// Advance
					//
					blockstart = blockstart - ablas.ablasblocksize(a);
					blocksize = ablas.ablasblocksize(a);
				}
			}


			/*************************************************************************
			Unpacking of matrix R from the QR decomposition of a matrix A

			Input parameters:
					A       -   matrices Q and R in compact form.
											Output of RMatrixQR subroutine.
					M       -   number of rows in given matrix A. M>=0.
					N       -   number of columns in given matrix A. N>=0.

			Output parameters:
					R       -   matrix R, array[0..M-1, 0..N-1].

				-- ALGLIB routine --
					 17.02.2010
					 Bochkanov Sergey
			*************************************************************************/
			public static void rmatrixqrunpackr(double[,] a,
					int m,
					int n,
					ref double[,] r)
			{
				int i = 0;
				int k = 0;
				int i_ = 0;

				r = new double[0, 0];

				if (m <= 0 || n <= 0)
				{
					return;
				}
				k = Math.Min(m, n);
				r = new double[m, n];
				for (i = 0; i <= n - 1; i++)
				{
					r[0, i] = 0;
				}
				for (i = 1; i <= m - 1; i++)
				{
					for (i_ = 0; i_ <= n - 1; i_++)
					{
						r[i, i_] = r[0, i_];
					}
				}
				for (i = 0; i <= k - 1; i++)
				{
					for (i_ = i; i_ <= n - 1; i_++)
					{
						r[i, i_] = a[i, i_];
					}
				}
			}


			/*************************************************************************
			Partial unpacking of matrix Q from the LQ decomposition of a matrix A

			Input parameters:
					A       -   matrices L and Q in compact form.
											Output of RMatrixLQ subroutine.
					M       -   number of rows in given matrix A. M>=0.
					N       -   number of columns in given matrix A. N>=0.
					Tau     -   scalar factors which are used to form Q.
											Output of the RMatrixLQ subroutine.
					QRows   -   required number of rows in matrix Q. N>=QRows>=0.

			Output parameters:
					Q       -   first QRows rows of matrix Q. Array whose indexes range
											within [0..QRows-1, 0..N-1]. If QRows=0, the array remains
											unchanged.

				-- ALGLIB routine --
					 17.02.2010
					 Bochkanov Sergey
			*************************************************************************/
			public static void rmatrixlqunpackq(double[,] a,
					int m,
					int n,
					double[] tau,
					int qrows,
					ref double[,] q)
			{
				double[] work = new double[0];
				double[] t = new double[0];
				double[] taubuf = new double[0];
				int minmn = 0;
				int refcnt = 0;
				double[,] tmpa = new double[0, 0];
				double[,] tmpt = new double[0, 0];
				double[,] tmpr = new double[0, 0];
				int blockstart = 0;
				int blocksize = 0;
				int columnscount = 0;
				int i = 0;
				int j = 0;
				int i_ = 0;
				int i1_ = 0;

				q = new double[0, 0];

				alglib.ap.assert(qrows <= n, "RMatrixLQUnpackQ: QRows>N!");
				if ((m <= 0 || n <= 0) || qrows <= 0)
				{
					return;
				}

				//
				// init
				//
				minmn = Math.Min(m, n);
				refcnt = Math.Min(minmn, qrows);
				work = new double[Math.Max(m, n) + 1];
				t = new double[Math.Max(m, n) + 1];
				taubuf = new double[minmn];
				tmpa = new double[ablas.ablasblocksize(a), n];
				tmpt = new double[ablas.ablasblocksize(a), 2 * ablas.ablasblocksize(a)];
				tmpr = new double[qrows, 2 * ablas.ablasblocksize(a)];
				q = new double[qrows, n];
				for (i = 0; i <= qrows - 1; i++)
				{
					for (j = 0; j <= n - 1; j++)
					{
						if (i == j)
						{
							q[i, j] = 1;
						}
						else
						{
							q[i, j] = 0;
						}
					}
				}

				//
				// Blocked code
				//
				blockstart = ablas.ablasblocksize(a) * (refcnt / ablas.ablasblocksize(a));
				blocksize = refcnt - blockstart;
				while (blockstart >= 0)
				{
					columnscount = n - blockstart;
					if (blocksize > 0)
					{

						//
						// Copy submatrix
						//
						ablas.rmatrixcopy(blocksize, columnscount, a, blockstart, blockstart, ref tmpa, 0, 0);
						i1_ = (blockstart) - (0);
						for (i_ = 0; i_ <= blocksize - 1; i_++)
						{
							taubuf[i_] = tau[i_ + i1_];
						}

						//
						// Update matrix, choose between:
						// a) Level 2 algorithm (when the rest of the matrix is small enough)
						// b) blocked algorithm, see algorithm 5 from  'A storage efficient WY
						//    representation for products of Householder transformations',
						//    by R. Schreiber and C. Van Loan.
						//
						if (qrows >= 2 * ablas.ablasblocksize(a))
						{

							//
							// Prepare block reflector
							//
							rmatrixblockreflector(ref tmpa, ref taubuf, false, columnscount, blocksize, ref tmpt, ref work);

							//
							// Multiply the rest of A by Q'.
							//
							// Q'  = E + Y*T'*Y'  = E + TmpA'*TmpT'*TmpA
							//
							ablas.rmatrixgemm(qrows, blocksize, columnscount, 1.0f, q, 0, blockstart, 0, tmpa, 0, 0, 1, 0.0f, tmpr, 0, 0);
							ablas.rmatrixgemm(qrows, blocksize, blocksize, 1.0f, tmpr, 0, 0, 0, tmpt, 0, 0, 1, 0.0f, tmpr, 0, blocksize);
							ablas.rmatrixgemm(qrows, columnscount, blocksize, 1.0f, tmpr, 0, blocksize, 0, tmpa, 0, 0, 0, 1.0f, q, 0, blockstart);
						}
						else
						{

							//
							// Level 2 algorithm
							//
							for (i = blocksize - 1; i >= 0; i--)
							{
								i1_ = (i) - (1);
								for (i_ = 1; i_ <= columnscount - i; i_++)
								{
									t[i_] = tmpa[i, i_ + i1_];
								}
								t[1] = 1;
								reflections.applyreflectionfromtheright(ref q, taubuf[i], t, 0, qrows - 1, blockstart + i, n - 1, ref work);
							}
						}
					}

					//
					// Advance
					//
					blockstart = blockstart - ablas.ablasblocksize(a);
					blocksize = ablas.ablasblocksize(a);
				}
			}


			/*************************************************************************
			Unpacking of matrix L from the LQ decomposition of a matrix A

			Input parameters:
					A       -   matrices Q and L in compact form.
											Output of RMatrixLQ subroutine.
					M       -   number of rows in given matrix A. M>=0.
					N       -   number of columns in given matrix A. N>=0.

			Output parameters:
					L       -   matrix L, array[0..M-1, 0..N-1].

				-- ALGLIB routine --
					 17.02.2010
					 Bochkanov Sergey
			*************************************************************************/
			public static void rmatrixlqunpackl(double[,] a,
					int m,
					int n,
					ref double[,] l)
			{
				int i = 0;
				int k = 0;
				int i_ = 0;

				l = new double[0, 0];

				if (m <= 0 || n <= 0)
				{
					return;
				}
				l = new double[m, n];
				for (i = 0; i <= n - 1; i++)
				{
					l[0, i] = 0;
				}
				for (i = 1; i <= m - 1; i++)
				{
					for (i_ = 0; i_ <= n - 1; i_++)
					{
						l[i, i_] = l[0, i_];
					}
				}
				for (i = 0; i <= m - 1; i++)
				{
					k = Math.Min(i, n - 1);
					for (i_ = 0; i_ <= k; i_++)
					{
						l[i, i_] = a[i, i_];
					}
				}
			}


			/*************************************************************************
			Partial unpacking of matrix Q from QR decomposition of a complex matrix A.

			Input parameters:
					A           -   matrices Q and R in compact form.
													Output of CMatrixQR subroutine .
					M           -   number of rows in matrix A. M>=0.
					N           -   number of columns in matrix A. N>=0.
					Tau         -   scalar factors which are used to form Q.
													Output of CMatrixQR subroutine .
					QColumns    -   required number of columns in matrix Q. M>=QColumns>=0.

			Output parameters:
					Q           -   first QColumns columns of matrix Q.
													Array whose index ranges within [0..M-1, 0..QColumns-1].
													If QColumns=0, array isn't changed.

				-- ALGLIB routine --
					 17.02.2010
					 Bochkanov Sergey
			*************************************************************************/
			public static void cmatrixqrunpackq(complex[,] a,
					int m,
					int n,
					complex[] tau,
					int qcolumns,
					ref complex[,] q)
			{
				complex[] work = new complex[0];
				complex[] t = new complex[0];
				complex[] taubuf = new complex[0];
				int minmn = 0;
				int refcnt = 0;
				complex[,] tmpa = new complex[0, 0];
				complex[,] tmpt = new complex[0, 0];
				complex[,] tmpr = new complex[0, 0];
				int blockstart = 0;
				int blocksize = 0;
				int rowscount = 0;
				int i = 0;
				int j = 0;
				int i_ = 0;
				int i1_ = 0;

				q = new complex[0, 0];

				alglib.ap.assert(qcolumns <= m, "UnpackQFromQR: QColumns>M!");
				if (m <= 0 || n <= 0)
				{
					return;
				}

				//
				// init
				//
				minmn = Math.Min(m, n);
				refcnt = Math.Min(minmn, qcolumns);
				work = new complex[Math.Max(m, n) + 1];
				t = new complex[Math.Max(m, n) + 1];
				taubuf = new complex[minmn];
				tmpa = new complex[m, ablas.ablascomplexblocksize(a)];
				tmpt = new complex[ablas.ablascomplexblocksize(a), ablas.ablascomplexblocksize(a)];
				tmpr = new complex[2 * ablas.ablascomplexblocksize(a), qcolumns];
				q = new complex[m, qcolumns];
				for (i = 0; i <= m - 1; i++)
				{
					for (j = 0; j <= qcolumns - 1; j++)
					{
						if (i == j)
						{
							q[i, j] = 1;
						}
						else
						{
							q[i, j] = 0;
						}
					}
				}

				//
				// Blocked code
				//
				blockstart = ablas.ablascomplexblocksize(a) * (refcnt / ablas.ablascomplexblocksize(a));
				blocksize = refcnt - blockstart;
				while (blockstart >= 0)
				{
					rowscount = m - blockstart;
					if (blocksize > 0)
					{

						//
						// QR decomposition of submatrix.
						// Matrix is copied to temporary storage to solve
						// some TLB issues arising from non-contiguous memory
						// access pattern.
						//
						ablas.cmatrixcopy(rowscount, blocksize, a, blockstart, blockstart, ref tmpa, 0, 0);
						i1_ = (blockstart) - (0);
						for (i_ = 0; i_ <= blocksize - 1; i_++)
						{
							taubuf[i_] = tau[i_ + i1_];
						}

						//
						// Update matrix, choose between:
						// a) Level 2 algorithm (when the rest of the matrix is small enough)
						// b) blocked algorithm, see algorithm 5 from  'A storage efficient WY
						//    representation for products of Householder transformations',
						//    by R. Schreiber and C. Van Loan.
						//
						if (qcolumns >= 2 * ablas.ablascomplexblocksize(a))
						{

							//
							// Prepare block reflector
							//
							cmatrixblockreflector(ref tmpa, ref taubuf, true, rowscount, blocksize, ref tmpt, ref work);

							//
							// Multiply the rest of A by Q.
							//
							// Q  = E + Y*T*Y'  = E + TmpA*TmpT*TmpA'
							//
							ablas.cmatrixgemm(blocksize, qcolumns, rowscount, 1.0f, tmpa, 0, 0, 2, q, blockstart, 0, 0, 0.0f, tmpr, 0, 0);
							ablas.cmatrixgemm(blocksize, qcolumns, blocksize, 1.0f, tmpt, 0, 0, 0, tmpr, 0, 0, 0, 0.0f, tmpr, blocksize, 0);
							ablas.cmatrixgemm(rowscount, qcolumns, blocksize, 1.0f, tmpa, 0, 0, 0, tmpr, blocksize, 0, 0, 1.0f, q, blockstart, 0);
						}
						else
						{

							//
							// Level 2 algorithm
							//
							for (i = blocksize - 1; i >= 0; i--)
							{
								i1_ = (i) - (1);
								for (i_ = 1; i_ <= rowscount - i; i_++)
								{
									t[i_] = tmpa[i_ + i1_, i];
								}
								t[1] = 1;
								creflections.complexapplyreflectionfromtheleft(ref q, taubuf[i], t, blockstart + i, m - 1, 0, qcolumns - 1, ref work);
							}
						}
					}

					//
					// Advance
					//
					blockstart = blockstart - ablas.ablascomplexblocksize(a);
					blocksize = ablas.ablascomplexblocksize(a);
				}
			}


			/*************************************************************************
			Unpacking of matrix R from the QR decomposition of a matrix A

			Input parameters:
					A       -   matrices Q and R in compact form.
											Output of CMatrixQR subroutine.
					M       -   number of rows in given matrix A. M>=0.
					N       -   number of columns in given matrix A. N>=0.

			Output parameters:
					R       -   matrix R, array[0..M-1, 0..N-1].

				-- ALGLIB routine --
					 17.02.2010
					 Bochkanov Sergey
			*************************************************************************/
			public static void cmatrixqrunpackr(complex[,] a,
					int m,
					int n,
					ref complex[,] r)
			{
				int i = 0;
				int k = 0;
				int i_ = 0;

				r = new complex[0, 0];

				if (m <= 0 || n <= 0)
				{
					return;
				}
				k = Math.Min(m, n);
				r = new complex[m, n];
				for (i = 0; i <= n - 1; i++)
				{
					r[0, i] = 0;
				}
				for (i = 1; i <= m - 1; i++)
				{
					for (i_ = 0; i_ <= n - 1; i_++)
					{
						r[i, i_] = r[0, i_];
					}
				}
				for (i = 0; i <= k - 1; i++)
				{
					for (i_ = i; i_ <= n - 1; i_++)
					{
						r[i, i_] = a[i, i_];
					}
				}
			}


			/*************************************************************************
			Partial unpacking of matrix Q from LQ decomposition of a complex matrix A.

			Input parameters:
					A           -   matrices Q and R in compact form.
													Output of CMatrixLQ subroutine .
					M           -   number of rows in matrix A. M>=0.
					N           -   number of columns in matrix A. N>=0.
					Tau         -   scalar factors which are used to form Q.
													Output of CMatrixLQ subroutine .
					QRows       -   required number of rows in matrix Q. N>=QColumns>=0.

			Output parameters:
					Q           -   first QRows rows of matrix Q.
													Array whose index ranges within [0..QRows-1, 0..N-1].
													If QRows=0, array isn't changed.

				-- ALGLIB routine --
					 17.02.2010
					 Bochkanov Sergey
			*************************************************************************/
			public static void cmatrixlqunpackq(complex[,] a,
					int m,
					int n,
					complex[] tau,
					int qrows,
					ref complex[,] q)
			{
				complex[] work = new complex[0];
				complex[] t = new complex[0];
				complex[] taubuf = new complex[0];
				int minmn = 0;
				int refcnt = 0;
				complex[,] tmpa = new complex[0, 0];
				complex[,] tmpt = new complex[0, 0];
				complex[,] tmpr = new complex[0, 0];
				int blockstart = 0;
				int blocksize = 0;
				int columnscount = 0;
				int i = 0;
				int j = 0;
				int i_ = 0;
				int i1_ = 0;

				q = new complex[0, 0];

				if (m <= 0 || n <= 0)
				{
					return;
				}

				//
				// Init
				//
				minmn = Math.Min(m, n);
				refcnt = Math.Min(minmn, qrows);
				work = new complex[Math.Max(m, n) + 1];
				t = new complex[Math.Max(m, n) + 1];
				taubuf = new complex[minmn];
				tmpa = new complex[ablas.ablascomplexblocksize(a), n];
				tmpt = new complex[ablas.ablascomplexblocksize(a), ablas.ablascomplexblocksize(a)];
				tmpr = new complex[qrows, 2 * ablas.ablascomplexblocksize(a)];
				q = new complex[qrows, n];
				for (i = 0; i <= qrows - 1; i++)
				{
					for (j = 0; j <= n - 1; j++)
					{
						if (i == j)
						{
							q[i, j] = 1;
						}
						else
						{
							q[i, j] = 0;
						}
					}
				}

				//
				// Blocked code
				//
				blockstart = ablas.ablascomplexblocksize(a) * (refcnt / ablas.ablascomplexblocksize(a));
				blocksize = refcnt - blockstart;
				while (blockstart >= 0)
				{
					columnscount = n - blockstart;
					if (blocksize > 0)
					{

						//
						// LQ decomposition of submatrix.
						// Matrix is copied to temporary storage to solve
						// some TLB issues arising from non-contiguous memory
						// access pattern.
						//
						ablas.cmatrixcopy(blocksize, columnscount, a, blockstart, blockstart, ref tmpa, 0, 0);
						i1_ = (blockstart) - (0);
						for (i_ = 0; i_ <= blocksize - 1; i_++)
						{
							taubuf[i_] = tau[i_ + i1_];
						}

						//
						// Update matrix, choose between:
						// a) Level 2 algorithm (when the rest of the matrix is small enough)
						// b) blocked algorithm, see algorithm 5 from  'A storage efficient WY
						//    representation for products of Householder transformations',
						//    by R. Schreiber and C. Van Loan.
						//
						if (qrows >= 2 * ablas.ablascomplexblocksize(a))
						{

							//
							// Prepare block reflector
							//
							cmatrixblockreflector(ref tmpa, ref taubuf, false, columnscount, blocksize, ref tmpt, ref work);

							//
							// Multiply the rest of A by Q'.
							//
							// Q'  = E + Y*T'*Y'  = E + TmpA'*TmpT'*TmpA
							//
							ablas.cmatrixgemm(qrows, blocksize, columnscount, 1.0f, q, 0, blockstart, 0, tmpa, 0, 0, 2, 0.0f, tmpr, 0, 0);
							ablas.cmatrixgemm(qrows, blocksize, blocksize, 1.0f, tmpr, 0, 0, 0, tmpt, 0, 0, 2, 0.0f, tmpr, 0, blocksize);
							ablas.cmatrixgemm(qrows, columnscount, blocksize, 1.0f, tmpr, 0, blocksize, 0, tmpa, 0, 0, 0, 1.0f, q, 0, blockstart);
						}
						else
						{

							//
							// Level 2 algorithm
							//
							for (i = blocksize - 1; i >= 0; i--)
							{
								i1_ = (i) - (1);
								for (i_ = 1; i_ <= columnscount - i; i_++)
								{
									t[i_] = math.conj(tmpa[i, i_ + i1_]);
								}
								t[1] = 1;
								creflections.complexapplyreflectionfromtheright(ref q, math.conj(taubuf[i]), ref t, 0, qrows - 1, blockstart + i, n - 1, ref work);
							}
						}
					}

					//
					// Advance
					//
					blockstart = blockstart - ablas.ablascomplexblocksize(a);
					blocksize = ablas.ablascomplexblocksize(a);
				}
			}


			/*************************************************************************
			Unpacking of matrix L from the LQ decomposition of a matrix A

			Input parameters:
					A       -   matrices Q and L in compact form.
											Output of CMatrixLQ subroutine.
					M       -   number of rows in given matrix A. M>=0.
					N       -   number of columns in given matrix A. N>=0.

			Output parameters:
					L       -   matrix L, array[0..M-1, 0..N-1].

				-- ALGLIB routine --
					 17.02.2010
					 Bochkanov Sergey
			*************************************************************************/
			public static void cmatrixlqunpackl(complex[,] a,
					int m,
					int n,
					ref complex[,] l)
			{
				int i = 0;
				int k = 0;
				int i_ = 0;

				l = new complex[0, 0];

				if (m <= 0 || n <= 0)
				{
					return;
				}
				l = new complex[m, n];
				for (i = 0; i <= n - 1; i++)
				{
					l[0, i] = 0;
				}
				for (i = 1; i <= m - 1; i++)
				{
					for (i_ = 0; i_ <= n - 1; i_++)
					{
						l[i, i_] = l[0, i_];
					}
				}
				for (i = 0; i <= m - 1; i++)
				{
					k = Math.Min(i, n - 1);
					for (i_ = 0; i_ <= k; i_++)
					{
						l[i, i_] = a[i, i_];
					}
				}
			}


			/*************************************************************************
			Base case for real QR

				-- LAPACK routine (version 3.0) --
					 Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
					 Courant Institute, Argonne National Lab, and Rice University
					 September 30, 1994.
					 Sergey Bochkanov, ALGLIB project, translation from FORTRAN to
					 pseudocode, 2007-2010.
			*************************************************************************/
			public static void rmatrixqrbasecase(ref double[,] a,
					int m,
					int n,
					ref double[] work,
					ref double[] t,
					ref double[] tau)
			{
				int i = 0;
				int k = 0;
				int minmn = 0;
				double tmp = 0;
				int i_ = 0;
				int i1_ = 0;

				minmn = Math.Min(m, n);

				//
				// Test the input arguments
				//
				k = minmn;
				for (i = 0; i <= k - 1; i++)
				{

					//
					// Generate elementary reflector H(i) to annihilate A(i+1:m,i)
					//
					i1_ = (i) - (1);
					for (i_ = 1; i_ <= m - i; i_++)
					{
						t[i_] = a[i_ + i1_, i];
					}
					reflections.generatereflection(ref t, m - i, ref tmp);
					tau[i] = tmp;
					i1_ = (1) - (i);
					for (i_ = i; i_ <= m - 1; i_++)
					{
						a[i_, i] = t[i_ + i1_];
					}
					t[1] = 1;
					if (i < n)
					{

						//
						// Apply H(i) to A(i:m-1,i+1:n-1) from the left
						//
						reflections.applyreflectionfromtheleft(ref a, tau[i], t, i, m - 1, i + 1, n - 1, ref work);
					}
				}
			}


			/*************************************************************************
			Base case for real LQ

				-- LAPACK routine (version 3.0) --
					 Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
					 Courant Institute, Argonne National Lab, and Rice University
					 September 30, 1994.
					 Sergey Bochkanov, ALGLIB project, translation from FORTRAN to
					 pseudocode, 2007-2010.
			*************************************************************************/
			public static void rmatrixlqbasecase(ref double[,] a,
					int m,
					int n,
					ref double[] work,
					ref double[] t,
					ref double[] tau)
			{
				int i = 0;
				int k = 0;
				double tmp = 0;
				int i_ = 0;
				int i1_ = 0;

				k = Math.Min(m, n);
				for (i = 0; i <= k - 1; i++)
				{

					//
					// Generate elementary reflector H(i) to annihilate A(i,i+1:n-1)
					//
					i1_ = (i) - (1);
					for (i_ = 1; i_ <= n - i; i_++)
					{
						t[i_] = a[i, i_ + i1_];
					}
					reflections.generatereflection(ref t, n - i, ref tmp);
					tau[i] = tmp;
					i1_ = (1) - (i);
					for (i_ = i; i_ <= n - 1; i_++)
					{
						a[i, i_] = t[i_ + i1_];
					}
					t[1] = 1;
					if (i < n)
					{

						//
						// Apply H(i) to A(i+1:m,i:n) from the right
						//
						reflections.applyreflectionfromtheright(ref a, tau[i], t, i + 1, m - 1, i, n - 1, ref work);
					}
				}
			}


			/*************************************************************************
			Reduction of a rectangular matrix to  bidiagonal form

			The algorithm reduces the rectangular matrix A to  bidiagonal form by
			orthogonal transformations P and Q: A = Q*B*P.

			Input parameters:
					A       -   source matrix. array[0..M-1, 0..N-1]
					M       -   number of rows in matrix A.
					N       -   number of columns in matrix A.

			Output parameters:
					A       -   matrices Q, B, P in compact form (see below).
					TauQ    -   scalar factors which are used to form matrix Q.
					TauP    -   scalar factors which are used to form matrix P.

			The main diagonal and one of the  secondary  diagonals  of  matrix  A  are
			replaced with bidiagonal  matrix  B.  Other  elements  contain  elementary
			reflections which form MxM matrix Q and NxN matrix P, respectively.

			If M>=N, B is the upper  bidiagonal  MxN  matrix  and  is  stored  in  the
			corresponding  elements  of  matrix  A.  Matrix  Q  is  represented  as  a
			product   of   elementary   reflections   Q = H(0)*H(1)*...*H(n-1),  where
			H(i) = 1-tau*v*v'. Here tau is a scalar which is stored  in  TauQ[i],  and
			vector v has the following  structure:  v(0:i-1)=0, v(i)=1, v(i+1:m-1)  is
			stored   in   elements   A(i+1:m-1,i).   Matrix   P  is  as  follows:  P =
			G(0)*G(1)*...*G(n-2), where G(i) = 1 - tau*u*u'. Tau is stored in TauP[i],
			u(0:i)=0, u(i+1)=1, u(i+2:n-1) is stored in elements A(i,i+2:n-1).

			If M<N, B is the  lower  bidiagonal  MxN  matrix  and  is  stored  in  the
			corresponding   elements  of  matrix  A.  Q = H(0)*H(1)*...*H(m-2),  where
			H(i) = 1 - tau*v*v', tau is stored in TauQ, v(0:i)=0, v(i+1)=1, v(i+2:m-1)
			is    stored    in   elements   A(i+2:m-1,i).    P = G(0)*G(1)*...*G(m-1),
			G(i) = 1-tau*u*u', tau is stored in  TauP,  u(0:i-1)=0, u(i)=1, u(i+1:n-1)
			is stored in A(i,i+1:n-1).

			EXAMPLE:

			m=6, n=5 (m > n):               m=5, n=6 (m < n):

			(  d   e   u1  u1  u1 )         (  d   u1  u1  u1  u1  u1 )
			(  v1  d   e   u2  u2 )         (  e   d   u2  u2  u2  u2 )
			(  v1  v2  d   e   u3 )         (  v1  e   d   u3  u3  u3 )
			(  v1  v2  v3  d   e  )         (  v1  v2  e   d   u4  u4 )
			(  v1  v2  v3  v4  d  )         (  v1  v2  v3  e   d   u5 )
			(  v1  v2  v3  v4  v5 )

			Here vi and ui are vectors which form H(i) and G(i), and d and e -
			are the diagonal and off-diagonal elements of matrix B.

				-- LAPACK routine (version 3.0) --
					 Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
					 Courant Institute, Argonne National Lab, and Rice University
					 September 30, 1994.
					 Sergey Bochkanov, ALGLIB project, translation from FORTRAN to
					 pseudocode, 2007-2010.
			*************************************************************************/
			public static void rmatrixbd(ref double[,] a,
					int m,
					int n,
					ref double[] tauq,
					ref double[] taup)
			{
				double[] work = new double[0];
				double[] t = new double[0];
				int maxmn = 0;
				int i = 0;
				double ltau = 0;
				int i_ = 0;
				int i1_ = 0;

				tauq = new double[0];
				taup = new double[0];


				//
				// Prepare
				//
				if (n <= 0 || m <= 0)
				{
					return;
				}
				maxmn = Math.Max(m, n);
				work = new double[maxmn + 1];
				t = new double[maxmn + 1];
				if (m >= n)
				{
					tauq = new double[n];
					taup = new double[n];
				}
				else
				{
					tauq = new double[m];
					taup = new double[m];
				}
				if (m >= n)
				{

					//
					// Reduce to upper bidiagonal form
					//
					for (i = 0; i <= n - 1; i++)
					{

						//
						// Generate elementary reflector H(i) to annihilate A(i+1:m-1,i)
						//
						i1_ = (i) - (1);
						for (i_ = 1; i_ <= m - i; i_++)
						{
							t[i_] = a[i_ + i1_, i];
						}
						reflections.generatereflection(ref t, m - i, ref ltau);
						tauq[i] = ltau;
						i1_ = (1) - (i);
						for (i_ = i; i_ <= m - 1; i_++)
						{
							a[i_, i] = t[i_ + i1_];
						}
						t[1] = 1;

						//
						// Apply H(i) to A(i:m-1,i+1:n-1) from the left
						//
						reflections.applyreflectionfromtheleft(ref a, ltau, t, i, m - 1, i + 1, n - 1, ref work);
						if (i < n - 1)
						{

							//
							// Generate elementary reflector G(i) to annihilate
							// A(i,i+2:n-1)
							//
							i1_ = (i + 1) - (1);
							for (i_ = 1; i_ <= n - i - 1; i_++)
							{
								t[i_] = a[i, i_ + i1_];
							}
							reflections.generatereflection(ref t, n - 1 - i, ref ltau);
							taup[i] = ltau;
							i1_ = (1) - (i + 1);
							for (i_ = i + 1; i_ <= n - 1; i_++)
							{
								a[i, i_] = t[i_ + i1_];
							}
							t[1] = 1;

							//
							// Apply G(i) to A(i+1:m-1,i+1:n-1) from the right
							//
							reflections.applyreflectionfromtheright(ref a, ltau, t, i + 1, m - 1, i + 1, n - 1, ref work);
						}
						else
						{
							taup[i] = 0;
						}
					}
				}
				else
				{

					//
					// Reduce to lower bidiagonal form
					//
					for (i = 0; i <= m - 1; i++)
					{

						//
						// Generate elementary reflector G(i) to annihilate A(i,i+1:n-1)
						//
						i1_ = (i) - (1);
						for (i_ = 1; i_ <= n - i; i_++)
						{
							t[i_] = a[i, i_ + i1_];
						}
						reflections.generatereflection(ref t, n - i, ref ltau);
						taup[i] = ltau;
						i1_ = (1) - (i);
						for (i_ = i; i_ <= n - 1; i_++)
						{
							a[i, i_] = t[i_ + i1_];
						}
						t[1] = 1;

						//
						// Apply G(i) to A(i+1:m-1,i:n-1) from the right
						//
						reflections.applyreflectionfromtheright(ref a, ltau, t, i + 1, m - 1, i, n - 1, ref work);
						if (i < m - 1)
						{

							//
							// Generate elementary reflector H(i) to annihilate
							// A(i+2:m-1,i)
							//
							i1_ = (i + 1) - (1);
							for (i_ = 1; i_ <= m - 1 - i; i_++)
							{
								t[i_] = a[i_ + i1_, i];
							}
							reflections.generatereflection(ref t, m - 1 - i, ref ltau);
							tauq[i] = ltau;
							i1_ = (1) - (i + 1);
							for (i_ = i + 1; i_ <= m - 1; i_++)
							{
								a[i_, i] = t[i_ + i1_];
							}
							t[1] = 1;

							//
							// Apply H(i) to A(i+1:m-1,i+1:n-1) from the left
							//
							reflections.applyreflectionfromtheleft(ref a, ltau, t, i + 1, m - 1, i + 1, n - 1, ref work);
						}
						else
						{
							tauq[i] = 0;
						}
					}
				}
			}


			/*************************************************************************
			Unpacking matrix Q which reduces a matrix to bidiagonal form.

			Input parameters:
					QP          -   matrices Q and P in compact form.
													Output of ToBidiagonal subroutine.
					M           -   number of rows in matrix A.
					N           -   number of columns in matrix A.
					TAUQ        -   scalar factors which are used to form Q.
													Output of ToBidiagonal subroutine.
					QColumns    -   required number of columns in matrix Q.
													M>=QColumns>=0.

			Output parameters:
					Q           -   first QColumns columns of matrix Q.
													Array[0..M-1, 0..QColumns-1]
													If QColumns=0, the array is not modified.

				-- ALGLIB --
					 2005-2010
					 Bochkanov Sergey
			*************************************************************************/
			public static void rmatrixbdunpackq(double[,] qp,
					int m,
					int n,
					double[] tauq,
					int qcolumns,
					ref double[,] q)
			{
				int i = 0;
				int j = 0;

				q = new double[0, 0];

				alglib.ap.assert(qcolumns <= m, "RMatrixBDUnpackQ: QColumns>M!");
				alglib.ap.assert(qcolumns >= 0, "RMatrixBDUnpackQ: QColumns<0!");
				if ((m == 0 || n == 0) || qcolumns == 0)
				{
					return;
				}

				//
				// prepare Q
				//
				q = new double[m, qcolumns];
				for (i = 0; i <= m - 1; i++)
				{
					for (j = 0; j <= qcolumns - 1; j++)
					{
						if (i == j)
						{
							q[i, j] = 1;
						}
						else
						{
							q[i, j] = 0;
						}
					}
				}

				//
				// Calculate
				//
				rmatrixbdmultiplybyq(qp, m, n, tauq, ref q, m, qcolumns, false, false);
			}


			/*************************************************************************
			Multiplication by matrix Q which reduces matrix A to  bidiagonal form.

			The algorithm allows pre- or post-multiply by Q or Q'.

			Input parameters:
					QP          -   matrices Q and P in compact form.
													Output of ToBidiagonal subroutine.
					M           -   number of rows in matrix A.
					N           -   number of columns in matrix A.
					TAUQ        -   scalar factors which are used to form Q.
													Output of ToBidiagonal subroutine.
					Z           -   multiplied matrix.
													array[0..ZRows-1,0..ZColumns-1]
					ZRows       -   number of rows in matrix Z. If FromTheRight=False,
													ZRows=M, otherwise ZRows can be arbitrary.
					ZColumns    -   number of columns in matrix Z. If FromTheRight=True,
													ZColumns=M, otherwise ZColumns can be arbitrary.
					FromTheRight -  pre- or post-multiply.
					DoTranspose -   multiply by Q or Q'.

			Output parameters:
					Z           -   product of Z and Q.
													Array[0..ZRows-1,0..ZColumns-1]
													If ZRows=0 or ZColumns=0, the array is not modified.

				-- ALGLIB --
					 2005-2010
					 Bochkanov Sergey
			*************************************************************************/
			public static void rmatrixbdmultiplybyq(double[,] qp,
					int m,
					int n,
					double[] tauq,
					ref double[,] z,
					int zrows,
					int zcolumns,
					bool fromtheright,
					bool dotranspose)
			{
				int i = 0;
				int i1 = 0;
				int i2 = 0;
				int istep = 0;
				double[] v = new double[0];
				double[] work = new double[0];
				int mx = 0;
				int i_ = 0;
				int i1_ = 0;

				if (((m <= 0 || n <= 0) || zrows <= 0) || zcolumns <= 0)
				{
					return;
				}
				alglib.ap.assert((fromtheright && zcolumns == m) || (!fromtheright && zrows == m), "RMatrixBDMultiplyByQ: incorrect Z size!");

				//
				// init
				//
				mx = Math.Max(m, n);
				mx = Math.Max(mx, zrows);
				mx = Math.Max(mx, zcolumns);
				v = new double[mx + 1];
				work = new double[mx + 1];
				if (m >= n)
				{

					//
					// setup
					//
					if (fromtheright)
					{
						i1 = 0;
						i2 = n - 1;
						istep = 1;
					}
					else
					{
						i1 = n - 1;
						i2 = 0;
						istep = -1;
					}
					if (dotranspose)
					{
						i = i1;
						i1 = i2;
						i2 = i;
						istep = -istep;
					}

					//
					// Process
					//
					i = i1;
					do
					{
						i1_ = (i) - (1);
						for (i_ = 1; i_ <= m - i; i_++)
						{
							v[i_] = qp[i_ + i1_, i];
						}
						v[1] = 1;
						if (fromtheright)
						{
							reflections.applyreflectionfromtheright(ref z, tauq[i], v, 0, zrows - 1, i, m - 1, ref work);
						}
						else
						{
							reflections.applyreflectionfromtheleft(ref z, tauq[i], v, i, m - 1, 0, zcolumns - 1, ref work);
						}
						i = i + istep;
					}
					while (i != i2 + istep);
				}
				else
				{

					//
					// setup
					//
					if (fromtheright)
					{
						i1 = 0;
						i2 = m - 2;
						istep = 1;
					}
					else
					{
						i1 = m - 2;
						i2 = 0;
						istep = -1;
					}
					if (dotranspose)
					{
						i = i1;
						i1 = i2;
						i2 = i;
						istep = -istep;
					}

					//
					// Process
					//
					if (m - 1 > 0)
					{
						i = i1;
						do
						{
							i1_ = (i + 1) - (1);
							for (i_ = 1; i_ <= m - i - 1; i_++)
							{
								v[i_] = qp[i_ + i1_, i];
							}
							v[1] = 1;
							if (fromtheright)
							{
								reflections.applyreflectionfromtheright(ref z, tauq[i], v, 0, zrows - 1, i + 1, m - 1, ref work);
							}
							else
							{
								reflections.applyreflectionfromtheleft(ref z, tauq[i], v, i + 1, m - 1, 0, zcolumns - 1, ref work);
							}
							i = i + istep;
						}
						while (i != i2 + istep);
					}
				}
			}


			/*************************************************************************
			Unpacking matrix P which reduces matrix A to bidiagonal form.
			The subroutine returns transposed matrix P.

			Input parameters:
					QP      -   matrices Q and P in compact form.
											Output of ToBidiagonal subroutine.
					M       -   number of rows in matrix A.
					N       -   number of columns in matrix A.
					TAUP    -   scalar factors which are used to form P.
											Output of ToBidiagonal subroutine.
					PTRows  -   required number of rows of matrix P^T. N >= PTRows >= 0.

			Output parameters:
					PT      -   first PTRows columns of matrix P^T
											Array[0..PTRows-1, 0..N-1]
											If PTRows=0, the array is not modified.

				-- ALGLIB --
					 2005-2010
					 Bochkanov Sergey
			*************************************************************************/
			public static void rmatrixbdunpackpt(double[,] qp,
					int m,
					int n,
					double[] taup,
					int ptrows,
					ref double[,] pt)
			{
				int i = 0;
				int j = 0;

				pt = new double[0, 0];

				alglib.ap.assert(ptrows <= n, "RMatrixBDUnpackPT: PTRows>N!");
				alglib.ap.assert(ptrows >= 0, "RMatrixBDUnpackPT: PTRows<0!");
				if ((m == 0 || n == 0) || ptrows == 0)
				{
					return;
				}

				//
				// prepare PT
				//
				pt = new double[ptrows, n];
				for (i = 0; i <= ptrows - 1; i++)
				{
					for (j = 0; j <= n - 1; j++)
					{
						if (i == j)
						{
							pt[i, j] = 1;
						}
						else
						{
							pt[i, j] = 0;
						}
					}
				}

				//
				// Calculate
				//
				rmatrixbdmultiplybyp(qp, m, n, taup, ref pt, ptrows, n, true, true);
			}


			/*************************************************************************
			Multiplication by matrix P which reduces matrix A to  bidiagonal form.

			The algorithm allows pre- or post-multiply by P or P'.

			Input parameters:
					QP          -   matrices Q and P in compact form.
													Output of RMatrixBD subroutine.
					M           -   number of rows in matrix A.
					N           -   number of columns in matrix A.
					TAUP        -   scalar factors which are used to form P.
													Output of RMatrixBD subroutine.
					Z           -   multiplied matrix.
													Array whose indexes range within [0..ZRows-1,0..ZColumns-1].
					ZRows       -   number of rows in matrix Z. If FromTheRight=False,
													ZRows=N, otherwise ZRows can be arbitrary.
					ZColumns    -   number of columns in matrix Z. If FromTheRight=True,
													ZColumns=N, otherwise ZColumns can be arbitrary.
					FromTheRight -  pre- or post-multiply.
					DoTranspose -   multiply by P or P'.

			Output parameters:
					Z - product of Z and P.
											Array whose indexes range within [0..ZRows-1,0..ZColumns-1].
											If ZRows=0 or ZColumns=0, the array is not modified.

				-- ALGLIB --
					 2005-2010
					 Bochkanov Sergey
			*************************************************************************/
			public static void rmatrixbdmultiplybyp(double[,] qp,
					int m,
					int n,
					double[] taup,
					ref double[,] z,
					int zrows,
					int zcolumns,
					bool fromtheright,
					bool dotranspose)
			{
				int i = 0;
				double[] v = new double[0];
				double[] work = new double[0];
				int mx = 0;
				int i1 = 0;
				int i2 = 0;
				int istep = 0;
				int i_ = 0;
				int i1_ = 0;

				if (((m <= 0 || n <= 0) || zrows <= 0) || zcolumns <= 0)
				{
					return;
				}
				alglib.ap.assert((fromtheright && zcolumns == n) || (!fromtheright && zrows == n), "RMatrixBDMultiplyByP: incorrect Z size!");

				//
				// init
				//
				mx = Math.Max(m, n);
				mx = Math.Max(mx, zrows);
				mx = Math.Max(mx, zcolumns);
				v = new double[mx + 1];
				work = new double[mx + 1];
				if (m >= n)
				{

					//
					// setup
					//
					if (fromtheright)
					{
						i1 = n - 2;
						i2 = 0;
						istep = -1;
					}
					else
					{
						i1 = 0;
						i2 = n - 2;
						istep = 1;
					}
					if (!dotranspose)
					{
						i = i1;
						i1 = i2;
						i2 = i;
						istep = -istep;
					}

					//
					// Process
					//
					if (n - 1 > 0)
					{
						i = i1;
						do
						{
							i1_ = (i + 1) - (1);
							for (i_ = 1; i_ <= n - 1 - i; i_++)
							{
								v[i_] = qp[i, i_ + i1_];
							}
							v[1] = 1;
							if (fromtheright)
							{
								reflections.applyreflectionfromtheright(ref z, taup[i], v, 0, zrows - 1, i + 1, n - 1, ref work);
							}
							else
							{
								reflections.applyreflectionfromtheleft(ref z, taup[i], v, i + 1, n - 1, 0, zcolumns - 1, ref work);
							}
							i = i + istep;
						}
						while (i != i2 + istep);
					}
				}
				else
				{

					//
					// setup
					//
					if (fromtheright)
					{
						i1 = m - 1;
						i2 = 0;
						istep = -1;
					}
					else
					{
						i1 = 0;
						i2 = m - 1;
						istep = 1;
					}
					if (!dotranspose)
					{
						i = i1;
						i1 = i2;
						i2 = i;
						istep = -istep;
					}

					//
					// Process
					//
					i = i1;
					do
					{
						i1_ = (i) - (1);
						for (i_ = 1; i_ <= n - i; i_++)
						{
							v[i_] = qp[i, i_ + i1_];
						}
						v[1] = 1;
						if (fromtheright)
						{
							reflections.applyreflectionfromtheright(ref z, taup[i], v, 0, zrows - 1, i, n - 1, ref work);
						}
						else
						{
							reflections.applyreflectionfromtheleft(ref z, taup[i], v, i, n - 1, 0, zcolumns - 1, ref work);
						}
						i = i + istep;
					}
					while (i != i2 + istep);
				}
			}


			/*************************************************************************
			Unpacking of the main and secondary diagonals of bidiagonal decomposition
			of matrix A.

			Input parameters:
					B   -   output of RMatrixBD subroutine.
					M   -   number of rows in matrix B.
					N   -   number of columns in matrix B.

			Output parameters:
					IsUpper -   True, if the matrix is upper bidiagonal.
											otherwise IsUpper is False.
					D       -   the main diagonal.
											Array whose index ranges within [0..Min(M,N)-1].
					E       -   the secondary diagonal (upper or lower, depending on
											the value of IsUpper).
											Array index ranges within [0..Min(M,N)-1], the last
											element is not used.

				-- ALGLIB --
					 2005-2010
					 Bochkanov Sergey
			*************************************************************************/
			public static void rmatrixbdunpackdiagonals(double[,] b,
					int m,
					int n,
					ref bool isupper,
					ref double[] d,
					ref double[] e)
			{
				int i = 0;

				isupper = new bool();
				d = new double[0];
				e = new double[0];

				isupper = m >= n;
				if (m <= 0 || n <= 0)
				{
					return;
				}
				if (isupper)
				{
					d = new double[n];
					e = new double[n];
					for (i = 0; i <= n - 2; i++)
					{
						d[i] = b[i, i];
						e[i] = b[i, i + 1];
					}
					d[n - 1] = b[n - 1, n - 1];
				}
				else
				{
					d = new double[m];
					e = new double[m];
					for (i = 0; i <= m - 2; i++)
					{
						d[i] = b[i, i];
						e[i] = b[i + 1, i];
					}
					d[m - 1] = b[m - 1, m - 1];
				}
			}


			/*************************************************************************
			Reduction of a square matrix to  upper Hessenberg form: Q'*A*Q = H,
			where Q is an orthogonal matrix, H - Hessenberg matrix.

			Input parameters:
					A       -   matrix A with elements [0..N-1, 0..N-1]
					N       -   size of matrix A.

			Output parameters:
					A       -   matrices Q and P in  compact form (see below).
					Tau     -   array of scalar factors which are used to form matrix Q.
											Array whose index ranges within [0..N-2]

			Matrix H is located on the main diagonal, on the lower secondary  diagonal
			and above the main diagonal of matrix A. The elements which are used to
			form matrix Q are situated in array Tau and below the lower secondary
			diagonal of matrix A as follows:

			Matrix Q is represented as a product of elementary reflections

			Q = H(0)*H(2)*...*H(n-2),

			where each H(i) is given by

			H(i) = 1 - tau * v * (v^T)

			where tau is a scalar stored in Tau[I]; v - is a real vector,
			so that v(0:i) = 0, v(i+1) = 1, v(i+2:n-1) stored in A(i+2:n-1,i).

				-- LAPACK routine (version 3.0) --
					 Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
					 Courant Institute, Argonne National Lab, and Rice University
					 October 31, 1992
			*************************************************************************/
			public static void rmatrixhessenberg(ref double[,] a,
					int n,
					ref double[] tau)
			{
				int i = 0;
				double v = 0;
				double[] t = new double[0];
				double[] work = new double[0];
				int i_ = 0;
				int i1_ = 0;

				tau = new double[0];

				alglib.ap.assert(n >= 0, "RMatrixHessenberg: incorrect N!");

				//
				// Quick return if possible
				//
				if (n <= 1)
				{
					return;
				}
				tau = new double[n - 2 + 1];
				t = new double[n + 1];
				work = new double[n - 1 + 1];
				for (i = 0; i <= n - 2; i++)
				{

					//
					// Compute elementary reflector H(i) to annihilate A(i+2:ihi,i)
					//
					i1_ = (i + 1) - (1);
					for (i_ = 1; i_ <= n - i - 1; i_++)
					{
						t[i_] = a[i_ + i1_, i];
					}
					reflections.generatereflection(ref t, n - i - 1, ref v);
					i1_ = (1) - (i + 1);
					for (i_ = i + 1; i_ <= n - 1; i_++)
					{
						a[i_, i] = t[i_ + i1_];
					}
					tau[i] = v;
					t[1] = 1;

					//
					// Apply H(i) to A(1:ihi,i+1:ihi) from the right
					//
					reflections.applyreflectionfromtheright(ref a, v, t, 0, n - 1, i + 1, n - 1, ref work);

					//
					// Apply H(i) to A(i+1:ihi,i+1:n) from the left
					//
					reflections.applyreflectionfromtheleft(ref a, v, t, i + 1, n - 1, i + 1, n - 1, ref work);
				}
			}


			/*************************************************************************
			Unpacking matrix Q which reduces matrix A to upper Hessenberg form

			Input parameters:
					A   -   output of RMatrixHessenberg subroutine.
					N   -   size of matrix A.
					Tau -   scalar factors which are used to form Q.
									Output of RMatrixHessenberg subroutine.

			Output parameters:
					Q   -   matrix Q.
									Array whose indexes range within [0..N-1, 0..N-1].

				-- ALGLIB --
					 2005-2010
					 Bochkanov Sergey
			*************************************************************************/
			public static void rmatrixhessenbergunpackq(double[,] a,
					int n,
					double[] tau,
					ref double[,] q)
			{
				int i = 0;
				int j = 0;
				double[] v = new double[0];
				double[] work = new double[0];
				int i_ = 0;
				int i1_ = 0;

				q = new double[0, 0];

				if (n == 0)
				{
					return;
				}

				//
				// init
				//
				q = new double[n - 1 + 1, n - 1 + 1];
				v = new double[n - 1 + 1];
				work = new double[n - 1 + 1];
				for (i = 0; i <= n - 1; i++)
				{
					for (j = 0; j <= n - 1; j++)
					{
						if (i == j)
						{
							q[i, j] = 1;
						}
						else
						{
							q[i, j] = 0;
						}
					}
				}

				//
				// unpack Q
				//
				for (i = 0; i <= n - 2; i++)
				{

					//
					// Apply H(i)
					//
					i1_ = (i + 1) - (1);
					for (i_ = 1; i_ <= n - i - 1; i_++)
					{
						v[i_] = a[i_ + i1_, i];
					}
					v[1] = 1;
					reflections.applyreflectionfromtheright(ref q, tau[i], v, 0, n - 1, i + 1, n - 1, ref work);
				}
			}


			/*************************************************************************
			Unpacking matrix H (the result of matrix A reduction to upper Hessenberg form)

			Input parameters:
					A   -   output of RMatrixHessenberg subroutine.
					N   -   size of matrix A.

			Output parameters:
					H   -   matrix H. Array whose indexes range within [0..N-1, 0..N-1].

				-- ALGLIB --
					 2005-2010
					 Bochkanov Sergey
			*************************************************************************/
			public static void rmatrixhessenbergunpackh(double[,] a,
					int n,
					ref double[,] h)
			{
				int i = 0;
				int j = 0;
				double[] v = new double[0];
				double[] work = new double[0];
				int i_ = 0;

				h = new double[0, 0];

				if (n == 0)
				{
					return;
				}
				h = new double[n - 1 + 1, n - 1 + 1];
				for (i = 0; i <= n - 1; i++)
				{
					for (j = 0; j <= i - 2; j++)
					{
						h[i, j] = 0;
					}
					j = Math.Max(0, i - 1);
					for (i_ = j; i_ <= n - 1; i_++)
					{
						h[i, i_] = a[i, i_];
					}
				}
			}


			/*************************************************************************
			Reduction of a symmetric matrix which is given by its higher or lower
			triangular part to a tridiagonal matrix using orthogonal similarity
			transformation: Q'*A*Q=T.

			Input parameters:
					A       -   matrix to be transformed
											array with elements [0..N-1, 0..N-1].
					N       -   size of matrix A.
					IsUpper -   storage format. If IsUpper = True, then matrix A is given
											by its upper triangle, and the lower triangle is not used
											and not modified by the algorithm, and vice versa
											if IsUpper = False.

			Output parameters:
					A       -   matrices T and Q in  compact form (see lower)
					Tau     -   array of factors which are forming matrices H(i)
											array with elements [0..N-2].
					D       -   main diagonal of symmetric matrix T.
											array with elements [0..N-1].
					E       -   secondary diagonal of symmetric matrix T.
											array with elements [0..N-2].


				If IsUpper=True, the matrix Q is represented as a product of elementary
				reflectors

					 Q = H(n-2) . . . H(2) H(0).

				Each H(i) has the form

					 H(i) = I - tau * v * v'

				where tau is a real scalar, and v is a real vector with
				v(i+1:n-1) = 0, v(i) = 1, v(0:i-1) is stored on exit in
				A(0:i-1,i+1), and tau in TAU(i).

				If IsUpper=False, the matrix Q is represented as a product of elementary
				reflectors

					 Q = H(0) H(2) . . . H(n-2).

				Each H(i) has the form

					 H(i) = I - tau * v * v'

				where tau is a real scalar, and v is a real vector with
				v(0:i) = 0, v(i+1) = 1, v(i+2:n-1) is stored on exit in A(i+2:n-1,i),
				and tau in TAU(i).

				The contents of A on exit are illustrated by the following examples
				with n = 5:

				if UPLO = 'U':                       if UPLO = 'L':

					(  d   e   v1  v2  v3 )              (  d                  )
					(      d   e   v2  v3 )              (  e   d              )
					(          d   e   v3 )              (  v0  e   d          )
					(              d   e  )              (  v0  v1  e   d      )
					(                  d  )              (  v0  v1  v2  e   d  )

				where d and e denote diagonal and off-diagonal elements of T, and vi
				denotes an element of the vector defining H(i).

				-- LAPACK routine (version 3.0) --
					 Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
					 Courant Institute, Argonne National Lab, and Rice University
					 October 31, 1992
			*************************************************************************/
			public static void smatrixtd(ref double[,] a,
					int n,
					bool isupper,
					ref double[] tau,
					ref double[] d,
					ref double[] e)
			{
				int i = 0;
				double alpha = 0;
				double taui = 0;
				double v = 0;
				double[] t = new double[0];
				double[] t2 = new double[0];
				double[] t3 = new double[0];
				int i_ = 0;
				int i1_ = 0;

				tau = new double[0];
				d = new double[0];
				e = new double[0];

				if (n <= 0)
				{
					return;
				}
				t = new double[n + 1];
				t2 = new double[n + 1];
				t3 = new double[n + 1];
				if (n > 1)
				{
					tau = new double[n - 2 + 1];
				}
				d = new double[n - 1 + 1];
				if (n > 1)
				{
					e = new double[n - 2 + 1];
				}
				if (isupper)
				{

					//
					// Reduce the upper triangle of A
					//
					for (i = n - 2; i >= 0; i--)
					{

						//
						// Generate elementary reflector H() = E - tau * v * v'
						//
						if (i >= 1)
						{
							i1_ = (0) - (2);
							for (i_ = 2; i_ <= i + 1; i_++)
							{
								t[i_] = a[i_ + i1_, i + 1];
							}
						}
						t[1] = a[i, i + 1];
						reflections.generatereflection(ref t, i + 1, ref taui);
						if (i >= 1)
						{
							i1_ = (2) - (0);
							for (i_ = 0; i_ <= i - 1; i_++)
							{
								a[i_, i + 1] = t[i_ + i1_];
							}
						}
						a[i, i + 1] = t[1];
						e[i] = a[i, i + 1];
						if ((double)(taui) != (double)(0))
						{

							//
							// Apply H from both sides to A
							//
							a[i, i + 1] = 1;

							//
							// Compute  x := tau * A * v  storing x in TAU
							//
							i1_ = (0) - (1);
							for (i_ = 1; i_ <= i + 1; i_++)
							{
								t[i_] = a[i_ + i1_, i + 1];
							}
							sblas.symmetricmatrixvectormultiply(a, isupper, 0, i, t, taui, ref t3);
							i1_ = (1) - (0);
							for (i_ = 0; i_ <= i; i_++)
							{
								tau[i_] = t3[i_ + i1_];
							}

							//
							// Compute  w := x - 1/2 * tau * (x'*v) * v
							//
							v = 0.0f;
							for (i_ = 0; i_ <= i; i_++)
							{
								v += tau[i_] * a[i_, i + 1];
							}
							alpha = -(0.5f * taui * v);
							for (i_ = 0; i_ <= i; i_++)
							{
								tau[i_] = tau[i_] + alpha * a[i_, i + 1];
							}

							//
							// Apply the transformation as a rank-2 update:
							//    A := A - v * w' - w * v'
							//
							i1_ = (0) - (1);
							for (i_ = 1; i_ <= i + 1; i_++)
							{
								t[i_] = a[i_ + i1_, i + 1];
							}
							i1_ = (0) - (1);
							for (i_ = 1; i_ <= i + 1; i_++)
							{
								t3[i_] = tau[i_ + i1_];
							}
							sblas.symmetricrank2update(ref a, isupper, 0, i, t, t3, ref t2, -1);
							a[i, i + 1] = e[i];
						}
						d[i + 1] = a[i + 1, i + 1];
						tau[i] = taui;
					}
					d[0] = a[0, 0];
				}
				else
				{

					//
					// Reduce the lower triangle of A
					//
					for (i = 0; i <= n - 2; i++)
					{

						//
						// Generate elementary reflector H = E - tau * v * v'
						//
						i1_ = (i + 1) - (1);
						for (i_ = 1; i_ <= n - i - 1; i_++)
						{
							t[i_] = a[i_ + i1_, i];
						}
						reflections.generatereflection(ref t, n - i - 1, ref taui);
						i1_ = (1) - (i + 1);
						for (i_ = i + 1; i_ <= n - 1; i_++)
						{
							a[i_, i] = t[i_ + i1_];
						}
						e[i] = a[i + 1, i];
						if ((double)(taui) != (double)(0))
						{

							//
							// Apply H from both sides to A
							//
							a[i + 1, i] = 1;

							//
							// Compute  x := tau * A * v  storing y in TAU
							//
							i1_ = (i + 1) - (1);
							for (i_ = 1; i_ <= n - i - 1; i_++)
							{
								t[i_] = a[i_ + i1_, i];
							}
							sblas.symmetricmatrixvectormultiply(a, isupper, i + 1, n - 1, t, taui, ref t2);
							i1_ = (1) - (i);
							for (i_ = i; i_ <= n - 2; i_++)
							{
								tau[i_] = t2[i_ + i1_];
							}

							//
							// Compute  w := x - 1/2 * tau * (x'*v) * v
							//
							i1_ = (i + 1) - (i);
							v = 0.0f;
							for (i_ = i; i_ <= n - 2; i_++)
							{
								v += tau[i_] * a[i_ + i1_, i];
							}
							alpha = -(0.5f * taui * v);
							i1_ = (i + 1) - (i);
							for (i_ = i; i_ <= n - 2; i_++)
							{
								tau[i_] = tau[i_] + alpha * a[i_ + i1_, i];
							}

							//
							// Apply the transformation as a rank-2 update:
							//     A := A - v * w' - w * v'
							//
							//
							i1_ = (i + 1) - (1);
							for (i_ = 1; i_ <= n - i - 1; i_++)
							{
								t[i_] = a[i_ + i1_, i];
							}
							i1_ = (i) - (1);
							for (i_ = 1; i_ <= n - i - 1; i_++)
							{
								t2[i_] = tau[i_ + i1_];
							}
							sblas.symmetricrank2update(ref a, isupper, i + 1, n - 1, t, t2, ref t3, -1);
							a[i + 1, i] = e[i];
						}
						d[i] = a[i, i];
						tau[i] = taui;
					}
					d[n - 1] = a[n - 1, n - 1];
				}
			}


			/*************************************************************************
			Unpacking matrix Q which reduces symmetric matrix to a tridiagonal
			form.

			Input parameters:
					A       -   the result of a SMatrixTD subroutine
					N       -   size of matrix A.
					IsUpper -   storage format (a parameter of SMatrixTD subroutine)
					Tau     -   the result of a SMatrixTD subroutine

			Output parameters:
					Q       -   transformation matrix.
											array with elements [0..N-1, 0..N-1].

				-- ALGLIB --
					 Copyright 2005-2010 by Bochkanov Sergey
			*************************************************************************/
			public static void smatrixtdunpackq(double[,] a,
					int n,
					bool isupper,
					double[] tau,
					ref double[,] q)
			{
				int i = 0;
				int j = 0;
				double[] v = new double[0];
				double[] work = new double[0];
				int i_ = 0;
				int i1_ = 0;

				q = new double[0, 0];

				if (n == 0)
				{
					return;
				}

				//
				// init
				//
				q = new double[n - 1 + 1, n - 1 + 1];
				v = new double[n + 1];
				work = new double[n - 1 + 1];
				for (i = 0; i <= n - 1; i++)
				{
					for (j = 0; j <= n - 1; j++)
					{
						if (i == j)
						{
							q[i, j] = 1;
						}
						else
						{
							q[i, j] = 0;
						}
					}
				}

				//
				// unpack Q
				//
				if (isupper)
				{
					for (i = 0; i <= n - 2; i++)
					{

						//
						// Apply H(i)
						//
						i1_ = (0) - (1);
						for (i_ = 1; i_ <= i + 1; i_++)
						{
							v[i_] = a[i_ + i1_, i + 1];
						}
						v[i + 1] = 1;
						reflections.applyreflectionfromtheleft(ref q, tau[i], v, 0, i, 0, n - 1, ref work);
					}
				}
				else
				{
					for (i = n - 2; i >= 0; i--)
					{

						//
						// Apply H(i)
						//
						i1_ = (i + 1) - (1);
						for (i_ = 1; i_ <= n - i - 1; i_++)
						{
							v[i_] = a[i_ + i1_, i];
						}
						v[1] = 1;
						reflections.applyreflectionfromtheleft(ref q, tau[i], v, i + 1, n - 1, 0, n - 1, ref work);
					}
				}
			}


			/*************************************************************************
			Reduction of a Hermitian matrix which is given  by  its  higher  or  lower
			triangular part to a real  tridiagonal  matrix  using  unitary  similarity
			transformation: Q'*A*Q = T.

			Input parameters:
					A       -   matrix to be transformed
											array with elements [0..N-1, 0..N-1].
					N       -   size of matrix A.
					IsUpper -   storage format. If IsUpper = True, then matrix A is  given
											by its upper triangle, and the lower triangle is not  used
											and not modified by the algorithm, and vice versa
											if IsUpper = False.

			Output parameters:
					A       -   matrices T and Q in  compact form (see lower)
					Tau     -   array of factors which are forming matrices H(i)
											array with elements [0..N-2].
					D       -   main diagonal of real symmetric matrix T.
											array with elements [0..N-1].
					E       -   secondary diagonal of real symmetric matrix T.
											array with elements [0..N-2].


				If IsUpper=True, the matrix Q is represented as a product of elementary
				reflectors

					 Q = H(n-2) . . . H(2) H(0).

				Each H(i) has the form

					 H(i) = I - tau * v * v'

				where tau is a complex scalar, and v is a complex vector with
				v(i+1:n-1) = 0, v(i) = 1, v(0:i-1) is stored on exit in
				A(0:i-1,i+1), and tau in TAU(i).

				If IsUpper=False, the matrix Q is represented as a product of elementary
				reflectors

					 Q = H(0) H(2) . . . H(n-2).

				Each H(i) has the form

					 H(i) = I - tau * v * v'

				where tau is a complex scalar, and v is a complex vector with
				v(0:i) = 0, v(i+1) = 1, v(i+2:n-1) is stored on exit in A(i+2:n-1,i),
				and tau in TAU(i).

				The contents of A on exit are illustrated by the following examples
				with n = 5:

				if UPLO = 'U':                       if UPLO = 'L':

					(  d   e   v1  v2  v3 )              (  d                  )
					(      d   e   v2  v3 )              (  e   d              )
					(          d   e   v3 )              (  v0  e   d          )
					(              d   e  )              (  v0  v1  e   d      )
					(                  d  )              (  v0  v1  v2  e   d  )

			where d and e denote diagonal and off-diagonal elements of T, and vi
			denotes an element of the vector defining H(i).

				-- LAPACK routine (version 3.0) --
					 Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
					 Courant Institute, Argonne National Lab, and Rice University
					 October 31, 1992
			*************************************************************************/
			public static void hmatrixtd(ref complex[,] a,
					int n,
					bool isupper,
					ref complex[] tau,
					ref double[] d,
					ref double[] e)
			{
				int i = 0;
				complex alpha = 0;
				complex taui = 0;
				complex v = 0;
				complex[] t = new complex[0];
				complex[] t2 = new complex[0];
				complex[] t3 = new complex[0];
				int i_ = 0;
				int i1_ = 0;

				tau = new complex[0];
				d = new double[0];
				e = new double[0];

				if (n <= 0)
				{
					return;
				}
				for (i = 0; i <= n - 1; i++)
				{
					alglib.ap.assert((double)(a[i, i].y) == (double)(0));
				}
				if (n > 1)
				{
					tau = new complex[n - 2 + 1];
					e = new double[n - 2 + 1];
				}
				d = new double[n - 1 + 1];
				t = new complex[n - 1 + 1];
				t2 = new complex[n - 1 + 1];
				t3 = new complex[n - 1 + 1];
				if (isupper)
				{

					//
					// Reduce the upper triangle of A
					//
					a[n - 1, n - 1] = a[n - 1, n - 1].x;
					for (i = n - 2; i >= 0; i--)
					{

						//
						// Generate elementary reflector H = I+1 - tau * v * v'
						//
						alpha = a[i, i + 1];
						t[1] = alpha;
						if (i >= 1)
						{
							i1_ = (0) - (2);
							for (i_ = 2; i_ <= i + 1; i_++)
							{
								t[i_] = a[i_ + i1_, i + 1];
							}
						}
						creflections.complexgeneratereflection(ref t, i + 1, ref taui);
						if (i >= 1)
						{
							i1_ = (2) - (0);
							for (i_ = 0; i_ <= i - 1; i_++)
							{
								a[i_, i + 1] = t[i_ + i1_];
							}
						}
						alpha = t[1];
						e[i] = alpha.x;
						if (taui != 0)
						{

							//
							// Apply H(I+1) from both sides to A
							//
							a[i, i + 1] = 1;

							//
							// Compute  x := tau * A * v  storing x in TAU
							//
							i1_ = (0) - (1);
							for (i_ = 1; i_ <= i + 1; i_++)
							{
								t[i_] = a[i_ + i1_, i + 1];
							}
							hblas.hermitianmatrixvectormultiply(a, isupper, 0, i, t, taui, ref t2);
							i1_ = (1) - (0);
							for (i_ = 0; i_ <= i; i_++)
							{
								tau[i_] = t2[i_ + i1_];
							}

							//
							// Compute  w := x - 1/2 * tau * (x'*v) * v
							//
							v = 0.0f;
							for (i_ = 0; i_ <= i; i_++)
							{
								v += math.conj(tau[i_]) * a[i_, i + 1];
							}
							alpha = -(0.5f * taui * v);
							for (i_ = 0; i_ <= i; i_++)
							{
								tau[i_] = tau[i_] + alpha * a[i_, i + 1];
							}

							//
							// Apply the transformation as a rank-2 update:
							//    A := A - v * w' - w * v'
							//
							i1_ = (0) - (1);
							for (i_ = 1; i_ <= i + 1; i_++)
							{
								t[i_] = a[i_ + i1_, i + 1];
							}
							i1_ = (0) - (1);
							for (i_ = 1; i_ <= i + 1; i_++)
							{
								t3[i_] = tau[i_ + i1_];
							}
							hblas.hermitianrank2update(ref a, isupper, 0, i, t, t3, ref t2, -1);
						}
						else
						{
							a[i, i] = a[i, i].x;
						}
						a[i, i + 1] = e[i];
						d[i + 1] = a[i + 1, i + 1].x;
						tau[i] = taui;
					}
					d[0] = a[0, 0].x;
				}
				else
				{

					//
					// Reduce the lower triangle of A
					//
					a[0, 0] = a[0, 0].x;
					for (i = 0; i <= n - 2; i++)
					{

						//
						// Generate elementary reflector H = I - tau * v * v'
						//
						i1_ = (i + 1) - (1);
						for (i_ = 1; i_ <= n - i - 1; i_++)
						{
							t[i_] = a[i_ + i1_, i];
						}
						creflections.complexgeneratereflection(ref t, n - i - 1, ref taui);
						i1_ = (1) - (i + 1);
						for (i_ = i + 1; i_ <= n - 1; i_++)
						{
							a[i_, i] = t[i_ + i1_];
						}
						e[i] = a[i + 1, i].x;
						if (taui != 0)
						{

							//
							// Apply H(i) from both sides to A(i+1:n,i+1:n)
							//
							a[i + 1, i] = 1;

							//
							// Compute  x := tau * A * v  storing y in TAU
							//
							i1_ = (i + 1) - (1);
							for (i_ = 1; i_ <= n - i - 1; i_++)
							{
								t[i_] = a[i_ + i1_, i];
							}
							hblas.hermitianmatrixvectormultiply(a, isupper, i + 1, n - 1, t, taui, ref t2);
							i1_ = (1) - (i);
							for (i_ = i; i_ <= n - 2; i_++)
							{
								tau[i_] = t2[i_ + i1_];
							}

							//
							// Compute  w := x - 1/2 * tau * (x'*v) * v
							//
							i1_ = (i + 1) - (i);
							v = 0.0f;
							for (i_ = i; i_ <= n - 2; i_++)
							{
								v += math.conj(tau[i_]) * a[i_ + i1_, i];
							}
							alpha = -(0.5f * taui * v);
							i1_ = (i + 1) - (i);
							for (i_ = i; i_ <= n - 2; i_++)
							{
								tau[i_] = tau[i_] + alpha * a[i_ + i1_, i];
							}

							//
							// Apply the transformation as a rank-2 update:
							// A := A - v * w' - w * v'
							//
							i1_ = (i + 1) - (1);
							for (i_ = 1; i_ <= n - i - 1; i_++)
							{
								t[i_] = a[i_ + i1_, i];
							}
							i1_ = (i) - (1);
							for (i_ = 1; i_ <= n - i - 1; i_++)
							{
								t2[i_] = tau[i_ + i1_];
							}
							hblas.hermitianrank2update(ref a, isupper, i + 1, n - 1, t, t2, ref t3, -1);
						}
						else
						{
							a[i + 1, i + 1] = a[i + 1, i + 1].x;
						}
						a[i + 1, i] = e[i];
						d[i] = a[i, i].x;
						tau[i] = taui;
					}
					d[n - 1] = a[n - 1, n - 1].x;
				}
			}


			/*************************************************************************
			Unpacking matrix Q which reduces a Hermitian matrix to a real  tridiagonal
			form.

			Input parameters:
					A       -   the result of a HMatrixTD subroutine
					N       -   size of matrix A.
					IsUpper -   storage format (a parameter of HMatrixTD subroutine)
					Tau     -   the result of a HMatrixTD subroutine

			Output parameters:
					Q       -   transformation matrix.
											array with elements [0..N-1, 0..N-1].

				-- ALGLIB --
					 Copyright 2005-2010 by Bochkanov Sergey
			*************************************************************************/
			public static void hmatrixtdunpackq(complex[,] a,
					int n,
					bool isupper,
					complex[] tau,
					ref complex[,] q)
			{
				int i = 0;
				int j = 0;
				complex[] v = new complex[0];
				complex[] work = new complex[0];
				int i_ = 0;
				int i1_ = 0;

				q = new complex[0, 0];

				if (n == 0)
				{
					return;
				}

				//
				// init
				//
				q = new complex[n - 1 + 1, n - 1 + 1];
				v = new complex[n + 1];
				work = new complex[n - 1 + 1];
				for (i = 0; i <= n - 1; i++)
				{
					for (j = 0; j <= n - 1; j++)
					{
						if (i == j)
						{
							q[i, j] = 1;
						}
						else
						{
							q[i, j] = 0;
						}
					}
				}

				//
				// unpack Q
				//
				if (isupper)
				{
					for (i = 0; i <= n - 2; i++)
					{

						//
						// Apply H(i)
						//
						i1_ = (0) - (1);
						for (i_ = 1; i_ <= i + 1; i_++)
						{
							v[i_] = a[i_ + i1_, i + 1];
						}
						v[i + 1] = 1;
						creflections.complexapplyreflectionfromtheleft(ref q, tau[i], v, 0, i, 0, n - 1, ref work);
					}
				}
				else
				{
					for (i = n - 2; i >= 0; i--)
					{

						//
						// Apply H(i)
						//
						i1_ = (i + 1) - (1);
						for (i_ = 1; i_ <= n - i - 1; i_++)
						{
							v[i_] = a[i_ + i1_, i];
						}
						v[1] = 1;
						creflections.complexapplyreflectionfromtheleft(ref q, tau[i], v, i + 1, n - 1, 0, n - 1, ref work);
					}
				}
			}


			/*************************************************************************
			Base case for complex QR

				-- LAPACK routine (version 3.0) --
					 Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
					 Courant Institute, Argonne National Lab, and Rice University
					 September 30, 1994.
					 Sergey Bochkanov, ALGLIB project, translation from FORTRAN to
					 pseudocode, 2007-2010.
			*************************************************************************/
			private static void cmatrixqrbasecase(ref complex[,] a,
					int m,
					int n,
					ref complex[] work,
					ref complex[] t,
					ref complex[] tau)
			{
				int i = 0;
				int k = 0;
				int mmi = 0;
				int minmn = 0;
				complex tmp = 0;
				int i_ = 0;
				int i1_ = 0;

				minmn = Math.Min(m, n);
				if (minmn <= 0)
				{
					return;
				}

				//
				// Test the input arguments
				//
				k = Math.Min(m, n);
				for (i = 0; i <= k - 1; i++)
				{

					//
					// Generate elementary reflector H(i) to annihilate A(i+1:m,i)
					//
					mmi = m - i;
					i1_ = (i) - (1);
					for (i_ = 1; i_ <= mmi; i_++)
					{
						t[i_] = a[i_ + i1_, i];
					}
					creflections.complexgeneratereflection(ref t, mmi, ref tmp);
					tau[i] = tmp;
					i1_ = (1) - (i);
					for (i_ = i; i_ <= m - 1; i_++)
					{
						a[i_, i] = t[i_ + i1_];
					}
					t[1] = 1;
					if (i < n - 1)
					{

						//
						// Apply H'(i) to A(i:m,i+1:n) from the left
						//
						creflections.complexapplyreflectionfromtheleft(ref a, math.conj(tau[i]), t, i, m - 1, i + 1, n - 1, ref work);
					}
				}
			}


			/*************************************************************************
			Base case for complex LQ

				-- LAPACK routine (version 3.0) --
					 Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
					 Courant Institute, Argonne National Lab, and Rice University
					 September 30, 1994.
					 Sergey Bochkanov, ALGLIB project, translation from FORTRAN to
					 pseudocode, 2007-2010.
			*************************************************************************/
			private static void cmatrixlqbasecase(ref complex[,] a,
					int m,
					int n,
					ref complex[] work,
					ref complex[] t,
					ref complex[] tau)
			{
				int i = 0;
				int minmn = 0;
				complex tmp = 0;
				int i_ = 0;
				int i1_ = 0;

				minmn = Math.Min(m, n);
				if (minmn <= 0)
				{
					return;
				}

				//
				// Test the input arguments
				//
				for (i = 0; i <= minmn - 1; i++)
				{

					//
					// Generate elementary reflector H(i)
					//
					// NOTE: ComplexGenerateReflection() generates left reflector,
					// i.e. H which reduces x by applyiong from the left, but we
					// need RIGHT reflector. So we replace H=E-tau*v*v' by H^H,
					// which changes v to conj(v).
					//
					i1_ = (i) - (1);
					for (i_ = 1; i_ <= n - i; i_++)
					{
						t[i_] = math.conj(a[i, i_ + i1_]);
					}
					creflections.complexgeneratereflection(ref t, n - i, ref tmp);
					tau[i] = tmp;
					i1_ = (1) - (i);
					for (i_ = i; i_ <= n - 1; i_++)
					{
						a[i, i_] = math.conj(t[i_ + i1_]);
					}
					t[1] = 1;
					if (i < m - 1)
					{

						//
						// Apply H'(i)
						//
						creflections.complexapplyreflectionfromtheright(ref a, tau[i], ref t, i + 1, m - 1, i, n - 1, ref work);
					}
				}
			}


			/*************************************************************************
			Generate block reflector:
			* fill unused parts of reflectors matrix by zeros
			* fill diagonal of reflectors matrix by ones
			* generate triangular factor T

			PARAMETERS:
					A           -   either LengthA*BlockSize (if ColumnwiseA) or
													BlockSize*LengthA (if not ColumnwiseA) matrix of
													elementary reflectors.
													Modified on exit.
					Tau         -   scalar factors
					ColumnwiseA -   reflectors are stored in rows or in columns
					LengthA     -   length of largest reflector
					BlockSize   -   number of reflectors
					T           -   array[BlockSize,2*BlockSize]. Left BlockSize*BlockSize
													submatrix stores triangular factor on exit.
					WORK        -   array[BlockSize]
            
				-- ALGLIB routine --
					 17.02.2010
					 Bochkanov Sergey
			*************************************************************************/
			private static void rmatrixblockreflector(ref double[,] a,
					ref double[] tau,
					bool columnwisea,
					int lengtha,
					int blocksize,
					ref double[,] t,
					ref double[] work)
			{
				int i = 0;
				int j = 0;
				int k = 0;
				double v = 0;
				int i_ = 0;
				int i1_ = 0;


				//
				// fill beginning of new column with zeros,
				// load 1.0f in the first non-zero element
				//
				for (k = 0; k <= blocksize - 1; k++)
				{
					if (columnwisea)
					{
						for (i = 0; i <= k - 1; i++)
						{
							a[i, k] = 0;
						}
					}
					else
					{
						for (i = 0; i <= k - 1; i++)
						{
							a[k, i] = 0;
						}
					}
					a[k, k] = 1;
				}

				//
				// Calculate Gram matrix of A
				//
				for (i = 0; i <= blocksize - 1; i++)
				{
					for (j = 0; j <= blocksize - 1; j++)
					{
						t[i, blocksize + j] = 0;
					}
				}
				for (k = 0; k <= lengtha - 1; k++)
				{
					for (j = 1; j <= blocksize - 1; j++)
					{
						if (columnwisea)
						{
							v = a[k, j];
							if ((double)(v) != (double)(0))
							{
								i1_ = (0) - (blocksize);
								for (i_ = blocksize; i_ <= blocksize + j - 1; i_++)
								{
									t[j, i_] = t[j, i_] + v * a[k, i_ + i1_];
								}
							}
						}
						else
						{
							v = a[j, k];
							if ((double)(v) != (double)(0))
							{
								i1_ = (0) - (blocksize);
								for (i_ = blocksize; i_ <= blocksize + j - 1; i_++)
								{
									t[j, i_] = t[j, i_] + v * a[i_ + i1_, k];
								}
							}
						}
					}
				}

				//
				// Prepare Y (stored in TmpA) and T (stored in TmpT)
				//
				for (k = 0; k <= blocksize - 1; k++)
				{

					//
					// fill non-zero part of T, use pre-calculated Gram matrix
					//
					i1_ = (blocksize) - (0);
					for (i_ = 0; i_ <= k - 1; i_++)
					{
						work[i_] = t[k, i_ + i1_];
					}
					for (i = 0; i <= k - 1; i++)
					{
						v = 0.0f;
						for (i_ = i; i_ <= k - 1; i_++)
						{
							v += t[i, i_] * work[i_];
						}
						t[i, k] = -(tau[k] * v);
					}
					t[k, k] = -tau[k];

					//
					// Rest of T is filled by zeros
					//
					for (i = k + 1; i <= blocksize - 1; i++)
					{
						t[i, k] = 0;
					}
				}
			}


			/*************************************************************************
			Generate block reflector (complex):
			* fill unused parts of reflectors matrix by zeros
			* fill diagonal of reflectors matrix by ones
			* generate triangular factor T


				-- ALGLIB routine --
					 17.02.2010
					 Bochkanov Sergey
			*************************************************************************/
			private static void cmatrixblockreflector(ref complex[,] a,
					ref complex[] tau,
					bool columnwisea,
					int lengtha,
					int blocksize,
					ref complex[,] t,
					ref complex[] work)
			{
				int i = 0;
				int k = 0;
				complex v = 0;
				int i_ = 0;


				//
				// Prepare Y (stored in TmpA) and T (stored in TmpT)
				//
				for (k = 0; k <= blocksize - 1; k++)
				{

					//
					// fill beginning of new column with zeros,
					// load 1.0f in the first non-zero element
					//
					if (columnwisea)
					{
						for (i = 0; i <= k - 1; i++)
						{
							a[i, k] = 0;
						}
					}
					else
					{
						for (i = 0; i <= k - 1; i++)
						{
							a[k, i] = 0;
						}
					}
					a[k, k] = 1;

					//
					// fill non-zero part of T,
					//
					for (i = 0; i <= k - 1; i++)
					{
						if (columnwisea)
						{
							v = 0.0f;
							for (i_ = k; i_ <= lengtha - 1; i_++)
							{
								v += math.conj(a[i_, i]) * a[i_, k];
							}
						}
						else
						{
							v = 0.0f;
							for (i_ = k; i_ <= lengtha - 1; i_++)
							{
								v += a[i, i_] * math.conj(a[k, i_]);
							}
						}
						work[i] = v;
					}
					for (i = 0; i <= k - 1; i++)
					{
						v = 0.0f;
						for (i_ = i; i_ <= k - 1; i_++)
						{
							v += t[i, i_] * work[i_];
						}
						t[i, k] = -(tau[k] * v);
					}
					t[k, k] = -tau[k];

					//
					// Rest of T is filled by zeros
					//
					for (i = k + 1; i <= blocksize - 1; i++)
					{
						t[i, k] = 0;
					}
				}
			}


		}
		public class bdsvd
		{
			/*************************************************************************
			Singular value decomposition of a bidiagonal matrix (extended algorithm)

			The algorithm performs the singular value decomposition  of  a  bidiagonal
			matrix B (upper or lower) representing it as B = Q*S*P^T, where Q and  P -
			orthogonal matrices, S - diagonal matrix with non-negative elements on the
			main diagonal, in descending order.

			The  algorithm  finds  singular  values.  In  addition,  the algorithm can
			calculate  matrices  Q  and P (more precisely, not the matrices, but their
			product  with  given  matrices U and VT - U*Q and (P^T)*VT)).  Of  course,
			matrices U and VT can be of any type, including identity. Furthermore, the
			algorithm can calculate Q'*C (this product is calculated more  effectively
			than U*Q,  because  this calculation operates with rows instead  of matrix
			columns).

			The feature of the algorithm is its ability to find  all  singular  values
			including those which are arbitrarily close to 0  with  relative  accuracy
			close to  machine precision. If the parameter IsFractionalAccuracyRequired
			is set to True, all singular values will have high relative accuracy close
			to machine precision. If the parameter is set to False, only  the  biggest
			singular value will have relative accuracy  close  to  machine  precision.
			The absolute error of other singular values is equal to the absolute error
			of the biggest singular value.

			Input parameters:
					D       -   main diagonal of matrix B.
											Array whose index ranges within [0..N-1].
					E       -   superdiagonal (or subdiagonal) of matrix B.
											Array whose index ranges within [0..N-2].
					N       -   size of matrix B.
					IsUpper -   True, if the matrix is upper bidiagonal.
					IsFractionalAccuracyRequired -
											THIS PARAMETER IS IGNORED SINCE ALGLIB 3.5.0
											SINGULAR VALUES ARE ALWAYS SEARCHED WITH HIGH ACCURACY.
					U       -   matrix to be multiplied by Q.
											Array whose indexes range within [0..NRU-1, 0..N-1].
											The matrix can be bigger, in that case only the  submatrix
											[0..NRU-1, 0..N-1] will be multiplied by Q.
					NRU     -   number of rows in matrix U.
					C       -   matrix to be multiplied by Q'.
											Array whose indexes range within [0..N-1, 0..NCC-1].
											The matrix can be bigger, in that case only the  submatrix
											[0..N-1, 0..NCC-1] will be multiplied by Q'.
					NCC     -   number of columns in matrix C.
					VT      -   matrix to be multiplied by P^T.
											Array whose indexes range within [0..N-1, 0..NCVT-1].
											The matrix can be bigger, in that case only the  submatrix
											[0..N-1, 0..NCVT-1] will be multiplied by P^T.
					NCVT    -   number of columns in matrix VT.

			Output parameters:
					D       -   singular values of matrix B in descending order.
					U       -   if NRU>0, contains matrix U*Q.
					VT      -   if NCVT>0, contains matrix (P^T)*VT.
					C       -   if NCC>0, contains matrix Q'*C.

			Result:
					True, if the algorithm has converged.
					False, if the algorithm hasn't converged (rare case).

			Additional information:
					The type of convergence is controlled by the internal  parameter  TOL.
					If the parameter is greater than 0, the singular values will have
					relative accuracy TOL. If TOL<0, the singular values will have
					absolute accuracy ABS(TOL)*norm(B).
					By default, |TOL| falls within the range of 10*Epsilon and 100*Epsilon,
					where Epsilon is the machine precision. It is not  recommended  to  use
					TOL less than 10*Epsilon since this will  considerably  slow  down  the
					algorithm and may not lead to error decreasing.
			History:
					* 31 March, 2007.
							changed MAXITR from 6 to 12.

				-- LAPACK routine (version 3.0) --
					 Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
					 Courant Institute, Argonne National Lab, and Rice University
					 October 31, 1999.
			*************************************************************************/
			public static bool rmatrixbdsvd(ref double[] d,
					double[] e,
					int n,
					bool isupper,
					bool isfractionalaccuracyrequired,
					ref double[,] u,
					int nru,
					ref double[,] c,
					int ncc,
					ref double[,] vt,
					int ncvt)
			{
				bool result = new bool();
				double[] d1 = new double[0];
				double[] e1 = new double[0];
				int i_ = 0;
				int i1_ = 0;

				e = (double[])e.Clone();

				d1 = new double[n + 1];
				i1_ = (0) - (1);
				for (i_ = 1; i_ <= n; i_++)
				{
					d1[i_] = d[i_ + i1_];
				}
				if (n > 1)
				{
					e1 = new double[n - 1 + 1];
					i1_ = (0) - (1);
					for (i_ = 1; i_ <= n - 1; i_++)
					{
						e1[i_] = e[i_ + i1_];
					}
				}
				result = bidiagonalsvddecompositioninternal(ref d1, e1, n, isupper, isfractionalaccuracyrequired, ref u, 0, nru, ref c, 0, ncc, ref vt, 0, ncvt);
				i1_ = (1) - (0);
				for (i_ = 0; i_ <= n - 1; i_++)
				{
					d[i_] = d1[i_ + i1_];
				}
				return result;
			}


			public static bool bidiagonalsvddecomposition(ref double[] d,
					double[] e,
					int n,
					bool isupper,
					bool isfractionalaccuracyrequired,
					ref double[,] u,
					int nru,
					ref double[,] c,
					int ncc,
					ref double[,] vt,
					int ncvt)
			{
				bool result = new bool();

				e = (double[])e.Clone();

				result = bidiagonalsvddecompositioninternal(ref d, e, n, isupper, isfractionalaccuracyrequired, ref u, 1, nru, ref c, 1, ncc, ref vt, 1, ncvt);
				return result;
			}


			/*************************************************************************
			Internal working subroutine for bidiagonal decomposition
			*************************************************************************/
			private static bool bidiagonalsvddecompositioninternal(ref double[] d,
					double[] e,
					int n,
					bool isupper,
					bool isfractionalaccuracyrequired,
					ref double[,] u,
					int ustart,
					int nru,
					ref double[,] c,
					int cstart,
					int ncc,
					ref double[,] vt,
					int vstart,
					int ncvt)
			{
				bool result = new bool();
				int i = 0;
				int idir = 0;
				int isub = 0;
				int iter = 0;
				int j = 0;
				int ll = 0;
				int lll = 0;
				int m = 0;
				int maxit = 0;
				int oldll = 0;
				int oldm = 0;
				double abse = 0;
				double abss = 0;
				double cosl = 0;
				double cosr = 0;
				double cs = 0;
				double eps = 0;
				double f = 0;
				double g = 0;
				double h = 0;
				double mu = 0;
				double oldcs = 0;
				double oldsn = 0;
				double r = 0;
				double shift = 0;
				double sigmn = 0;
				double sigmx = 0;
				double sinl = 0;
				double sinr = 0;
				double sll = 0;
				double smax = 0;
				double smin = 0;
				double sminl = 0;
				double sminoa = 0;
				double sn = 0;
				double thresh = 0;
				double tol = 0;
				double tolmul = 0;
				double unfl = 0;
				double[] work0 = new double[0];
				double[] work1 = new double[0];
				double[] work2 = new double[0];
				double[] work3 = new double[0];
				int maxitr = 0;
				bool matrixsplitflag = new bool();
				bool iterflag = new bool();
				double[] utemp = new double[0];
				double[] vttemp = new double[0];
				double[] ctemp = new double[0];
				double[] etemp = new double[0];
				bool fwddir = new bool();
				double tmp = 0;
				int mm1 = 0;
				int mm0 = 0;
				bool bchangedir = new bool();
				int uend = 0;
				int cend = 0;
				int vend = 0;
				int i_ = 0;

				e = (double[])e.Clone();

				result = true;
				if (n == 0)
				{
					return result;
				}
				if (n == 1)
				{
					if ((double)(d[1]) < (double)(0))
					{
						d[1] = -d[1];
						if (ncvt > 0)
						{
							for (i_ = vstart; i_ <= vstart + ncvt - 1; i_++)
							{
								vt[vstart, i_] = -1 * vt[vstart, i_];
							}
						}
					}
					return result;
				}

				//
				// these initializers are not really necessary,
				// but without them compiler complains about uninitialized locals
				//
				ll = 0;
				oldsn = 0;

				//
				// init
				//
				work0 = new double[n - 1 + 1];
				work1 = new double[n - 1 + 1];
				work2 = new double[n - 1 + 1];
				work3 = new double[n - 1 + 1];
				uend = ustart + Math.Max(nru - 1, 0);
				vend = vstart + Math.Max(ncvt - 1, 0);
				cend = cstart + Math.Max(ncc - 1, 0);
				utemp = new double[uend + 1];
				vttemp = new double[vend + 1];
				ctemp = new double[cend + 1];
				maxitr = 12;
				fwddir = true;

				//
				// resize E from N-1 to N
				//
				etemp = new double[n + 1];
				for (i = 1; i <= n - 1; i++)
				{
					etemp[i] = e[i];
				}
				e = new double[n + 1];
				for (i = 1; i <= n - 1; i++)
				{
					e[i] = etemp[i];
				}
				e[n] = 0;
				idir = 0;

				//
				// Get machine constants
				//
				eps = math.machineepsilon;
				unfl = math.minrealnumber;

				//
				// If matrix lower bidiagonal, rotate to be upper bidiagonal
				// by applying Givens rotations on the left
				//
				if (!isupper)
				{
					for (i = 1; i <= n - 1; i++)
					{
						rotations.generaterotation(d[i], e[i], ref cs, ref sn, ref r);
						d[i] = r;
						e[i] = sn * d[i + 1];
						d[i + 1] = cs * d[i + 1];
						work0[i] = cs;
						work1[i] = sn;
					}

					//
					// Update singular vectors if desired
					//
					if (nru > 0)
					{
						rotations.applyrotationsfromtheright(fwddir, ustart, uend, 1 + ustart - 1, n + ustart - 1, work0, work1, ref u, ref utemp);
					}
					if (ncc > 0)
					{
						rotations.applyrotationsfromtheleft(fwddir, 1 + cstart - 1, n + cstart - 1, cstart, cend, work0, work1, ref c, ref ctemp);
					}
				}

				//
				// Compute singular values to relative accuracy TOL
				// (By setting TOL to be negative, algorithm will compute
				// singular values to absolute accuracy ABS(TOL)*norm(input matrix))
				//
				tolmul = (double)(Math.Max(10, Math.Min(100, Math.Pow(eps, -0.125f))));
				tol = tolmul * eps;

				//
				// Compute approximate maximum, minimum singular values
				//
				smax = 0;
				for (i = 1; i <= n; i++)
				{
					smax = Math.Max(smax, Math.Abs(d[i]));
				}
				for (i = 1; i <= n - 1; i++)
				{
					smax = Math.Max(smax, Math.Abs(e[i]));
				}
				sminl = 0;
				if ((double)(tol) >= (double)(0))
				{

					//
					// Relative accuracy desired
					//
					sminoa = Math.Abs(d[1]);
					if ((double)(sminoa) != (double)(0))
					{
						mu = sminoa;
						for (i = 2; i <= n; i++)
						{
							mu = Math.Abs(d[i]) * (mu / (mu + Math.Abs(e[i - 1])));
							sminoa = Math.Min(sminoa, mu);
							if ((double)(sminoa) == (double)(0))
							{
								break;
							}
						}
					}
					sminoa = (double)(sminoa / Math.Sqrt(n));
					thresh = Math.Max(tol * sminoa, maxitr * n * n * unfl);
				}
				else
				{

					//
					// Absolute accuracy desired
					//
					thresh = Math.Max(Math.Abs(tol) * smax, maxitr * n * n * unfl);
				}

				//
				// Prepare for main iteration loop for the singular values
				// (MAXIT is the maximum number of passes through the inner
				// loop permitted before nonconvergence signalled.)
				//
				maxit = maxitr * n * n;
				iter = 0;
				oldll = -1;
				oldm = -1;

				//
				// M points to last element of unconverged part of matrix
				//
				m = n;

				//
				// Begin main iteration loop
				//
				while (true)
				{

					//
					// Check for convergence or exceeding iteration count
					//
					if (m <= 1)
					{
						break;
					}
					if (iter > maxit)
					{
						result = false;
						return result;
					}

					//
					// Find diagonal block of matrix to work on
					//
					if ((double)(tol) < (double)(0) && (double)(Math.Abs(d[m])) <= (double)(thresh))
					{
						d[m] = 0;
					}
					smax = Math.Abs(d[m]);
					smin = smax;
					matrixsplitflag = false;
					for (lll = 1; lll <= m - 1; lll++)
					{
						ll = m - lll;
						abss = Math.Abs(d[ll]);
						abse = Math.Abs(e[ll]);
						if ((double)(tol) < (double)(0) && (double)(abss) <= (double)(thresh))
						{
							d[ll] = 0;
						}
						if ((double)(abse) <= (double)(thresh))
						{
							matrixsplitflag = true;
							break;
						}
						smin = Math.Min(smin, abss);
						smax = Math.Max(smax, Math.Max(abss, abse));
					}
					if (!matrixsplitflag)
					{
						ll = 0;
					}
					else
					{

						//
						// Matrix splits since E(LL) = 0
						//
						e[ll] = 0;
						if (ll == m - 1)
						{

							//
							// Convergence of bottom singular value, return to top of loop
							//
							m = m - 1;
							continue;
						}
					}
					ll = ll + 1;

					//
					// E(LL) through E(M-1) are nonzero, E(LL-1) is zero
					//
					if (ll == m - 1)
					{

						//
						// 2 by 2 block, handle separately
						//
						svdv2x2(d[m - 1], e[m - 1], d[m], ref sigmn, ref sigmx, ref sinr, ref cosr, ref sinl, ref cosl);
						d[m - 1] = sigmx;
						e[m - 1] = 0;
						d[m] = sigmn;

						//
						// Compute singular vectors, if desired
						//
						if (ncvt > 0)
						{
							mm0 = m + (vstart - 1);
							mm1 = m - 1 + (vstart - 1);
							for (i_ = vstart; i_ <= vend; i_++)
							{
								vttemp[i_] = cosr * vt[mm1, i_];
							}
							for (i_ = vstart; i_ <= vend; i_++)
							{
								vttemp[i_] = vttemp[i_] + sinr * vt[mm0, i_];
							}
							for (i_ = vstart; i_ <= vend; i_++)
							{
								vt[mm0, i_] = cosr * vt[mm0, i_];
							}
							for (i_ = vstart; i_ <= vend; i_++)
							{
								vt[mm0, i_] = vt[mm0, i_] - sinr * vt[mm1, i_];
							}
							for (i_ = vstart; i_ <= vend; i_++)
							{
								vt[mm1, i_] = vttemp[i_];
							}
						}
						if (nru > 0)
						{
							mm0 = m + ustart - 1;
							mm1 = m - 1 + ustart - 1;
							for (i_ = ustart; i_ <= uend; i_++)
							{
								utemp[i_] = cosl * u[i_, mm1];
							}
							for (i_ = ustart; i_ <= uend; i_++)
							{
								utemp[i_] = utemp[i_] + sinl * u[i_, mm0];
							}
							for (i_ = ustart; i_ <= uend; i_++)
							{
								u[i_, mm0] = cosl * u[i_, mm0];
							}
							for (i_ = ustart; i_ <= uend; i_++)
							{
								u[i_, mm0] = u[i_, mm0] - sinl * u[i_, mm1];
							}
							for (i_ = ustart; i_ <= uend; i_++)
							{
								u[i_, mm1] = utemp[i_];
							}
						}
						if (ncc > 0)
						{
							mm0 = m + cstart - 1;
							mm1 = m - 1 + cstart - 1;
							for (i_ = cstart; i_ <= cend; i_++)
							{
								ctemp[i_] = cosl * c[mm1, i_];
							}
							for (i_ = cstart; i_ <= cend; i_++)
							{
								ctemp[i_] = ctemp[i_] + sinl * c[mm0, i_];
							}
							for (i_ = cstart; i_ <= cend; i_++)
							{
								c[mm0, i_] = cosl * c[mm0, i_];
							}
							for (i_ = cstart; i_ <= cend; i_++)
							{
								c[mm0, i_] = c[mm0, i_] - sinl * c[mm1, i_];
							}
							for (i_ = cstart; i_ <= cend; i_++)
							{
								c[mm1, i_] = ctemp[i_];
							}
						}
						m = m - 2;
						continue;
					}

					//
					// If working on new submatrix, choose shift direction
					// (from larger end diagonal element towards smaller)
					//
					// Previously was
					//     "if (LL>OLDM) or (M<OLDLL) then"
					// fixed thanks to Michael Rolle < m@rolle.name >
					// Very strange that LAPACK still contains it.
					//
					bchangedir = false;
					if (idir == 1 && (double)(Math.Abs(d[ll])) < (double)(1.0E-3 * Math.Abs(d[m])))
					{
						bchangedir = true;
					}
					if (idir == 2 && (double)(Math.Abs(d[m])) < (double)(1.0E-3 * Math.Abs(d[ll])))
					{
						bchangedir = true;
					}
					if ((ll != oldll || m != oldm) || bchangedir)
					{
						if ((double)(Math.Abs(d[ll])) >= (double)(Math.Abs(d[m])))
						{

							//
							// Chase bulge from top (big end) to bottom (small end)
							//
							idir = 1;
						}
						else
						{

							//
							// Chase bulge from bottom (big end) to top (small end)
							//
							idir = 2;
						}
					}

					//
					// Apply convergence tests
					//
					if (idir == 1)
					{

						//
						// Run convergence test in forward direction
						// First apply standard test to bottom of matrix
						//
						if ((double)(Math.Abs(e[m - 1])) <= (double)(Math.Abs(tol) * Math.Abs(d[m])) || ((double)(tol) < (double)(0) && (double)(Math.Abs(e[m - 1])) <= (double)(thresh)))
						{
							e[m - 1] = 0;
							continue;
						}
						if ((double)(tol) >= (double)(0))
						{

							//
							// If relative accuracy desired,
							// apply convergence criterion forward
							//
							mu = Math.Abs(d[ll]);
							sminl = mu;
							iterflag = false;
							for (lll = ll; lll <= m - 1; lll++)
							{
								if ((double)(Math.Abs(e[lll])) <= (double)(tol * mu))
								{
									e[lll] = 0;
									iterflag = true;
									break;
								}
								mu = Math.Abs(d[lll + 1]) * (mu / (mu + Math.Abs(e[lll])));
								sminl = Math.Min(sminl, mu);
							}
							if (iterflag)
							{
								continue;
							}
						}
					}
					else
					{

						//
						// Run convergence test in backward direction
						// First apply standard test to top of matrix
						//
						if ((double)(Math.Abs(e[ll])) <= (double)(Math.Abs(tol) * Math.Abs(d[ll])) || ((double)(tol) < (double)(0) && (double)(Math.Abs(e[ll])) <= (double)(thresh)))
						{
							e[ll] = 0;
							continue;
						}
						if ((double)(tol) >= (double)(0))
						{

							//
							// If relative accuracy desired,
							// apply convergence criterion backward
							//
							mu = Math.Abs(d[m]);
							sminl = mu;
							iterflag = false;
							for (lll = m - 1; lll >= ll; lll--)
							{
								if ((double)(Math.Abs(e[lll])) <= (double)(tol * mu))
								{
									e[lll] = 0;
									iterflag = true;
									break;
								}
								mu = Math.Abs(d[lll]) * (mu / (mu + Math.Abs(e[lll])));
								sminl = Math.Min(sminl, mu);
							}
							if (iterflag)
							{
								continue;
							}
						}
					}
					oldll = ll;
					oldm = m;

					//
					// Compute shift.  First, test if shifting would ruin relative
					// accuracy, and if so set the shift to zero.
					//
					if ((double)(tol) >= (double)(0) && (double)(n * tol * (sminl / smax)) <= (double)(Math.Max(eps, 0.01 * tol)))
					{

						//
						// Use a zero shift to avoid loss of relative accuracy
						//
						shift = 0;
					}
					else
					{

						//
						// Compute the shift from 2-by-2 block at end of matrix
						//
						if (idir == 1)
						{
							sll = Math.Abs(d[ll]);
							svd2x2(d[m - 1], e[m - 1], d[m], ref shift, ref r);
						}
						else
						{
							sll = Math.Abs(d[m]);
							svd2x2(d[ll], e[ll], d[ll + 1], ref shift, ref r);
						}

						//
						// Test if shift negligible, and if so set to zero
						//
						if ((double)(sll) > (double)(0))
						{
							if ((double)(math.sqr(shift / sll)) < (double)(eps))
							{
								shift = 0;
							}
						}
					}

					//
					// Increment iteration count
					//
					iter = iter + m - ll;

					//
					// If SHIFT = 0, do simplified QR iteration
					//
					if ((double)(shift) == (double)(0))
					{
						if (idir == 1)
						{

							//
							// Chase bulge from top to bottom
							// Save cosines and sines for later singular vector updates
							//
							cs = 1;
							oldcs = 1;
							for (i = ll; i <= m - 1; i++)
							{
								rotations.generaterotation(d[i] * cs, e[i], ref cs, ref sn, ref r);
								if (i > ll)
								{
									e[i - 1] = oldsn * r;
								}
								rotations.generaterotation(oldcs * r, d[i + 1] * sn, ref oldcs, ref oldsn, ref tmp);
								d[i] = tmp;
								work0[i - ll + 1] = cs;
								work1[i - ll + 1] = sn;
								work2[i - ll + 1] = oldcs;
								work3[i - ll + 1] = oldsn;
							}
							h = d[m] * cs;
							d[m] = h * oldcs;
							e[m - 1] = h * oldsn;

							//
							// Update singular vectors
							//
							if (ncvt > 0)
							{
								rotations.applyrotationsfromtheleft(fwddir, ll + vstart - 1, m + vstart - 1, vstart, vend, work0, work1, ref vt, ref vttemp);
							}
							if (nru > 0)
							{
								rotations.applyrotationsfromtheright(fwddir, ustart, uend, ll + ustart - 1, m + ustart - 1, work2, work3, ref u, ref utemp);
							}
							if (ncc > 0)
							{
								rotations.applyrotationsfromtheleft(fwddir, ll + cstart - 1, m + cstart - 1, cstart, cend, work2, work3, ref c, ref ctemp);
							}

							//
							// Test convergence
							//
							if ((double)(Math.Abs(e[m - 1])) <= (double)(thresh))
							{
								e[m - 1] = 0;
							}
						}
						else
						{

							//
							// Chase bulge from bottom to top
							// Save cosines and sines for later singular vector updates
							//
							cs = 1;
							oldcs = 1;
							for (i = m; i >= ll + 1; i--)
							{
								rotations.generaterotation(d[i] * cs, e[i - 1], ref cs, ref sn, ref r);
								if (i < m)
								{
									e[i] = oldsn * r;
								}
								rotations.generaterotation(oldcs * r, d[i - 1] * sn, ref oldcs, ref oldsn, ref tmp);
								d[i] = tmp;
								work0[i - ll] = cs;
								work1[i - ll] = -sn;
								work2[i - ll] = oldcs;
								work3[i - ll] = -oldsn;
							}
							h = d[ll] * cs;
							d[ll] = h * oldcs;
							e[ll] = h * oldsn;

							//
							// Update singular vectors
							//
							if (ncvt > 0)
							{
								rotations.applyrotationsfromtheleft(!fwddir, ll + vstart - 1, m + vstart - 1, vstart, vend, work2, work3, ref vt, ref vttemp);
							}
							if (nru > 0)
							{
								rotations.applyrotationsfromtheright(!fwddir, ustart, uend, ll + ustart - 1, m + ustart - 1, work0, work1, ref u, ref utemp);
							}
							if (ncc > 0)
							{
								rotations.applyrotationsfromtheleft(!fwddir, ll + cstart - 1, m + cstart - 1, cstart, cend, work0, work1, ref c, ref ctemp);
							}

							//
							// Test convergence
							//
							if ((double)(Math.Abs(e[ll])) <= (double)(thresh))
							{
								e[ll] = 0;
							}
						}
					}
					else
					{

						//
						// Use nonzero shift
						//
						if (idir == 1)
						{

							//
							// Chase bulge from top to bottom
							// Save cosines and sines for later singular vector updates
							//
							f = (Math.Abs(d[ll]) - shift) * (extsignbdsqr(1, d[ll]) + shift / d[ll]);
							g = e[ll];
							for (i = ll; i <= m - 1; i++)
							{
								rotations.generaterotation(f, g, ref cosr, ref sinr, ref r);
								if (i > ll)
								{
									e[i - 1] = r;
								}
								f = cosr * d[i] + sinr * e[i];
								e[i] = cosr * e[i] - sinr * d[i];
								g = sinr * d[i + 1];
								d[i + 1] = cosr * d[i + 1];
								rotations.generaterotation(f, g, ref cosl, ref sinl, ref r);
								d[i] = r;
								f = cosl * e[i] + sinl * d[i + 1];
								d[i + 1] = cosl * d[i + 1] - sinl * e[i];
								if (i < m - 1)
								{
									g = sinl * e[i + 1];
									e[i + 1] = cosl * e[i + 1];
								}
								work0[i - ll + 1] = cosr;
								work1[i - ll + 1] = sinr;
								work2[i - ll + 1] = cosl;
								work3[i - ll + 1] = sinl;
							}
							e[m - 1] = f;

							//
							// Update singular vectors
							//
							if (ncvt > 0)
							{
								rotations.applyrotationsfromtheleft(fwddir, ll + vstart - 1, m + vstart - 1, vstart, vend, work0, work1, ref vt, ref vttemp);
							}
							if (nru > 0)
							{
								rotations.applyrotationsfromtheright(fwddir, ustart, uend, ll + ustart - 1, m + ustart - 1, work2, work3, ref u, ref utemp);
							}
							if (ncc > 0)
							{
								rotations.applyrotationsfromtheleft(fwddir, ll + cstart - 1, m + cstart - 1, cstart, cend, work2, work3, ref c, ref ctemp);
							}

							//
							// Test convergence
							//
							if ((double)(Math.Abs(e[m - 1])) <= (double)(thresh))
							{
								e[m - 1] = 0;
							}
						}
						else
						{

							//
							// Chase bulge from bottom to top
							// Save cosines and sines for later singular vector updates
							//
							f = (Math.Abs(d[m]) - shift) * (extsignbdsqr(1, d[m]) + shift / d[m]);
							g = e[m - 1];
							for (i = m; i >= ll + 1; i--)
							{
								rotations.generaterotation(f, g, ref cosr, ref sinr, ref r);
								if (i < m)
								{
									e[i] = r;
								}
								f = cosr * d[i] + sinr * e[i - 1];
								e[i - 1] = cosr * e[i - 1] - sinr * d[i];
								g = sinr * d[i - 1];
								d[i - 1] = cosr * d[i - 1];
								rotations.generaterotation(f, g, ref cosl, ref sinl, ref r);
								d[i] = r;
								f = cosl * e[i - 1] + sinl * d[i - 1];
								d[i - 1] = cosl * d[i - 1] - sinl * e[i - 1];
								if (i > ll + 1)
								{
									g = sinl * e[i - 2];
									e[i - 2] = cosl * e[i - 2];
								}
								work0[i - ll] = cosr;
								work1[i - ll] = -sinr;
								work2[i - ll] = cosl;
								work3[i - ll] = -sinl;
							}
							e[ll] = f;

							//
							// Test convergence
							//
							if ((double)(Math.Abs(e[ll])) <= (double)(thresh))
							{
								e[ll] = 0;
							}

							//
							// Update singular vectors if desired
							//
							if (ncvt > 0)
							{
								rotations.applyrotationsfromtheleft(!fwddir, ll + vstart - 1, m + vstart - 1, vstart, vend, work2, work3, ref vt, ref vttemp);
							}
							if (nru > 0)
							{
								rotations.applyrotationsfromtheright(!fwddir, ustart, uend, ll + ustart - 1, m + ustart - 1, work0, work1, ref u, ref utemp);
							}
							if (ncc > 0)
							{
								rotations.applyrotationsfromtheleft(!fwddir, ll + cstart - 1, m + cstart - 1, cstart, cend, work0, work1, ref c, ref ctemp);
							}
						}
					}

					//
					// QR iteration finished, go back and check convergence
					//
					continue;
				}

				//
				// All singular values converged, so make them positive
				//
				for (i = 1; i <= n; i++)
				{
					if ((double)(d[i]) < (double)(0))
					{
						d[i] = -d[i];

						//
						// Change sign of singular vectors, if desired
						//
						if (ncvt > 0)
						{
							for (i_ = vstart; i_ <= vend; i_++)
							{
								vt[i + vstart - 1, i_] = -1 * vt[i + vstart - 1, i_];
							}
						}
					}
				}

				//
				// Sort the singular values into decreasing order (insertion sort on
				// singular values, but only one transposition per singular vector)
				//
				for (i = 1; i <= n - 1; i++)
				{

					//
					// Scan for smallest D(I)
					//
					isub = 1;
					smin = d[1];
					for (j = 2; j <= n + 1 - i; j++)
					{
						if ((double)(d[j]) <= (double)(smin))
						{
							isub = j;
							smin = d[j];
						}
					}
					if (isub != n + 1 - i)
					{

						//
						// Swap singular values and vectors
						//
						d[isub] = d[n + 1 - i];
						d[n + 1 - i] = smin;
						if (ncvt > 0)
						{
							j = n + 1 - i;
							for (i_ = vstart; i_ <= vend; i_++)
							{
								vttemp[i_] = vt[isub + vstart - 1, i_];
							}
							for (i_ = vstart; i_ <= vend; i_++)
							{
								vt[isub + vstart - 1, i_] = vt[j + vstart - 1, i_];
							}
							for (i_ = vstart; i_ <= vend; i_++)
							{
								vt[j + vstart - 1, i_] = vttemp[i_];
							}
						}
						if (nru > 0)
						{
							j = n + 1 - i;
							for (i_ = ustart; i_ <= uend; i_++)
							{
								utemp[i_] = u[i_, isub + ustart - 1];
							}
							for (i_ = ustart; i_ <= uend; i_++)
							{
								u[i_, isub + ustart - 1] = u[i_, j + ustart - 1];
							}
							for (i_ = ustart; i_ <= uend; i_++)
							{
								u[i_, j + ustart - 1] = utemp[i_];
							}
						}
						if (ncc > 0)
						{
							j = n + 1 - i;
							for (i_ = cstart; i_ <= cend; i_++)
							{
								ctemp[i_] = c[isub + cstart - 1, i_];
							}
							for (i_ = cstart; i_ <= cend; i_++)
							{
								c[isub + cstart - 1, i_] = c[j + cstart - 1, i_];
							}
							for (i_ = cstart; i_ <= cend; i_++)
							{
								c[j + cstart - 1, i_] = ctemp[i_];
							}
						}
					}
				}
				return result;
			}


			private static double extsignbdsqr(double a,
					double b)
			{
				double result = 0;

				if ((double)(b) >= (double)(0))
				{
					result = Math.Abs(a);
				}
				else
				{
					result = -Math.Abs(a);
				}
				return result;
			}


			private static void svd2x2(double f,
					double g,
					double h,
					ref double ssmin,
					ref double ssmax)
			{
				double aas = 0;
				double at = 0;
				double au = 0;
				double c = 0;
				double fa = 0;
				double fhmn = 0;
				double fhmx = 0;
				double ga = 0;
				double ha = 0;

				ssmin = 0;
				ssmax = 0;

				fa = Math.Abs(f);
				ga = Math.Abs(g);
				ha = Math.Abs(h);
				fhmn = Math.Min(fa, ha);
				fhmx = Math.Max(fa, ha);
				if ((double)(fhmn) == (double)(0))
				{
					ssmin = 0;
					if ((double)(fhmx) == (double)(0))
					{
						ssmax = ga;
					}
					else
					{
						ssmax = (double)(Math.Max(fhmx, ga) * Math.Sqrt(1 + math.sqr(Math.Min(fhmx, ga) / Math.Max(fhmx, ga))));
					}
				}
				else
				{
					if ((double)(ga) < (double)(fhmx))
					{
						aas = 1 + fhmn / fhmx;
						at = (fhmx - fhmn) / fhmx;
						au = math.sqr(ga / fhmx);
						c = (double)(2 / (Math.Sqrt(aas * aas + au) + Math.Sqrt(at * at + au)));
						ssmin = fhmn * c;
						ssmax = fhmx / c;
					}
					else
					{
						au = fhmx / ga;
						if ((double)(au) == (double)(0))
						{

							//
							// Avoid possible harmful underflow if exponent range
							// asymmetric (true SSMIN may not underflow even if
							// AU underflows)
							//
							ssmin = fhmn * fhmx / ga;
							ssmax = ga;
						}
						else
						{
							aas = 1 + fhmn / fhmx;
							at = (fhmx - fhmn) / fhmx;
							c = (double)(1 / (Math.Sqrt(1 + math.sqr(aas * au)) + Math.Sqrt(1 + math.sqr(at * au))));
							ssmin = fhmn * c * au;
							ssmin = ssmin + ssmin;
							ssmax = ga / (c + c);
						}
					}
				}
			}


			private static void svdv2x2(double f,
					double g,
					double h,
					ref double ssmin,
					ref double ssmax,
					ref double snr,
					ref double csr,
					ref double snl,
					ref double csl)
			{
				bool gasmal = new bool();
				bool swp = new bool();
				int pmax = 0;
				double a = 0;
				double clt = 0;
				double crt = 0;
				double d = 0;
				double fa = 0;
				double ft = 0;
				double ga = 0;
				double gt = 0;
				double ha = 0;
				double ht = 0;
				double l = 0;
				double m = 0;
				double mm = 0;
				double r = 0;
				double s = 0;
				double slt = 0;
				double srt = 0;
				double t = 0;
				double temp = 0;
				double tsign = 0;
				double tt = 0;
				double v = 0;

				ssmin = 0;
				ssmax = 0;
				snr = 0;
				csr = 0;
				snl = 0;
				csl = 0;

				ft = f;
				fa = Math.Abs(ft);
				ht = h;
				ha = Math.Abs(h);

				//
				// these initializers are not really necessary,
				// but without them compiler complains about uninitialized locals
				//
				clt = 0;
				crt = 0;
				slt = 0;
				srt = 0;
				tsign = 0;

				//
				// PMAX points to the maximum absolute element of matrix
				//  PMAX = 1 if F largest in absolute values
				//  PMAX = 2 if G largest in absolute values
				//  PMAX = 3 if H largest in absolute values
				//
				pmax = 1;
				swp = (double)(ha) > (double)(fa);
				if (swp)
				{

					//
					// Now FA .ge. HA
					//
					pmax = 3;
					temp = ft;
					ft = ht;
					ht = temp;
					temp = fa;
					fa = ha;
					ha = temp;
				}
				gt = g;
				ga = Math.Abs(gt);
				if ((double)(ga) == (double)(0))
				{

					//
					// Diagonal matrix
					//
					ssmin = ha;
					ssmax = fa;
					clt = 1;
					crt = 1;
					slt = 0;
					srt = 0;
				}
				else
				{
					gasmal = true;
					if ((double)(ga) > (double)(fa))
					{
						pmax = 2;
						if ((double)(fa / ga) < (double)(math.machineepsilon))
						{

							//
							// Case of very large GA
							//
							gasmal = false;
							ssmax = ga;
							if ((double)(ha) > (double)(1))
							{
								v = ga / ha;
								ssmin = fa / v;
							}
							else
							{
								v = fa / ga;
								ssmin = v * ha;
							}
							clt = 1;
							slt = ht / gt;
							srt = 1;
							crt = ft / gt;
						}
					}
					if (gasmal)
					{

						//
						// Normal case
						//
						d = fa - ha;
						if ((double)(d) == (double)(fa))
						{
							l = 1;
						}
						else
						{
							l = d / fa;
						}
						m = gt / ft;
						t = 2 - l;
						mm = m * m;
						tt = t * t;
						s = (double)(Math.Sqrt(tt + mm));
						if ((double)(l) == (double)(0))
						{
							r = (double)Math.Abs(m);
						}
						else
						{
							r = (double)Math.Sqrt(l * l + mm);
						}
						a = 0.5f * (s + r);
						ssmin = ha / a;
						ssmax = fa * a;
						if ((double)(mm) == (double)(0))
						{

							//
							// Note that M is very tiny
							//
							if ((double)(l) == (double)(0))
							{
								t = extsignbdsqr(2, ft) * extsignbdsqr(1, gt);
							}
							else
							{
								t = gt / extsignbdsqr(d, ft) + m / t;
							}
						}
						else
						{
							t = (m / (s + t) + m / (r + l)) * (1 + a);
						}
						l = (double)Math.Sqrt(t * t + 4);
						crt = 2 / l;
						srt = t / l;
						clt = (crt + srt * m) / a;
						v = ht / ft;
						slt = v * srt / a;
					}
				}
				if (swp)
				{
					csl = srt;
					snl = crt;
					csr = slt;
					snr = clt;
				}
				else
				{
					csl = clt;
					snl = slt;
					csr = crt;
					snr = srt;
				}

				//
				// Correct signs of SSMAX and SSMIN
				//
				if (pmax == 1)
				{
					tsign = extsignbdsqr(1, csr) * extsignbdsqr(1, csl) * extsignbdsqr(1, f);
				}
				if (pmax == 2)
				{
					tsign = extsignbdsqr(1, snr) * extsignbdsqr(1, csl) * extsignbdsqr(1, g);
				}
				if (pmax == 3)
				{
					tsign = extsignbdsqr(1, snr) * extsignbdsqr(1, snl) * extsignbdsqr(1, h);
				}
				ssmax = extsignbdsqr(ssmax, tsign);
				ssmin = extsignbdsqr(ssmin, tsign * extsignbdsqr(1, f) * extsignbdsqr(1, h));
			}


		}
		public class svd
		{
			/*************************************************************************
			Singular value decomposition of a rectangular matrix.

			The algorithm calculates the singular value decomposition of a matrix of
			size MxN: A = U * S * V^T

			The algorithm finds the singular values and, optionally, matrices U and V^T.
			The algorithm can find both first min(M,N) columns of matrix U and rows of
			matrix V^T (singular vectors), and matrices U and V^T wholly (of sizes MxM
			and NxN respectively).

			Take into account that the subroutine does not return matrix V but V^T.

			Input parameters:
					A           -   matrix to be decomposed.
													Array whose indexes range within [0..M-1, 0..N-1].
					M           -   number of rows in matrix A.
					N           -   number of columns in matrix A.
					UNeeded     -   0, 1 or 2. See the description of the parameter U.
					VTNeeded    -   0, 1 or 2. See the description of the parameter VT.
					AdditionalMemory -
													If the parameter:
													 * equals 0, the algorithm doesn’t use additional
														 memory (lower requirements, lower performance).
													 * equals 1, the algorithm uses additional
														 memory of size min(M,N)*min(M,N) of real numbers.
														 It often speeds up the algorithm.
													 * equals 2, the algorithm uses additional
														 memory of size M*min(M,N) of real numbers.
														 It allows to get a maximum performance.
													The recommended value of the parameter is 2.

			Output parameters:
					W           -   contains singular values in descending order.
					U           -   if UNeeded=0, U isn't changed, the left singular vectors
													are not calculated.
													if Uneeded=1, U contains left singular vectors (first
													min(M,N) columns of matrix U). Array whose indexes range
													within [0..M-1, 0..Min(M,N)-1].
													if UNeeded=2, U contains matrix U wholly. Array whose
													indexes range within [0..M-1, 0..M-1].
					VT          -   if VTNeeded=0, VT isn’t changed, the right singular vectors
													are not calculated.
													if VTNeeded=1, VT contains right singular vectors (first
													min(M,N) rows of matrix V^T). Array whose indexes range
													within [0..min(M,N)-1, 0..N-1].
													if VTNeeded=2, VT contains matrix V^T wholly. Array whose
													indexes range within [0..N-1, 0..N-1].

				-- ALGLIB --
					 Copyright 2005 by Bochkanov Sergey
			*************************************************************************/
			public static bool rmatrixsvd(double[,] a,
					int m,
					int n,
					int uneeded,
					int vtneeded,
					int additionalmemory,
					ref double[] w,
					ref double[,] u,
					ref double[,] vt)
			{
				bool result = new bool();
				double[] tauq = new double[0];
				double[] taup = new double[0];
				double[] tau = new double[0];
				double[] e = new double[0];
				double[] work = new double[0];
				double[,] t2 = new double[0, 0];
				bool isupper = new bool();
				int minmn = 0;
				int ncu = 0;
				int nrvt = 0;
				int nru = 0;
				int ncvt = 0;
				int i = 0;
				int j = 0;

				a = (double[,])a.Clone();
				w = new double[0];
				u = new double[0, 0];
				vt = new double[0, 0];

				result = true;
				if (m == 0 || n == 0)
				{
					return result;
				}
				alglib.ap.assert(uneeded >= 0 && uneeded <= 2, "SVDDecomposition: wrong parameters!");
				alglib.ap.assert(vtneeded >= 0 && vtneeded <= 2, "SVDDecomposition: wrong parameters!");
				alglib.ap.assert(additionalmemory >= 0 && additionalmemory <= 2, "SVDDecomposition: wrong parameters!");

				//
				// initialize
				//
				minmn = Math.Min(m, n);
				w = new double[minmn + 1];
				ncu = 0;
				nru = 0;
				if (uneeded == 1)
				{
					nru = m;
					ncu = minmn;
					u = new double[nru - 1 + 1, ncu - 1 + 1];
				}
				if (uneeded == 2)
				{
					nru = m;
					ncu = m;
					u = new double[nru - 1 + 1, ncu - 1 + 1];
				}
				nrvt = 0;
				ncvt = 0;
				if (vtneeded == 1)
				{
					nrvt = minmn;
					ncvt = n;
					vt = new double[nrvt - 1 + 1, ncvt - 1 + 1];
				}
				if (vtneeded == 2)
				{
					nrvt = n;
					ncvt = n;
					vt = new double[nrvt - 1 + 1, ncvt - 1 + 1];
				}

				//
				// M much larger than N
				// Use bidiagonal reduction with QR-decomposition
				//
				if ((double)(m) > (double)(1.6 * n))
				{
					if (uneeded == 0)
					{

						//
						// No left singular vectors to be computed
						//
						ortfac.rmatrixqr(ref a, m, n, ref tau);
						for (i = 0; i <= n - 1; i++)
						{
							for (j = 0; j <= i - 1; j++)
							{
								a[i, j] = 0;
							}
						}
						ortfac.rmatrixbd(ref a, n, n, ref tauq, ref taup);
						ortfac.rmatrixbdunpackpt(a, n, n, taup, nrvt, ref vt);
						ortfac.rmatrixbdunpackdiagonals(a, n, n, ref isupper, ref w, ref e);
						result = bdsvd.rmatrixbdsvd(ref w, e, n, isupper, false, ref u, 0, ref a, 0, ref vt, ncvt);
						return result;
					}
					else
					{

						//
						// Left singular vectors (may be full matrix U) to be computed
						//
						ortfac.rmatrixqr(ref a, m, n, ref tau);
						ortfac.rmatrixqrunpackq(a, m, n, tau, ncu, ref u);
						for (i = 0; i <= n - 1; i++)
						{
							for (j = 0; j <= i - 1; j++)
							{
								a[i, j] = 0;
							}
						}
						ortfac.rmatrixbd(ref a, n, n, ref tauq, ref taup);
						ortfac.rmatrixbdunpackpt(a, n, n, taup, nrvt, ref vt);
						ortfac.rmatrixbdunpackdiagonals(a, n, n, ref isupper, ref w, ref e);
						if (additionalmemory < 1)
						{

							//
							// No additional memory can be used
							//
							ortfac.rmatrixbdmultiplybyq(a, n, n, tauq, ref u, m, n, true, false);
							result = bdsvd.rmatrixbdsvd(ref w, e, n, isupper, false, ref u, m, ref a, 0, ref vt, ncvt);
						}
						else
						{

							//
							// Large U. Transforming intermediate matrix T2
							//
							work = new double[Math.Max(m, n) + 1];
							ortfac.rmatrixbdunpackq(a, n, n, tauq, n, ref t2);
							blas.copymatrix(u, 0, m - 1, 0, n - 1, ref a, 0, m - 1, 0, n - 1);
							blas.inplacetranspose(ref t2, 0, n - 1, 0, n - 1, ref work);
							result = bdsvd.rmatrixbdsvd(ref w, e, n, isupper, false, ref u, 0, ref t2, n, ref vt, ncvt);
							blas.matrixmatrixmultiply(a, 0, m - 1, 0, n - 1, false, t2, 0, n - 1, 0, n - 1, true, 1.0f, ref u, 0, m - 1, 0, n - 1, 0.0f, ref work);
						}
						return result;
					}
				}

				//
				// N much larger than M
				// Use bidiagonal reduction with LQ-decomposition
				//
				if ((double)(n) > (double)(1.6 * m))
				{
					if (vtneeded == 0)
					{

						//
						// No right singular vectors to be computed
						//
						ortfac.rmatrixlq(ref a, m, n, ref tau);
						for (i = 0; i <= m - 1; i++)
						{
							for (j = i + 1; j <= m - 1; j++)
							{
								a[i, j] = 0;
							}
						}
						ortfac.rmatrixbd(ref a, m, m, ref tauq, ref taup);
						ortfac.rmatrixbdunpackq(a, m, m, tauq, ncu, ref u);
						ortfac.rmatrixbdunpackdiagonals(a, m, m, ref isupper, ref w, ref e);
						work = new double[m + 1];
						blas.inplacetranspose(ref u, 0, nru - 1, 0, ncu - 1, ref work);
						result = bdsvd.rmatrixbdsvd(ref w, e, m, isupper, false, ref a, 0, ref u, nru, ref vt, 0);
						blas.inplacetranspose(ref u, 0, nru - 1, 0, ncu - 1, ref work);
						return result;
					}
					else
					{

						//
						// Right singular vectors (may be full matrix VT) to be computed
						//
						ortfac.rmatrixlq(ref a, m, n, ref tau);
						ortfac.rmatrixlqunpackq(a, m, n, tau, nrvt, ref vt);
						for (i = 0; i <= m - 1; i++)
						{
							for (j = i + 1; j <= m - 1; j++)
							{
								a[i, j] = 0;
							}
						}
						ortfac.rmatrixbd(ref a, m, m, ref tauq, ref taup);
						ortfac.rmatrixbdunpackq(a, m, m, tauq, ncu, ref u);
						ortfac.rmatrixbdunpackdiagonals(a, m, m, ref isupper, ref w, ref e);
						work = new double[Math.Max(m, n) + 1];
						blas.inplacetranspose(ref u, 0, nru - 1, 0, ncu - 1, ref work);
						if (additionalmemory < 1)
						{

							//
							// No additional memory available
							//
							ortfac.rmatrixbdmultiplybyp(a, m, m, taup, ref vt, m, n, false, true);
							result = bdsvd.rmatrixbdsvd(ref w, e, m, isupper, false, ref a, 0, ref u, nru, ref vt, n);
						}
						else
						{

							//
							// Large VT. Transforming intermediate matrix T2
							//
							ortfac.rmatrixbdunpackpt(a, m, m, taup, m, ref t2);
							result = bdsvd.rmatrixbdsvd(ref w, e, m, isupper, false, ref a, 0, ref u, nru, ref t2, m);
							blas.copymatrix(vt, 0, m - 1, 0, n - 1, ref a, 0, m - 1, 0, n - 1);
							blas.matrixmatrixmultiply(t2, 0, m - 1, 0, m - 1, false, a, 0, m - 1, 0, n - 1, false, 1.0f, ref vt, 0, m - 1, 0, n - 1, 0.0f, ref work);
						}
						blas.inplacetranspose(ref u, 0, nru - 1, 0, ncu - 1, ref work);
						return result;
					}
				}

				//
				// M<=N
				// We can use inplace transposition of U to get rid of columnwise operations
				//
				if (m <= n)
				{
					ortfac.rmatrixbd(ref a, m, n, ref tauq, ref taup);
					ortfac.rmatrixbdunpackq(a, m, n, tauq, ncu, ref u);
					ortfac.rmatrixbdunpackpt(a, m, n, taup, nrvt, ref vt);
					ortfac.rmatrixbdunpackdiagonals(a, m, n, ref isupper, ref w, ref e);
					work = new double[m + 1];
					blas.inplacetranspose(ref u, 0, nru - 1, 0, ncu - 1, ref work);
					result = bdsvd.rmatrixbdsvd(ref w, e, minmn, isupper, false, ref a, 0, ref u, nru, ref vt, ncvt);
					blas.inplacetranspose(ref u, 0, nru - 1, 0, ncu - 1, ref work);
					return result;
				}

				//
				// Simple bidiagonal reduction
				//
				ortfac.rmatrixbd(ref a, m, n, ref tauq, ref taup);
				ortfac.rmatrixbdunpackq(a, m, n, tauq, ncu, ref u);
				ortfac.rmatrixbdunpackpt(a, m, n, taup, nrvt, ref vt);
				ortfac.rmatrixbdunpackdiagonals(a, m, n, ref isupper, ref w, ref e);
				if (additionalmemory < 2 || uneeded == 0)
				{

					//
					// We cant use additional memory or there is no need in such operations
					//
					result = bdsvd.rmatrixbdsvd(ref w, e, minmn, isupper, false, ref u, nru, ref a, 0, ref vt, ncvt);
				}
				else
				{

					//
					// We can use additional memory
					//
					t2 = new double[minmn - 1 + 1, m - 1 + 1];
					blas.copyandtranspose(u, 0, m - 1, 0, minmn - 1, ref t2, 0, minmn - 1, 0, m - 1);
					result = bdsvd.rmatrixbdsvd(ref w, e, minmn, isupper, false, ref u, 0, ref t2, m, ref vt, ncvt);
					blas.copyandtranspose(t2, 0, minmn - 1, 0, m - 1, ref u, 0, m - 1, 0, minmn - 1);
				}
				return result;
			}


		}
		public class evd
		{
			/*************************************************************************
			Finding the eigenvalues and eigenvectors of a symmetric matrix

			The algorithm finds eigen pairs of a symmetric matrix by reducing it to
			tridiagonal form and using the QL/QR algorithm.

			Input parameters:
					A       -   symmetric matrix which is given by its upper or lower
											triangular part.
											Array whose indexes range within [0..N-1, 0..N-1].
					N       -   size of matrix A.
					ZNeeded -   flag controlling whether the eigenvectors are needed or not.
											If ZNeeded is equal to:
											 * 0, the eigenvectors are not returned;
											 * 1, the eigenvectors are returned.
					IsUpper -   storage format.

			Output parameters:
					D       -   eigenvalues in ascending order.
											Array whose index ranges within [0..N-1].
					Z       -   if ZNeeded is equal to:
											 * 0, Z hasn’t changed;
											 * 1, Z contains the eigenvectors.
											Array whose indexes range within [0..N-1, 0..N-1].
											The eigenvectors are stored in the matrix columns.

			Result:
					True, if the algorithm has converged.
					False, if the algorithm hasn't converged (rare case).

				-- ALGLIB --
					 Copyright 2005-2008 by Bochkanov Sergey
			*************************************************************************/
			public static bool smatrixevd(double[,] a,
					int n,
					int zneeded,
					bool isupper,
					ref double[] d,
					ref double[,] z)
			{
				bool result = new bool();
				double[] tau = new double[0];
				double[] e = new double[0];

				a = (double[,])a.Clone();
				d = new double[0];
				z = new double[0, 0];

				alglib.ap.assert(zneeded == 0 || zneeded == 1, "SMatrixEVD: incorrect ZNeeded");
				ortfac.smatrixtd(ref a, n, isupper, ref tau, ref d, ref e);
				if (zneeded == 1)
				{
					ortfac.smatrixtdunpackq(a, n, isupper, tau, ref z);
				}
				result = smatrixtdevd(ref d, e, n, zneeded, ref z);
				return result;
			}


			/*************************************************************************
			Subroutine for finding the eigenvalues (and eigenvectors) of  a  symmetric
			matrix  in  a  given half open interval (A, B] by using  a  bisection  and
			inverse iteration

			Input parameters:
					A       -   symmetric matrix which is given by its upper or lower
											triangular part. Array [0..N-1, 0..N-1].
					N       -   size of matrix A.
					ZNeeded -   flag controlling whether the eigenvectors are needed or not.
											If ZNeeded is equal to:
											 * 0, the eigenvectors are not returned;
											 * 1, the eigenvectors are returned.
					IsUpperA -  storage format of matrix A.
					B1, B2 -    half open interval (B1, B2] to search eigenvalues in.

			Output parameters:
					M       -   number of eigenvalues found in a given half-interval (M>=0).
					W       -   array of the eigenvalues found.
											Array whose index ranges within [0..M-1].
					Z       -   if ZNeeded is equal to:
											 * 0, Z hasn’t changed;
											 * 1, Z contains eigenvectors.
											Array whose indexes range within [0..N-1, 0..M-1].
											The eigenvectors are stored in the matrix columns.

			Result:
					True, if successful. M contains the number of eigenvalues in the given
					half-interval (could be equal to 0), W contains the eigenvalues,
					Z contains the eigenvectors (if needed).

					False, if the bisection method subroutine wasn't able to find the
					eigenvalues in the given interval or if the inverse iteration subroutine
					wasn't able to find all the corresponding eigenvectors.
					In that case, the eigenvalues and eigenvectors are not returned,
					M is equal to 0.

				-- ALGLIB --
					 Copyright 07.01.2006 by Bochkanov Sergey
			*************************************************************************/
			public static bool smatrixevdr(double[,] a,
					int n,
					int zneeded,
					bool isupper,
					double b1,
					double b2,
					ref int m,
					ref double[] w,
					ref double[,] z)
			{
				bool result = new bool();
				double[] tau = new double[0];
				double[] e = new double[0];

				a = (double[,])a.Clone();
				m = 0;
				w = new double[0];
				z = new double[0, 0];

				alglib.ap.assert(zneeded == 0 || zneeded == 1, "SMatrixTDEVDR: incorrect ZNeeded");
				ortfac.smatrixtd(ref a, n, isupper, ref tau, ref w, ref e);
				if (zneeded == 1)
				{
					ortfac.smatrixtdunpackq(a, n, isupper, tau, ref z);
				}
				result = smatrixtdevdr(ref w, e, n, zneeded, b1, b2, ref m, ref z);
				return result;
			}


			/*************************************************************************
			Subroutine for finding the eigenvalues and  eigenvectors  of  a  symmetric
			matrix with given indexes by using bisection and inverse iteration methods.

			Input parameters:
					A       -   symmetric matrix which is given by its upper or lower
											triangular part. Array whose indexes range within [0..N-1, 0..N-1].
					N       -   size of matrix A.
					ZNeeded -   flag controlling whether the eigenvectors are needed or not.
											If ZNeeded is equal to:
											 * 0, the eigenvectors are not returned;
											 * 1, the eigenvectors are returned.
					IsUpperA -  storage format of matrix A.
					I1, I2 -    index interval for searching (from I1 to I2).
											0 <= I1 <= I2 <= N-1.

			Output parameters:
					W       -   array of the eigenvalues found.
											Array whose index ranges within [0..I2-I1].
					Z       -   if ZNeeded is equal to:
											 * 0, Z hasn’t changed;
											 * 1, Z contains eigenvectors.
											Array whose indexes range within [0..N-1, 0..I2-I1].
											In that case, the eigenvectors are stored in the matrix columns.

			Result:
					True, if successful. W contains the eigenvalues, Z contains the
					eigenvectors (if needed).

					False, if the bisection method subroutine wasn't able to find the
					eigenvalues in the given interval or if the inverse iteration subroutine
					wasn't able to find all the corresponding eigenvectors.
					In that case, the eigenvalues and eigenvectors are not returned.

				-- ALGLIB --
					 Copyright 07.01.2006 by Bochkanov Sergey
			*************************************************************************/
			public static bool smatrixevdi(double[,] a,
					int n,
					int zneeded,
					bool isupper,
					int i1,
					int i2,
					ref double[] w,
					ref double[,] z)
			{
				bool result = new bool();
				double[] tau = new double[0];
				double[] e = new double[0];

				a = (double[,])a.Clone();
				w = new double[0];
				z = new double[0, 0];

				alglib.ap.assert(zneeded == 0 || zneeded == 1, "SMatrixEVDI: incorrect ZNeeded");
				ortfac.smatrixtd(ref a, n, isupper, ref tau, ref w, ref e);
				if (zneeded == 1)
				{
					ortfac.smatrixtdunpackq(a, n, isupper, tau, ref z);
				}
				result = smatrixtdevdi(ref w, e, n, zneeded, i1, i2, ref z);
				return result;
			}


			/*************************************************************************
			Finding the eigenvalues and eigenvectors of a Hermitian matrix

			The algorithm finds eigen pairs of a Hermitian matrix by  reducing  it  to
			real tridiagonal form and using the QL/QR algorithm.

			Input parameters:
					A       -   Hermitian matrix which is given  by  its  upper  or  lower
											triangular part.
											Array whose indexes range within [0..N-1, 0..N-1].
					N       -   size of matrix A.
					IsUpper -   storage format.
					ZNeeded -   flag controlling whether the eigenvectors  are  needed  or
											not. If ZNeeded is equal to:
											 * 0, the eigenvectors are not returned;
											 * 1, the eigenvectors are returned.

			Output parameters:
					D       -   eigenvalues in ascending order.
											Array whose index ranges within [0..N-1].
					Z       -   if ZNeeded is equal to:
											 * 0, Z hasn’t changed;
											 * 1, Z contains the eigenvectors.
											Array whose indexes range within [0..N-1, 0..N-1].
											The eigenvectors are stored in the matrix columns.

			Result:
					True, if the algorithm has converged.
					False, if the algorithm hasn't converged (rare case).

			Note:
					eigenvectors of Hermitian matrix are defined up to  multiplication  by
					a complex number L, such that |L|=1.

				-- ALGLIB --
					 Copyright 2005, 23 March 2007 by Bochkanov Sergey
			*************************************************************************/
			public static bool hmatrixevd(complex[,] a,
					int n,
					int zneeded,
					bool isupper,
					ref double[] d,
					ref complex[,] z)
			{
				bool result = new bool();
				complex[] tau = new complex[0];
				double[] e = new double[0];
				double[] work = new double[0];
				double[,] t = new double[0, 0];
				complex[,] q = new complex[0, 0];
				int i = 0;
				int k = 0;
				double v = 0;
				int i_ = 0;

				a = (complex[,])a.Clone();
				d = new double[0];
				z = new complex[0, 0];

				alglib.ap.assert(zneeded == 0 || zneeded == 1, "HermitianEVD: incorrect ZNeeded");

				//
				// Reduce to tridiagonal form
				//
				ortfac.hmatrixtd(ref a, n, isupper, ref tau, ref d, ref e);
				if (zneeded == 1)
				{
					ortfac.hmatrixtdunpackq(a, n, isupper, tau, ref q);
					zneeded = 2;
				}

				//
				// TDEVD
				//
				result = smatrixtdevd(ref d, e, n, zneeded, ref t);

				//
				// Eigenvectors are needed
				// Calculate Z = Q*T = Re(Q)*T + i*Im(Q)*T
				//
				if (result && zneeded != 0)
				{
					work = new double[n - 1 + 1];
					z = new complex[n - 1 + 1, n - 1 + 1];
					for (i = 0; i <= n - 1; i++)
					{

						//
						// Calculate real part
						//
						for (k = 0; k <= n - 1; k++)
						{
							work[k] = 0;
						}
						for (k = 0; k <= n - 1; k++)
						{
							v = q[i, k].x;
							for (i_ = 0; i_ <= n - 1; i_++)
							{
								work[i_] = work[i_] + v * t[k, i_];
							}
						}
						for (k = 0; k <= n - 1; k++)
						{
							z[i, k].x = work[k];
						}

						//
						// Calculate imaginary part
						//
						for (k = 0; k <= n - 1; k++)
						{
							work[k] = 0;
						}
						for (k = 0; k <= n - 1; k++)
						{
							v = q[i, k].y;
							for (i_ = 0; i_ <= n - 1; i_++)
							{
								work[i_] = work[i_] + v * t[k, i_];
							}
						}
						for (k = 0; k <= n - 1; k++)
						{
							z[i, k].y = work[k];
						}
					}
				}
				return result;
			}


			/*************************************************************************
			Subroutine for finding the eigenvalues (and eigenvectors) of  a  Hermitian
			matrix  in  a  given half-interval (A, B] by using a bisection and inverse
			iteration

			Input parameters:
					A       -   Hermitian matrix which is given  by  its  upper  or  lower
											triangular  part.  Array  whose   indexes   range   within
											[0..N-1, 0..N-1].
					N       -   size of matrix A.
					ZNeeded -   flag controlling whether the eigenvectors  are  needed  or
											not. If ZNeeded is equal to:
											 * 0, the eigenvectors are not returned;
											 * 1, the eigenvectors are returned.
					IsUpperA -  storage format of matrix A.
					B1, B2 -    half-interval (B1, B2] to search eigenvalues in.

			Output parameters:
					M       -   number of eigenvalues found in a given half-interval, M>=0
					W       -   array of the eigenvalues found.
											Array whose index ranges within [0..M-1].
					Z       -   if ZNeeded is equal to:
											 * 0, Z hasn’t changed;
											 * 1, Z contains eigenvectors.
											Array whose indexes range within [0..N-1, 0..M-1].
											The eigenvectors are stored in the matrix columns.

			Result:
					True, if successful. M contains the number of eigenvalues in the given
					half-interval (could be equal to 0), W contains the eigenvalues,
					Z contains the eigenvectors (if needed).

					False, if the bisection method subroutine  wasn't  able  to  find  the
					eigenvalues  in  the  given  interval  or  if  the  inverse  iteration
					subroutine  wasn't  able  to  find all the corresponding eigenvectors.
					In that case, the eigenvalues and eigenvectors are not returned, M  is
					equal to 0.

			Note:
					eigen vectors of Hermitian matrix are defined up to multiplication  by
					a complex number L, such as |L|=1.

				-- ALGLIB --
					 Copyright 07.01.2006, 24.03.2007 by Bochkanov Sergey.
			*************************************************************************/
			public static bool hmatrixevdr(complex[,] a,
					int n,
					int zneeded,
					bool isupper,
					double b1,
					double b2,
					ref int m,
					ref double[] w,
					ref complex[,] z)
			{
				bool result = new bool();
				complex[,] q = new complex[0, 0];
				double[,] t = new double[0, 0];
				complex[] tau = new complex[0];
				double[] e = new double[0];
				double[] work = new double[0];
				int i = 0;
				int k = 0;
				double v = 0;
				int i_ = 0;

				a = (complex[,])a.Clone();
				m = 0;
				w = new double[0];
				z = new complex[0, 0];

				alglib.ap.assert(zneeded == 0 || zneeded == 1, "HermitianEigenValuesAndVectorsInInterval: incorrect ZNeeded");

				//
				// Reduce to tridiagonal form
				//
				ortfac.hmatrixtd(ref a, n, isupper, ref tau, ref w, ref e);
				if (zneeded == 1)
				{
					ortfac.hmatrixtdunpackq(a, n, isupper, tau, ref q);
					zneeded = 2;
				}

				//
				// Bisection and inverse iteration
				//
				result = smatrixtdevdr(ref w, e, n, zneeded, b1, b2, ref m, ref t);

				//
				// Eigenvectors are needed
				// Calculate Z = Q*T = Re(Q)*T + i*Im(Q)*T
				//
				if ((result && zneeded != 0) && m != 0)
				{
					work = new double[m - 1 + 1];
					z = new complex[n - 1 + 1, m - 1 + 1];
					for (i = 0; i <= n - 1; i++)
					{

						//
						// Calculate real part
						//
						for (k = 0; k <= m - 1; k++)
						{
							work[k] = 0;
						}
						for (k = 0; k <= n - 1; k++)
						{
							v = q[i, k].x;
							for (i_ = 0; i_ <= m - 1; i_++)
							{
								work[i_] = work[i_] + v * t[k, i_];
							}
						}
						for (k = 0; k <= m - 1; k++)
						{
							z[i, k].x = work[k];
						}

						//
						// Calculate imaginary part
						//
						for (k = 0; k <= m - 1; k++)
						{
							work[k] = 0;
						}
						for (k = 0; k <= n - 1; k++)
						{
							v = q[i, k].y;
							for (i_ = 0; i_ <= m - 1; i_++)
							{
								work[i_] = work[i_] + v * t[k, i_];
							}
						}
						for (k = 0; k <= m - 1; k++)
						{
							z[i, k].y = work[k];
						}
					}
				}
				return result;
			}


			/*************************************************************************
			Subroutine for finding the eigenvalues and  eigenvectors  of  a  Hermitian
			matrix with given indexes by using bisection and inverse iteration methods

			Input parameters:
					A       -   Hermitian matrix which is given  by  its  upper  or  lower
											triangular part.
											Array whose indexes range within [0..N-1, 0..N-1].
					N       -   size of matrix A.
					ZNeeded -   flag controlling whether the eigenvectors  are  needed  or
											not. If ZNeeded is equal to:
											 * 0, the eigenvectors are not returned;
											 * 1, the eigenvectors are returned.
					IsUpperA -  storage format of matrix A.
					I1, I2 -    index interval for searching (from I1 to I2).
											0 <= I1 <= I2 <= N-1.

			Output parameters:
					W       -   array of the eigenvalues found.
											Array whose index ranges within [0..I2-I1].
					Z       -   if ZNeeded is equal to:
											 * 0, Z hasn’t changed;
											 * 1, Z contains eigenvectors.
											Array whose indexes range within [0..N-1, 0..I2-I1].
											In  that  case,  the eigenvectors are stored in the matrix
											columns.

			Result:
					True, if successful. W contains the eigenvalues, Z contains the
					eigenvectors (if needed).

					False, if the bisection method subroutine  wasn't  able  to  find  the
					eigenvalues  in  the  given  interval  or  if  the  inverse  iteration
					subroutine wasn't able to find  all  the  corresponding  eigenvectors.
					In that case, the eigenvalues and eigenvectors are not returned.

			Note:
					eigen vectors of Hermitian matrix are defined up to multiplication  by
					a complex number L, such as |L|=1.

				-- ALGLIB --
					 Copyright 07.01.2006, 24.03.2007 by Bochkanov Sergey.
			*************************************************************************/
			public static bool hmatrixevdi(complex[,] a,
					int n,
					int zneeded,
					bool isupper,
					int i1,
					int i2,
					ref double[] w,
					ref complex[,] z)
			{
				bool result = new bool();
				complex[,] q = new complex[0, 0];
				double[,] t = new double[0, 0];
				complex[] tau = new complex[0];
				double[] e = new double[0];
				double[] work = new double[0];
				int i = 0;
				int k = 0;
				double v = 0;
				int m = 0;
				int i_ = 0;

				a = (complex[,])a.Clone();
				w = new double[0];
				z = new complex[0, 0];

				alglib.ap.assert(zneeded == 0 || zneeded == 1, "HermitianEigenValuesAndVectorsByIndexes: incorrect ZNeeded");

				//
				// Reduce to tridiagonal form
				//
				ortfac.hmatrixtd(ref a, n, isupper, ref tau, ref w, ref e);
				if (zneeded == 1)
				{
					ortfac.hmatrixtdunpackq(a, n, isupper, tau, ref q);
					zneeded = 2;
				}

				//
				// Bisection and inverse iteration
				//
				result = smatrixtdevdi(ref w, e, n, zneeded, i1, i2, ref t);

				//
				// Eigenvectors are needed
				// Calculate Z = Q*T = Re(Q)*T + i*Im(Q)*T
				//
				m = i2 - i1 + 1;
				if (result && zneeded != 0)
				{
					work = new double[m - 1 + 1];
					z = new complex[n - 1 + 1, m - 1 + 1];
					for (i = 0; i <= n - 1; i++)
					{

						//
						// Calculate real part
						//
						for (k = 0; k <= m - 1; k++)
						{
							work[k] = 0;
						}
						for (k = 0; k <= n - 1; k++)
						{
							v = q[i, k].x;
							for (i_ = 0; i_ <= m - 1; i_++)
							{
								work[i_] = work[i_] + v * t[k, i_];
							}
						}
						for (k = 0; k <= m - 1; k++)
						{
							z[i, k].x = work[k];
						}

						//
						// Calculate imaginary part
						//
						for (k = 0; k <= m - 1; k++)
						{
							work[k] = 0;
						}
						for (k = 0; k <= n - 1; k++)
						{
							v = q[i, k].y;
							for (i_ = 0; i_ <= m - 1; i_++)
							{
								work[i_] = work[i_] + v * t[k, i_];
							}
						}
						for (k = 0; k <= m - 1; k++)
						{
							z[i, k].y = work[k];
						}
					}
				}
				return result;
			}


			/*************************************************************************
			Finding the eigenvalues and eigenvectors of a tridiagonal symmetric matrix

			The algorithm finds the eigen pairs of a tridiagonal symmetric matrix by
			using an QL/QR algorithm with implicit shifts.

			Input parameters:
					D       -   the main diagonal of a tridiagonal matrix.
											Array whose index ranges within [0..N-1].
					E       -   the secondary diagonal of a tridiagonal matrix.
											Array whose index ranges within [0..N-2].
					N       -   size of matrix A.
					ZNeeded -   flag controlling whether the eigenvectors are needed or not.
											If ZNeeded is equal to:
											 * 0, the eigenvectors are not needed;
											 * 1, the eigenvectors of a tridiagonal matrix
												 are multiplied by the square matrix Z. It is used if the
												 tridiagonal matrix is obtained by the similarity
												 transformation of a symmetric matrix;
											 * 2, the eigenvectors of a tridiagonal matrix replace the
												 square matrix Z;
											 * 3, matrix Z contains the first row of the eigenvectors
												 matrix.
					Z       -   if ZNeeded=1, Z contains the square matrix by which the
											eigenvectors are multiplied.
											Array whose indexes range within [0..N-1, 0..N-1].

			Output parameters:
					D       -   eigenvalues in ascending order.
											Array whose index ranges within [0..N-1].
					Z       -   if ZNeeded is equal to:
											 * 0, Z hasn’t changed;
											 * 1, Z contains the product of a given matrix (from the left)
												 and the eigenvectors matrix (from the right);
											 * 2, Z contains the eigenvectors.
											 * 3, Z contains the first row of the eigenvectors matrix.
											If ZNeeded<3, Z is the array whose indexes range within [0..N-1, 0..N-1].
											In that case, the eigenvectors are stored in the matrix columns.
											If ZNeeded=3, Z is the array whose indexes range within [0..0, 0..N-1].

			Result:
					True, if the algorithm has converged.
					False, if the algorithm hasn't converged.

				-- LAPACK routine (version 3.0) --
					 Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
					 Courant Institute, Argonne National Lab, and Rice University
					 September 30, 1994
			*************************************************************************/
			public static bool smatrixtdevd(ref double[] d,
					double[] e,
					int n,
					int zneeded,
					ref double[,] z)
			{
				bool result = new bool();
				double[] d1 = new double[0];
				double[] e1 = new double[0];
				double[,] z1 = new double[0, 0];
				int i = 0;
				int i_ = 0;
				int i1_ = 0;

				e = (double[])e.Clone();


				//
				// Prepare 1-based task
				//
				d1 = new double[n + 1];
				e1 = new double[n + 1];
				i1_ = (0) - (1);
				for (i_ = 1; i_ <= n; i_++)
				{
					d1[i_] = d[i_ + i1_];
				}
				if (n > 1)
				{
					i1_ = (0) - (1);
					for (i_ = 1; i_ <= n - 1; i_++)
					{
						e1[i_] = e[i_ + i1_];
					}
				}
				if (zneeded == 1)
				{
					z1 = new double[n + 1, n + 1];
					for (i = 1; i <= n; i++)
					{
						i1_ = (0) - (1);
						for (i_ = 1; i_ <= n; i_++)
						{
							z1[i, i_] = z[i - 1, i_ + i1_];
						}
					}
				}

				//
				// Solve 1-based task
				//
				result = tridiagonalevd(ref d1, e1, n, zneeded, ref z1);
				if (!result)
				{
					return result;
				}

				//
				// Convert back to 0-based result
				//
				i1_ = (1) - (0);
				for (i_ = 0; i_ <= n - 1; i_++)
				{
					d[i_] = d1[i_ + i1_];
				}
				if (zneeded != 0)
				{
					if (zneeded == 1)
					{
						for (i = 1; i <= n; i++)
						{
							i1_ = (1) - (0);
							for (i_ = 0; i_ <= n - 1; i_++)
							{
								z[i - 1, i_] = z1[i, i_ + i1_];
							}
						}
						return result;
					}
					if (zneeded == 2)
					{
						z = new double[n - 1 + 1, n - 1 + 1];
						for (i = 1; i <= n; i++)
						{
							i1_ = (1) - (0);
							for (i_ = 0; i_ <= n - 1; i_++)
							{
								z[i - 1, i_] = z1[i, i_ + i1_];
							}
						}
						return result;
					}
					if (zneeded == 3)
					{
						z = new double[0 + 1, n - 1 + 1];
						i1_ = (1) - (0);
						for (i_ = 0; i_ <= n - 1; i_++)
						{
							z[0, i_] = z1[1, i_ + i1_];
						}
						return result;
					}
					alglib.ap.assert(false, "SMatrixTDEVD: Incorrect ZNeeded!");
				}
				return result;
			}


			/*************************************************************************
			Subroutine for finding the tridiagonal matrix eigenvalues/vectors in a
			given half-interval (A, B] by using bisection and inverse iteration.

			Input parameters:
					D       -   the main diagonal of a tridiagonal matrix.
											Array whose index ranges within [0..N-1].
					E       -   the secondary diagonal of a tridiagonal matrix.
											Array whose index ranges within [0..N-2].
					N       -   size of matrix, N>=0.
					ZNeeded -   flag controlling whether the eigenvectors are needed or not.
											If ZNeeded is equal to:
											 * 0, the eigenvectors are not needed;
											 * 1, the eigenvectors of a tridiagonal matrix are multiplied
												 by the square matrix Z. It is used if the tridiagonal
												 matrix is obtained by the similarity transformation
												 of a symmetric matrix.
											 * 2, the eigenvectors of a tridiagonal matrix replace matrix Z.
					A, B    -   half-interval (A, B] to search eigenvalues in.
					Z       -   if ZNeeded is equal to:
											 * 0, Z isn't used and remains unchanged;
											 * 1, Z contains the square matrix (array whose indexes range
												 within [0..N-1, 0..N-1]) which reduces the given symmetric
												 matrix to tridiagonal form;
											 * 2, Z isn't used (but changed on the exit).

			Output parameters:
					D       -   array of the eigenvalues found.
											Array whose index ranges within [0..M-1].
					M       -   number of eigenvalues found in the given half-interval (M>=0).
					Z       -   if ZNeeded is equal to:
											 * 0, doesn't contain any information;
											 * 1, contains the product of a given NxN matrix Z (from the
												 left) and NxM matrix of the eigenvectors found (from the
												 right). Array whose indexes range within [0..N-1, 0..M-1].
											 * 2, contains the matrix of the eigenvectors found.
												 Array whose indexes range within [0..N-1, 0..M-1].

			Result:

					True, if successful. In that case, M contains the number of eigenvalues
					in the given half-interval (could be equal to 0), D contains the eigenvalues,
					Z contains the eigenvectors (if needed).
					It should be noted that the subroutine changes the size of arrays D and Z.

					False, if the bisection method subroutine wasn't able to find the
					eigenvalues in the given interval or if the inverse iteration subroutine
					wasn't able to find all the corresponding eigenvectors. In that case,
					the eigenvalues and eigenvectors are not returned, M is equal to 0.

				-- ALGLIB --
					 Copyright 31.03.2008 by Bochkanov Sergey
			*************************************************************************/
			public static bool smatrixtdevdr(ref double[] d,
					double[] e,
					int n,
					int zneeded,
					double a,
					double b,
					ref int m,
					ref double[,] z)
			{
				bool result = new bool();
				int errorcode = 0;
				int nsplit = 0;
				int i = 0;
				int j = 0;
				int k = 0;
				int cr = 0;
				int[] iblock = new int[0];
				int[] isplit = new int[0];
				int[] ifail = new int[0];
				double[] d1 = new double[0];
				double[] e1 = new double[0];
				double[] w = new double[0];
				double[,] z2 = new double[0, 0];
				double[,] z3 = new double[0, 0];
				double v = 0;
				int i_ = 0;
				int i1_ = 0;

				m = 0;

				alglib.ap.assert(zneeded >= 0 && zneeded <= 2, "SMatrixTDEVDR: incorrect ZNeeded!");

				//
				// Special cases
				//
				if ((double)(b) <= (double)(a))
				{
					m = 0;
					result = true;
					return result;
				}
				if (n <= 0)
				{
					m = 0;
					result = true;
					return result;
				}

				//
				// Copy D,E to D1, E1
				//
				d1 = new double[n + 1];
				i1_ = (0) - (1);
				for (i_ = 1; i_ <= n; i_++)
				{
					d1[i_] = d[i_ + i1_];
				}
				if (n > 1)
				{
					e1 = new double[n - 1 + 1];
					i1_ = (0) - (1);
					for (i_ = 1; i_ <= n - 1; i_++)
					{
						e1[i_] = e[i_ + i1_];
					}
				}

				//
				// No eigen vectors
				//
				if (zneeded == 0)
				{
					result = internalbisectioneigenvalues(d1, e1, n, 2, 1, a, b, 0, 0, -1, ref w, ref m, ref nsplit, ref iblock, ref isplit, ref errorcode);
					if (!result || m == 0)
					{
						m = 0;
						return result;
					}
					d = new double[m - 1 + 1];
					i1_ = (1) - (0);
					for (i_ = 0; i_ <= m - 1; i_++)
					{
						d[i_] = w[i_ + i1_];
					}
					return result;
				}

				//
				// Eigen vectors are multiplied by Z
				//
				if (zneeded == 1)
				{

					//
					// Find eigen pairs
					//
					result = internalbisectioneigenvalues(d1, e1, n, 2, 2, a, b, 0, 0, -1, ref w, ref m, ref nsplit, ref iblock, ref isplit, ref errorcode);
					if (!result || m == 0)
					{
						m = 0;
						return result;
					}
					internaldstein(n, d1, e1, m, w, iblock, isplit, ref z2, ref ifail, ref cr);
					if (cr != 0)
					{
						m = 0;
						result = false;
						return result;
					}

					//
					// Sort eigen values and vectors
					//
					for (i = 1; i <= m; i++)
					{
						k = i;
						for (j = i; j <= m; j++)
						{
							if ((double)(w[j]) < (double)(w[k]))
							{
								k = j;
							}
						}
						v = w[i];
						w[i] = w[k];
						w[k] = v;
						for (j = 1; j <= n; j++)
						{
							v = z2[j, i];
							z2[j, i] = z2[j, k];
							z2[j, k] = v;
						}
					}

					//
					// Transform Z2 and overwrite Z
					//
					z3 = new double[m + 1, n + 1];
					for (i = 1; i <= m; i++)
					{
						for (i_ = 1; i_ <= n; i_++)
						{
							z3[i, i_] = z2[i_, i];
						}
					}
					for (i = 1; i <= n; i++)
					{
						for (j = 1; j <= m; j++)
						{
							i1_ = (1) - (0);
							v = 0.0f;
							for (i_ = 0; i_ <= n - 1; i_++)
							{
								v += z[i - 1, i_] * z3[j, i_ + i1_];
							}
							z2[i, j] = v;
						}
					}
					z = new double[n - 1 + 1, m - 1 + 1];
					for (i = 1; i <= m; i++)
					{
						i1_ = (1) - (0);
						for (i_ = 0; i_ <= n - 1; i_++)
						{
							z[i_, i - 1] = z2[i_ + i1_, i];
						}
					}

					//
					// Store W
					//
					d = new double[m - 1 + 1];
					for (i = 1; i <= m; i++)
					{
						d[i - 1] = w[i];
					}
					return result;
				}

				//
				// Eigen vectors are stored in Z
				//
				if (zneeded == 2)
				{

					//
					// Find eigen pairs
					//
					result = internalbisectioneigenvalues(d1, e1, n, 2, 2, a, b, 0, 0, -1, ref w, ref m, ref nsplit, ref iblock, ref isplit, ref errorcode);
					if (!result || m == 0)
					{
						m = 0;
						return result;
					}
					internaldstein(n, d1, e1, m, w, iblock, isplit, ref z2, ref ifail, ref cr);
					if (cr != 0)
					{
						m = 0;
						result = false;
						return result;
					}

					//
					// Sort eigen values and vectors
					//
					for (i = 1; i <= m; i++)
					{
						k = i;
						for (j = i; j <= m; j++)
						{
							if ((double)(w[j]) < (double)(w[k]))
							{
								k = j;
							}
						}
						v = w[i];
						w[i] = w[k];
						w[k] = v;
						for (j = 1; j <= n; j++)
						{
							v = z2[j, i];
							z2[j, i] = z2[j, k];
							z2[j, k] = v;
						}
					}

					//
					// Store W
					//
					d = new double[m - 1 + 1];
					for (i = 1; i <= m; i++)
					{
						d[i - 1] = w[i];
					}
					z = new double[n - 1 + 1, m - 1 + 1];
					for (i = 1; i <= m; i++)
					{
						i1_ = (1) - (0);
						for (i_ = 0; i_ <= n - 1; i_++)
						{
							z[i_, i - 1] = z2[i_ + i1_, i];
						}
					}
					return result;
				}
				result = false;
				return result;
			}


			/*************************************************************************
			Subroutine for finding tridiagonal matrix eigenvalues/vectors with given
			indexes (in ascending order) by using the bisection and inverse iteraion.

			Input parameters:
					D       -   the main diagonal of a tridiagonal matrix.
											Array whose index ranges within [0..N-1].
					E       -   the secondary diagonal of a tridiagonal matrix.
											Array whose index ranges within [0..N-2].
					N       -   size of matrix. N>=0.
					ZNeeded -   flag controlling whether the eigenvectors are needed or not.
											If ZNeeded is equal to:
											 * 0, the eigenvectors are not needed;
											 * 1, the eigenvectors of a tridiagonal matrix are multiplied
												 by the square matrix Z. It is used if the
												 tridiagonal matrix is obtained by the similarity transformation
												 of a symmetric matrix.
											 * 2, the eigenvectors of a tridiagonal matrix replace
												 matrix Z.
					I1, I2  -   index interval for searching (from I1 to I2).
											0 <= I1 <= I2 <= N-1.
					Z       -   if ZNeeded is equal to:
											 * 0, Z isn't used and remains unchanged;
											 * 1, Z contains the square matrix (array whose indexes range within [0..N-1, 0..N-1])
												 which reduces the given symmetric matrix to  tridiagonal form;
											 * 2, Z isn't used (but changed on the exit).

			Output parameters:
					D       -   array of the eigenvalues found.
											Array whose index ranges within [0..I2-I1].
					Z       -   if ZNeeded is equal to:
											 * 0, doesn't contain any information;
											 * 1, contains the product of a given NxN matrix Z (from the left) and
												 Nx(I2-I1) matrix of the eigenvectors found (from the right).
												 Array whose indexes range within [0..N-1, 0..I2-I1].
											 * 2, contains the matrix of the eigenvalues found.
												 Array whose indexes range within [0..N-1, 0..I2-I1].


			Result:

					True, if successful. In that case, D contains the eigenvalues,
					Z contains the eigenvectors (if needed).
					It should be noted that the subroutine changes the size of arrays D and Z.

					False, if the bisection method subroutine wasn't able to find the eigenvalues
					in the given interval or if the inverse iteration subroutine wasn't able
					to find all the corresponding eigenvectors. In that case, the eigenvalues
					and eigenvectors are not returned.

				-- ALGLIB --
					 Copyright 25.12.2005 by Bochkanov Sergey
			*************************************************************************/
			public static bool smatrixtdevdi(ref double[] d,
					double[] e,
					int n,
					int zneeded,
					int i1,
					int i2,
					ref double[,] z)
			{
				bool result = new bool();
				int errorcode = 0;
				int nsplit = 0;
				int i = 0;
				int j = 0;
				int k = 0;
				int m = 0;
				int cr = 0;
				int[] iblock = new int[0];
				int[] isplit = new int[0];
				int[] ifail = new int[0];
				double[] w = new double[0];
				double[] d1 = new double[0];
				double[] e1 = new double[0];
				double[,] z2 = new double[0, 0];
				double[,] z3 = new double[0, 0];
				double v = 0;
				int i_ = 0;
				int i1_ = 0;

				alglib.ap.assert((0 <= i1 && i1 <= i2) && i2 < n, "SMatrixTDEVDI: incorrect I1/I2!");

				//
				// Copy D,E to D1, E1
				//
				d1 = new double[n + 1];
				i1_ = (0) - (1);
				for (i_ = 1; i_ <= n; i_++)
				{
					d1[i_] = d[i_ + i1_];
				}
				if (n > 1)
				{
					e1 = new double[n - 1 + 1];
					i1_ = (0) - (1);
					for (i_ = 1; i_ <= n - 1; i_++)
					{
						e1[i_] = e[i_ + i1_];
					}
				}

				//
				// No eigen vectors
				//
				if (zneeded == 0)
				{
					result = internalbisectioneigenvalues(d1, e1, n, 3, 1, 0, 0, i1 + 1, i2 + 1, -1, ref w, ref m, ref nsplit, ref iblock, ref isplit, ref errorcode);
					if (!result)
					{
						return result;
					}
					if (m != i2 - i1 + 1)
					{
						result = false;
						return result;
					}
					d = new double[m - 1 + 1];
					for (i = 1; i <= m; i++)
					{
						d[i - 1] = w[i];
					}
					return result;
				}

				//
				// Eigen vectors are multiplied by Z
				//
				if (zneeded == 1)
				{

					//
					// Find eigen pairs
					//
					result = internalbisectioneigenvalues(d1, e1, n, 3, 2, 0, 0, i1 + 1, i2 + 1, -1, ref w, ref m, ref nsplit, ref iblock, ref isplit, ref errorcode);
					if (!result)
					{
						return result;
					}
					if (m != i2 - i1 + 1)
					{
						result = false;
						return result;
					}
					internaldstein(n, d1, e1, m, w, iblock, isplit, ref z2, ref ifail, ref cr);
					if (cr != 0)
					{
						result = false;
						return result;
					}

					//
					// Sort eigen values and vectors
					//
					for (i = 1; i <= m; i++)
					{
						k = i;
						for (j = i; j <= m; j++)
						{
							if ((double)(w[j]) < (double)(w[k]))
							{
								k = j;
							}
						}
						v = w[i];
						w[i] = w[k];
						w[k] = v;
						for (j = 1; j <= n; j++)
						{
							v = z2[j, i];
							z2[j, i] = z2[j, k];
							z2[j, k] = v;
						}
					}

					//
					// Transform Z2 and overwrite Z
					//
					z3 = new double[m + 1, n + 1];
					for (i = 1; i <= m; i++)
					{
						for (i_ = 1; i_ <= n; i_++)
						{
							z3[i, i_] = z2[i_, i];
						}
					}
					for (i = 1; i <= n; i++)
					{
						for (j = 1; j <= m; j++)
						{
							i1_ = (1) - (0);
							v = 0.0f;
							for (i_ = 0; i_ <= n - 1; i_++)
							{
								v += z[i - 1, i_] * z3[j, i_ + i1_];
							}
							z2[i, j] = v;
						}
					}
					z = new double[n - 1 + 1, m - 1 + 1];
					for (i = 1; i <= m; i++)
					{
						i1_ = (1) - (0);
						for (i_ = 0; i_ <= n - 1; i_++)
						{
							z[i_, i - 1] = z2[i_ + i1_, i];
						}
					}

					//
					// Store W
					//
					d = new double[m - 1 + 1];
					for (i = 1; i <= m; i++)
					{
						d[i - 1] = w[i];
					}
					return result;
				}

				//
				// Eigen vectors are stored in Z
				//
				if (zneeded == 2)
				{

					//
					// Find eigen pairs
					//
					result = internalbisectioneigenvalues(d1, e1, n, 3, 2, 0, 0, i1 + 1, i2 + 1, -1, ref w, ref m, ref nsplit, ref iblock, ref isplit, ref errorcode);
					if (!result)
					{
						return result;
					}
					if (m != i2 - i1 + 1)
					{
						result = false;
						return result;
					}
					internaldstein(n, d1, e1, m, w, iblock, isplit, ref z2, ref ifail, ref cr);
					if (cr != 0)
					{
						result = false;
						return result;
					}

					//
					// Sort eigen values and vectors
					//
					for (i = 1; i <= m; i++)
					{
						k = i;
						for (j = i; j <= m; j++)
						{
							if ((double)(w[j]) < (double)(w[k]))
							{
								k = j;
							}
						}
						v = w[i];
						w[i] = w[k];
						w[k] = v;
						for (j = 1; j <= n; j++)
						{
							v = z2[j, i];
							z2[j, i] = z2[j, k];
							z2[j, k] = v;
						}
					}

					//
					// Store Z
					//
					z = new double[n - 1 + 1, m - 1 + 1];
					for (i = 1; i <= m; i++)
					{
						i1_ = (1) - (0);
						for (i_ = 0; i_ <= n - 1; i_++)
						{
							z[i_, i - 1] = z2[i_ + i1_, i];
						}
					}

					//
					// Store W
					//
					d = new double[m - 1 + 1];
					for (i = 1; i <= m; i++)
					{
						d[i - 1] = w[i];
					}
					return result;
				}
				result = false;
				return result;
			}


			/*************************************************************************
			Finding eigenvalues and eigenvectors of a general matrix

			The algorithm finds eigenvalues and eigenvectors of a general matrix by
			using the QR algorithm with multiple shifts. The algorithm can find
			eigenvalues and both left and right eigenvectors.

			The right eigenvector is a vector x such that A*x = w*x, and the left
			eigenvector is a vector y such that y'*A = w*y' (here y' implies a complex
			conjugate transposition of vector y).

			Input parameters:
					A       -   matrix. Array whose indexes range within [0..N-1, 0..N-1].
					N       -   size of matrix A.
					VNeeded -   flag controlling whether eigenvectors are needed or not.
											If VNeeded is equal to:
											 * 0, eigenvectors are not returned;
											 * 1, right eigenvectors are returned;
											 * 2, left eigenvectors are returned;
											 * 3, both left and right eigenvectors are returned.

			Output parameters:
					WR      -   real parts of eigenvalues.
											Array whose index ranges within [0..N-1].
					WR      -   imaginary parts of eigenvalues.
											Array whose index ranges within [0..N-1].
					VL, VR  -   arrays of left and right eigenvectors (if they are needed).
											If WI[i]=0, the respective eigenvalue is a real number,
											and it corresponds to the column number I of matrices VL/VR.
											If WI[i]>0, we have a pair of complex conjugate numbers with
											positive and negative imaginary parts:
													the first eigenvalue WR[i] + sqrt(-1)*WI[i];
													the second eigenvalue WR[i+1] + sqrt(-1)*WI[i+1];
													WI[i]>0
													WI[i+1] = -WI[i] < 0
											In that case, the eigenvector  corresponding to the first
											eigenvalue is located in i and i+1 columns of matrices
											VL/VR (the column number i contains the real part, and the
											column number i+1 contains the imaginary part), and the vector
											corresponding to the second eigenvalue is a complex conjugate to
											the first vector.
											Arrays whose indexes range within [0..N-1, 0..N-1].

			Result:
					True, if the algorithm has converged.
					False, if the algorithm has not converged.

			Note 1:
					Some users may ask the following question: what if WI[N-1]>0?
					WI[N] must contain an eigenvalue which is complex conjugate to the
					N-th eigenvalue, but the array has only size N?
					The answer is as follows: such a situation cannot occur because the
					algorithm finds a pairs of eigenvalues, therefore, if WI[i]>0, I is
					strictly less than N-1.

			Note 2:
					The algorithm performance depends on the value of the internal parameter
					NS of the InternalSchurDecomposition subroutine which defines the number
					of shifts in the QR algorithm (similarly to the block width in block-matrix
					algorithms of linear algebra). If you require maximum performance
					on your machine, it is recommended to adjust this parameter manually.


			See also the InternalTREVC subroutine.

			The algorithm is based on the LAPACK 3.0 library.
			*************************************************************************/
			public static bool rmatrixevd(double[,] a,
					int n,
					int vneeded,
					ref double[] wr,
					ref double[] wi,
					ref double[,] vl,
					ref double[,] vr)
			{
				bool result = new bool();
				double[,] a1 = new double[0, 0];
				double[,] vl1 = new double[0, 0];
				double[,] vr1 = new double[0, 0];
				double[] wr1 = new double[0];
				double[] wi1 = new double[0];
				int i = 0;
				int i_ = 0;
				int i1_ = 0;

				a = (double[,])a.Clone();
				wr = new double[0];
				wi = new double[0];
				vl = new double[0, 0];
				vr = new double[0, 0];

				alglib.ap.assert(vneeded >= 0 && vneeded <= 3, "RMatrixEVD: incorrect VNeeded!");
				a1 = new double[n + 1, n + 1];
				for (i = 1; i <= n; i++)
				{
					i1_ = (0) - (1);
					for (i_ = 1; i_ <= n; i_++)
					{
						a1[i, i_] = a[i - 1, i_ + i1_];
					}
				}
				result = nonsymmetricevd(a1, n, vneeded, ref wr1, ref wi1, ref vl1, ref vr1);
				if (result)
				{
					wr = new double[n - 1 + 1];
					wi = new double[n - 1 + 1];
					i1_ = (1) - (0);
					for (i_ = 0; i_ <= n - 1; i_++)
					{
						wr[i_] = wr1[i_ + i1_];
					}
					i1_ = (1) - (0);
					for (i_ = 0; i_ <= n - 1; i_++)
					{
						wi[i_] = wi1[i_ + i1_];
					}
					if (vneeded == 2 || vneeded == 3)
					{
						vl = new double[n - 1 + 1, n - 1 + 1];
						for (i = 0; i <= n - 1; i++)
						{
							i1_ = (1) - (0);
							for (i_ = 0; i_ <= n - 1; i_++)
							{
								vl[i, i_] = vl1[i + 1, i_ + i1_];
							}
						}
					}
					if (vneeded == 1 || vneeded == 3)
					{
						vr = new double[n - 1 + 1, n - 1 + 1];
						for (i = 0; i <= n - 1; i++)
						{
							i1_ = (1) - (0);
							for (i_ = 0; i_ <= n - 1; i_++)
							{
								vr[i, i_] = vr1[i + 1, i_ + i1_];
							}
						}
					}
				}
				return result;
			}


			private static bool tridiagonalevd(ref double[] d,
					double[] e,
					int n,
					int zneeded,
					ref double[,] z)
			{
				bool result = new bool();
				int maxit = 0;
				int i = 0;
				int ii = 0;
				int iscale = 0;
				int j = 0;
				int jtot = 0;
				int k = 0;
				int t = 0;
				int l = 0;
				int l1 = 0;
				int lend = 0;
				int lendm1 = 0;
				int lendp1 = 0;
				int lendsv = 0;
				int lm1 = 0;
				int lsv = 0;
				int m = 0;
				int mm1 = 0;
				int nm1 = 0;
				int nmaxit = 0;
				int tmpint = 0;
				double anorm = 0;
				double b = 0;
				double c = 0;
				double eps = 0;
				double eps2 = 0;
				double f = 0;
				double g = 0;
				double p = 0;
				double r = 0;
				double rt1 = 0;
				double rt2 = 0;
				double s = 0;
				double safmax = 0;
				double safmin = 0;
				double ssfmax = 0;
				double ssfmin = 0;
				double tst = 0;
				double tmp = 0;
				double[] work1 = new double[0];
				double[] work2 = new double[0];
				double[] workc = new double[0];
				double[] works = new double[0];
				double[] wtemp = new double[0];
				bool gotoflag = new bool();
				int zrows = 0;
				bool wastranspose = new bool();
				int i_ = 0;

				e = (double[])e.Clone();

				alglib.ap.assert(zneeded >= 0 && zneeded <= 3, "TridiagonalEVD: Incorrent ZNeeded");

				//
				// Quick return if possible
				//
				if (zneeded < 0 || zneeded > 3)
				{
					result = false;
					return result;
				}
				result = true;
				if (n == 0)
				{
					return result;
				}
				if (n == 1)
				{
					if (zneeded == 2 || zneeded == 3)
					{
						z = new double[1 + 1, 1 + 1];
						z[1, 1] = 1;
					}
					return result;
				}
				maxit = 30;

				//
				// Initialize arrays
				//
				wtemp = new double[n + 1];
				work1 = new double[n - 1 + 1];
				work2 = new double[n - 1 + 1];
				workc = new double[n + 1];
				works = new double[n + 1];

				//
				// Determine the unit roundoff and over/underflow thresholds.
				//
				eps = math.machineepsilon;
				eps2 = math.sqr(eps);
				safmin = math.minrealnumber;
				safmax = math.maxrealnumber;
				ssfmax = (double)Math.Sqrt(safmax) / 3;
				ssfmin = (double)Math.Sqrt(safmin) / eps2;

				//
				// Prepare Z
				//
				// Here we are using transposition to get rid of column operations
				//
				//
				wastranspose = false;
				zrows = 0;
				if (zneeded == 1)
				{
					zrows = n;
				}
				if (zneeded == 2)
				{
					zrows = n;
				}
				if (zneeded == 3)
				{
					zrows = 1;
				}
				if (zneeded == 1)
				{
					wastranspose = true;
					blas.inplacetranspose(ref z, 1, n, 1, n, ref wtemp);
				}
				if (zneeded == 2)
				{
					wastranspose = true;
					z = new double[n + 1, n + 1];
					for (i = 1; i <= n; i++)
					{
						for (j = 1; j <= n; j++)
						{
							if (i == j)
							{
								z[i, j] = 1;
							}
							else
							{
								z[i, j] = 0;
							}
						}
					}
				}
				if (zneeded == 3)
				{
					wastranspose = false;
					z = new double[1 + 1, n + 1];
					for (j = 1; j <= n; j++)
					{
						if (j == 1)
						{
							z[1, j] = 1;
						}
						else
						{
							z[1, j] = 0;
						}
					}
				}
				nmaxit = n * maxit;
				jtot = 0;

				//
				// Determine where the matrix splits and choose QL or QR iteration
				// for each block, according to whether top or bottom diagonal
				// element is smaller.
				//
				l1 = 1;
				nm1 = n - 1;
				while (true)
				{
					if (l1 > n)
					{
						break;
					}
					if (l1 > 1)
					{
						e[l1 - 1] = 0;
					}
					gotoflag = false;
					m = l1;
					if (l1 <= nm1)
					{
						for (m = l1; m <= nm1; m++)
						{
							tst = Math.Abs(e[m]);
							if ((double)(tst) == (double)(0))
							{
								gotoflag = true;
								break;
							}
							if ((double)(tst) <= (double)(Math.Sqrt(Math.Abs(d[m])) * Math.Sqrt(Math.Abs(d[m + 1])) * eps))
							{
								e[m] = 0;
								gotoflag = true;
								break;
							}
						}
					}
					if (!gotoflag)
					{
						m = n;
					}

					//
					// label 30:
					//
					l = l1;
					lsv = l;
					lend = m;
					lendsv = lend;
					l1 = m + 1;
					if (lend == l)
					{
						continue;
					}

					//
					// Scale submatrix in rows and columns L to LEND
					//
					if (l == lend)
					{
						anorm = Math.Abs(d[l]);
					}
					else
					{
						anorm = Math.Max(Math.Abs(d[l]) + Math.Abs(e[l]), Math.Abs(e[lend - 1]) + Math.Abs(d[lend]));
						for (i = l + 1; i <= lend - 1; i++)
						{
							anorm = Math.Max(anorm, Math.Abs(d[i]) + Math.Abs(e[i]) + Math.Abs(e[i - 1]));
						}
					}
					iscale = 0;
					if ((double)(anorm) == (double)(0))
					{
						continue;
					}
					if ((double)(anorm) > (double)(ssfmax))
					{
						iscale = 1;
						tmp = ssfmax / anorm;
						tmpint = lend - 1;
						for (i_ = l; i_ <= lend; i_++)
						{
							d[i_] = tmp * d[i_];
						}
						for (i_ = l; i_ <= tmpint; i_++)
						{
							e[i_] = tmp * e[i_];
						}
					}
					if ((double)(anorm) < (double)(ssfmin))
					{
						iscale = 2;
						tmp = ssfmin / anorm;
						tmpint = lend - 1;
						for (i_ = l; i_ <= lend; i_++)
						{
							d[i_] = tmp * d[i_];
						}
						for (i_ = l; i_ <= tmpint; i_++)
						{
							e[i_] = tmp * e[i_];
						}
					}

					//
					// Choose between QL and QR iteration
					//
					if ((double)(Math.Abs(d[lend])) < (double)(Math.Abs(d[l])))
					{
						lend = lsv;
						l = lendsv;
					}
					if (lend > l)
					{

						//
						// QL Iteration
						//
						// Look for small subdiagonal element.
						//
						while (true)
						{
							gotoflag = false;
							if (l != lend)
							{
								lendm1 = lend - 1;
								for (m = l; m <= lendm1; m++)
								{
									tst = math.sqr(Math.Abs(e[m]));
									if ((double)(tst) <= (double)(eps2 * Math.Abs(d[m]) * Math.Abs(d[m + 1]) + safmin))
									{
										gotoflag = true;
										break;
									}
								}
							}
							if (!gotoflag)
							{
								m = lend;
							}
							if (m < lend)
							{
								e[m] = 0;
							}
							p = d[l];
							if (m != l)
							{

								//
								// If remaining matrix is 2-by-2, use DLAE2 or SLAEV2
								// to compute its eigensystem.
								//
								if (m == l + 1)
								{
									if (zneeded > 0)
									{
										tdevdev2(d[l], e[l], d[l + 1], ref rt1, ref rt2, ref c, ref s);
										work1[l] = c;
										work2[l] = s;
										workc[1] = work1[l];
										works[1] = work2[l];
										if (!wastranspose)
										{
											rotations.applyrotationsfromtheright(false, 1, zrows, l, l + 1, workc, works, ref z, ref wtemp);
										}
										else
										{
											rotations.applyrotationsfromtheleft(false, l, l + 1, 1, zrows, workc, works, ref z, ref wtemp);
										}
									}
									else
									{
										tdevde2(d[l], e[l], d[l + 1], ref rt1, ref rt2);
									}
									d[l] = rt1;
									d[l + 1] = rt2;
									e[l] = 0;
									l = l + 2;
									if (l <= lend)
									{
										continue;
									}

									//
									// GOTO 140
									//
									break;
								}
								if (jtot == nmaxit)
								{

									//
									// GOTO 140
									//
									break;
								}
								jtot = jtot + 1;

								//
								// Form shift.
								//
								g = (d[l + 1] - p) / (2 * e[l]);
								r = tdevdpythag(g, 1);
								g = d[m] - p + e[l] / (g + tdevdextsign(r, g));
								s = 1;
								c = 1;
								p = 0;

								//
								// Inner loop
								//
								mm1 = m - 1;
								for (i = mm1; i >= l; i--)
								{
									f = s * e[i];
									b = c * e[i];
									rotations.generaterotation(g, f, ref c, ref s, ref r);
									if (i != m - 1)
									{
										e[i + 1] = r;
									}
									g = d[i + 1] - p;
									r = (d[i] - g) * s + 2 * c * b;
									p = s * r;
									d[i + 1] = g + p;
									g = c * r - b;

									//
									// If eigenvectors are desired, then save rotations.
									//
									if (zneeded > 0)
									{
										work1[i] = c;
										work2[i] = -s;
									}
								}

								//
								// If eigenvectors are desired, then apply saved rotations.
								//
								if (zneeded > 0)
								{
									for (i = l; i <= m - 1; i++)
									{
										workc[i - l + 1] = work1[i];
										works[i - l + 1] = work2[i];
									}
									if (!wastranspose)
									{
										rotations.applyrotationsfromtheright(false, 1, zrows, l, m, workc, works, ref z, ref wtemp);
									}
									else
									{
										rotations.applyrotationsfromtheleft(false, l, m, 1, zrows, workc, works, ref z, ref wtemp);
									}
								}
								d[l] = d[l] - p;
								e[l] = g;
								continue;
							}

							//
							// Eigenvalue found.
							//
							d[l] = p;
							l = l + 1;
							if (l <= lend)
							{
								continue;
							}
							break;
						}
					}
					else
					{

						//
						// QR Iteration
						//
						// Look for small superdiagonal element.
						//
						while (true)
						{
							gotoflag = false;
							if (l != lend)
							{
								lendp1 = lend + 1;
								for (m = l; m >= lendp1; m--)
								{
									tst = math.sqr(Math.Abs(e[m - 1]));
									if ((double)(tst) <= (double)(eps2 * Math.Abs(d[m]) * Math.Abs(d[m - 1]) + safmin))
									{
										gotoflag = true;
										break;
									}
								}
							}
							if (!gotoflag)
							{
								m = lend;
							}
							if (m > lend)
							{
								e[m - 1] = 0;
							}
							p = d[l];
							if (m != l)
							{

								//
								// If remaining matrix is 2-by-2, use DLAE2 or SLAEV2
								// to compute its eigensystem.
								//
								if (m == l - 1)
								{
									if (zneeded > 0)
									{
										tdevdev2(d[l - 1], e[l - 1], d[l], ref rt1, ref rt2, ref c, ref s);
										work1[m] = c;
										work2[m] = s;
										workc[1] = c;
										works[1] = s;
										if (!wastranspose)
										{
											rotations.applyrotationsfromtheright(true, 1, zrows, l - 1, l, workc, works, ref z, ref wtemp);
										}
										else
										{
											rotations.applyrotationsfromtheleft(true, l - 1, l, 1, zrows, workc, works, ref z, ref wtemp);
										}
									}
									else
									{
										tdevde2(d[l - 1], e[l - 1], d[l], ref rt1, ref rt2);
									}
									d[l - 1] = rt1;
									d[l] = rt2;
									e[l - 1] = 0;
									l = l - 2;
									if (l >= lend)
									{
										continue;
									}
									break;
								}
								if (jtot == nmaxit)
								{
									break;
								}
								jtot = jtot + 1;

								//
								// Form shift.
								//
								g = (d[l - 1] - p) / (2 * e[l - 1]);
								r = tdevdpythag(g, 1);
								g = d[m] - p + e[l - 1] / (g + tdevdextsign(r, g));
								s = 1;
								c = 1;
								p = 0;

								//
								// Inner loop
								//
								lm1 = l - 1;
								for (i = m; i <= lm1; i++)
								{
									f = s * e[i];
									b = c * e[i];
									rotations.generaterotation(g, f, ref c, ref s, ref r);
									if (i != m)
									{
										e[i - 1] = r;
									}
									g = d[i] - p;
									r = (d[i + 1] - g) * s + 2 * c * b;
									p = s * r;
									d[i] = g + p;
									g = c * r - b;

									//
									// If eigenvectors are desired, then save rotations.
									//
									if (zneeded > 0)
									{
										work1[i] = c;
										work2[i] = s;
									}
								}

								//
								// If eigenvectors are desired, then apply saved rotations.
								//
								if (zneeded > 0)
								{
									for (i = m; i <= l - 1; i++)
									{
										workc[i - m + 1] = work1[i];
										works[i - m + 1] = work2[i];
									}
									if (!wastranspose)
									{
										rotations.applyrotationsfromtheright(true, 1, zrows, m, l, workc, works, ref z, ref wtemp);
									}
									else
									{
										rotations.applyrotationsfromtheleft(true, m, l, 1, zrows, workc, works, ref z, ref wtemp);
									}
								}
								d[l] = d[l] - p;
								e[lm1] = g;
								continue;
							}

							//
							// Eigenvalue found.
							//
							d[l] = p;
							l = l - 1;
							if (l >= lend)
							{
								continue;
							}
							break;
						}
					}

					//
					// Undo scaling if necessary
					//
					if (iscale == 1)
					{
						tmp = anorm / ssfmax;
						tmpint = lendsv - 1;
						for (i_ = lsv; i_ <= lendsv; i_++)
						{
							d[i_] = tmp * d[i_];
						}
						for (i_ = lsv; i_ <= tmpint; i_++)
						{
							e[i_] = tmp * e[i_];
						}
					}
					if (iscale == 2)
					{
						tmp = anorm / ssfmin;
						tmpint = lendsv - 1;
						for (i_ = lsv; i_ <= lendsv; i_++)
						{
							d[i_] = tmp * d[i_];
						}
						for (i_ = lsv; i_ <= tmpint; i_++)
						{
							e[i_] = tmp * e[i_];
						}
					}

					//
					// Check for no convergence to an eigenvalue after a total
					// of N*MAXIT iterations.
					//
					if (jtot >= nmaxit)
					{
						result = false;
						if (wastranspose)
						{
							blas.inplacetranspose(ref z, 1, n, 1, n, ref wtemp);
						}
						return result;
					}
				}

				//
				// Order eigenvalues and eigenvectors.
				//
				if (zneeded == 0)
				{

					//
					// Sort
					//
					if (n == 1)
					{
						return result;
					}
					if (n == 2)
					{
						if ((double)(d[1]) > (double)(d[2]))
						{
							tmp = d[1];
							d[1] = d[2];
							d[2] = tmp;
						}
						return result;
					}
					i = 2;
					do
					{
						t = i;
						while (t != 1)
						{
							k = t / 2;
							if ((double)(d[k]) >= (double)(d[t]))
							{
								t = 1;
							}
							else
							{
								tmp = d[k];
								d[k] = d[t];
								d[t] = tmp;
								t = k;
							}
						}
						i = i + 1;
					}
					while (i <= n);
					i = n - 1;
					do
					{
						tmp = d[i + 1];
						d[i + 1] = d[1];
						d[1] = tmp;
						t = 1;
						while (t != 0)
						{
							k = 2 * t;
							if (k > i)
							{
								t = 0;
							}
							else
							{
								if (k < i)
								{
									if ((double)(d[k + 1]) > (double)(d[k]))
									{
										k = k + 1;
									}
								}
								if ((double)(d[t]) >= (double)(d[k]))
								{
									t = 0;
								}
								else
								{
									tmp = d[k];
									d[k] = d[t];
									d[t] = tmp;
									t = k;
								}
							}
						}
						i = i - 1;
					}
					while (i >= 1);
				}
				else
				{

					//
					// Use Selection Sort to minimize swaps of eigenvectors
					//
					for (ii = 2; ii <= n; ii++)
					{
						i = ii - 1;
						k = i;
						p = d[i];
						for (j = ii; j <= n; j++)
						{
							if ((double)(d[j]) < (double)(p))
							{
								k = j;
								p = d[j];
							}
						}
						if (k != i)
						{
							d[k] = d[i];
							d[i] = p;
							if (wastranspose)
							{
								for (i_ = 1; i_ <= n; i_++)
								{
									wtemp[i_] = z[i, i_];
								}
								for (i_ = 1; i_ <= n; i_++)
								{
									z[i, i_] = z[k, i_];
								}
								for (i_ = 1; i_ <= n; i_++)
								{
									z[k, i_] = wtemp[i_];
								}
							}
							else
							{
								for (i_ = 1; i_ <= zrows; i_++)
								{
									wtemp[i_] = z[i_, i];
								}
								for (i_ = 1; i_ <= zrows; i_++)
								{
									z[i_, i] = z[i_, k];
								}
								for (i_ = 1; i_ <= zrows; i_++)
								{
									z[i_, k] = wtemp[i_];
								}
							}
						}
					}
					if (wastranspose)
					{
						blas.inplacetranspose(ref z, 1, n, 1, n, ref wtemp);
					}
				}
				return result;
			}


			/*************************************************************************
			DLAE2  computes the eigenvalues of a 2-by-2 symmetric matrix
				 [  A   B  ]
				 [  B   C  ].
			On return, RT1 is the eigenvalue of larger absolute value, and RT2
			is the eigenvalue of smaller absolute value.

				-- LAPACK auxiliary routine (version 3.0) --
					 Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
					 Courant Institute, Argonne National Lab, and Rice University
					 October 31, 1992
			*************************************************************************/
			private static void tdevde2(double a,
					double b,
					double c,
					ref double rt1,
					ref double rt2)
			{
				double ab = 0;
				double acmn = 0;
				double acmx = 0;
				double adf = 0;
				double df = 0;
				double rt = 0;
				double sm = 0;
				double tb = 0;

				rt1 = 0;
				rt2 = 0;

				sm = a + c;
				df = a - c;
				adf = Math.Abs(df);
				tb = b + b;
				ab = Math.Abs(tb);
				if ((double)(Math.Abs(a)) > (double)(Math.Abs(c)))
				{
					acmx = a;
					acmn = c;
				}
				else
				{
					acmx = c;
					acmn = a;
				}
				if ((double)(adf) > (double)(ab))
				{
					rt = (double)(adf * Math.Sqrt(1 + math.sqr(ab / adf)));
				}
				else
				{
					if ((double)(adf) < (double)(ab))
					{
						rt = (double)(ab * Math.Sqrt(1 + math.sqr(adf / ab)));
					}
					else
					{

						//
						// Includes case AB=ADF=0
						//
						rt = (double)(ab * Math.Sqrt(2));
					}
				}
				if ((double)(sm) < (double)(0))
				{
					rt1 = 0.5f * (sm - rt);

					//
					// Order of execution important.
					// To get fully accurate smaller eigenvalue,
					// next line needs to be executed in higher precision.
					//
					rt2 = acmx / rt1 * acmn - b / rt1 * b;
				}
				else
				{
					if ((double)(sm) > (double)(0))
					{
						rt1 = 0.5f * (sm + rt);

						//
						// Order of execution important.
						// To get fully accurate smaller eigenvalue,
						// next line needs to be executed in higher precision.
						//
						rt2 = acmx / rt1 * acmn - b / rt1 * b;
					}
					else
					{

						//
						// Includes case RT1 = RT2 = 0
						//
						rt1 = 0.5f * rt;
						rt2 = -(0.5f * rt);
					}
				}
			}


			/*************************************************************************
			DLAEV2 computes the eigendecomposition of a 2-by-2 symmetric matrix

				 [  A   B  ]
				 [  B   C  ].

			On return, RT1 is the eigenvalue of larger absolute value, RT2 is the
			eigenvalue of smaller absolute value, and (CS1,SN1) is the unit right
			eigenvector for RT1, giving the decomposition

				 [ CS1  SN1 ] [  A   B  ] [ CS1 -SN1 ]  =  [ RT1  0  ]
				 [-SN1  CS1 ] [  B   C  ] [ SN1  CS1 ]     [  0  RT2 ].


				-- LAPACK auxiliary routine (version 3.0) --
					 Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
					 Courant Institute, Argonne National Lab, and Rice University
					 October 31, 1992
			*************************************************************************/
			private static void tdevdev2(double a,
					double b,
					double c,
					ref double rt1,
					ref double rt2,
					ref double cs1,
					ref double sn1)
			{
				int sgn1 = 0;
				int sgn2 = 0;
				double ab = 0;
				double acmn = 0;
				double acmx = 0;
				double acs = 0;
				double adf = 0;
				double cs = 0;
				double ct = 0;
				double df = 0;
				double rt = 0;
				double sm = 0;
				double tb = 0;
				double tn = 0;

				rt1 = 0;
				rt2 = 0;
				cs1 = 0;
				sn1 = 0;


				//
				// Compute the eigenvalues
				//
				sm = a + c;
				df = a - c;
				adf = Math.Abs(df);
				tb = b + b;
				ab = Math.Abs(tb);
				if ((double)(Math.Abs(a)) > (double)(Math.Abs(c)))
				{
					acmx = a;
					acmn = c;
				}
				else
				{
					acmx = c;
					acmn = a;
				}
				if ((double)(adf) > (double)(ab))
				{
					rt = (double)(adf * Math.Sqrt(1 + math.sqr(ab / adf)));
				}
				else
				{
					if ((double)(adf) < (double)(ab))
					{
						rt = (double)(ab * Math.Sqrt(1 + math.sqr(adf / ab)));
					}
					else
					{

						//
						// Includes case AB=ADF=0
						//
						rt = (double)(ab * Math.Sqrt(2));
					}
				}
				if ((double)(sm) < (double)(0))
				{
					rt1 = 0.5f * (sm - rt);
					sgn1 = -1;

					//
					// Order of execution important.
					// To get fully accurate smaller eigenvalue,
					// next line needs to be executed in higher precision.
					//
					rt2 = acmx / rt1 * acmn - b / rt1 * b;
				}
				else
				{
					if ((double)(sm) > (double)(0))
					{
						rt1 = 0.5f * (sm + rt);
						sgn1 = 1;

						//
						// Order of execution important.
						// To get fully accurate smaller eigenvalue,
						// next line needs to be executed in higher precision.
						//
						rt2 = acmx / rt1 * acmn - b / rt1 * b;
					}
					else
					{

						//
						// Includes case RT1 = RT2 = 0
						//
						rt1 = 0.5f * rt;
						rt2 = -(0.5f * rt);
						sgn1 = 1;
					}
				}

				//
				// Compute the eigenvector
				//
				if ((double)(df) >= (double)(0))
				{
					cs = df + rt;
					sgn2 = 1;
				}
				else
				{
					cs = df - rt;
					sgn2 = -1;
				}
				acs = Math.Abs(cs);
				if ((double)(acs) > (double)(ab))
				{
					ct = -(tb / cs);
					sn1 = (double)(1 / Math.Sqrt(1 + ct * ct));
					cs1 = ct * sn1;
				}
				else
				{
					if ((double)(ab) == (double)(0))
					{
						cs1 = 1;
						sn1 = 0;
					}
					else
					{
						tn = -(cs / tb);
						cs1 = (double)(1 / Math.Sqrt(1 + tn * tn));
						sn1 = tn * cs1;
					}
				}
				if (sgn1 == sgn2)
				{
					tn = cs1;
					cs1 = -sn1;
					sn1 = tn;
				}
			}


			/*************************************************************************
			Internal routine
			*************************************************************************/
			private static double tdevdpythag(double a,
					double b)
			{
				double result = 0;

				if ((double)(Math.Abs(a)) < (double)(Math.Abs(b)))
				{
					result = (double)(Math.Abs(b) * Math.Sqrt(1 + math.sqr(a / b)));
				}
				else
				{
					result = (double)(Math.Abs(a) * Math.Sqrt(1 + math.sqr(b / a)));
				}
				return result;
			}


			/*************************************************************************
			Internal routine
			*************************************************************************/
			private static double tdevdextsign(double a,
					double b)
			{
				double result = 0;

				if ((double)(b) >= (double)(0))
				{
					result = Math.Abs(a);
				}
				else
				{
					result = -Math.Abs(a);
				}
				return result;
			}


			private static bool internalbisectioneigenvalues(double[] d,
					double[] e,
					int n,
					int irange,
					int iorder,
					double vl,
					double vu,
					int il,
					int iu,
					double abstol,
					ref double[] w,
					ref int m,
					ref int nsplit,
					ref int[] iblock,
					ref int[] isplit,
					ref int errorcode)
			{
				bool result = new bool();
				double fudge = 0;
				double relfac = 0;
				bool ncnvrg = new bool();
				bool toofew = new bool();
				int ib = 0;
				int ibegin = 0;
				int idiscl = 0;
				int idiscu = 0;
				int ie = 0;
				int iend = 0;
				int iinfo = 0;
				int im = 0;
				int iin = 0;
				int ioff = 0;
				int iout = 0;
				int itmax = 0;
				int iw = 0;
				int iwoff = 0;
				int j = 0;
				int itmp1 = 0;
				int jb = 0;
				int jdisc = 0;
				int je = 0;
				int nwl = 0;
				int nwu = 0;
				double atoli = 0;
				double bnorm = 0;
				double gl = 0;
				double gu = 0;
				double pivmin = 0;
				double rtoli = 0;
				double safemn = 0;
				double tmp1 = 0;
				double tmp2 = 0;
				double tnorm = 0;
				double ulp = 0;
				double wkill = 0;
				double wl = 0;
				double wlu = 0;
				double wu = 0;
				double wul = 0;
				double scalefactor = 0;
				double t = 0;
				int[] idumma = new int[0];
				double[] work = new double[0];
				int[] iwork = new int[0];
				int[] ia1s2 = new int[0];
				double[] ra1s2 = new double[0];
				double[,] ra1s2x2 = new double[0, 0];
				int[,] ia1s2x2 = new int[0, 0];
				double[] ra1siin = new double[0];
				double[] ra2siin = new double[0];
				double[] ra3siin = new double[0];
				double[] ra4siin = new double[0];
				double[,] ra1siinx2 = new double[0, 0];
				int[,] ia1siinx2 = new int[0, 0];
				int[] iworkspace = new int[0];
				double[] rworkspace = new double[0];
				int tmpi = 0;

				d = (double[])d.Clone();
				e = (double[])e.Clone();
				w = new double[0];
				m = 0;
				nsplit = 0;
				iblock = new int[0];
				isplit = new int[0];
				errorcode = 0;


				//
				// Quick return if possible
				//
				m = 0;
				if (n == 0)
				{
					result = true;
					return result;
				}

				//
				// Get machine constants
				// NB is the minimum vector length for vector bisection, or 0
				// if only scalar is to be done.
				//
				fudge = 2;
				relfac = 2;
				safemn = math.minrealnumber;
				ulp = 2 * math.machineepsilon;
				rtoli = ulp * relfac;
				idumma = new int[1 + 1];
				work = new double[4 * n + 1];
				iwork = new int[3 * n + 1];
				w = new double[n + 1];
				iblock = new int[n + 1];
				isplit = new int[n + 1];
				ia1s2 = new int[2 + 1];
				ra1s2 = new double[2 + 1];
				ra1s2x2 = new double[2 + 1, 2 + 1];
				ia1s2x2 = new int[2 + 1, 2 + 1];
				ra1siin = new double[n + 1];
				ra2siin = new double[n + 1];
				ra3siin = new double[n + 1];
				ra4siin = new double[n + 1];
				ra1siinx2 = new double[n + 1, 2 + 1];
				ia1siinx2 = new int[n + 1, 2 + 1];
				iworkspace = new int[n + 1];
				rworkspace = new double[n + 1];

				//
				// these initializers are not really necessary,
				// but without them compiler complains about uninitialized locals
				//
				wlu = 0;
				wul = 0;

				//
				// Check for Errors
				//
				result = false;
				errorcode = 0;
				if (irange <= 0 || irange >= 4)
				{
					errorcode = -4;
				}
				if (iorder <= 0 || iorder >= 3)
				{
					errorcode = -5;
				}
				if (n < 0)
				{
					errorcode = -3;
				}
				if (irange == 2 && (double)(vl) >= (double)(vu))
				{
					errorcode = -6;
				}
				if (irange == 3 && (il < 1 || il > Math.Max(1, n)))
				{
					errorcode = -8;
				}
				if (irange == 3 && (iu < Math.Min(n, il) || iu > n))
				{
					errorcode = -9;
				}
				if (errorcode != 0)
				{
					return result;
				}

				//
				// Initialize error flags
				//
				ncnvrg = false;
				toofew = false;

				//
				// Simplifications:
				//
				if ((irange == 3 && il == 1) && iu == n)
				{
					irange = 1;
				}

				//
				// Special Case when N=1
				//
				if (n == 1)
				{
					nsplit = 1;
					isplit[1] = 1;
					if (irange == 2 && ((double)(vl) >= (double)(d[1]) || (double)(vu) < (double)(d[1])))
					{
						m = 0;
					}
					else
					{
						w[1] = d[1];
						iblock[1] = 1;
						m = 1;
					}
					result = true;
					return result;
				}

				//
				// Scaling
				//
				t = Math.Abs(d[n]);
				for (j = 1; j <= n - 1; j++)
				{
					t = Math.Max(t, Math.Abs(d[j]));
					t = Math.Max(t, Math.Abs(e[j]));
				}
				scalefactor = 1;
				if ((double)(t) != (double)(0))
				{
					if ((double)(t) > (double)(Math.Sqrt(Math.Sqrt(math.minrealnumber)) * Math.Sqrt(math.maxrealnumber)))
					{
						scalefactor = t;
					}
					if ((double)(t) < (double)(Math.Sqrt(Math.Sqrt(math.maxrealnumber)) * Math.Sqrt(math.minrealnumber)))
					{
						scalefactor = t;
					}
					for (j = 1; j <= n - 1; j++)
					{
						d[j] = d[j] / scalefactor;
						e[j] = e[j] / scalefactor;
					}
					d[n] = d[n] / scalefactor;
				}

				//
				// Compute Splitting Points
				//
				nsplit = 1;
				work[n] = 0;
				pivmin = 1;
				for (j = 2; j <= n; j++)
				{
					tmp1 = math.sqr(e[j - 1]);
					if ((double)(Math.Abs(d[j] * d[j - 1]) * math.sqr(ulp) + safemn) > (double)(tmp1))
					{
						isplit[nsplit] = j - 1;
						nsplit = nsplit + 1;
						work[j - 1] = 0;
					}
					else
					{
						work[j - 1] = tmp1;
						pivmin = Math.Max(pivmin, tmp1);
					}
				}
				isplit[nsplit] = n;
				pivmin = pivmin * safemn;

				//
				// Compute Interval and ATOLI
				//
				if (irange == 3)
				{

					//
					// RANGE='I': Compute the interval containing eigenvalues
					//     IL through IU.
					//
					// Compute Gershgorin interval for entire (split) matrix
					// and use it as the initial interval
					//
					gu = d[1];
					gl = d[1];
					tmp1 = 0;
					for (j = 1; j <= n - 1; j++)
					{
						tmp2 = (double)Math.Sqrt(work[j]);
						gu = Math.Max(gu, d[j] + tmp1 + tmp2);
						gl = Math.Min(gl, d[j] - tmp1 - tmp2);
						tmp1 = tmp2;
					}
					gu = Math.Max(gu, d[n] + tmp1);
					gl = Math.Min(gl, d[n] - tmp1);
					tnorm = Math.Max(Math.Abs(gl), Math.Abs(gu));
					gl = gl - fudge * tnorm * ulp * n - fudge * 2 * pivmin;
					gu = gu + fudge * tnorm * ulp * n + fudge * pivmin;

					//
					// Compute Iteration parameters
					//
					itmax = (int)Math.Ceiling((Math.Log(tnorm + pivmin) - Math.Log(pivmin)) / Math.Log(2)) + 2;
					if ((double)(abstol) <= (double)(0))
					{
						atoli = ulp * tnorm;
					}
					else
					{
						atoli = abstol;
					}
					work[n + 1] = gl;
					work[n + 2] = gl;
					work[n + 3] = gu;
					work[n + 4] = gu;
					work[n + 5] = gl;
					work[n + 6] = gu;
					iwork[1] = -1;
					iwork[2] = -1;
					iwork[3] = n + 1;
					iwork[4] = n + 1;
					iwork[5] = il - 1;
					iwork[6] = iu;

					//
					// Calling DLAEBZ
					//
					// DLAEBZ( 3, ITMAX, N, 2, 2, NB, ATOLI, RTOLI, PIVMIN, D, E,
					//    WORK, IWORK( 5 ), WORK( N+1 ), WORK( N+5 ), IOUT,
					//    IWORK, W, IBLOCK, IINFO )
					//
					ia1s2[1] = iwork[5];
					ia1s2[2] = iwork[6];
					ra1s2[1] = work[n + 5];
					ra1s2[2] = work[n + 6];
					ra1s2x2[1, 1] = work[n + 1];
					ra1s2x2[2, 1] = work[n + 2];
					ra1s2x2[1, 2] = work[n + 3];
					ra1s2x2[2, 2] = work[n + 4];
					ia1s2x2[1, 1] = iwork[1];
					ia1s2x2[2, 1] = iwork[2];
					ia1s2x2[1, 2] = iwork[3];
					ia1s2x2[2, 2] = iwork[4];
					internaldlaebz(3, itmax, n, 2, 2, atoli, rtoli, pivmin, d, e, work, ref ia1s2, ref ra1s2x2, ref ra1s2, ref iout, ref ia1s2x2, ref w, ref iblock, ref iinfo);
					iwork[5] = ia1s2[1];
					iwork[6] = ia1s2[2];
					work[n + 5] = ra1s2[1];
					work[n + 6] = ra1s2[2];
					work[n + 1] = ra1s2x2[1, 1];
					work[n + 2] = ra1s2x2[2, 1];
					work[n + 3] = ra1s2x2[1, 2];
					work[n + 4] = ra1s2x2[2, 2];
					iwork[1] = ia1s2x2[1, 1];
					iwork[2] = ia1s2x2[2, 1];
					iwork[3] = ia1s2x2[1, 2];
					iwork[4] = ia1s2x2[2, 2];
					if (iwork[6] == iu)
					{
						wl = work[n + 1];
						wlu = work[n + 3];
						nwl = iwork[1];
						wu = work[n + 4];
						wul = work[n + 2];
						nwu = iwork[4];
					}
					else
					{
						wl = work[n + 2];
						wlu = work[n + 4];
						nwl = iwork[2];
						wu = work[n + 3];
						wul = work[n + 1];
						nwu = iwork[3];
					}
					if (((nwl < 0 || nwl >= n) || nwu < 1) || nwu > n)
					{
						errorcode = 4;
						result = false;
						return result;
					}
				}
				else
				{

					//
					// RANGE='A' or 'V' -- Set ATOLI
					//
					tnorm = Math.Max(Math.Abs(d[1]) + Math.Abs(e[1]), Math.Abs(d[n]) + Math.Abs(e[n - 1]));
					for (j = 2; j <= n - 1; j++)
					{
						tnorm = Math.Max(tnorm, Math.Abs(d[j]) + Math.Abs(e[j - 1]) + Math.Abs(e[j]));
					}
					if ((double)(abstol) <= (double)(0))
					{
						atoli = ulp * tnorm;
					}
					else
					{
						atoli = abstol;
					}
					if (irange == 2)
					{
						wl = vl;
						wu = vu;
					}
					else
					{
						wl = 0;
						wu = 0;
					}
				}

				//
				// Find Eigenvalues -- Loop Over Blocks and recompute NWL and NWU.
				// NWL accumulates the number of eigenvalues .le. WL,
				// NWU accumulates the number of eigenvalues .le. WU
				//
				m = 0;
				iend = 0;
				errorcode = 0;
				nwl = 0;
				nwu = 0;
				for (jb = 1; jb <= nsplit; jb++)
				{
					ioff = iend;
					ibegin = ioff + 1;
					iend = isplit[jb];
					iin = iend - ioff;
					if (iin == 1)
					{

						//
						// Special Case -- IIN=1
						//
						if (irange == 1 || (double)(wl) >= (double)(d[ibegin] - pivmin))
						{
							nwl = nwl + 1;
						}
						if (irange == 1 || (double)(wu) >= (double)(d[ibegin] - pivmin))
						{
							nwu = nwu + 1;
						}
						if (irange == 1 || ((double)(wl) < (double)(d[ibegin] - pivmin) && (double)(wu) >= (double)(d[ibegin] - pivmin)))
						{
							m = m + 1;
							w[m] = d[ibegin];
							iblock[m] = jb;
						}
					}
					else
					{

						//
						// General Case -- IIN > 1
						//
						// Compute Gershgorin Interval
						// and use it as the initial interval
						//
						gu = d[ibegin];
						gl = d[ibegin];
						tmp1 = 0;
						for (j = ibegin; j <= iend - 1; j++)
						{
							tmp2 = Math.Abs(e[j]);
							gu = Math.Max(gu, d[j] + tmp1 + tmp2);
							gl = Math.Min(gl, d[j] - tmp1 - tmp2);
							tmp1 = tmp2;
						}
						gu = Math.Max(gu, d[iend] + tmp1);
						gl = Math.Min(gl, d[iend] - tmp1);
						bnorm = Math.Max(Math.Abs(gl), Math.Abs(gu));
						gl = gl - fudge * bnorm * ulp * iin - fudge * pivmin;
						gu = gu + fudge * bnorm * ulp * iin + fudge * pivmin;

						//
						// Compute ATOLI for the current submatrix
						//
						if ((double)(abstol) <= (double)(0))
						{
							atoli = ulp * Math.Max(Math.Abs(gl), Math.Abs(gu));
						}
						else
						{
							atoli = abstol;
						}
						if (irange > 1)
						{
							if ((double)(gu) < (double)(wl))
							{
								nwl = nwl + iin;
								nwu = nwu + iin;
								continue;
							}
							gl = Math.Max(gl, wl);
							gu = Math.Min(gu, wu);
							if ((double)(gl) >= (double)(gu))
							{
								continue;
							}
						}

						//
						// Set Up Initial Interval
						//
						work[n + 1] = gl;
						work[n + iin + 1] = gu;

						//
						// Calling DLAEBZ
						//
						// CALL DLAEBZ( 1, 0, IN, IN, 1, NB, ATOLI, RTOLI, PIVMIN,
						//    D( IBEGIN ), E( IBEGIN ), WORK( IBEGIN ),
						//    IDUMMA, WORK( N+1 ), WORK( N+2*IN+1 ), IM,
						//    IWORK, W( M+1 ), IBLOCK( M+1 ), IINFO )
						//
						for (tmpi = 1; tmpi <= iin; tmpi++)
						{
							ra1siin[tmpi] = d[ibegin - 1 + tmpi];
							if (ibegin - 1 + tmpi < n)
							{
								ra2siin[tmpi] = e[ibegin - 1 + tmpi];
							}
							ra3siin[tmpi] = work[ibegin - 1 + tmpi];
							ra1siinx2[tmpi, 1] = work[n + tmpi];
							ra1siinx2[tmpi, 2] = work[n + tmpi + iin];
							ra4siin[tmpi] = work[n + 2 * iin + tmpi];
							rworkspace[tmpi] = w[m + tmpi];
							iworkspace[tmpi] = iblock[m + tmpi];
							ia1siinx2[tmpi, 1] = iwork[tmpi];
							ia1siinx2[tmpi, 2] = iwork[tmpi + iin];
						}
						internaldlaebz(1, 0, iin, iin, 1, atoli, rtoli, pivmin, ra1siin, ra2siin, ra3siin, ref idumma, ref ra1siinx2, ref ra4siin, ref im, ref ia1siinx2, ref rworkspace, ref iworkspace, ref iinfo);
						for (tmpi = 1; tmpi <= iin; tmpi++)
						{
							work[n + tmpi] = ra1siinx2[tmpi, 1];
							work[n + tmpi + iin] = ra1siinx2[tmpi, 2];
							work[n + 2 * iin + tmpi] = ra4siin[tmpi];
							w[m + tmpi] = rworkspace[tmpi];
							iblock[m + tmpi] = iworkspace[tmpi];
							iwork[tmpi] = ia1siinx2[tmpi, 1];
							iwork[tmpi + iin] = ia1siinx2[tmpi, 2];
						}
						nwl = nwl + iwork[1];
						nwu = nwu + iwork[iin + 1];
						iwoff = m - iwork[1];

						//
						// Compute Eigenvalues
						//
						itmax = (int)Math.Ceiling((Math.Log(gu - gl + pivmin) - Math.Log(pivmin)) / Math.Log(2)) + 2;

						//
						// Calling DLAEBZ
						//
						//CALL DLAEBZ( 2, ITMAX, IN, IN, 1, NB, ATOLI, RTOLI, PIVMIN,
						//    D( IBEGIN ), E( IBEGIN ), WORK( IBEGIN ),
						//    IDUMMA, WORK( N+1 ), WORK( N+2*IN+1 ), IOUT,
						//    IWORK, W( M+1 ), IBLOCK( M+1 ), IINFO )
						//
						for (tmpi = 1; tmpi <= iin; tmpi++)
						{
							ra1siin[tmpi] = d[ibegin - 1 + tmpi];
							if (ibegin - 1 + tmpi < n)
							{
								ra2siin[tmpi] = e[ibegin - 1 + tmpi];
							}
							ra3siin[tmpi] = work[ibegin - 1 + tmpi];
							ra1siinx2[tmpi, 1] = work[n + tmpi];
							ra1siinx2[tmpi, 2] = work[n + tmpi + iin];
							ra4siin[tmpi] = work[n + 2 * iin + tmpi];
							rworkspace[tmpi] = w[m + tmpi];
							iworkspace[tmpi] = iblock[m + tmpi];
							ia1siinx2[tmpi, 1] = iwork[tmpi];
							ia1siinx2[tmpi, 2] = iwork[tmpi + iin];
						}
						internaldlaebz(2, itmax, iin, iin, 1, atoli, rtoli, pivmin, ra1siin, ra2siin, ra3siin, ref idumma, ref ra1siinx2, ref ra4siin, ref iout, ref ia1siinx2, ref rworkspace, ref iworkspace, ref iinfo);
						for (tmpi = 1; tmpi <= iin; tmpi++)
						{
							work[n + tmpi] = ra1siinx2[tmpi, 1];
							work[n + tmpi + iin] = ra1siinx2[tmpi, 2];
							work[n + 2 * iin + tmpi] = ra4siin[tmpi];
							w[m + tmpi] = rworkspace[tmpi];
							iblock[m + tmpi] = iworkspace[tmpi];
							iwork[tmpi] = ia1siinx2[tmpi, 1];
							iwork[tmpi + iin] = ia1siinx2[tmpi, 2];
						}

						//
						// Copy Eigenvalues Into W and IBLOCK
						// Use -JB for block number for unconverged eigenvalues.
						//
						for (j = 1; j <= iout; j++)
						{
							tmp1 = 0.5f * (work[j + n] + work[j + iin + n]);

							//
							// Flag non-convergence.
							//
							if (j > iout - iinfo)
							{
								ncnvrg = true;
								ib = -jb;
							}
							else
							{
								ib = jb;
							}
							for (je = iwork[j] + 1 + iwoff; je <= iwork[j + iin] + iwoff; je++)
							{
								w[je] = tmp1;
								iblock[je] = ib;
							}
						}
						m = m + im;
					}
				}

				//
				// If RANGE='I', then (WL,WU) contains eigenvalues NWL+1,...,NWU
				// If NWL+1 < IL or NWU > IU, discard extra eigenvalues.
				//
				if (irange == 3)
				{
					im = 0;
					idiscl = il - 1 - nwl;
					idiscu = nwu - iu;
					if (idiscl > 0 || idiscu > 0)
					{
						for (je = 1; je <= m; je++)
						{
							if ((double)(w[je]) <= (double)(wlu) && idiscl > 0)
							{
								idiscl = idiscl - 1;
							}
							else
							{
								if ((double)(w[je]) >= (double)(wul) && idiscu > 0)
								{
									idiscu = idiscu - 1;
								}
								else
								{
									im = im + 1;
									w[im] = w[je];
									iblock[im] = iblock[je];
								}
							}
						}
						m = im;
					}
					if (idiscl > 0 || idiscu > 0)
					{

						//
						// Code to deal with effects of bad arithmetic:
						// Some low eigenvalues to be discarded are not in (WL,WLU],
						// or high eigenvalues to be discarded are not in (WUL,WU]
						// so just kill off the smallest IDISCL/largest IDISCU
						// eigenvalues, by simply finding the smallest/largest
						// eigenvalue(s).
						//
						// (If N(w) is monotone non-decreasing, this should never
						//  happen.)
						//
						if (idiscl > 0)
						{
							wkill = wu;
							for (jdisc = 1; jdisc <= idiscl; jdisc++)
							{
								iw = 0;
								for (je = 1; je <= m; je++)
								{
									if (iblock[je] != 0 && ((double)(w[je]) < (double)(wkill) || iw == 0))
									{
										iw = je;
										wkill = w[je];
									}
								}
								iblock[iw] = 0;
							}
						}
						if (idiscu > 0)
						{
							wkill = wl;
							for (jdisc = 1; jdisc <= idiscu; jdisc++)
							{
								iw = 0;
								for (je = 1; je <= m; je++)
								{
									if (iblock[je] != 0 && ((double)(w[je]) > (double)(wkill) || iw == 0))
									{
										iw = je;
										wkill = w[je];
									}
								}
								iblock[iw] = 0;
							}
						}
						im = 0;
						for (je = 1; je <= m; je++)
						{
							if (iblock[je] != 0)
							{
								im = im + 1;
								w[im] = w[je];
								iblock[im] = iblock[je];
							}
						}
						m = im;
					}
					if (idiscl < 0 || idiscu < 0)
					{
						toofew = true;
					}
				}

				//
				// If ORDER='B', do nothing -- the eigenvalues are already sorted
				//    by block.
				// If ORDER='E', sort the eigenvalues from smallest to largest
				//
				if (iorder == 1 && nsplit > 1)
				{
					for (je = 1; je <= m - 1; je++)
					{
						ie = 0;
						tmp1 = w[je];
						for (j = je + 1; j <= m; j++)
						{
							if ((double)(w[j]) < (double)(tmp1))
							{
								ie = j;
								tmp1 = w[j];
							}
						}
						if (ie != 0)
						{
							itmp1 = iblock[ie];
							w[ie] = w[je];
							iblock[ie] = iblock[je];
							w[je] = tmp1;
							iblock[je] = itmp1;
						}
					}
				}
				for (j = 1; j <= m; j++)
				{
					w[j] = w[j] * scalefactor;
				}
				errorcode = 0;
				if (ncnvrg)
				{
					errorcode = errorcode + 1;
				}
				if (toofew)
				{
					errorcode = errorcode + 2;
				}
				result = errorcode == 0;
				return result;
			}


			private static void internaldstein(int n,
					double[] d,
					double[] e,
					int m,
					double[] w,
					int[] iblock,
					int[] isplit,
					ref double[,] z,
					ref int[] ifail,
					ref int info)
			{
				int maxits = 0;
				int extra = 0;
				int b1 = 0;
				int blksiz = 0;
				int bn = 0;
				int gpind = 0;
				int i = 0;
				int iinfo = 0;
				int its = 0;
				int j = 0;
				int j1 = 0;
				int jblk = 0;
				int jmax = 0;
				int nblk = 0;
				int nrmchk = 0;
				double dtpcrt = 0;
				double eps = 0;
				double eps1 = 0;
				double nrm = 0;
				double onenrm = 0;
				double ortol = 0;
				double pertol = 0;
				double scl = 0;
				double sep = 0;
				double tol = 0;
				double xj = 0;
				double xjm = 0;
				double ztr = 0;
				double[] work1 = new double[0];
				double[] work2 = new double[0];
				double[] work3 = new double[0];
				double[] work4 = new double[0];
				double[] work5 = new double[0];
				int[] iwork = new int[0];
				bool tmpcriterion = new bool();
				int ti = 0;
				int i1 = 0;
				int i2 = 0;
				double v = 0;
				int i_ = 0;
				int i1_ = 0;

				e = (double[])e.Clone();
				w = (double[])w.Clone();
				z = new double[0, 0];
				ifail = new int[0];
				info = 0;

				maxits = 5;
				extra = 2;
				work1 = new double[Math.Max(n, 1) + 1];
				work2 = new double[Math.Max(n - 1, 1) + 1];
				work3 = new double[Math.Max(n, 1) + 1];
				work4 = new double[Math.Max(n, 1) + 1];
				work5 = new double[Math.Max(n, 1) + 1];
				iwork = new int[Math.Max(n, 1) + 1];
				ifail = new int[Math.Max(m, 1) + 1];
				z = new double[Math.Max(n, 1) + 1, Math.Max(m, 1) + 1];

				//
				// these initializers are not really necessary,
				// but without them compiler complains about uninitialized locals
				//
				gpind = 0;
				onenrm = 0;
				ortol = 0;
				dtpcrt = 0;
				xjm = 0;

				//
				// Test the input parameters.
				//
				info = 0;
				for (i = 1; i <= m; i++)
				{
					ifail[i] = 0;
				}
				if (n < 0)
				{
					info = -1;
					return;
				}
				if (m < 0 || m > n)
				{
					info = -4;
					return;
				}
				for (j = 2; j <= m; j++)
				{
					if (iblock[j] < iblock[j - 1])
					{
						info = -6;
						break;
					}
					if (iblock[j] == iblock[j - 1] && (double)(w[j]) < (double)(w[j - 1]))
					{
						info = -5;
						break;
					}
				}
				if (info != 0)
				{
					return;
				}

				//
				// Quick return if possible
				//
				if (n == 0 || m == 0)
				{
					return;
				}
				if (n == 1)
				{
					z[1, 1] = 1;
					return;
				}

				//
				// Some preparations
				//
				ti = n - 1;
				for (i_ = 1; i_ <= ti; i_++)
				{
					work1[i_] = e[i_];
				}
				e = new double[n + 1];
				for (i_ = 1; i_ <= ti; i_++)
				{
					e[i_] = work1[i_];
				}
				for (i_ = 1; i_ <= m; i_++)
				{
					work1[i_] = w[i_];
				}
				w = new double[n + 1];
				for (i_ = 1; i_ <= m; i_++)
				{
					w[i_] = work1[i_];
				}

				//
				// Get machine constants.
				//
				eps = math.machineepsilon;

				//
				// Compute eigenvectors of matrix blocks.
				//
				j1 = 1;
				for (nblk = 1; nblk <= iblock[m]; nblk++)
				{

					//
					// Find starting and ending indices of block nblk.
					//
					if (nblk == 1)
					{
						b1 = 1;
					}
					else
					{
						b1 = isplit[nblk - 1] + 1;
					}
					bn = isplit[nblk];
					blksiz = bn - b1 + 1;
					if (blksiz != 1)
					{

						//
						// Compute reorthogonalization criterion and stopping criterion.
						//
						gpind = b1;
						onenrm = Math.Abs(d[b1]) + Math.Abs(e[b1]);
						onenrm = Math.Max(onenrm, Math.Abs(d[bn]) + Math.Abs(e[bn - 1]));
						for (i = b1 + 1; i <= bn - 1; i++)
						{
							onenrm = Math.Max(onenrm, Math.Abs(d[i]) + Math.Abs(e[i - 1]) + Math.Abs(e[i]));
						}
						ortol = 0.001f * onenrm;
						dtpcrt = (double)(Math.Sqrt(0.1 / blksiz));
					}

					//
					// Loop through eigenvalues of block nblk.
					//
					jblk = 0;
					for (j = j1; j <= m; j++)
					{
						if (iblock[j] != nblk)
						{
							j1 = j;
							break;
						}
						jblk = jblk + 1;
						xj = w[j];
						if (blksiz == 1)
						{

							//
							// Skip all the work if the block size is one.
							//
							work1[1] = 1;
						}
						else
						{

							//
							// If eigenvalues j and j-1 are too close, add a relatively
							// small perturbation.
							//
							if (jblk > 1)
							{
								eps1 = Math.Abs(eps * xj);
								pertol = 10 * eps1;
								sep = xj - xjm;
								if ((double)(sep) < (double)(pertol))
								{
									xj = xjm + pertol;
								}
							}
							its = 0;
							nrmchk = 0;

							//
							// Get random starting vector.
							//
							for (ti = 1; ti <= blksiz; ti++)
							{
								work1[ti] = 2 * math.randomreal() - 1;
							}

							//
							// Copy the matrix T so it won't be destroyed in factorization.
							//
							for (ti = 1; ti <= blksiz - 1; ti++)
							{
								work2[ti] = e[b1 + ti - 1];
								work3[ti] = e[b1 + ti - 1];
								work4[ti] = d[b1 + ti - 1];
							}
							work4[blksiz] = d[b1 + blksiz - 1];

							//
							// Compute LU factors with partial pivoting  ( PT = LU )
							//
							tol = 0;
							tdininternaldlagtf(blksiz, ref work4, xj, ref work2, ref work3, tol, ref work5, ref iwork, ref iinfo);

							//
							// Update iteration count.
							//
							do
							{
								its = its + 1;
								if (its > maxits)
								{

									//
									// If stopping criterion was not satisfied, update info and
									// store eigenvector number in array ifail.
									//
									info = info + 1;
									ifail[info] = j;
									break;
								}

								//
								// Normalize and scale the righthand side vector Pb.
								//
								v = 0;
								for (ti = 1; ti <= blksiz; ti++)
								{
									v = v + Math.Abs(work1[ti]);
								}
								scl = blksiz * onenrm * Math.Max(eps, Math.Abs(work4[blksiz])) / v;
								for (i_ = 1; i_ <= blksiz; i_++)
								{
									work1[i_] = scl * work1[i_];
								}

								//
								// Solve the system LU = Pb.
								//
								tdininternaldlagts(blksiz, work4, work2, work3, work5, iwork, ref work1, ref tol, ref iinfo);

								//
								// Reorthogonalize by modified Gram-Schmidt if eigenvalues are
								// close enough.
								//
								if (jblk != 1)
								{
									if ((double)(Math.Abs(xj - xjm)) > (double)(ortol))
									{
										gpind = j;
									}
									if (gpind != j)
									{
										for (i = gpind; i <= j - 1; i++)
										{
											i1 = b1;
											i2 = b1 + blksiz - 1;
											i1_ = (i1) - (1);
											ztr = 0.0f;
											for (i_ = 1; i_ <= blksiz; i_++)
											{
												ztr += work1[i_] * z[i_ + i1_, i];
											}
											i1_ = (i1) - (1);
											for (i_ = 1; i_ <= blksiz; i_++)
											{
												work1[i_] = work1[i_] - ztr * z[i_ + i1_, i];
											}
											apserv.touchint(ref i2);
										}
									}
								}

								//
								// Check the infinity norm of the iterate.
								//
								jmax = blas.vectoridxabsmax(work1, 1, blksiz);
								nrm = Math.Abs(work1[jmax]);

								//
								// Continue for additional iterations after norm reaches
								// stopping criterion.
								//
								tmpcriterion = false;
								if ((double)(nrm) < (double)(dtpcrt))
								{
									tmpcriterion = true;
								}
								else
								{
									nrmchk = nrmchk + 1;
									if (nrmchk < extra + 1)
									{
										tmpcriterion = true;
									}
								}
							}
							while (tmpcriterion);

							//
							// Accept iterate as jth eigenvector.
							//
							scl = 1 / blas.vectornorm2(work1, 1, blksiz);
							jmax = blas.vectoridxabsmax(work1, 1, blksiz);
							if ((double)(work1[jmax]) < (double)(0))
							{
								scl = -scl;
							}
							for (i_ = 1; i_ <= blksiz; i_++)
							{
								work1[i_] = scl * work1[i_];
							}
						}
						for (i = 1; i <= n; i++)
						{
							z[i, j] = 0;
						}
						for (i = 1; i <= blksiz; i++)
						{
							z[b1 + i - 1, j] = work1[i];
						}

						//
						// Save the shift to check eigenvalue spacing at next
						// iteration.
						//
						xjm = xj;
					}
				}
			}


			private static void tdininternaldlagtf(int n,
					ref double[] a,
					double lambdav,
					ref double[] b,
					ref double[] c,
					double tol,
					ref double[] d,
					ref int[] iin,
					ref int info)
			{
				int k = 0;
				double eps = 0;
				double mult = 0;
				double piv1 = 0;
				double piv2 = 0;
				double scale1 = 0;
				double scale2 = 0;
				double temp = 0;
				double tl = 0;

				info = 0;

				info = 0;
				if (n < 0)
				{
					info = -1;
					return;
				}
				if (n == 0)
				{
					return;
				}
				a[1] = a[1] - lambdav;
				iin[n] = 0;
				if (n == 1)
				{
					if ((double)(a[1]) == (double)(0))
					{
						iin[1] = 1;
					}
					return;
				}
				eps = math.machineepsilon;
				tl = Math.Max(tol, eps);
				scale1 = Math.Abs(a[1]) + Math.Abs(b[1]);
				for (k = 1; k <= n - 1; k++)
				{
					a[k + 1] = a[k + 1] - lambdav;
					scale2 = Math.Abs(c[k]) + Math.Abs(a[k + 1]);
					if (k < n - 1)
					{
						scale2 = scale2 + Math.Abs(b[k + 1]);
					}
					if ((double)(a[k]) == (double)(0))
					{
						piv1 = 0;
					}
					else
					{
						piv1 = Math.Abs(a[k]) / scale1;
					}
					if ((double)(c[k]) == (double)(0))
					{
						iin[k] = 0;
						piv2 = 0;
						scale1 = scale2;
						if (k < n - 1)
						{
							d[k] = 0;
						}
					}
					else
					{
						piv2 = Math.Abs(c[k]) / scale2;
						if ((double)(piv2) <= (double)(piv1))
						{
							iin[k] = 0;
							scale1 = scale2;
							c[k] = c[k] / a[k];
							a[k + 1] = a[k + 1] - c[k] * b[k];
							if (k < n - 1)
							{
								d[k] = 0;
							}
						}
						else
						{
							iin[k] = 1;
							mult = a[k] / c[k];
							a[k] = c[k];
							temp = a[k + 1];
							a[k + 1] = b[k] - mult * temp;
							if (k < n - 1)
							{
								d[k] = b[k + 1];
								b[k + 1] = -(mult * d[k]);
							}
							b[k] = temp;
							c[k] = mult;
						}
					}
					if ((double)(Math.Max(piv1, piv2)) <= (double)(tl) && iin[n] == 0)
					{
						iin[n] = k;
					}
				}
				if ((double)(Math.Abs(a[n])) <= (double)(scale1 * tl) && iin[n] == 0)
				{
					iin[n] = n;
				}
			}


			private static void tdininternaldlagts(int n,
					double[] a,
					double[] b,
					double[] c,
					double[] d,
					int[] iin,
					ref double[] y,
					ref double tol,
					ref int info)
			{
				int k = 0;
				double absak = 0;
				double ak = 0;
				double bignum = 0;
				double eps = 0;
				double pert = 0;
				double sfmin = 0;
				double temp = 0;

				info = 0;

				info = 0;
				if (n < 0)
				{
					info = -1;
					return;
				}
				if (n == 0)
				{
					return;
				}
				eps = math.machineepsilon;
				sfmin = math.minrealnumber;
				bignum = 1 / sfmin;
				if ((double)(tol) <= (double)(0))
				{
					tol = Math.Abs(a[1]);
					if (n > 1)
					{
						tol = Math.Max(tol, Math.Max(Math.Abs(a[2]), Math.Abs(b[1])));
					}
					for (k = 3; k <= n; k++)
					{
						tol = Math.Max(tol, Math.Max(Math.Abs(a[k]), Math.Max(Math.Abs(b[k - 1]), Math.Abs(d[k - 2]))));
					}
					tol = tol * eps;
					if ((double)(tol) == (double)(0))
					{
						tol = eps;
					}
				}
				for (k = 2; k <= n; k++)
				{
					if (iin[k - 1] == 0)
					{
						y[k] = y[k] - c[k - 1] * y[k - 1];
					}
					else
					{
						temp = y[k - 1];
						y[k - 1] = y[k];
						y[k] = temp - c[k - 1] * y[k];
					}
				}
				for (k = n; k >= 1; k--)
				{
					if (k <= n - 2)
					{
						temp = y[k] - b[k] * y[k + 1] - d[k] * y[k + 2];
					}
					else
					{
						if (k == n - 1)
						{
							temp = y[k] - b[k] * y[k + 1];
						}
						else
						{
							temp = y[k];
						}
					}
					ak = a[k];
					pert = Math.Abs(tol);
					if ((double)(ak) < (double)(0))
					{
						pert = -pert;
					}
					while (true)
					{
						absak = Math.Abs(ak);
						if ((double)(absak) < (double)(1))
						{
							if ((double)(absak) < (double)(sfmin))
							{
								if ((double)(absak) == (double)(0) || (double)(Math.Abs(temp) * sfmin) > (double)(absak))
								{
									ak = ak + pert;
									pert = 2 * pert;
									continue;
								}
								else
								{
									temp = temp * bignum;
									ak = ak * bignum;
								}
							}
							else
							{
								if ((double)(Math.Abs(temp)) > (double)(absak * bignum))
								{
									ak = ak + pert;
									pert = 2 * pert;
									continue;
								}
							}
						}
						break;
					}
					y[k] = temp / ak;
				}
			}


			private static void internaldlaebz(int ijob,
					int nitmax,
					int n,
					int mmax,
					int minp,
					double abstol,
					double reltol,
					double pivmin,
					double[] d,
					double[] e,
					double[] e2,
					ref int[] nval,
					ref double[,] ab,
					ref double[] c,
					ref int mout,
					ref int[,] nab,
					ref double[] work,
					ref int[] iwork,
					ref int info)
			{
				int itmp1 = 0;
				int itmp2 = 0;
				int j = 0;
				int ji = 0;
				int jit = 0;
				int jp = 0;
				int kf = 0;
				int kfnew = 0;
				int kl = 0;
				int klnew = 0;
				double tmp1 = 0;
				double tmp2 = 0;

				mout = 0;
				info = 0;

				info = 0;
				if (ijob < 1 || ijob > 3)
				{
					info = -1;
					return;
				}

				//
				// Initialize NAB
				//
				if (ijob == 1)
				{

					//
					// Compute the number of eigenvalues in the initial intervals.
					//
					mout = 0;

					//
					//DIR$ NOVECTOR
					//
					for (ji = 1; ji <= minp; ji++)
					{
						for (jp = 1; jp <= 2; jp++)
						{
							tmp1 = d[1] - ab[ji, jp];
							if ((double)(Math.Abs(tmp1)) < (double)(pivmin))
							{
								tmp1 = -pivmin;
							}
							nab[ji, jp] = 0;
							if ((double)(tmp1) <= (double)(0))
							{
								nab[ji, jp] = 1;
							}
							for (j = 2; j <= n; j++)
							{
								tmp1 = d[j] - e2[j - 1] / tmp1 - ab[ji, jp];
								if ((double)(Math.Abs(tmp1)) < (double)(pivmin))
								{
									tmp1 = -pivmin;
								}
								if ((double)(tmp1) <= (double)(0))
								{
									nab[ji, jp] = nab[ji, jp] + 1;
								}
							}
						}
						mout = mout + nab[ji, 2] - nab[ji, 1];
					}
					return;
				}

				//
				// Initialize for loop
				//
				// KF and KL have the following meaning:
				//   Intervals 1,...,KF-1 have converged.
				//   Intervals KF,...,KL  still need to be refined.
				//
				kf = 1;
				kl = minp;

				//
				// If IJOB=2, initialize C.
				// If IJOB=3, use the user-supplied starting point.
				//
				if (ijob == 2)
				{
					for (ji = 1; ji <= minp; ji++)
					{
						c[ji] = 0.5f * (ab[ji, 1] + ab[ji, 2]);
					}
				}

				//
				// Iteration loop
				//
				for (jit = 1; jit <= nitmax; jit++)
				{

					//
					// Loop over intervals
					//
					//
					// Serial Version of the loop
					//
					klnew = kl;
					for (ji = kf; ji <= kl; ji++)
					{

						//
						// Compute N(w), the number of eigenvalues less than w
						//
						tmp1 = c[ji];
						tmp2 = d[1] - tmp1;
						itmp1 = 0;
						if ((double)(tmp2) <= (double)(pivmin))
						{
							itmp1 = 1;
							tmp2 = Math.Min(tmp2, -pivmin);
						}

						//
						// A series of compiler directives to defeat vectorization
						// for the next loop
						//
						//*$PL$ CMCHAR=' '
						//CDIR$          NEXTSCALAR
						//C$DIR          SCALAR
						//CDIR$          NEXT SCALAR
						//CVD$L          NOVECTOR
						//CDEC$          NOVECTOR
						//CVD$           NOVECTOR
						//*VDIR          NOVECTOR
						//*VOCL          LOOP,SCALAR
						//CIBM           PREFER SCALAR
						//*$PL$ CMCHAR='*'
						//
						for (j = 2; j <= n; j++)
						{
							tmp2 = d[j] - e2[j - 1] / tmp2 - tmp1;
							if ((double)(tmp2) <= (double)(pivmin))
							{
								itmp1 = itmp1 + 1;
								tmp2 = Math.Min(tmp2, -pivmin);
							}
						}
						if (ijob <= 2)
						{

							//
							// IJOB=2: Choose all intervals containing eigenvalues.
							//
							// Insure that N(w) is monotone
							//
							itmp1 = Math.Min(nab[ji, 2], Math.Max(nab[ji, 1], itmp1));

							//
							// Update the Queue -- add intervals if both halves
							// contain eigenvalues.
							//
							if (itmp1 == nab[ji, 2])
							{

								//
								// No eigenvalue in the upper interval:
								// just use the lower interval.
								//
								ab[ji, 2] = tmp1;
							}
							else
							{
								if (itmp1 == nab[ji, 1])
								{

									//
									// No eigenvalue in the lower interval:
									// just use the upper interval.
									//
									ab[ji, 1] = tmp1;
								}
								else
								{
									if (klnew < mmax)
									{

										//
										// Eigenvalue in both intervals -- add upper to queue.
										//
										klnew = klnew + 1;
										ab[klnew, 2] = ab[ji, 2];
										nab[klnew, 2] = nab[ji, 2];
										ab[klnew, 1] = tmp1;
										nab[klnew, 1] = itmp1;
										ab[ji, 2] = tmp1;
										nab[ji, 2] = itmp1;
									}
									else
									{
										info = mmax + 1;
										return;
									}
								}
							}
						}
						else
						{

							//
							// IJOB=3: Binary search.  Keep only the interval
							// containing  w  s.t. N(w) = NVAL
							//
							if (itmp1 <= nval[ji])
							{
								ab[ji, 1] = tmp1;
								nab[ji, 1] = itmp1;
							}
							if (itmp1 >= nval[ji])
							{
								ab[ji, 2] = tmp1;
								nab[ji, 2] = itmp1;
							}
						}
					}
					kl = klnew;

					//
					// Check for convergence
					//
					kfnew = kf;
					for (ji = kf; ji <= kl; ji++)
					{
						tmp1 = Math.Abs(ab[ji, 2] - ab[ji, 1]);
						tmp2 = Math.Max(Math.Abs(ab[ji, 2]), Math.Abs(ab[ji, 1]));
						if ((double)(tmp1) < (double)(Math.Max(abstol, Math.Max(pivmin, reltol * tmp2))) || nab[ji, 1] >= nab[ji, 2])
						{

							//
							// Converged -- Swap with position KFNEW,
							// then increment KFNEW
							//
							if (ji > kfnew)
							{
								tmp1 = ab[ji, 1];
								tmp2 = ab[ji, 2];
								itmp1 = nab[ji, 1];
								itmp2 = nab[ji, 2];
								ab[ji, 1] = ab[kfnew, 1];
								ab[ji, 2] = ab[kfnew, 2];
								nab[ji, 1] = nab[kfnew, 1];
								nab[ji, 2] = nab[kfnew, 2];
								ab[kfnew, 1] = tmp1;
								ab[kfnew, 2] = tmp2;
								nab[kfnew, 1] = itmp1;
								nab[kfnew, 2] = itmp2;
								if (ijob == 3)
								{
									itmp1 = nval[ji];
									nval[ji] = nval[kfnew];
									nval[kfnew] = itmp1;
								}
							}
							kfnew = kfnew + 1;
						}
					}
					kf = kfnew;

					//
					// Choose Midpoints
					//
					for (ji = kf; ji <= kl; ji++)
					{
						c[ji] = 0.5f * (ab[ji, 1] + ab[ji, 2]);
					}

					//
					// If no more intervals to refine, quit.
					//
					if (kf > kl)
					{
						break;
					}
				}

				//
				// Converged
				//
				info = Math.Max(kl + 1 - kf, 0);
				mout = kl;
			}


			/*************************************************************************
			Internal subroutine

				-- LAPACK routine (version 3.0) --
					 Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
					 Courant Institute, Argonne National Lab, and Rice University
					 June 30, 1999
			*************************************************************************/
			private static void internaltrevc(double[,] t,
					int n,
					int side,
					int howmny,
					bool[] vselect,
					ref double[,] vl,
					ref double[,] vr,
					ref int m,
					ref int info)
			{
				bool allv = new bool();
				bool bothv = new bool();
				bool leftv = new bool();
				bool over = new bool();
				bool pair = new bool();
				bool rightv = new bool();
				bool somev = new bool();
				int i = 0;
				int ierr = 0;
				int ii = 0;
				int ip = 0;
				int iis = 0;
				int j = 0;
				int j1 = 0;
				int j2 = 0;
				int jnxt = 0;
				int k = 0;
				int ki = 0;
				int n2 = 0;
				double beta = 0;
				double bignum = 0;
				double emax = 0;
				double rec = 0;
				double remax = 0;
				double scl = 0;
				double smin = 0;
				double smlnum = 0;
				double ulp = 0;
				double unfl = 0;
				double vcrit = 0;
				double vmax = 0;
				double wi = 0;
				double wr = 0;
				double xnorm = 0;
				double[,] x = new double[0, 0];
				double[] work = new double[0];
				double[] temp = new double[0];
				double[,] temp11 = new double[0, 0];
				double[,] temp22 = new double[0, 0];
				double[,] temp11b = new double[0, 0];
				double[,] temp21b = new double[0, 0];
				double[,] temp12b = new double[0, 0];
				double[,] temp22b = new double[0, 0];
				bool skipflag = new bool();
				int k1 = 0;
				int k2 = 0;
				int k3 = 0;
				int k4 = 0;
				double vt = 0;
				bool[] rswap4 = new bool[0];
				bool[] zswap4 = new bool[0];
				int[,] ipivot44 = new int[0, 0];
				double[] civ4 = new double[0];
				double[] crv4 = new double[0];
				int i_ = 0;
				int i1_ = 0;

				vselect = (bool[])vselect.Clone();
				m = 0;
				info = 0;

				x = new double[2 + 1, 2 + 1];
				temp11 = new double[1 + 1, 1 + 1];
				temp11b = new double[1 + 1, 1 + 1];
				temp21b = new double[2 + 1, 1 + 1];
				temp12b = new double[1 + 1, 2 + 1];
				temp22b = new double[2 + 1, 2 + 1];
				temp22 = new double[2 + 1, 2 + 1];
				work = new double[3 * n + 1];
				temp = new double[n + 1];
				rswap4 = new bool[4 + 1];
				zswap4 = new bool[4 + 1];
				ipivot44 = new int[4 + 1, 4 + 1];
				civ4 = new double[4 + 1];
				crv4 = new double[4 + 1];
				if (howmny != 1)
				{
					if (side == 1 || side == 3)
					{
						vr = new double[n + 1, n + 1];
					}
					if (side == 2 || side == 3)
					{
						vl = new double[n + 1, n + 1];
					}
				}

				//
				// Decode and test the input parameters
				//
				bothv = side == 3;
				rightv = side == 1 || bothv;
				leftv = side == 2 || bothv;
				allv = howmny == 2;
				over = howmny == 1;
				somev = howmny == 3;
				info = 0;
				if (n < 0)
				{
					info = -2;
					return;
				}
				if (!rightv && !leftv)
				{
					info = -3;
					return;
				}
				if ((!allv && !over) && !somev)
				{
					info = -4;
					return;
				}

				//
				// Set M to the number of columns required to store the selected
				// eigenvectors, standardize the array SELECT if necessary, and
				// test MM.
				//
				if (somev)
				{
					m = 0;
					pair = false;
					for (j = 1; j <= n; j++)
					{
						if (pair)
						{
							pair = false;
							vselect[j] = false;
						}
						else
						{
							if (j < n)
							{
								if ((double)(t[j + 1, j]) == (double)(0))
								{
									if (vselect[j])
									{
										m = m + 1;
									}
								}
								else
								{
									pair = true;
									if (vselect[j] || vselect[j + 1])
									{
										vselect[j] = true;
										m = m + 2;
									}
								}
							}
							else
							{
								if (vselect[n])
								{
									m = m + 1;
								}
							}
						}
					}
				}
				else
				{
					m = n;
				}

				//
				// Quick return if possible.
				//
				if (n == 0)
				{
					return;
				}

				//
				// Set the constants to control overflow.
				//
				unfl = math.minrealnumber;
				ulp = math.machineepsilon;
				smlnum = unfl * (n / ulp);
				bignum = (1 - ulp) / smlnum;

				//
				// Compute 1-norm of each column of strictly upper triangular
				// part of T to control overflow in triangular solver.
				//
				work[1] = 0;
				for (j = 2; j <= n; j++)
				{
					work[j] = 0;
					for (i = 1; i <= j - 1; i++)
					{
						work[j] = work[j] + Math.Abs(t[i, j]);
					}
				}

				//
				// Index IP is used to specify the real or complex eigenvalue:
				// IP = 0, real eigenvalue,
				//      1, first of conjugate complex pair: (wr,wi)
				//     -1, second of conjugate complex pair: (wr,wi)
				//
				n2 = 2 * n;
				if (rightv)
				{

					//
					// Compute right eigenvectors.
					//
					ip = 0;
					iis = m;
					for (ki = n; ki >= 1; ki--)
					{
						skipflag = false;
						if (ip == 1)
						{
							skipflag = true;
						}
						else
						{
							if (ki != 1)
							{
								if ((double)(t[ki, ki - 1]) != (double)(0))
								{
									ip = -1;
								}
							}
							if (somev)
							{
								if (ip == 0)
								{
									if (!vselect[ki])
									{
										skipflag = true;
									}
								}
								else
								{
									if (!vselect[ki - 1])
									{
										skipflag = true;
									}
								}
							}
						}
						if (!skipflag)
						{

							//
							// Compute the KI-th eigenvalue (WR,WI).
							//
							wr = t[ki, ki];
							wi = 0;
							if (ip != 0)
							{
								wi = (double)(Math.Sqrt(Math.Abs(t[ki, ki - 1])) * Math.Sqrt(Math.Abs(t[ki - 1, ki])));
							}
							smin = Math.Max(ulp * (Math.Abs(wr) + Math.Abs(wi)), smlnum);
							if (ip == 0)
							{

								//
								// Real right eigenvector
								//
								work[ki + n] = 1;

								//
								// Form right-hand side
								//
								for (k = 1; k <= ki - 1; k++)
								{
									work[k + n] = -t[k, ki];
								}

								//
								// Solve the upper quasi-triangular system:
								//   (T(1:KI-1,1:KI-1) - WR)*X = SCALE*WORK.
								//
								jnxt = ki - 1;
								for (j = ki - 1; j >= 1; j--)
								{
									if (j > jnxt)
									{
										continue;
									}
									j1 = j;
									j2 = j;
									jnxt = j - 1;
									if (j > 1)
									{
										if ((double)(t[j, j - 1]) != (double)(0))
										{
											j1 = j - 1;
											jnxt = j - 2;
										}
									}
									if (j1 == j2)
									{

										//
										// 1-by-1 diagonal block
										//
										temp11[1, 1] = t[j, j];
										temp11b[1, 1] = work[j + n];
										internalhsevdlaln2(false, 1, 1, smin, 1, temp11, 1.0f, 1.0f, temp11b, wr, 0.0f, ref rswap4, ref zswap4, ref ipivot44, ref civ4, ref crv4, ref x, ref scl, ref xnorm, ref ierr);

										//
										// Scale X(1,1) to avoid overflow when updating
										// the right-hand side.
										//
										if ((double)(xnorm) > (double)(1))
										{
											if ((double)(work[j]) > (double)(bignum / xnorm))
											{
												x[1, 1] = x[1, 1] / xnorm;
												scl = scl / xnorm;
											}
										}

										//
										// Scale if necessary
										//
										if ((double)(scl) != (double)(1))
										{
											k1 = n + 1;
											k2 = n + ki;
											for (i_ = k1; i_ <= k2; i_++)
											{
												work[i_] = scl * work[i_];
											}
										}
										work[j + n] = x[1, 1];

										//
										// Update right-hand side
										//
										k1 = 1 + n;
										k2 = j - 1 + n;
										k3 = j - 1;
										vt = -x[1, 1];
										i1_ = (1) - (k1);
										for (i_ = k1; i_ <= k2; i_++)
										{
											work[i_] = work[i_] + vt * t[i_ + i1_, j];
										}
									}
									else
									{

										//
										// 2-by-2 diagonal block
										//
										temp22[1, 1] = t[j - 1, j - 1];
										temp22[1, 2] = t[j - 1, j];
										temp22[2, 1] = t[j, j - 1];
										temp22[2, 2] = t[j, j];
										temp21b[1, 1] = work[j - 1 + n];
										temp21b[2, 1] = work[j + n];
										internalhsevdlaln2(false, 2, 1, smin, 1.0f, temp22, 1.0f, 1.0f, temp21b, wr, 0, ref rswap4, ref zswap4, ref ipivot44, ref civ4, ref crv4, ref x, ref scl, ref xnorm, ref ierr);

										//
										// Scale X(1,1) and X(2,1) to avoid overflow when
										// updating the right-hand side.
										//
										if ((double)(xnorm) > (double)(1))
										{
											beta = Math.Max(work[j - 1], work[j]);
											if ((double)(beta) > (double)(bignum / xnorm))
											{
												x[1, 1] = x[1, 1] / xnorm;
												x[2, 1] = x[2, 1] / xnorm;
												scl = scl / xnorm;
											}
										}

										//
										// Scale if necessary
										//
										if ((double)(scl) != (double)(1))
										{
											k1 = 1 + n;
											k2 = ki + n;
											for (i_ = k1; i_ <= k2; i_++)
											{
												work[i_] = scl * work[i_];
											}
										}
										work[j - 1 + n] = x[1, 1];
										work[j + n] = x[2, 1];

										//
										// Update right-hand side
										//
										k1 = 1 + n;
										k2 = j - 2 + n;
										k3 = j - 2;
										k4 = j - 1;
										vt = -x[1, 1];
										i1_ = (1) - (k1);
										for (i_ = k1; i_ <= k2; i_++)
										{
											work[i_] = work[i_] + vt * t[i_ + i1_, k4];
										}
										vt = -x[2, 1];
										i1_ = (1) - (k1);
										for (i_ = k1; i_ <= k2; i_++)
										{
											work[i_] = work[i_] + vt * t[i_ + i1_, j];
										}
									}
								}

								//
								// Copy the vector x or Q*x to VR and normalize.
								//
								if (!over)
								{
									k1 = 1 + n;
									k2 = ki + n;
									i1_ = (k1) - (1);
									for (i_ = 1; i_ <= ki; i_++)
									{
										vr[i_, iis] = work[i_ + i1_];
									}
									ii = blas.columnidxabsmax(vr, 1, ki, iis);
									remax = 1 / Math.Abs(vr[ii, iis]);
									for (i_ = 1; i_ <= ki; i_++)
									{
										vr[i_, iis] = remax * vr[i_, iis];
									}
									for (k = ki + 1; k <= n; k++)
									{
										vr[k, iis] = 0;
									}
								}
								else
								{
									if (ki > 1)
									{
										for (i_ = 1; i_ <= n; i_++)
										{
											temp[i_] = vr[i_, ki];
										}
										blas.matrixvectormultiply(vr, 1, n, 1, ki - 1, false, work, 1 + n, ki - 1 + n, 1.0f, ref temp, 1, n, work[ki + n]);
										for (i_ = 1; i_ <= n; i_++)
										{
											vr[i_, ki] = temp[i_];
										}
									}
									ii = blas.columnidxabsmax(vr, 1, n, ki);
									remax = 1 / Math.Abs(vr[ii, ki]);
									for (i_ = 1; i_ <= n; i_++)
									{
										vr[i_, ki] = remax * vr[i_, ki];
									}
								}
							}
							else
							{

								//
								// Complex right eigenvector.
								//
								// Initial solve
								//     [ (T(KI-1,KI-1) T(KI-1,KI) ) - (WR + I* WI)]*X = 0.
								//     [ (T(KI,KI-1)   T(KI,KI)   )               ]
								//
								if ((double)(Math.Abs(t[ki - 1, ki])) >= (double)(Math.Abs(t[ki, ki - 1])))
								{
									work[ki - 1 + n] = 1;
									work[ki + n2] = wi / t[ki - 1, ki];
								}
								else
								{
									work[ki - 1 + n] = -(wi / t[ki, ki - 1]);
									work[ki + n2] = 1;
								}
								work[ki + n] = 0;
								work[ki - 1 + n2] = 0;

								//
								// Form right-hand side
								//
								for (k = 1; k <= ki - 2; k++)
								{
									work[k + n] = -(work[ki - 1 + n] * t[k, ki - 1]);
									work[k + n2] = -(work[ki + n2] * t[k, ki]);
								}

								//
								// Solve upper quasi-triangular system:
								// (T(1:KI-2,1:KI-2) - (WR+i*WI))*X = SCALE*(WORK+i*WORK2)
								//
								jnxt = ki - 2;
								for (j = ki - 2; j >= 1; j--)
								{
									if (j > jnxt)
									{
										continue;
									}
									j1 = j;
									j2 = j;
									jnxt = j - 1;
									if (j > 1)
									{
										if ((double)(t[j, j - 1]) != (double)(0))
										{
											j1 = j - 1;
											jnxt = j - 2;
										}
									}
									if (j1 == j2)
									{

										//
										// 1-by-1 diagonal block
										//
										temp11[1, 1] = t[j, j];
										temp12b[1, 1] = work[j + n];
										temp12b[1, 2] = work[j + n + n];
										internalhsevdlaln2(false, 1, 2, smin, 1.0f, temp11, 1.0f, 1.0f, temp12b, wr, wi, ref rswap4, ref zswap4, ref ipivot44, ref civ4, ref crv4, ref x, ref scl, ref xnorm, ref ierr);

										//
										// Scale X(1,1) and X(1,2) to avoid overflow when
										// updating the right-hand side.
										//
										if ((double)(xnorm) > (double)(1))
										{
											if ((double)(work[j]) > (double)(bignum / xnorm))
											{
												x[1, 1] = x[1, 1] / xnorm;
												x[1, 2] = x[1, 2] / xnorm;
												scl = scl / xnorm;
											}
										}

										//
										// Scale if necessary
										//
										if ((double)(scl) != (double)(1))
										{
											k1 = 1 + n;
											k2 = ki + n;
											for (i_ = k1; i_ <= k2; i_++)
											{
												work[i_] = scl * work[i_];
											}
											k1 = 1 + n2;
											k2 = ki + n2;
											for (i_ = k1; i_ <= k2; i_++)
											{
												work[i_] = scl * work[i_];
											}
										}
										work[j + n] = x[1, 1];
										work[j + n2] = x[1, 2];

										//
										// Update the right-hand side
										//
										k1 = 1 + n;
										k2 = j - 1 + n;
										k3 = 1;
										k4 = j - 1;
										vt = -x[1, 1];
										i1_ = (k3) - (k1);
										for (i_ = k1; i_ <= k2; i_++)
										{
											work[i_] = work[i_] + vt * t[i_ + i1_, j];
										}
										k1 = 1 + n2;
										k2 = j - 1 + n2;
										k3 = 1;
										k4 = j - 1;
										vt = -x[1, 2];
										i1_ = (k3) - (k1);
										for (i_ = k1; i_ <= k2; i_++)
										{
											work[i_] = work[i_] + vt * t[i_ + i1_, j];
										}
									}
									else
									{

										//
										// 2-by-2 diagonal block
										//
										temp22[1, 1] = t[j - 1, j - 1];
										temp22[1, 2] = t[j - 1, j];
										temp22[2, 1] = t[j, j - 1];
										temp22[2, 2] = t[j, j];
										temp22b[1, 1] = work[j - 1 + n];
										temp22b[1, 2] = work[j - 1 + n + n];
										temp22b[2, 1] = work[j + n];
										temp22b[2, 2] = work[j + n + n];
										internalhsevdlaln2(false, 2, 2, smin, 1.0f, temp22, 1.0f, 1.0f, temp22b, wr, wi, ref rswap4, ref zswap4, ref ipivot44, ref civ4, ref crv4, ref x, ref scl, ref xnorm, ref ierr);

										//
										// Scale X to avoid overflow when updating
										// the right-hand side.
										//
										if ((double)(xnorm) > (double)(1))
										{
											beta = Math.Max(work[j - 1], work[j]);
											if ((double)(beta) > (double)(bignum / xnorm))
											{
												rec = 1 / xnorm;
												x[1, 1] = x[1, 1] * rec;
												x[1, 2] = x[1, 2] * rec;
												x[2, 1] = x[2, 1] * rec;
												x[2, 2] = x[2, 2] * rec;
												scl = scl * rec;
											}
										}

										//
										// Scale if necessary
										//
										if ((double)(scl) != (double)(1))
										{
											for (i_ = 1 + n; i_ <= ki + n; i_++)
											{
												work[i_] = scl * work[i_];
											}
											for (i_ = 1 + n2; i_ <= ki + n2; i_++)
											{
												work[i_] = scl * work[i_];
											}
										}
										work[j - 1 + n] = x[1, 1];
										work[j + n] = x[2, 1];
										work[j - 1 + n2] = x[1, 2];
										work[j + n2] = x[2, 2];

										//
										// Update the right-hand side
										//
										vt = -x[1, 1];
										i1_ = (1) - (n + 1);
										for (i_ = n + 1; i_ <= n + j - 2; i_++)
										{
											work[i_] = work[i_] + vt * t[i_ + i1_, j - 1];
										}
										vt = -x[2, 1];
										i1_ = (1) - (n + 1);
										for (i_ = n + 1; i_ <= n + j - 2; i_++)
										{
											work[i_] = work[i_] + vt * t[i_ + i1_, j];
										}
										vt = -x[1, 2];
										i1_ = (1) - (n2 + 1);
										for (i_ = n2 + 1; i_ <= n2 + j - 2; i_++)
										{
											work[i_] = work[i_] + vt * t[i_ + i1_, j - 1];
										}
										vt = -x[2, 2];
										i1_ = (1) - (n2 + 1);
										for (i_ = n2 + 1; i_ <= n2 + j - 2; i_++)
										{
											work[i_] = work[i_] + vt * t[i_ + i1_, j];
										}
									}
								}

								//
								// Copy the vector x or Q*x to VR and normalize.
								//
								if (!over)
								{
									i1_ = (n + 1) - (1);
									for (i_ = 1; i_ <= ki; i_++)
									{
										vr[i_, iis - 1] = work[i_ + i1_];
									}
									i1_ = (n2 + 1) - (1);
									for (i_ = 1; i_ <= ki; i_++)
									{
										vr[i_, iis] = work[i_ + i1_];
									}
									emax = 0;
									for (k = 1; k <= ki; k++)
									{
										emax = Math.Max(emax, Math.Abs(vr[k, iis - 1]) + Math.Abs(vr[k, iis]));
									}
									remax = 1 / emax;
									for (i_ = 1; i_ <= ki; i_++)
									{
										vr[i_, iis - 1] = remax * vr[i_, iis - 1];
									}
									for (i_ = 1; i_ <= ki; i_++)
									{
										vr[i_, iis] = remax * vr[i_, iis];
									}
									for (k = ki + 1; k <= n; k++)
									{
										vr[k, iis - 1] = 0;
										vr[k, iis] = 0;
									}
								}
								else
								{
									if (ki > 2)
									{
										for (i_ = 1; i_ <= n; i_++)
										{
											temp[i_] = vr[i_, ki - 1];
										}
										blas.matrixvectormultiply(vr, 1, n, 1, ki - 2, false, work, 1 + n, ki - 2 + n, 1.0f, ref temp, 1, n, work[ki - 1 + n]);
										for (i_ = 1; i_ <= n; i_++)
										{
											vr[i_, ki - 1] = temp[i_];
										}
										for (i_ = 1; i_ <= n; i_++)
										{
											temp[i_] = vr[i_, ki];
										}
										blas.matrixvectormultiply(vr, 1, n, 1, ki - 2, false, work, 1 + n2, ki - 2 + n2, 1.0f, ref temp, 1, n, work[ki + n2]);
										for (i_ = 1; i_ <= n; i_++)
										{
											vr[i_, ki] = temp[i_];
										}
									}
									else
									{
										vt = work[ki - 1 + n];
										for (i_ = 1; i_ <= n; i_++)
										{
											vr[i_, ki - 1] = vt * vr[i_, ki - 1];
										}
										vt = work[ki + n2];
										for (i_ = 1; i_ <= n; i_++)
										{
											vr[i_, ki] = vt * vr[i_, ki];
										}
									}
									emax = 0;
									for (k = 1; k <= n; k++)
									{
										emax = Math.Max(emax, Math.Abs(vr[k, ki - 1]) + Math.Abs(vr[k, ki]));
									}
									remax = 1 / emax;
									for (i_ = 1; i_ <= n; i_++)
									{
										vr[i_, ki - 1] = remax * vr[i_, ki - 1];
									}
									for (i_ = 1; i_ <= n; i_++)
									{
										vr[i_, ki] = remax * vr[i_, ki];
									}
								}
							}
							iis = iis - 1;
							if (ip != 0)
							{
								iis = iis - 1;
							}
						}
						if (ip == 1)
						{
							ip = 0;
						}
						if (ip == -1)
						{
							ip = 1;
						}
					}
				}
				if (leftv)
				{

					//
					// Compute left eigenvectors.
					//
					ip = 0;
					iis = 1;
					for (ki = 1; ki <= n; ki++)
					{
						skipflag = false;
						if (ip == -1)
						{
							skipflag = true;
						}
						else
						{
							if (ki != n)
							{
								if ((double)(t[ki + 1, ki]) != (double)(0))
								{
									ip = 1;
								}
							}
							if (somev)
							{
								if (!vselect[ki])
								{
									skipflag = true;
								}
							}
						}
						if (!skipflag)
						{

							//
							// Compute the KI-th eigenvalue (WR,WI).
							//
							wr = t[ki, ki];
							wi = 0;
							if (ip != 0)
							{
								wi = (double)(Math.Sqrt(Math.Abs(t[ki, ki + 1])) * Math.Sqrt(Math.Abs(t[ki + 1, ki])));
							}
							smin = Math.Max(ulp * (Math.Abs(wr) + Math.Abs(wi)), smlnum);
							if (ip == 0)
							{

								//
								// Real left eigenvector.
								//
								work[ki + n] = 1;

								//
								// Form right-hand side
								//
								for (k = ki + 1; k <= n; k++)
								{
									work[k + n] = -t[ki, k];
								}

								//
								// Solve the quasi-triangular system:
								// (T(KI+1:N,KI+1:N) - WR)'*X = SCALE*WORK
								//
								vmax = 1;
								vcrit = bignum;
								jnxt = ki + 1;
								for (j = ki + 1; j <= n; j++)
								{
									if (j < jnxt)
									{
										continue;
									}
									j1 = j;
									j2 = j;
									jnxt = j + 1;
									if (j < n)
									{
										if ((double)(t[j + 1, j]) != (double)(0))
										{
											j2 = j + 1;
											jnxt = j + 2;
										}
									}
									if (j1 == j2)
									{

										//
										// 1-by-1 diagonal block
										//
										// Scale if necessary to avoid overflow when forming
										// the right-hand side.
										//
										if ((double)(work[j]) > (double)(vcrit))
										{
											rec = 1 / vmax;
											for (i_ = ki + n; i_ <= n + n; i_++)
											{
												work[i_] = rec * work[i_];
											}
											vmax = 1;
											vcrit = bignum;
										}
										i1_ = (ki + 1 + n) - (ki + 1);
										vt = 0.0f;
										for (i_ = ki + 1; i_ <= j - 1; i_++)
										{
											vt += t[i_, j] * work[i_ + i1_];
										}
										work[j + n] = work[j + n] - vt;

										//
										// Solve (T(J,J)-WR)'*X = WORK
										//
										temp11[1, 1] = t[j, j];
										temp11b[1, 1] = work[j + n];
										internalhsevdlaln2(false, 1, 1, smin, 1.0f, temp11, 1.0f, 1.0f, temp11b, wr, 0, ref rswap4, ref zswap4, ref ipivot44, ref civ4, ref crv4, ref x, ref scl, ref xnorm, ref ierr);

										//
										// Scale if necessary
										//
										if ((double)(scl) != (double)(1))
										{
											for (i_ = ki + n; i_ <= n + n; i_++)
											{
												work[i_] = scl * work[i_];
											}
										}
										work[j + n] = x[1, 1];
										vmax = Math.Max(Math.Abs(work[j + n]), vmax);
										vcrit = bignum / vmax;
									}
									else
									{

										//
										// 2-by-2 diagonal block
										//
										// Scale if necessary to avoid overflow when forming
										// the right-hand side.
										//
										beta = Math.Max(work[j], work[j + 1]);
										if ((double)(beta) > (double)(vcrit))
										{
											rec = 1 / vmax;
											for (i_ = ki + n; i_ <= n + n; i_++)
											{
												work[i_] = rec * work[i_];
											}
											vmax = 1;
											vcrit = bignum;
										}
										i1_ = (ki + 1 + n) - (ki + 1);
										vt = 0.0f;
										for (i_ = ki + 1; i_ <= j - 1; i_++)
										{
											vt += t[i_, j] * work[i_ + i1_];
										}
										work[j + n] = work[j + n] - vt;
										i1_ = (ki + 1 + n) - (ki + 1);
										vt = 0.0f;
										for (i_ = ki + 1; i_ <= j - 1; i_++)
										{
											vt += t[i_, j + 1] * work[i_ + i1_];
										}
										work[j + 1 + n] = work[j + 1 + n] - vt;

										//
										// Solve
										//    [T(J,J)-WR   T(J,J+1)     ]'* X = SCALE*( WORK1 )
										//    [T(J+1,J)    T(J+1,J+1)-WR]             ( WORK2 )
										//
										temp22[1, 1] = t[j, j];
										temp22[1, 2] = t[j, j + 1];
										temp22[2, 1] = t[j + 1, j];
										temp22[2, 2] = t[j + 1, j + 1];
										temp21b[1, 1] = work[j + n];
										temp21b[2, 1] = work[j + 1 + n];
										internalhsevdlaln2(true, 2, 1, smin, 1.0f, temp22, 1.0f, 1.0f, temp21b, wr, 0, ref rswap4, ref zswap4, ref ipivot44, ref civ4, ref crv4, ref x, ref scl, ref xnorm, ref ierr);

										//
										// Scale if necessary
										//
										if ((double)(scl) != (double)(1))
										{
											for (i_ = ki + n; i_ <= n + n; i_++)
											{
												work[i_] = scl * work[i_];
											}
										}
										work[j + n] = x[1, 1];
										work[j + 1 + n] = x[2, 1];
										vmax = Math.Max(Math.Abs(work[j + n]), Math.Max(Math.Abs(work[j + 1 + n]), vmax));
										vcrit = bignum / vmax;
									}
								}

								//
								// Copy the vector x or Q*x to VL and normalize.
								//
								if (!over)
								{
									i1_ = (ki + n) - (ki);
									for (i_ = ki; i_ <= n; i_++)
									{
										vl[i_, iis] = work[i_ + i1_];
									}
									ii = blas.columnidxabsmax(vl, ki, n, iis);
									remax = 1 / Math.Abs(vl[ii, iis]);
									for (i_ = ki; i_ <= n; i_++)
									{
										vl[i_, iis] = remax * vl[i_, iis];
									}
									for (k = 1; k <= ki - 1; k++)
									{
										vl[k, iis] = 0;
									}
								}
								else
								{
									if (ki < n)
									{
										for (i_ = 1; i_ <= n; i_++)
										{
											temp[i_] = vl[i_, ki];
										}
										blas.matrixvectormultiply(vl, 1, n, ki + 1, n, false, work, ki + 1 + n, n + n, 1.0f, ref temp, 1, n, work[ki + n]);
										for (i_ = 1; i_ <= n; i_++)
										{
											vl[i_, ki] = temp[i_];
										}
									}
									ii = blas.columnidxabsmax(vl, 1, n, ki);
									remax = 1 / Math.Abs(vl[ii, ki]);
									for (i_ = 1; i_ <= n; i_++)
									{
										vl[i_, ki] = remax * vl[i_, ki];
									}
								}
							}
							else
							{

								//
								// Complex left eigenvector.
								//
								// Initial solve:
								//   ((T(KI,KI)    T(KI,KI+1) )' - (WR - I* WI))*X = 0.
								//   ((T(KI+1,KI) T(KI+1,KI+1))                )
								//
								if ((double)(Math.Abs(t[ki, ki + 1])) >= (double)(Math.Abs(t[ki + 1, ki])))
								{
									work[ki + n] = wi / t[ki, ki + 1];
									work[ki + 1 + n2] = 1;
								}
								else
								{
									work[ki + n] = 1;
									work[ki + 1 + n2] = -(wi / t[ki + 1, ki]);
								}
								work[ki + 1 + n] = 0;
								work[ki + n2] = 0;

								//
								// Form right-hand side
								//
								for (k = ki + 2; k <= n; k++)
								{
									work[k + n] = -(work[ki + n] * t[ki, k]);
									work[k + n2] = -(work[ki + 1 + n2] * t[ki + 1, k]);
								}

								//
								// Solve complex quasi-triangular system:
								// ( T(KI+2,N:KI+2,N) - (WR-i*WI) )*X = WORK1+i*WORK2
								//
								vmax = 1;
								vcrit = bignum;
								jnxt = ki + 2;
								for (j = ki + 2; j <= n; j++)
								{
									if (j < jnxt)
									{
										continue;
									}
									j1 = j;
									j2 = j;
									jnxt = j + 1;
									if (j < n)
									{
										if ((double)(t[j + 1, j]) != (double)(0))
										{
											j2 = j + 1;
											jnxt = j + 2;
										}
									}
									if (j1 == j2)
									{

										//
										// 1-by-1 diagonal block
										//
										// Scale if necessary to avoid overflow when
										// forming the right-hand side elements.
										//
										if ((double)(work[j]) > (double)(vcrit))
										{
											rec = 1 / vmax;
											for (i_ = ki + n; i_ <= n + n; i_++)
											{
												work[i_] = rec * work[i_];
											}
											for (i_ = ki + n2; i_ <= n + n2; i_++)
											{
												work[i_] = rec * work[i_];
											}
											vmax = 1;
											vcrit = bignum;
										}
										i1_ = (ki + 2 + n) - (ki + 2);
										vt = 0.0f;
										for (i_ = ki + 2; i_ <= j - 1; i_++)
										{
											vt += t[i_, j] * work[i_ + i1_];
										}
										work[j + n] = work[j + n] - vt;
										i1_ = (ki + 2 + n2) - (ki + 2);
										vt = 0.0f;
										for (i_ = ki + 2; i_ <= j - 1; i_++)
										{
											vt += t[i_, j] * work[i_ + i1_];
										}
										work[j + n2] = work[j + n2] - vt;

										//
										// Solve (T(J,J)-(WR-i*WI))*(X11+i*X12)= WK+I*WK2
										//
										temp11[1, 1] = t[j, j];
										temp12b[1, 1] = work[j + n];
										temp12b[1, 2] = work[j + n + n];
										internalhsevdlaln2(false, 1, 2, smin, 1.0f, temp11, 1.0f, 1.0f, temp12b, wr, -wi, ref rswap4, ref zswap4, ref ipivot44, ref civ4, ref crv4, ref x, ref scl, ref xnorm, ref ierr);

										//
										// Scale if necessary
										//
										if ((double)(scl) != (double)(1))
										{
											for (i_ = ki + n; i_ <= n + n; i_++)
											{
												work[i_] = scl * work[i_];
											}
											for (i_ = ki + n2; i_ <= n + n2; i_++)
											{
												work[i_] = scl * work[i_];
											}
										}
										work[j + n] = x[1, 1];
										work[j + n2] = x[1, 2];
										vmax = Math.Max(Math.Abs(work[j + n]), Math.Max(Math.Abs(work[j + n2]), vmax));
										vcrit = bignum / vmax;
									}
									else
									{

										//
										// 2-by-2 diagonal block
										//
										// Scale if necessary to avoid overflow when forming
										// the right-hand side elements.
										//
										beta = Math.Max(work[j], work[j + 1]);
										if ((double)(beta) > (double)(vcrit))
										{
											rec = 1 / vmax;
											for (i_ = ki + n; i_ <= n + n; i_++)
											{
												work[i_] = rec * work[i_];
											}
											for (i_ = ki + n2; i_ <= n + n2; i_++)
											{
												work[i_] = rec * work[i_];
											}
											vmax = 1;
											vcrit = bignum;
										}
										i1_ = (ki + 2 + n) - (ki + 2);
										vt = 0.0f;
										for (i_ = ki + 2; i_ <= j - 1; i_++)
										{
											vt += t[i_, j] * work[i_ + i1_];
										}
										work[j + n] = work[j + n] - vt;
										i1_ = (ki + 2 + n2) - (ki + 2);
										vt = 0.0f;
										for (i_ = ki + 2; i_ <= j - 1; i_++)
										{
											vt += t[i_, j] * work[i_ + i1_];
										}
										work[j + n2] = work[j + n2] - vt;
										i1_ = (ki + 2 + n) - (ki + 2);
										vt = 0.0f;
										for (i_ = ki + 2; i_ <= j - 1; i_++)
										{
											vt += t[i_, j + 1] * work[i_ + i1_];
										}
										work[j + 1 + n] = work[j + 1 + n] - vt;
										i1_ = (ki + 2 + n2) - (ki + 2);
										vt = 0.0f;
										for (i_ = ki + 2; i_ <= j - 1; i_++)
										{
											vt += t[i_, j + 1] * work[i_ + i1_];
										}
										work[j + 1 + n2] = work[j + 1 + n2] - vt;

										//
										// Solve 2-by-2 complex linear equation
										//   ([T(j,j)   T(j,j+1)  ]'-(wr-i*wi)*I)*X = SCALE*B
										//   ([T(j+1,j) T(j+1,j+1)]             )
										//
										temp22[1, 1] = t[j, j];
										temp22[1, 2] = t[j, j + 1];
										temp22[2, 1] = t[j + 1, j];
										temp22[2, 2] = t[j + 1, j + 1];
										temp22b[1, 1] = work[j + n];
										temp22b[1, 2] = work[j + n + n];
										temp22b[2, 1] = work[j + 1 + n];
										temp22b[2, 2] = work[j + 1 + n + n];
										internalhsevdlaln2(true, 2, 2, smin, 1.0f, temp22, 1.0f, 1.0f, temp22b, wr, -wi, ref rswap4, ref zswap4, ref ipivot44, ref civ4, ref crv4, ref x, ref scl, ref xnorm, ref ierr);

										//
										// Scale if necessary
										//
										if ((double)(scl) != (double)(1))
										{
											for (i_ = ki + n; i_ <= n + n; i_++)
											{
												work[i_] = scl * work[i_];
											}
											for (i_ = ki + n2; i_ <= n + n2; i_++)
											{
												work[i_] = scl * work[i_];
											}
										}
										work[j + n] = x[1, 1];
										work[j + n2] = x[1, 2];
										work[j + 1 + n] = x[2, 1];
										work[j + 1 + n2] = x[2, 2];
										vmax = Math.Max(Math.Abs(x[1, 1]), vmax);
										vmax = Math.Max(Math.Abs(x[1, 2]), vmax);
										vmax = Math.Max(Math.Abs(x[2, 1]), vmax);
										vmax = Math.Max(Math.Abs(x[2, 2]), vmax);
										vcrit = bignum / vmax;
									}
								}

								//
								// Copy the vector x or Q*x to VL and normalize.
								//
								if (!over)
								{
									i1_ = (ki + n) - (ki);
									for (i_ = ki; i_ <= n; i_++)
									{
										vl[i_, iis] = work[i_ + i1_];
									}
									i1_ = (ki + n2) - (ki);
									for (i_ = ki; i_ <= n; i_++)
									{
										vl[i_, iis + 1] = work[i_ + i1_];
									}
									emax = 0;
									for (k = ki; k <= n; k++)
									{
										emax = Math.Max(emax, Math.Abs(vl[k, iis]) + Math.Abs(vl[k, iis + 1]));
									}
									remax = 1 / emax;
									for (i_ = ki; i_ <= n; i_++)
									{
										vl[i_, iis] = remax * vl[i_, iis];
									}
									for (i_ = ki; i_ <= n; i_++)
									{
										vl[i_, iis + 1] = remax * vl[i_, iis + 1];
									}
									for (k = 1; k <= ki - 1; k++)
									{
										vl[k, iis] = 0;
										vl[k, iis + 1] = 0;
									}
								}
								else
								{
									if (ki < n - 1)
									{
										for (i_ = 1; i_ <= n; i_++)
										{
											temp[i_] = vl[i_, ki];
										}
										blas.matrixvectormultiply(vl, 1, n, ki + 2, n, false, work, ki + 2 + n, n + n, 1.0f, ref temp, 1, n, work[ki + n]);
										for (i_ = 1; i_ <= n; i_++)
										{
											vl[i_, ki] = temp[i_];
										}
										for (i_ = 1; i_ <= n; i_++)
										{
											temp[i_] = vl[i_, ki + 1];
										}
										blas.matrixvectormultiply(vl, 1, n, ki + 2, n, false, work, ki + 2 + n2, n + n2, 1.0f, ref temp, 1, n, work[ki + 1 + n2]);
										for (i_ = 1; i_ <= n; i_++)
										{
											vl[i_, ki + 1] = temp[i_];
										}
									}
									else
									{
										vt = work[ki + n];
										for (i_ = 1; i_ <= n; i_++)
										{
											vl[i_, ki] = vt * vl[i_, ki];
										}
										vt = work[ki + 1 + n2];
										for (i_ = 1; i_ <= n; i_++)
										{
											vl[i_, ki + 1] = vt * vl[i_, ki + 1];
										}
									}
									emax = 0;
									for (k = 1; k <= n; k++)
									{
										emax = Math.Max(emax, Math.Abs(vl[k, ki]) + Math.Abs(vl[k, ki + 1]));
									}
									remax = 1 / emax;
									for (i_ = 1; i_ <= n; i_++)
									{
										vl[i_, ki] = remax * vl[i_, ki];
									}
									for (i_ = 1; i_ <= n; i_++)
									{
										vl[i_, ki + 1] = remax * vl[i_, ki + 1];
									}
								}
							}
							iis = iis + 1;
							if (ip != 0)
							{
								iis = iis + 1;
							}
						}
						if (ip == -1)
						{
							ip = 0;
						}
						if (ip == 1)
						{
							ip = -1;
						}
					}
				}
			}


			/*************************************************************************
			DLALN2 solves a system of the form  (ca A - w D ) X = s B
			or (ca A' - w D) X = s B   with possible scaling ("s") and
			perturbation of A.  (A' means A-transpose.)

			A is an NA x NA real matrix, ca is a real scalar, D is an NA x NA
			real diagonal matrix, w is a real or complex value, and X and B are
			NA x 1 matrices -- real if w is real, complex if w is complex.  NA
			may be 1 or 2.

			If w is complex, X and B are represented as NA x 2 matrices,
			the first column of each being the real part and the second
			being the imaginary part.

			"s" is a scaling factor (.LE. 1), computed by DLALN2, which is
			so chosen that X can be computed without overflow.  X is further
			scaled if necessary to assure that norm(ca A - w D)*norm(X) is less
			than overflow.

			If both singular values of (ca A - w D) are less than SMIN,
			SMIN*identity will be used instead of (ca A - w D).  If only one
			singular value is less than SMIN, one element of (ca A - w D) will be
			perturbed enough to make the smallest singular value roughly SMIN.
			If both singular values are at least SMIN, (ca A - w D) will not be
			perturbed.  In any case, the perturbation will be at most some small
			multiple of max( SMIN, ulp*norm(ca A - w D) ).  The singular values
			are computed by infinity-norm approximations, and thus will only be
			correct to a factor of 2 or so.

			Note: all input quantities are assumed to be smaller than overflow
			by a reasonable factor.  (See BIGNUM.)

				-- LAPACK auxiliary routine (version 3.0) --
					 Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
					 Courant Institute, Argonne National Lab, and Rice University
					 October 31, 1992
			*************************************************************************/
			private static void internalhsevdlaln2(bool ltrans,
					int na,
					int nw,
					double smin,
					double ca,
					double[,] a,
					double d1,
					double d2,
					double[,] b,
					double wr,
					double wi,
					ref bool[] rswap4,
					ref bool[] zswap4,
					ref int[,] ipivot44,
					ref double[] civ4,
					ref double[] crv4,
					ref double[,] x,
					ref double scl,
					ref double xnorm,
					ref int info)
			{
				int icmax = 0;
				int j = 0;
				double bbnd = 0;
				double bi1 = 0;
				double bi2 = 0;
				double bignum = 0;
				double bnorm = 0;
				double br1 = 0;
				double br2 = 0;
				double ci21 = 0;
				double ci22 = 0;
				double cmax = 0;
				double cnorm = 0;
				double cr21 = 0;
				double cr22 = 0;
				double csi = 0;
				double csr = 0;
				double li21 = 0;
				double lr21 = 0;
				double smini = 0;
				double smlnum = 0;
				double temp = 0;
				double u22abs = 0;
				double ui11 = 0;
				double ui11r = 0;
				double ui12 = 0;
				double ui12s = 0;
				double ui22 = 0;
				double ur11 = 0;
				double ur11r = 0;
				double ur12 = 0;
				double ur12s = 0;
				double ur22 = 0;
				double xi1 = 0;
				double xi2 = 0;
				double xr1 = 0;
				double xr2 = 0;
				double tmp1 = 0;
				double tmp2 = 0;

				scl = 0;
				xnorm = 0;
				info = 0;

				zswap4[1] = false;
				zswap4[2] = false;
				zswap4[3] = true;
				zswap4[4] = true;
				rswap4[1] = false;
				rswap4[2] = true;
				rswap4[3] = false;
				rswap4[4] = true;
				ipivot44[1, 1] = 1;
				ipivot44[2, 1] = 2;
				ipivot44[3, 1] = 3;
				ipivot44[4, 1] = 4;
				ipivot44[1, 2] = 2;
				ipivot44[2, 2] = 1;
				ipivot44[3, 2] = 4;
				ipivot44[4, 2] = 3;
				ipivot44[1, 3] = 3;
				ipivot44[2, 3] = 4;
				ipivot44[3, 3] = 1;
				ipivot44[4, 3] = 2;
				ipivot44[1, 4] = 4;
				ipivot44[2, 4] = 3;
				ipivot44[3, 4] = 2;
				ipivot44[4, 4] = 1;
				smlnum = 2 * math.minrealnumber;
				bignum = 1 / smlnum;
				smini = Math.Max(smin, smlnum);

				//
				// Don't check for input errors
				//
				info = 0;

				//
				// Standard Initializations
				//
				scl = 1;
				if (na == 1)
				{

					//
					// 1 x 1  (i.e., scalar) system   C X = B
					//
					if (nw == 1)
					{

						//
						// Real 1x1 system.
						//
						// C = ca A - w D
						//
						csr = ca * a[1, 1] - wr * d1;
						cnorm = Math.Abs(csr);

						//
						// If | C | < SMINI, use C = SMINI
						//
						if ((double)(cnorm) < (double)(smini))
						{
							csr = smini;
							cnorm = smini;
							info = 1;
						}

						//
						// Check scaling for  X = B / C
						//
						bnorm = Math.Abs(b[1, 1]);
						if ((double)(cnorm) < (double)(1) && (double)(bnorm) > (double)(1))
						{
							if ((double)(bnorm) > (double)(bignum * cnorm))
							{
								scl = 1 / bnorm;
							}
						}

						//
						// Compute X
						//
						x[1, 1] = b[1, 1] * scl / csr;
						xnorm = Math.Abs(x[1, 1]);
					}
					else
					{

						//
						// Complex 1x1 system (w is complex)
						//
						// C = ca A - w D
						//
						csr = ca * a[1, 1] - wr * d1;
						csi = -(wi * d1);
						cnorm = Math.Abs(csr) + Math.Abs(csi);

						//
						// If | C | < SMINI, use C = SMINI
						//
						if ((double)(cnorm) < (double)(smini))
						{
							csr = smini;
							csi = 0;
							cnorm = smini;
							info = 1;
						}

						//
						// Check scaling for  X = B / C
						//
						bnorm = Math.Abs(b[1, 1]) + Math.Abs(b[1, 2]);
						if ((double)(cnorm) < (double)(1) && (double)(bnorm) > (double)(1))
						{
							if ((double)(bnorm) > (double)(bignum * cnorm))
							{
								scl = 1 / bnorm;
							}
						}

						//
						// Compute X
						//
						internalhsevdladiv(scl * b[1, 1], scl * b[1, 2], csr, csi, ref tmp1, ref tmp2);
						x[1, 1] = tmp1;
						x[1, 2] = tmp2;
						xnorm = Math.Abs(x[1, 1]) + Math.Abs(x[1, 2]);
					}
				}
				else
				{

					//
					// 2x2 System
					//
					// Compute the real part of  C = ca A - w D  (or  ca A' - w D )
					//
					crv4[1 + 0] = ca * a[1, 1] - wr * d1;
					crv4[2 + 2] = ca * a[2, 2] - wr * d2;
					if (ltrans)
					{
						crv4[1 + 2] = ca * a[2, 1];
						crv4[2 + 0] = ca * a[1, 2];
					}
					else
					{
						crv4[2 + 0] = ca * a[2, 1];
						crv4[1 + 2] = ca * a[1, 2];
					}
					if (nw == 1)
					{

						//
						// Real 2x2 system  (w is real)
						//
						// Find the largest element in C
						//
						cmax = 0;
						icmax = 0;
						for (j = 1; j <= 4; j++)
						{
							if ((double)(Math.Abs(crv4[j])) > (double)(cmax))
							{
								cmax = Math.Abs(crv4[j]);
								icmax = j;
							}
						}

						//
						// If norm(C) < SMINI, use SMINI*identity.
						//
						if ((double)(cmax) < (double)(smini))
						{
							bnorm = Math.Max(Math.Abs(b[1, 1]), Math.Abs(b[2, 1]));
							if ((double)(smini) < (double)(1) && (double)(bnorm) > (double)(1))
							{
								if ((double)(bnorm) > (double)(bignum * smini))
								{
									scl = 1 / bnorm;
								}
							}
							temp = scl / smini;
							x[1, 1] = temp * b[1, 1];
							x[2, 1] = temp * b[2, 1];
							xnorm = temp * bnorm;
							info = 1;
							return;
						}

						//
						// Gaussian elimination with complete pivoting.
						//
						ur11 = crv4[icmax];
						cr21 = crv4[ipivot44[2, icmax]];
						ur12 = crv4[ipivot44[3, icmax]];
						cr22 = crv4[ipivot44[4, icmax]];
						ur11r = 1 / ur11;
						lr21 = ur11r * cr21;
						ur22 = cr22 - ur12 * lr21;

						//
						// If smaller pivot < SMINI, use SMINI
						//
						if ((double)(Math.Abs(ur22)) < (double)(smini))
						{
							ur22 = smini;
							info = 1;
						}
						if (rswap4[icmax])
						{
							br1 = b[2, 1];
							br2 = b[1, 1];
						}
						else
						{
							br1 = b[1, 1];
							br2 = b[2, 1];
						}
						br2 = br2 - lr21 * br1;
						bbnd = Math.Max(Math.Abs(br1 * (ur22 * ur11r)), Math.Abs(br2));
						if ((double)(bbnd) > (double)(1) && (double)(Math.Abs(ur22)) < (double)(1))
						{
							if ((double)(bbnd) >= (double)(bignum * Math.Abs(ur22)))
							{
								scl = 1 / bbnd;
							}
						}
						xr2 = br2 * scl / ur22;
						xr1 = scl * br1 * ur11r - xr2 * (ur11r * ur12);
						if (zswap4[icmax])
						{
							x[1, 1] = xr2;
							x[2, 1] = xr1;
						}
						else
						{
							x[1, 1] = xr1;
							x[2, 1] = xr2;
						}
						xnorm = Math.Max(Math.Abs(xr1), Math.Abs(xr2));

						//
						// Further scaling if  norm(A) norm(X) > overflow
						//
						if ((double)(xnorm) > (double)(1) && (double)(cmax) > (double)(1))
						{
							if ((double)(xnorm) > (double)(bignum / cmax))
							{
								temp = cmax / bignum;
								x[1, 1] = temp * x[1, 1];
								x[2, 1] = temp * x[2, 1];
								xnorm = temp * xnorm;
								scl = temp * scl;
							}
						}
					}
					else
					{

						//
						// Complex 2x2 system  (w is complex)
						//
						// Find the largest element in C
						//
						civ4[1 + 0] = -(wi * d1);
						civ4[2 + 0] = 0;
						civ4[1 + 2] = 0;
						civ4[2 + 2] = -(wi * d2);
						cmax = 0;
						icmax = 0;
						for (j = 1; j <= 4; j++)
						{
							if ((double)(Math.Abs(crv4[j]) + Math.Abs(civ4[j])) > (double)(cmax))
							{
								cmax = Math.Abs(crv4[j]) + Math.Abs(civ4[j]);
								icmax = j;
							}
						}

						//
						// If norm(C) < SMINI, use SMINI*identity.
						//
						if ((double)(cmax) < (double)(smini))
						{
							bnorm = Math.Max(Math.Abs(b[1, 1]) + Math.Abs(b[1, 2]), Math.Abs(b[2, 1]) + Math.Abs(b[2, 2]));
							if ((double)(smini) < (double)(1) && (double)(bnorm) > (double)(1))
							{
								if ((double)(bnorm) > (double)(bignum * smini))
								{
									scl = 1 / bnorm;
								}
							}
							temp = scl / smini;
							x[1, 1] = temp * b[1, 1];
							x[2, 1] = temp * b[2, 1];
							x[1, 2] = temp * b[1, 2];
							x[2, 2] = temp * b[2, 2];
							xnorm = temp * bnorm;
							info = 1;
							return;
						}

						//
						// Gaussian elimination with complete pivoting.
						//
						ur11 = crv4[icmax];
						ui11 = civ4[icmax];
						cr21 = crv4[ipivot44[2, icmax]];
						ci21 = civ4[ipivot44[2, icmax]];
						ur12 = crv4[ipivot44[3, icmax]];
						ui12 = civ4[ipivot44[3, icmax]];
						cr22 = crv4[ipivot44[4, icmax]];
						ci22 = civ4[ipivot44[4, icmax]];
						if (icmax == 1 || icmax == 4)
						{

							//
							// Code when off-diagonals of pivoted C are real
							//
							if ((double)(Math.Abs(ur11)) > (double)(Math.Abs(ui11)))
							{
								temp = ui11 / ur11;
								ur11r = 1 / (ur11 * (1 + math.sqr(temp)));
								ui11r = -(temp * ur11r);
							}
							else
							{
								temp = ur11 / ui11;
								ui11r = -(1 / (ui11 * (1 + math.sqr(temp))));
								ur11r = -(temp * ui11r);
							}
							lr21 = cr21 * ur11r;
							li21 = cr21 * ui11r;
							ur12s = ur12 * ur11r;
							ui12s = ur12 * ui11r;
							ur22 = cr22 - ur12 * lr21;
							ui22 = ci22 - ur12 * li21;
						}
						else
						{

							//
							// Code when diagonals of pivoted C are real
							//
							ur11r = 1 / ur11;
							ui11r = 0;
							lr21 = cr21 * ur11r;
							li21 = ci21 * ur11r;
							ur12s = ur12 * ur11r;
							ui12s = ui12 * ur11r;
							ur22 = cr22 - ur12 * lr21 + ui12 * li21;
							ui22 = -(ur12 * li21) - ui12 * lr21;
						}
						u22abs = Math.Abs(ur22) + Math.Abs(ui22);

						//
						// If smaller pivot < SMINI, use SMINI
						//
						if ((double)(u22abs) < (double)(smini))
						{
							ur22 = smini;
							ui22 = 0;
							info = 1;
						}
						if (rswap4[icmax])
						{
							br2 = b[1, 1];
							br1 = b[2, 1];
							bi2 = b[1, 2];
							bi1 = b[2, 2];
						}
						else
						{
							br1 = b[1, 1];
							br2 = b[2, 1];
							bi1 = b[1, 2];
							bi2 = b[2, 2];
						}
						br2 = br2 - lr21 * br1 + li21 * bi1;
						bi2 = bi2 - li21 * br1 - lr21 * bi1;
						bbnd = Math.Max((Math.Abs(br1) + Math.Abs(bi1)) * (u22abs * (Math.Abs(ur11r) + Math.Abs(ui11r))), Math.Abs(br2) + Math.Abs(bi2));
						if ((double)(bbnd) > (double)(1) && (double)(u22abs) < (double)(1))
						{
							if ((double)(bbnd) >= (double)(bignum * u22abs))
							{
								scl = 1 / bbnd;
								br1 = scl * br1;
								bi1 = scl * bi1;
								br2 = scl * br2;
								bi2 = scl * bi2;
							}
						}
						internalhsevdladiv(br2, bi2, ur22, ui22, ref xr2, ref xi2);
						xr1 = ur11r * br1 - ui11r * bi1 - ur12s * xr2 + ui12s * xi2;
						xi1 = ui11r * br1 + ur11r * bi1 - ui12s * xr2 - ur12s * xi2;
						if (zswap4[icmax])
						{
							x[1, 1] = xr2;
							x[2, 1] = xr1;
							x[1, 2] = xi2;
							x[2, 2] = xi1;
						}
						else
						{
							x[1, 1] = xr1;
							x[2, 1] = xr2;
							x[1, 2] = xi1;
							x[2, 2] = xi2;
						}
						xnorm = Math.Max(Math.Abs(xr1) + Math.Abs(xi1), Math.Abs(xr2) + Math.Abs(xi2));

						//
						// Further scaling if  norm(A) norm(X) > overflow
						//
						if ((double)(xnorm) > (double)(1) && (double)(cmax) > (double)(1))
						{
							if ((double)(xnorm) > (double)(bignum / cmax))
							{
								temp = cmax / bignum;
								x[1, 1] = temp * x[1, 1];
								x[2, 1] = temp * x[2, 1];
								x[1, 2] = temp * x[1, 2];
								x[2, 2] = temp * x[2, 2];
								xnorm = temp * xnorm;
								scl = temp * scl;
							}
						}
					}
				}
			}


			/*************************************************************************
			performs complex division in  real arithmetic

															a + i*b
									 p + i*q = ---------
															c + i*d

			The algorithm is due to Robert L. Smith and can be found
			in D. Knuth, The art of Computer Programming, Vol.2, p.195

				-- LAPACK auxiliary routine (version 3.0) --
					 Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
					 Courant Institute, Argonne National Lab, and Rice University
					 October 31, 1992
			*************************************************************************/
			private static void internalhsevdladiv(double a,
					double b,
					double c,
					double d,
					ref double p,
					ref double q)
			{
				double e = 0;
				double f = 0;

				p = 0;
				q = 0;

				if ((double)(Math.Abs(d)) < (double)(Math.Abs(c)))
				{
					e = d / c;
					f = c + d * e;
					p = (a + b * e) / f;
					q = (b - a * e) / f;
				}
				else
				{
					e = c / d;
					f = d + c * e;
					p = (b + a * e) / f;
					q = (-a + b * e) / f;
				}
			}


			private static bool nonsymmetricevd(double[,] a,
					int n,
					int vneeded,
					ref double[] wr,
					ref double[] wi,
					ref double[,] vl,
					ref double[,] vr)
			{
				bool result = new bool();
				double[,] s = new double[0, 0];
				double[] tau = new double[0];
				bool[] sel = new bool[0];
				int i = 0;
				int info = 0;
				int m = 0;
				int i_ = 0;

				a = (double[,])a.Clone();
				wr = new double[0];
				wi = new double[0];
				vl = new double[0, 0];
				vr = new double[0, 0];

				alglib.ap.assert(vneeded >= 0 && vneeded <= 3, "NonSymmetricEVD: incorrect VNeeded!");
				if (vneeded == 0)
				{

					//
					// Eigen values only
					//
					toupperhessenberg(ref a, n, ref tau);
					hsschur.internalschurdecomposition(ref a, n, 0, 0, ref wr, ref wi, ref s, ref info);
					result = info == 0;
					return result;
				}

				//
				// Eigen values and vectors
				//
				toupperhessenberg(ref a, n, ref tau);
				unpackqfromupperhessenberg(a, n, tau, ref s);
				hsschur.internalschurdecomposition(ref a, n, 1, 1, ref wr, ref wi, ref s, ref info);
				result = info == 0;
				if (!result)
				{
					return result;
				}
				if (vneeded == 1 || vneeded == 3)
				{
					vr = new double[n + 1, n + 1];
					for (i = 1; i <= n; i++)
					{
						for (i_ = 1; i_ <= n; i_++)
						{
							vr[i, i_] = s[i, i_];
						}
					}
				}
				if (vneeded == 2 || vneeded == 3)
				{
					vl = new double[n + 1, n + 1];
					for (i = 1; i <= n; i++)
					{
						for (i_ = 1; i_ <= n; i_++)
						{
							vl[i, i_] = s[i, i_];
						}
					}
				}
				internaltrevc(a, n, vneeded, 1, sel, ref vl, ref vr, ref m, ref info);
				result = info == 0;
				return result;
			}


			private static void toupperhessenberg(ref double[,] a,
					int n,
					ref double[] tau)
			{
				int i = 0;
				int ip1 = 0;
				int nmi = 0;
				double v = 0;
				double[] t = new double[0];
				double[] work = new double[0];
				int i_ = 0;
				int i1_ = 0;

				tau = new double[0];

				alglib.ap.assert(n >= 0, "ToUpperHessenberg: incorrect N!");

				//
				// Quick return if possible
				//
				if (n <= 1)
				{
					return;
				}
				tau = new double[n - 1 + 1];
				t = new double[n + 1];
				work = new double[n + 1];
				for (i = 1; i <= n - 1; i++)
				{

					//
					// Compute elementary reflector H(i) to annihilate A(i+2:ihi,i)
					//
					ip1 = i + 1;
					nmi = n - i;
					i1_ = (ip1) - (1);
					for (i_ = 1; i_ <= nmi; i_++)
					{
						t[i_] = a[i_ + i1_, i];
					}
					reflections.generatereflection(ref t, nmi, ref v);
					i1_ = (1) - (ip1);
					for (i_ = ip1; i_ <= n; i_++)
					{
						a[i_, i] = t[i_ + i1_];
					}
					tau[i] = v;
					t[1] = 1;

					//
					// Apply H(i) to A(1:ihi,i+1:ihi) from the right
					//
					reflections.applyreflectionfromtheright(ref a, v, t, 1, n, i + 1, n, ref work);

					//
					// Apply H(i) to A(i+1:ihi,i+1:n) from the left
					//
					reflections.applyreflectionfromtheleft(ref a, v, t, i + 1, n, i + 1, n, ref work);
				}
			}


			private static void unpackqfromupperhessenberg(double[,] a,
					int n,
					double[] tau,
					ref double[,] q)
			{
				int i = 0;
				int j = 0;
				double[] v = new double[0];
				double[] work = new double[0];
				int ip1 = 0;
				int nmi = 0;
				int i_ = 0;
				int i1_ = 0;

				q = new double[0, 0];

				if (n == 0)
				{
					return;
				}

				//
				// init
				//
				q = new double[n + 1, n + 1];
				v = new double[n + 1];
				work = new double[n + 1];
				for (i = 1; i <= n; i++)
				{
					for (j = 1; j <= n; j++)
					{
						if (i == j)
						{
							q[i, j] = 1;
						}
						else
						{
							q[i, j] = 0;
						}
					}
				}

				//
				// unpack Q
				//
				for (i = 1; i <= n - 1; i++)
				{

					//
					// Apply H(i)
					//
					ip1 = i + 1;
					nmi = n - i;
					i1_ = (ip1) - (1);
					for (i_ = 1; i_ <= nmi; i_++)
					{
						v[i_] = a[i_ + i1_, i];
					}
					v[1] = 1;
					reflections.applyreflectionfromtheright(ref q, tau[i], v, 1, n, i + 1, n, ref work);
				}
			}


		}
		public class matgen
		{
			/*************************************************************************
			Generation of a random uniformly distributed (Haar) orthogonal matrix

			INPUT PARAMETERS:
					N   -   matrix size, N>=1
            
			OUTPUT PARAMETERS:
					A   -   orthogonal NxN matrix, array[0..N-1,0..N-1]

				-- ALGLIB routine --
					 04.12.2009
					 Bochkanov Sergey
			*************************************************************************/
			public static void rmatrixrndorthogonal(int n,
					ref double[,] a)
			{
				int i = 0;
				int j = 0;

				a = new double[0, 0];

				alglib.ap.assert(n >= 1, "RMatrixRndOrthogonal: N<1!");
				a = new double[n, n];
				for (i = 0; i <= n - 1; i++)
				{
					for (j = 0; j <= n - 1; j++)
					{
						if (i == j)
						{
							a[i, j] = 1;
						}
						else
						{
							a[i, j] = 0;
						}
					}
				}
				rmatrixrndorthogonalfromtheright(ref a, n, n);
			}


			/*************************************************************************
			Generation of random NxN matrix with given condition number and norm2(A)=1

			INPUT PARAMETERS:
					N   -   matrix size
					C   -   condition number (in 2-norm)

			OUTPUT PARAMETERS:
					A   -   random matrix with norm2(A)=1 and cond(A)=C

				-- ALGLIB routine --
					 04.12.2009
					 Bochkanov Sergey
			*************************************************************************/
			public static void rmatrixrndcond(int n,
					double c,
					ref double[,] a)
			{
				int i = 0;
				int j = 0;
				double l1 = 0;
				double l2 = 0;
				hqrnd.hqrndstate rs = new hqrnd.hqrndstate();

				a = new double[0, 0];

				alglib.ap.assert(n >= 1 && (double)(c) >= (double)(1), "RMatrixRndCond: N<1 or C<1!");
				a = new double[n, n];
				if (n == 1)
				{

					//
					// special case
					//
					a[0, 0] = 2 * math.randominteger(2) - 1;
					return;
				}
				hqrnd.hqrndrandomize(rs);
				l1 = 0;
				l2 = (double)Math.Log(1 / c);
				for (i = 0; i <= n - 1; i++)
				{
					for (j = 0; j <= n - 1; j++)
					{
						a[i, j] = 0;
					}
				}
				a[0, 0] = (double)Math.Exp(l1);
				for (i = 1; i <= n - 2; i++)
				{
					a[i, i] = (double)Math.Exp(hqrnd.hqrnduniformr(rs) * (l2 - l1) + l1);
				}
				a[n - 1, n - 1] = (double)Math.Exp(l2);
				rmatrixrndorthogonalfromtheleft(ref a, n, n);
				rmatrixrndorthogonalfromtheright(ref a, n, n);
			}


			/*************************************************************************
			Generation of a random Haar distributed orthogonal complex matrix

			INPUT PARAMETERS:
					N   -   matrix size, N>=1

			OUTPUT PARAMETERS:
					A   -   orthogonal NxN matrix, array[0..N-1,0..N-1]

				-- ALGLIB routine --
					 04.12.2009
					 Bochkanov Sergey
			*************************************************************************/
			public static void cmatrixrndorthogonal(int n,
					ref complex[,] a)
			{
				int i = 0;
				int j = 0;

				a = new complex[0, 0];

				alglib.ap.assert(n >= 1, "CMatrixRndOrthogonal: N<1!");
				a = new complex[n, n];
				for (i = 0; i <= n - 1; i++)
				{
					for (j = 0; j <= n - 1; j++)
					{
						if (i == j)
						{
							a[i, j] = 1;
						}
						else
						{
							a[i, j] = 0;
						}
					}
				}
				cmatrixrndorthogonalfromtheright(ref a, n, n);
			}


			/*************************************************************************
			Generation of random NxN complex matrix with given condition number C and
			norm2(A)=1

			INPUT PARAMETERS:
					N   -   matrix size
					C   -   condition number (in 2-norm)

			OUTPUT PARAMETERS:
					A   -   random matrix with norm2(A)=1 and cond(A)=C

				-- ALGLIB routine --
					 04.12.2009
					 Bochkanov Sergey
			*************************************************************************/
			public static void cmatrixrndcond(int n,
					double c,
					ref complex[,] a)
			{
				int i = 0;
				int j = 0;
				double l1 = 0;
				double l2 = 0;
				hqrnd.hqrndstate state = new hqrnd.hqrndstate();
				complex v = 0;

				a = new complex[0, 0];

				alglib.ap.assert(n >= 1 && (double)(c) >= (double)(1), "CMatrixRndCond: N<1 or C<1!");
				a = new complex[n, n];
				if (n == 1)
				{

					//
					// special case
					//
					hqrnd.hqrndrandomize(state);
					hqrnd.hqrndunit2(state, ref v.x, ref v.y);
					a[0, 0] = v;
					return;
				}
				hqrnd.hqrndrandomize(state);
				l1 = 0;
				l2 = (double)Math.Log(1 / c);
				for (i = 0; i <= n - 1; i++)
				{
					for (j = 0; j <= n - 1; j++)
					{
						a[i, j] = 0;
					}
				}
				a[0, 0] = (double)Math.Exp(l1);
				for (i = 1; i <= n - 2; i++)
				{
					a[i, i] = (double)Math.Exp(hqrnd.hqrnduniformr(state) * (l2 - l1) + l1);
				}
				a[n - 1, n - 1] = (double)Math.Exp(l2);
				cmatrixrndorthogonalfromtheleft(ref a, n, n);
				cmatrixrndorthogonalfromtheright(ref a, n, n);
			}


			/*************************************************************************
			Generation of random NxN symmetric matrix with given condition number  and
			norm2(A)=1

			INPUT PARAMETERS:
					N   -   matrix size
					C   -   condition number (in 2-norm)

			OUTPUT PARAMETERS:
					A   -   random matrix with norm2(A)=1 and cond(A)=C

				-- ALGLIB routine --
					 04.12.2009
					 Bochkanov Sergey
			*************************************************************************/
			public static void smatrixrndcond(int n,
					double c,
					ref double[,] a)
			{
				int i = 0;
				int j = 0;
				double l1 = 0;
				double l2 = 0;
				hqrnd.hqrndstate rs = new hqrnd.hqrndstate();

				a = new double[0, 0];

				alglib.ap.assert(n >= 1 && (double)(c) >= (double)(1), "SMatrixRndCond: N<1 or C<1!");
				a = new double[n, n];
				if (n == 1)
				{

					//
					// special case
					//
					a[0, 0] = 2 * math.randominteger(2) - 1;
					return;
				}

				//
				// Prepare matrix
				//
				hqrnd.hqrndrandomize(rs);
				l1 = 0;
				l2 = (double)Math.Log(1 / c);
				for (i = 0; i <= n - 1; i++)
				{
					for (j = 0; j <= n - 1; j++)
					{
						a[i, j] = 0;
					}
				}
				a[0, 0] = (double)Math.Exp(l1);
				for (i = 1; i <= n - 2; i++)
				{
					a[i, i] = (double)((2 * hqrnd.hqrnduniformi(rs, 2) - 1) * Math.Exp(hqrnd.hqrnduniformr(rs) * (l2 - l1) + l1));
				}
				a[n - 1, n - 1] = (double)Math.Exp(l2);

				//
				// Multiply
				//
				smatrixrndmultiply(ref a, n);
			}


			/*************************************************************************
			Generation of random NxN symmetric positive definite matrix with given
			condition number and norm2(A)=1

			INPUT PARAMETERS:
					N   -   matrix size
					C   -   condition number (in 2-norm)

			OUTPUT PARAMETERS:
					A   -   random SPD matrix with norm2(A)=1 and cond(A)=C

				-- ALGLIB routine --
					 04.12.2009
					 Bochkanov Sergey
			*************************************************************************/
			public static void spdmatrixrndcond(int n,
					double c,
					ref double[,] a)
			{
				int i = 0;
				int j = 0;
				double l1 = 0;
				double l2 = 0;
				hqrnd.hqrndstate rs = new hqrnd.hqrndstate();

				a = new double[0, 0];


				//
				// Special cases
				//
				if (n <= 0 || (double)(c) < (double)(1))
				{
					return;
				}
				a = new double[n, n];
				if (n == 1)
				{
					a[0, 0] = 1;
					return;
				}

				//
				// Prepare matrix
				//
				hqrnd.hqrndrandomize(rs);
				l1 = 0;
				l2 = (double)Math.Log(1 / c);
				for (i = 0; i <= n - 1; i++)
				{
					for (j = 0; j <= n - 1; j++)
					{
						a[i, j] = 0;
					}
				}
				a[0, 0] = (double)Math.Exp(l1);
				for (i = 1; i <= n - 2; i++)
				{
					a[i, i] = (double)Math.Exp(hqrnd.hqrnduniformr(rs) * (l2 - l1) + l1);
				}
				a[n - 1, n - 1] = (double)Math.Exp(l2);

				//
				// Multiply
				//
				smatrixrndmultiply(ref a, n);
			}


			/*************************************************************************
			Generation of random NxN Hermitian matrix with given condition number  and
			norm2(A)=1

			INPUT PARAMETERS:
					N   -   matrix size
					C   -   condition number (in 2-norm)

			OUTPUT PARAMETERS:
					A   -   random matrix with norm2(A)=1 and cond(A)=C

				-- ALGLIB routine --
					 04.12.2009
					 Bochkanov Sergey
			*************************************************************************/
			public static void hmatrixrndcond(int n,
					double c,
					ref complex[,] a)
			{
				int i = 0;
				int j = 0;
				double l1 = 0;
				double l2 = 0;
				hqrnd.hqrndstate rs = new hqrnd.hqrndstate();

				a = new complex[0, 0];

				alglib.ap.assert(n >= 1 && (double)(c) >= (double)(1), "HMatrixRndCond: N<1 or C<1!");
				a = new complex[n, n];
				if (n == 1)
				{

					//
					// special case
					//
					a[0, 0] = 2 * math.randominteger(2) - 1;
					return;
				}

				//
				// Prepare matrix
				//
				hqrnd.hqrndrandomize(rs);
				l1 = 0;
				l2 = (double)Math.Log(1 / c);
				for (i = 0; i <= n - 1; i++)
				{
					for (j = 0; j <= n - 1; j++)
					{
						a[i, j] = 0;
					}
				}
				a[0, 0] = (double)Math.Exp(l1);
				for (i = 1; i <= n - 2; i++)
				{
					a[i, i] = (double)((2 * hqrnd.hqrnduniformi(rs, 2) - 1) * Math.Exp(hqrnd.hqrnduniformr(rs) * (l2 - l1) + l1));
				}
				a[n - 1, n - 1] = (double)Math.Exp(l2);

				//
				// Multiply
				//
				hmatrixrndmultiply(ref a, n);

				//
				// post-process to ensure that matrix diagonal is real
				//
				for (i = 0; i <= n - 1; i++)
				{
					a[i, i].y = 0;
				}
			}


			/*************************************************************************
			Generation of random NxN Hermitian positive definite matrix with given
			condition number and norm2(A)=1

			INPUT PARAMETERS:
					N   -   matrix size
					C   -   condition number (in 2-norm)

			OUTPUT PARAMETERS:
					A   -   random HPD matrix with norm2(A)=1 and cond(A)=C

				-- ALGLIB routine --
					 04.12.2009
					 Bochkanov Sergey
			*************************************************************************/
			public static void hpdmatrixrndcond(int n,
					double c,
					ref complex[,] a)
			{
				int i = 0;
				int j = 0;
				double l1 = 0;
				double l2 = 0;
				hqrnd.hqrndstate rs = new hqrnd.hqrndstate();

				a = new complex[0, 0];


				//
				// Special cases
				//
				if (n <= 0 || (double)(c) < (double)(1))
				{
					return;
				}
				a = new complex[n, n];
				if (n == 1)
				{
					a[0, 0] = 1;
					return;
				}

				//
				// Prepare matrix
				//
				hqrnd.hqrndrandomize(rs);
				l1 = 0;
				l2 = (double)Math.Log(1 / c);
				for (i = 0; i <= n - 1; i++)
				{
					for (j = 0; j <= n - 1; j++)
					{
						a[i, j] = 0;
					}
				}
				a[0, 0] = (double)Math.Exp(l1);
				for (i = 1; i <= n - 2; i++)
				{
					a[i, i] = (double)Math.Exp(hqrnd.hqrnduniformr(rs) * (l2 - l1) + l1);
				}
				a[n - 1, n - 1] = (double)Math.Exp(l2);

				//
				// Multiply
				//
				hmatrixrndmultiply(ref a, n);

				//
				// post-process to ensure that matrix diagonal is real
				//
				for (i = 0; i <= n - 1; i++)
				{
					a[i, i].y = 0;
				}
			}


			/*************************************************************************
			Multiplication of MxN matrix by NxN random Haar distributed orthogonal matrix

			INPUT PARAMETERS:
					A   -   matrix, array[0..M-1, 0..N-1]
					M, N-   matrix size

			OUTPUT PARAMETERS:
					A   -   A*Q, where Q is random NxN orthogonal matrix

				-- ALGLIB routine --
					 04.12.2009
					 Bochkanov Sergey
			*************************************************************************/
			public static void rmatrixrndorthogonalfromtheright(ref double[,] a,
					int m,
					int n)
			{
				double tau = 0;
				double lambdav = 0;
				int s = 0;
				int i = 0;
				double u1 = 0;
				double u2 = 0;
				double[] w = new double[0];
				double[] v = new double[0];
				hqrnd.hqrndstate state = new hqrnd.hqrndstate();
				int i_ = 0;

				alglib.ap.assert(n >= 1 && m >= 1, "RMatrixRndOrthogonalFromTheRight: N<1 or M<1!");
				if (n == 1)
				{

					//
					// Special case
					//
					tau = 2 * math.randominteger(2) - 1;
					for (i = 0; i <= m - 1; i++)
					{
						a[i, 0] = a[i, 0] * tau;
					}
					return;
				}

				//
				// General case.
				// First pass.
				//
				w = new double[m];
				v = new double[n + 1];
				hqrnd.hqrndrandomize(state);
				for (s = 2; s <= n; s++)
				{

					//
					// Prepare random normal v
					//
					do
					{
						i = 1;
						while (i <= s)
						{
							hqrnd.hqrndnormal2(state, ref u1, ref u2);
							v[i] = u1;
							if (i + 1 <= s)
							{
								v[i + 1] = u2;
							}
							i = i + 2;
						}
						lambdav = 0.0f;
						for (i_ = 1; i_ <= s; i_++)
						{
							lambdav += v[i_] * v[i_];
						}
					}
					while ((double)(lambdav) == (double)(0));

					//
					// Prepare and apply reflection
					//
					reflections.generatereflection(ref v, s, ref tau);
					v[1] = 1;
					reflections.applyreflectionfromtheright(ref a, tau, v, 0, m - 1, n - s, n - 1, ref w);
				}

				//
				// Second pass.
				//
				for (i = 0; i <= n - 1; i++)
				{
					tau = 2 * hqrnd.hqrnduniformi(state, 2) - 1;
					for (i_ = 0; i_ <= m - 1; i_++)
					{
						a[i_, i] = tau * a[i_, i];
					}
				}
			}


			/*************************************************************************
			Multiplication of MxN matrix by MxM random Haar distributed orthogonal matrix

			INPUT PARAMETERS:
					A   -   matrix, array[0..M-1, 0..N-1]
					M, N-   matrix size

			OUTPUT PARAMETERS:
					A   -   Q*A, where Q is random MxM orthogonal matrix

				-- ALGLIB routine --
					 04.12.2009
					 Bochkanov Sergey
			*************************************************************************/
			public static void rmatrixrndorthogonalfromtheleft(ref double[,] a,
					int m,
					int n)
			{
				double tau = 0;
				double lambdav = 0;
				int s = 0;
				int i = 0;
				int j = 0;
				double u1 = 0;
				double u2 = 0;
				double[] w = new double[0];
				double[] v = new double[0];
				hqrnd.hqrndstate state = new hqrnd.hqrndstate();
				int i_ = 0;

				alglib.ap.assert(n >= 1 && m >= 1, "RMatrixRndOrthogonalFromTheRight: N<1 or M<1!");
				if (m == 1)
				{

					//
					// special case
					//
					tau = 2 * math.randominteger(2) - 1;
					for (j = 0; j <= n - 1; j++)
					{
						a[0, j] = a[0, j] * tau;
					}
					return;
				}

				//
				// General case.
				// First pass.
				//
				w = new double[n];
				v = new double[m + 1];
				hqrnd.hqrndrandomize(state);
				for (s = 2; s <= m; s++)
				{

					//
					// Prepare random normal v
					//
					do
					{
						i = 1;
						while (i <= s)
						{
							hqrnd.hqrndnormal2(state, ref u1, ref u2);
							v[i] = u1;
							if (i + 1 <= s)
							{
								v[i + 1] = u2;
							}
							i = i + 2;
						}
						lambdav = 0.0f;
						for (i_ = 1; i_ <= s; i_++)
						{
							lambdav += v[i_] * v[i_];
						}
					}
					while ((double)(lambdav) == (double)(0));

					//
					// Prepare and apply reflection
					//
					reflections.generatereflection(ref v, s, ref tau);
					v[1] = 1;
					reflections.applyreflectionfromtheleft(ref a, tau, v, m - s, m - 1, 0, n - 1, ref w);
				}

				//
				// Second pass.
				//
				for (i = 0; i <= m - 1; i++)
				{
					tau = 2 * hqrnd.hqrnduniformi(state, 2) - 1;
					for (i_ = 0; i_ <= n - 1; i_++)
					{
						a[i, i_] = tau * a[i, i_];
					}
				}
			}


			/*************************************************************************
			Multiplication of MxN complex matrix by NxN random Haar distributed
			complex orthogonal matrix

			INPUT PARAMETERS:
					A   -   matrix, array[0..M-1, 0..N-1]
					M, N-   matrix size

			OUTPUT PARAMETERS:
					A   -   A*Q, where Q is random NxN orthogonal matrix

				-- ALGLIB routine --
					 04.12.2009
					 Bochkanov Sergey
			*************************************************************************/
			public static void cmatrixrndorthogonalfromtheright(ref complex[,] a,
					int m,
					int n)
			{
				complex lambdav = 0;
				complex tau = 0;
				int s = 0;
				int i = 0;
				complex[] w = new complex[0];
				complex[] v = new complex[0];
				hqrnd.hqrndstate state = new hqrnd.hqrndstate();
				int i_ = 0;

				alglib.ap.assert(n >= 1 && m >= 1, "CMatrixRndOrthogonalFromTheRight: N<1 or M<1!");
				if (n == 1)
				{

					//
					// Special case
					//
					hqrnd.hqrndrandomize(state);
					hqrnd.hqrndunit2(state, ref tau.x, ref tau.y);
					for (i = 0; i <= m - 1; i++)
					{
						a[i, 0] = a[i, 0] * tau;
					}
					return;
				}

				//
				// General case.
				// First pass.
				//
				w = new complex[m];
				v = new complex[n + 1];
				hqrnd.hqrndrandomize(state);
				for (s = 2; s <= n; s++)
				{

					//
					// Prepare random normal v
					//
					do
					{
						for (i = 1; i <= s; i++)
						{
							hqrnd.hqrndnormal2(state, ref tau.x, ref tau.y);
							v[i] = tau;
						}
						lambdav = 0.0f;
						for (i_ = 1; i_ <= s; i_++)
						{
							lambdav += v[i_] * math.conj(v[i_]);
						}
					}
					while (lambdav == 0);

					//
					// Prepare and apply reflection
					//
					creflections.complexgeneratereflection(ref v, s, ref tau);
					v[1] = 1;
					creflections.complexapplyreflectionfromtheright(ref a, tau, ref v, 0, m - 1, n - s, n - 1, ref w);
				}

				//
				// Second pass.
				//
				for (i = 0; i <= n - 1; i++)
				{
					hqrnd.hqrndunit2(state, ref tau.x, ref tau.y);
					for (i_ = 0; i_ <= m - 1; i_++)
					{
						a[i_, i] = tau * a[i_, i];
					}
				}
			}


			/*************************************************************************
			Multiplication of MxN complex matrix by MxM random Haar distributed
			complex orthogonal matrix

			INPUT PARAMETERS:
					A   -   matrix, array[0..M-1, 0..N-1]
					M, N-   matrix size

			OUTPUT PARAMETERS:
					A   -   Q*A, where Q is random MxM orthogonal matrix

				-- ALGLIB routine --
					 04.12.2009
					 Bochkanov Sergey
			*************************************************************************/
			public static void cmatrixrndorthogonalfromtheleft(ref complex[,] a,
					int m,
					int n)
			{
				complex tau = 0;
				complex lambdav = 0;
				int s = 0;
				int i = 0;
				int j = 0;
				complex[] w = new complex[0];
				complex[] v = new complex[0];
				hqrnd.hqrndstate state = new hqrnd.hqrndstate();
				int i_ = 0;

				alglib.ap.assert(n >= 1 && m >= 1, "CMatrixRndOrthogonalFromTheRight: N<1 or M<1!");
				if (m == 1)
				{

					//
					// special case
					//
					hqrnd.hqrndrandomize(state);
					hqrnd.hqrndunit2(state, ref tau.x, ref tau.y);
					for (j = 0; j <= n - 1; j++)
					{
						a[0, j] = a[0, j] * tau;
					}
					return;
				}

				//
				// General case.
				// First pass.
				//
				w = new complex[n];
				v = new complex[m + 1];
				hqrnd.hqrndrandomize(state);
				for (s = 2; s <= m; s++)
				{

					//
					// Prepare random normal v
					//
					do
					{
						for (i = 1; i <= s; i++)
						{
							hqrnd.hqrndnormal2(state, ref tau.x, ref tau.y);
							v[i] = tau;
						}
						lambdav = 0.0f;
						for (i_ = 1; i_ <= s; i_++)
						{
							lambdav += v[i_] * math.conj(v[i_]);
						}
					}
					while (lambdav == 0);

					//
					// Prepare and apply reflection
					//
					creflections.complexgeneratereflection(ref v, s, ref tau);
					v[1] = 1;
					creflections.complexapplyreflectionfromtheleft(ref a, tau, v, m - s, m - 1, 0, n - 1, ref w);
				}

				//
				// Second pass.
				//
				for (i = 0; i <= m - 1; i++)
				{
					hqrnd.hqrndunit2(state, ref tau.x, ref tau.y);
					for (i_ = 0; i_ <= n - 1; i_++)
					{
						a[i, i_] = tau * a[i, i_];
					}
				}
			}


			/*************************************************************************
			Symmetric multiplication of NxN matrix by random Haar distributed
			orthogonal  matrix

			INPUT PARAMETERS:
					A   -   matrix, array[0..N-1, 0..N-1]
					N   -   matrix size

			OUTPUT PARAMETERS:
					A   -   Q'*A*Q, where Q is random NxN orthogonal matrix

				-- ALGLIB routine --
					 04.12.2009
					 Bochkanov Sergey
			*************************************************************************/
			public static void smatrixrndmultiply(ref double[,] a,
					int n)
			{
				double tau = 0;
				double lambdav = 0;
				int s = 0;
				int i = 0;
				double u1 = 0;
				double u2 = 0;
				double[] w = new double[0];
				double[] v = new double[0];
				hqrnd.hqrndstate state = new hqrnd.hqrndstate();
				int i_ = 0;


				//
				// General case.
				//
				w = new double[n];
				v = new double[n + 1];
				hqrnd.hqrndrandomize(state);
				for (s = 2; s <= n; s++)
				{

					//
					// Prepare random normal v
					//
					do
					{
						i = 1;
						while (i <= s)
						{
							hqrnd.hqrndnormal2(state, ref u1, ref u2);
							v[i] = u1;
							if (i + 1 <= s)
							{
								v[i + 1] = u2;
							}
							i = i + 2;
						}
						lambdav = 0.0f;
						for (i_ = 1; i_ <= s; i_++)
						{
							lambdav += v[i_] * v[i_];
						}
					}
					while ((double)(lambdav) == (double)(0));

					//
					// Prepare and apply reflection
					//
					reflections.generatereflection(ref v, s, ref tau);
					v[1] = 1;
					reflections.applyreflectionfromtheright(ref a, tau, v, 0, n - 1, n - s, n - 1, ref w);
					reflections.applyreflectionfromtheleft(ref a, tau, v, n - s, n - 1, 0, n - 1, ref w);
				}

				//
				// Second pass.
				//
				for (i = 0; i <= n - 1; i++)
				{
					tau = 2 * hqrnd.hqrnduniformi(state, 2) - 1;
					for (i_ = 0; i_ <= n - 1; i_++)
					{
						a[i_, i] = tau * a[i_, i];
					}
					for (i_ = 0; i_ <= n - 1; i_++)
					{
						a[i, i_] = tau * a[i, i_];
					}
				}

				//
				// Copy upper triangle to lower
				//
				for (i = 0; i <= n - 2; i++)
				{
					for (i_ = i + 1; i_ <= n - 1; i_++)
					{
						a[i_, i] = a[i, i_];
					}
				}
			}


			/*************************************************************************
			Hermitian multiplication of NxN matrix by random Haar distributed
			complex orthogonal matrix

			INPUT PARAMETERS:
					A   -   matrix, array[0..N-1, 0..N-1]
					N   -   matrix size

			OUTPUT PARAMETERS:
					A   -   Q^H*A*Q, where Q is random NxN orthogonal matrix

				-- ALGLIB routine --
					 04.12.2009
					 Bochkanov Sergey
			*************************************************************************/
			public static void hmatrixrndmultiply(ref complex[,] a,
					int n)
			{
				complex tau = 0;
				complex lambdav = 0;
				int s = 0;
				int i = 0;
				complex[] w = new complex[0];
				complex[] v = new complex[0];
				hqrnd.hqrndstate state = new hqrnd.hqrndstate();
				int i_ = 0;


				//
				// General case.
				//
				w = new complex[n];
				v = new complex[n + 1];
				hqrnd.hqrndrandomize(state);
				for (s = 2; s <= n; s++)
				{

					//
					// Prepare random normal v
					//
					do
					{
						for (i = 1; i <= s; i++)
						{
							hqrnd.hqrndnormal2(state, ref tau.x, ref tau.y);
							v[i] = tau;
						}
						lambdav = 0.0f;
						for (i_ = 1; i_ <= s; i_++)
						{
							lambdav += v[i_] * math.conj(v[i_]);
						}
					}
					while (lambdav == 0);

					//
					// Prepare and apply reflection
					//
					creflections.complexgeneratereflection(ref v, s, ref tau);
					v[1] = 1;
					creflections.complexapplyreflectionfromtheright(ref a, tau, ref v, 0, n - 1, n - s, n - 1, ref w);
					creflections.complexapplyreflectionfromtheleft(ref a, math.conj(tau), v, n - s, n - 1, 0, n - 1, ref w);
				}

				//
				// Second pass.
				//
				for (i = 0; i <= n - 1; i++)
				{
					hqrnd.hqrndunit2(state, ref tau.x, ref tau.y);
					for (i_ = 0; i_ <= n - 1; i_++)
					{
						a[i_, i] = tau * a[i_, i];
					}
					tau = math.conj(tau);
					for (i_ = 0; i_ <= n - 1; i_++)
					{
						a[i, i_] = tau * a[i, i_];
					}
				}

				//
				// Change all values from lower triangle by complex-conjugate values
				// from upper one
				//
				for (i = 0; i <= n - 2; i++)
				{
					for (i_ = i + 1; i_ <= n - 1; i_++)
					{
						a[i_, i] = a[i, i_];
					}
				}
				for (s = 0; s <= n - 2; s++)
				{
					for (i = s + 1; i <= n - 1; i++)
					{
						a[i, s].y = -a[i, s].y;
					}
				}
			}


		}
		public class trfac
		{
			/*************************************************************************
			LU decomposition of a general real matrix with row pivoting

			A is represented as A = P*L*U, where:
			* L is lower unitriangular matrix
			* U is upper triangular matrix
			* P = P0*P1*...*PK, K=min(M,N)-1,
				Pi - permutation matrix for I and Pivots[I]

			This is cache-oblivous implementation of LU decomposition.
			It is optimized for square matrices. As for rectangular matrices:
			* best case - M>>N
			* worst case - N>>M, small M, large N, matrix does not fit in CPU cache

			INPUT PARAMETERS:
					A       -   array[0..M-1, 0..N-1].
					M       -   number of rows in matrix A.
					N       -   number of columns in matrix A.


			OUTPUT PARAMETERS:
					A       -   matrices L and U in compact form:
											* L is stored under main diagonal
											* U is stored on and above main diagonal
					Pivots  -   permutation matrix in compact form.
											array[0..Min(M-1,N-1)].

				-- ALGLIB routine --
					 10.01.2010
					 Bochkanov Sergey
			*************************************************************************/
			public static void rmatrixlu(ref double[,] a,
					int m,
					int n,
					ref int[] pivots)
			{
				pivots = new int[0];

				alglib.ap.assert(m > 0, "RMatrixLU: incorrect M!");
				alglib.ap.assert(n > 0, "RMatrixLU: incorrect N!");
				rmatrixplu(ref a, m, n, ref pivots);
			}


			/*************************************************************************
			LU decomposition of a general complex matrix with row pivoting

			A is represented as A = P*L*U, where:
			* L is lower unitriangular matrix
			* U is upper triangular matrix
			* P = P0*P1*...*PK, K=min(M,N)-1,
				Pi - permutation matrix for I and Pivots[I]

			This is cache-oblivous implementation of LU decomposition. It is optimized
			for square matrices. As for rectangular matrices:
			* best case - M>>N
			* worst case - N>>M, small M, large N, matrix does not fit in CPU cache

			INPUT PARAMETERS:
					A       -   array[0..M-1, 0..N-1].
					M       -   number of rows in matrix A.
					N       -   number of columns in matrix A.


			OUTPUT PARAMETERS:
					A       -   matrices L and U in compact form:
											* L is stored under main diagonal
											* U is stored on and above main diagonal
					Pivots  -   permutation matrix in compact form.
											array[0..Min(M-1,N-1)].

				-- ALGLIB routine --
					 10.01.2010
					 Bochkanov Sergey
			*************************************************************************/
			public static void cmatrixlu(ref complex[,] a,
					int m,
					int n,
					ref int[] pivots)
			{
				pivots = new int[0];

				alglib.ap.assert(m > 0, "CMatrixLU: incorrect M!");
				alglib.ap.assert(n > 0, "CMatrixLU: incorrect N!");
				cmatrixplu(ref a, m, n, ref pivots);
			}


			/*************************************************************************
			Cache-oblivious Cholesky decomposition

			The algorithm computes Cholesky decomposition  of  a  Hermitian  positive-
			definite matrix. The result of an algorithm is a representation  of  A  as
			A=U'*U  or A=L*L' (here X' detones conj(X^T)).

			INPUT PARAMETERS:
					A       -   upper or lower triangle of a factorized matrix.
											array with elements [0..N-1, 0..N-1].
					N       -   size of matrix A.
					IsUpper -   if IsUpper=True, then A contains an upper triangle of
											a symmetric matrix, otherwise A contains a lower one.

			OUTPUT PARAMETERS:
					A       -   the result of factorization. If IsUpper=True, then
											the upper triangle contains matrix U, so that A = U'*U,
											and the elements below the main diagonal are not modified.
											Similarly, if IsUpper = False.

			RESULT:
					If  the  matrix  is  positive-definite,  the  function  returns  True.
					Otherwise, the function returns False. Contents of A is not determined
					in such case.

				-- ALGLIB routine --
					 15.12.2009
					 Bochkanov Sergey
			*************************************************************************/
			public static bool hpdmatrixcholesky(ref complex[,] a,
					int n,
					bool isupper)
			{
				bool result = new bool();
				complex[] tmp = new complex[0];

				if (n < 1)
				{
					result = false;
					return result;
				}
				result = hpdmatrixcholeskyrec(ref a, 0, n, isupper, ref tmp);
				return result;
			}


			/*************************************************************************
			Cache-oblivious Cholesky decomposition

			The algorithm computes Cholesky decomposition  of  a  symmetric  positive-
			definite matrix. The result of an algorithm is a representation  of  A  as
			A=U^T*U  or A=L*L^T

			INPUT PARAMETERS:
					A       -   upper or lower triangle of a factorized matrix.
											array with elements [0..N-1, 0..N-1].
					N       -   size of matrix A.
					IsUpper -   if IsUpper=True, then A contains an upper triangle of
											a symmetric matrix, otherwise A contains a lower one.

			OUTPUT PARAMETERS:
					A       -   the result of factorization. If IsUpper=True, then
											the upper triangle contains matrix U, so that A = U^T*U,
											and the elements below the main diagonal are not modified.
											Similarly, if IsUpper = False.

			RESULT:
					If  the  matrix  is  positive-definite,  the  function  returns  True.
					Otherwise, the function returns False. Contents of A is not determined
					in such case.

				-- ALGLIB routine --
					 15.12.2009
					 Bochkanov Sergey
			*************************************************************************/
			public static bool spdmatrixcholesky(ref double[,] a,
					int n,
					bool isupper)
			{
				bool result = new bool();
				double[] tmp = new double[0];

				if (n < 1)
				{
					result = false;
					return result;
				}
				result = spdmatrixcholeskyrec(ref a, 0, n, isupper, ref tmp);
				return result;
			}


			public static void rmatrixlup(ref double[,] a,
					int m,
					int n,
					ref int[] pivots)
			{
				double[] tmp = new double[0];
				int i = 0;
				int j = 0;
				double mx = 0;
				double v = 0;
				int i_ = 0;

				pivots = new int[0];


				//
				// Internal LU decomposition subroutine.
				// Never call it directly.
				//
				alglib.ap.assert(m > 0, "RMatrixLUP: incorrect M!");
				alglib.ap.assert(n > 0, "RMatrixLUP: incorrect N!");

				//
				// Scale matrix to avoid overflows,
				// decompose it, then scale back.
				//
				mx = 0;
				for (i = 0; i <= m - 1; i++)
				{
					for (j = 0; j <= n - 1; j++)
					{
						mx = Math.Max(mx, Math.Abs(a[i, j]));
					}
				}
				if ((double)(mx) != (double)(0))
				{
					v = 1 / mx;
					for (i = 0; i <= m - 1; i++)
					{
						for (i_ = 0; i_ <= n - 1; i_++)
						{
							a[i, i_] = v * a[i, i_];
						}
					}
				}
				pivots = new int[Math.Min(m, n)];
				tmp = new double[2 * Math.Max(m, n)];
				rmatrixluprec(ref a, 0, m, n, ref pivots, ref tmp);
				if ((double)(mx) != (double)(0))
				{
					v = mx;
					for (i = 0; i <= m - 1; i++)
					{
						for (i_ = 0; i_ <= Math.Min(i, n - 1); i_++)
						{
							a[i, i_] = v * a[i, i_];
						}
					}
				}
			}


			public static void cmatrixlup(ref complex[,] a,
					int m,
					int n,
					ref int[] pivots)
			{
				complex[] tmp = new complex[0];
				int i = 0;
				int j = 0;
				double mx = 0;
				double v = 0;
				int i_ = 0;

				pivots = new int[0];


				//
				// Internal LU decomposition subroutine.
				// Never call it directly.
				//
				alglib.ap.assert(m > 0, "CMatrixLUP: incorrect M!");
				alglib.ap.assert(n > 0, "CMatrixLUP: incorrect N!");

				//
				// Scale matrix to avoid overflows,
				// decompose it, then scale back.
				//
				mx = 0;
				for (i = 0; i <= m - 1; i++)
				{
					for (j = 0; j <= n - 1; j++)
					{
						mx = Math.Max(mx, math.abscomplex(a[i, j]));
					}
				}
				if ((double)(mx) != (double)(0))
				{
					v = 1 / mx;
					for (i = 0; i <= m - 1; i++)
					{
						for (i_ = 0; i_ <= n - 1; i_++)
						{
							a[i, i_] = v * a[i, i_];
						}
					}
				}
				pivots = new int[Math.Min(m, n)];
				tmp = new complex[2 * Math.Max(m, n)];
				cmatrixluprec(ref a, 0, m, n, ref pivots, ref tmp);
				if ((double)(mx) != (double)(0))
				{
					v = mx;
					for (i = 0; i <= m - 1; i++)
					{
						for (i_ = 0; i_ <= Math.Min(i, n - 1); i_++)
						{
							a[i, i_] = v * a[i, i_];
						}
					}
				}
			}


			public static void rmatrixplu(ref double[,] a,
					int m,
					int n,
					ref int[] pivots)
			{
				double[] tmp = new double[0];
				int i = 0;
				int j = 0;
				double mx = 0;
				double v = 0;
				int i_ = 0;

				pivots = new int[0];


				//
				// Internal LU decomposition subroutine.
				// Never call it directly.
				//
				alglib.ap.assert(m > 0, "RMatrixPLU: incorrect M!");
				alglib.ap.assert(n > 0, "RMatrixPLU: incorrect N!");
				tmp = new double[2 * Math.Max(m, n)];
				pivots = new int[Math.Min(m, n)];

				//
				// Scale matrix to avoid overflows,
				// decompose it, then scale back.
				//
				mx = 0;
				for (i = 0; i <= m - 1; i++)
				{
					for (j = 0; j <= n - 1; j++)
					{
						mx = Math.Max(mx, Math.Abs(a[i, j]));
					}
				}
				if ((double)(mx) != (double)(0))
				{
					v = 1 / mx;
					for (i = 0; i <= m - 1; i++)
					{
						for (i_ = 0; i_ <= n - 1; i_++)
						{
							a[i, i_] = v * a[i, i_];
						}
					}
				}
				rmatrixplurec(ref a, 0, m, n, ref pivots, ref tmp);
				if ((double)(mx) != (double)(0))
				{
					v = mx;
					for (i = 0; i <= Math.Min(m, n) - 1; i++)
					{
						for (i_ = i; i_ <= n - 1; i_++)
						{
							a[i, i_] = v * a[i, i_];
						}
					}
				}
			}


			public static void cmatrixplu(ref complex[,] a,
					int m,
					int n,
					ref int[] pivots)
			{
				complex[] tmp = new complex[0];
				int i = 0;
				int j = 0;
				double mx = 0;
				complex v = 0;
				int i_ = 0;

				pivots = new int[0];


				//
				// Internal LU decomposition subroutine.
				// Never call it directly.
				//
				alglib.ap.assert(m > 0, "CMatrixPLU: incorrect M!");
				alglib.ap.assert(n > 0, "CMatrixPLU: incorrect N!");
				tmp = new complex[2 * Math.Max(m, n)];
				pivots = new int[Math.Min(m, n)];

				//
				// Scale matrix to avoid overflows,
				// decompose it, then scale back.
				//
				mx = 0;
				for (i = 0; i <= m - 1; i++)
				{
					for (j = 0; j <= n - 1; j++)
					{
						mx = Math.Max(mx, math.abscomplex(a[i, j]));
					}
				}
				if ((double)(mx) != (double)(0))
				{
					v = 1 / mx;
					for (i = 0; i <= m - 1; i++)
					{
						for (i_ = 0; i_ <= n - 1; i_++)
						{
							a[i, i_] = v * a[i, i_];
						}
					}
				}
				cmatrixplurec(ref a, 0, m, n, ref pivots, ref tmp);
				if ((double)(mx) != (double)(0))
				{
					v = mx;
					for (i = 0; i <= Math.Min(m, n) - 1; i++)
					{
						for (i_ = i; i_ <= n - 1; i_++)
						{
							a[i, i_] = v * a[i, i_];
						}
					}
				}
			}


			/*************************************************************************
			Recursive computational subroutine for SPDMatrixCholesky.

			INPUT PARAMETERS:
					A       -   matrix given by upper or lower triangle
					Offs    -   offset of diagonal block to decompose
					N       -   diagonal block size
					IsUpper -   what half is given
					Tmp     -   temporary array; allocated by function, if its size is too
											small; can be reused on subsequent calls.
                        
			OUTPUT PARAMETERS:
					A       -   upper (or lower) triangle contains Cholesky decomposition

			RESULT:
					True, on success
					False, on failure

				-- ALGLIB routine --
					 15.12.2009
					 Bochkanov Sergey
			*************************************************************************/
			public static bool spdmatrixcholeskyrec(ref double[,] a,
					int offs,
					int n,
					bool isupper,
					ref double[] tmp)
			{
				bool result = new bool();
				int n1 = 0;
				int n2 = 0;


				//
				// check N
				//
				if (n < 1)
				{
					result = false;
					return result;
				}

				//
				// Prepare buffer
				//
				if (alglib.ap.len(tmp) < 2 * n)
				{
					tmp = new double[2 * n];
				}

				//
				// special cases
				//
				if (n == 1)
				{
					if ((double)(a[offs, offs]) > (double)(0))
					{
						a[offs, offs] = (double)Math.Sqrt(a[offs, offs]);
						result = true;
					}
					else
					{
						result = false;
					}
					return result;
				}
				if (n <= ablas.ablasblocksize(a))
				{
					result = spdmatrixcholesky2(ref a, offs, n, isupper, ref tmp);
					return result;
				}

				//
				// general case: split task in cache-oblivious manner
				//
				result = true;
				ablas.ablassplitlength(a, n, ref n1, ref n2);
				result = spdmatrixcholeskyrec(ref a, offs, n1, isupper, ref tmp);
				if (!result)
				{
					return result;
				}
				if (n2 > 0)
				{
					if (isupper)
					{
						ablas.rmatrixlefttrsm(n1, n2, a, offs, offs, isupper, false, 1, a, offs, offs + n1);
						ablas.rmatrixsyrk(n2, n1, -1.0f, a, offs, offs + n1, 1, 1.0f, a, offs + n1, offs + n1, isupper);
					}
					else
					{
						ablas.rmatrixrighttrsm(n2, n1, a, offs, offs, isupper, false, 1, a, offs + n1, offs);
						ablas.rmatrixsyrk(n2, n1, -1.0f, a, offs + n1, offs, 0, 1.0f, a, offs + n1, offs + n1, isupper);
					}
					result = spdmatrixcholeskyrec(ref a, offs + n1, n2, isupper, ref tmp);
					if (!result)
					{
						return result;
					}
				}
				return result;
			}


			/*************************************************************************
			Recurrent complex LU subroutine.
			Never call it directly.

				-- ALGLIB routine --
					 04.01.2010
					 Bochkanov Sergey
			*************************************************************************/
			private static void cmatrixluprec(ref complex[,] a,
					int offs,
					int m,
					int n,
					ref int[] pivots,
					ref complex[] tmp)
			{
				int i = 0;
				int m1 = 0;
				int m2 = 0;
				int i_ = 0;
				int i1_ = 0;


				//
				// Kernel case
				//
				if (Math.Min(m, n) <= ablas.ablascomplexblocksize(a))
				{
					cmatrixlup2(ref a, offs, m, n, ref pivots, ref tmp);
					return;
				}

				//
				// Preliminary step, make N>=M
				//
				//     ( A1 )
				// A = (    ), where A1 is square
				//     ( A2 )
				//
				// Factorize A1, update A2
				//
				if (m > n)
				{
					cmatrixluprec(ref a, offs, n, n, ref pivots, ref tmp);
					for (i = 0; i <= n - 1; i++)
					{
						i1_ = (offs + n) - (0);
						for (i_ = 0; i_ <= m - n - 1; i_++)
						{
							tmp[i_] = a[i_ + i1_, offs + i];
						}
						for (i_ = offs + n; i_ <= offs + m - 1; i_++)
						{
							a[i_, offs + i] = a[i_, pivots[offs + i]];
						}
						i1_ = (0) - (offs + n);
						for (i_ = offs + n; i_ <= offs + m - 1; i_++)
						{
							a[i_, pivots[offs + i]] = tmp[i_ + i1_];
						}
					}
					ablas.cmatrixrighttrsm(m - n, n, a, offs, offs, true, true, 0, a, offs + n, offs);
					return;
				}

				//
				// Non-kernel case
				//
				ablas.ablascomplexsplitlength(a, m, ref m1, ref m2);
				cmatrixluprec(ref a, offs, m1, n, ref pivots, ref tmp);
				if (m2 > 0)
				{
					for (i = 0; i <= m1 - 1; i++)
					{
						if (offs + i != pivots[offs + i])
						{
							i1_ = (offs + m1) - (0);
							for (i_ = 0; i_ <= m2 - 1; i_++)
							{
								tmp[i_] = a[i_ + i1_, offs + i];
							}
							for (i_ = offs + m1; i_ <= offs + m - 1; i_++)
							{
								a[i_, offs + i] = a[i_, pivots[offs + i]];
							}
							i1_ = (0) - (offs + m1);
							for (i_ = offs + m1; i_ <= offs + m - 1; i_++)
							{
								a[i_, pivots[offs + i]] = tmp[i_ + i1_];
							}
						}
					}
					ablas.cmatrixrighttrsm(m2, m1, a, offs, offs, true, true, 0, a, offs + m1, offs);
					ablas.cmatrixgemm(m - m1, n - m1, m1, -1.0f, a, offs + m1, offs, 0, a, offs, offs + m1, 0, 1.0f, a, offs + m1, offs + m1);
					cmatrixluprec(ref a, offs + m1, m - m1, n - m1, ref pivots, ref tmp);
					for (i = 0; i <= m2 - 1; i++)
					{
						if (offs + m1 + i != pivots[offs + m1 + i])
						{
							i1_ = (offs) - (0);
							for (i_ = 0; i_ <= m1 - 1; i_++)
							{
								tmp[i_] = a[i_ + i1_, offs + m1 + i];
							}
							for (i_ = offs; i_ <= offs + m1 - 1; i_++)
							{
								a[i_, offs + m1 + i] = a[i_, pivots[offs + m1 + i]];
							}
							i1_ = (0) - (offs);
							for (i_ = offs; i_ <= offs + m1 - 1; i_++)
							{
								a[i_, pivots[offs + m1 + i]] = tmp[i_ + i1_];
							}
						}
					}
				}
			}


			/*************************************************************************
			Recurrent real LU subroutine.
			Never call it directly.

				-- ALGLIB routine --
					 04.01.2010
					 Bochkanov Sergey
			*************************************************************************/
			private static void rmatrixluprec(ref double[,] a,
					int offs,
					int m,
					int n,
					ref int[] pivots,
					ref double[] tmp)
			{
				int i = 0;
				int m1 = 0;
				int m2 = 0;
				int i_ = 0;
				int i1_ = 0;


				//
				// Kernel case
				//
				if (Math.Min(m, n) <= ablas.ablasblocksize(a))
				{
					rmatrixlup2(ref a, offs, m, n, ref pivots, ref tmp);
					return;
				}

				//
				// Preliminary step, make N>=M
				//
				//     ( A1 )
				// A = (    ), where A1 is square
				//     ( A2 )
				//
				// Factorize A1, update A2
				//
				if (m > n)
				{
					rmatrixluprec(ref a, offs, n, n, ref pivots, ref tmp);
					for (i = 0; i <= n - 1; i++)
					{
						if (offs + i != pivots[offs + i])
						{
							i1_ = (offs + n) - (0);
							for (i_ = 0; i_ <= m - n - 1; i_++)
							{
								tmp[i_] = a[i_ + i1_, offs + i];
							}
							for (i_ = offs + n; i_ <= offs + m - 1; i_++)
							{
								a[i_, offs + i] = a[i_, pivots[offs + i]];
							}
							i1_ = (0) - (offs + n);
							for (i_ = offs + n; i_ <= offs + m - 1; i_++)
							{
								a[i_, pivots[offs + i]] = tmp[i_ + i1_];
							}
						}
					}
					ablas.rmatrixrighttrsm(m - n, n, a, offs, offs, true, true, 0, a, offs + n, offs);
					return;
				}

				//
				// Non-kernel case
				//
				ablas.ablassplitlength(a, m, ref m1, ref m2);
				rmatrixluprec(ref a, offs, m1, n, ref pivots, ref tmp);
				if (m2 > 0)
				{
					for (i = 0; i <= m1 - 1; i++)
					{
						if (offs + i != pivots[offs + i])
						{
							i1_ = (offs + m1) - (0);
							for (i_ = 0; i_ <= m2 - 1; i_++)
							{
								tmp[i_] = a[i_ + i1_, offs + i];
							}
							for (i_ = offs + m1; i_ <= offs + m - 1; i_++)
							{
								a[i_, offs + i] = a[i_, pivots[offs + i]];
							}
							i1_ = (0) - (offs + m1);
							for (i_ = offs + m1; i_ <= offs + m - 1; i_++)
							{
								a[i_, pivots[offs + i]] = tmp[i_ + i1_];
							}
						}
					}
					ablas.rmatrixrighttrsm(m2, m1, a, offs, offs, true, true, 0, a, offs + m1, offs);
					ablas.rmatrixgemm(m - m1, n - m1, m1, -1.0f, a, offs + m1, offs, 0, a, offs, offs + m1, 0, 1.0f, a, offs + m1, offs + m1);
					rmatrixluprec(ref a, offs + m1, m - m1, n - m1, ref pivots, ref tmp);
					for (i = 0; i <= m2 - 1; i++)
					{
						if (offs + m1 + i != pivots[offs + m1 + i])
						{
							i1_ = (offs) - (0);
							for (i_ = 0; i_ <= m1 - 1; i_++)
							{
								tmp[i_] = a[i_ + i1_, offs + m1 + i];
							}
							for (i_ = offs; i_ <= offs + m1 - 1; i_++)
							{
								a[i_, offs + m1 + i] = a[i_, pivots[offs + m1 + i]];
							}
							i1_ = (0) - (offs);
							for (i_ = offs; i_ <= offs + m1 - 1; i_++)
							{
								a[i_, pivots[offs + m1 + i]] = tmp[i_ + i1_];
							}
						}
					}
				}
			}


			/*************************************************************************
			Recurrent complex LU subroutine.
			Never call it directly.

				-- ALGLIB routine --
					 04.01.2010
					 Bochkanov Sergey
			*************************************************************************/
			private static void cmatrixplurec(ref complex[,] a,
					int offs,
					int m,
					int n,
					ref int[] pivots,
					ref complex[] tmp)
			{
				int i = 0;
				int n1 = 0;
				int n2 = 0;
				int i_ = 0;
				int i1_ = 0;


				//
				// Kernel case
				//
				if (Math.Min(m, n) <= ablas.ablascomplexblocksize(a))
				{
					cmatrixplu2(ref a, offs, m, n, ref pivots, ref tmp);
					return;
				}

				//
				// Preliminary step, make M>=N.
				//
				// A = (A1 A2), where A1 is square
				// Factorize A1, update A2
				//
				if (n > m)
				{
					cmatrixplurec(ref a, offs, m, m, ref pivots, ref tmp);
					for (i = 0; i <= m - 1; i++)
					{
						i1_ = (offs + m) - (0);
						for (i_ = 0; i_ <= n - m - 1; i_++)
						{
							tmp[i_] = a[offs + i, i_ + i1_];
						}
						for (i_ = offs + m; i_ <= offs + n - 1; i_++)
						{
							a[offs + i, i_] = a[pivots[offs + i], i_];
						}
						i1_ = (0) - (offs + m);
						for (i_ = offs + m; i_ <= offs + n - 1; i_++)
						{
							a[pivots[offs + i], i_] = tmp[i_ + i1_];
						}
					}
					ablas.cmatrixlefttrsm(m, n - m, a, offs, offs, false, true, 0, a, offs, offs + m);
					return;
				}

				//
				// Non-kernel case
				//
				ablas.ablascomplexsplitlength(a, n, ref n1, ref n2);
				cmatrixplurec(ref a, offs, m, n1, ref pivots, ref tmp);
				if (n2 > 0)
				{
					for (i = 0; i <= n1 - 1; i++)
					{
						if (offs + i != pivots[offs + i])
						{
							i1_ = (offs + n1) - (0);
							for (i_ = 0; i_ <= n2 - 1; i_++)
							{
								tmp[i_] = a[offs + i, i_ + i1_];
							}
							for (i_ = offs + n1; i_ <= offs + n - 1; i_++)
							{
								a[offs + i, i_] = a[pivots[offs + i], i_];
							}
							i1_ = (0) - (offs + n1);
							for (i_ = offs + n1; i_ <= offs + n - 1; i_++)
							{
								a[pivots[offs + i], i_] = tmp[i_ + i1_];
							}
						}
					}
					ablas.cmatrixlefttrsm(n1, n2, a, offs, offs, false, true, 0, a, offs, offs + n1);
					ablas.cmatrixgemm(m - n1, n - n1, n1, -1.0f, a, offs + n1, offs, 0, a, offs, offs + n1, 0, 1.0f, a, offs + n1, offs + n1);
					cmatrixplurec(ref a, offs + n1, m - n1, n - n1, ref pivots, ref tmp);
					for (i = 0; i <= n2 - 1; i++)
					{
						if (offs + n1 + i != pivots[offs + n1 + i])
						{
							i1_ = (offs) - (0);
							for (i_ = 0; i_ <= n1 - 1; i_++)
							{
								tmp[i_] = a[offs + n1 + i, i_ + i1_];
							}
							for (i_ = offs; i_ <= offs + n1 - 1; i_++)
							{
								a[offs + n1 + i, i_] = a[pivots[offs + n1 + i], i_];
							}
							i1_ = (0) - (offs);
							for (i_ = offs; i_ <= offs + n1 - 1; i_++)
							{
								a[pivots[offs + n1 + i], i_] = tmp[i_ + i1_];
							}
						}
					}
				}
			}


			/*************************************************************************
			Recurrent real LU subroutine.
			Never call it directly.

				-- ALGLIB routine --
					 04.01.2010
					 Bochkanov Sergey
			*************************************************************************/
			private static void rmatrixplurec(ref double[,] a,
					int offs,
					int m,
					int n,
					ref int[] pivots,
					ref double[] tmp)
			{
				int i = 0;
				int n1 = 0;
				int n2 = 0;
				int i_ = 0;
				int i1_ = 0;


				//
				// Kernel case
				//
				if (Math.Min(m, n) <= ablas.ablasblocksize(a))
				{
					rmatrixplu2(ref a, offs, m, n, ref pivots, ref tmp);
					return;
				}

				//
				// Preliminary step, make M>=N.
				//
				// A = (A1 A2), where A1 is square
				// Factorize A1, update A2
				//
				if (n > m)
				{
					rmatrixplurec(ref a, offs, m, m, ref pivots, ref tmp);
					for (i = 0; i <= m - 1; i++)
					{
						i1_ = (offs + m) - (0);
						for (i_ = 0; i_ <= n - m - 1; i_++)
						{
							tmp[i_] = a[offs + i, i_ + i1_];
						}
						for (i_ = offs + m; i_ <= offs + n - 1; i_++)
						{
							a[offs + i, i_] = a[pivots[offs + i], i_];
						}
						i1_ = (0) - (offs + m);
						for (i_ = offs + m; i_ <= offs + n - 1; i_++)
						{
							a[pivots[offs + i], i_] = tmp[i_ + i1_];
						}
					}
					ablas.rmatrixlefttrsm(m, n - m, a, offs, offs, false, true, 0, a, offs, offs + m);
					return;
				}

				//
				// Non-kernel case
				//
				ablas.ablassplitlength(a, n, ref n1, ref n2);
				rmatrixplurec(ref a, offs, m, n1, ref pivots, ref tmp);
				if (n2 > 0)
				{
					for (i = 0; i <= n1 - 1; i++)
					{
						if (offs + i != pivots[offs + i])
						{
							i1_ = (offs + n1) - (0);
							for (i_ = 0; i_ <= n2 - 1; i_++)
							{
								tmp[i_] = a[offs + i, i_ + i1_];
							}
							for (i_ = offs + n1; i_ <= offs + n - 1; i_++)
							{
								a[offs + i, i_] = a[pivots[offs + i], i_];
							}
							i1_ = (0) - (offs + n1);
							for (i_ = offs + n1; i_ <= offs + n - 1; i_++)
							{
								a[pivots[offs + i], i_] = tmp[i_ + i1_];
							}
						}
					}
					ablas.rmatrixlefttrsm(n1, n2, a, offs, offs, false, true, 0, a, offs, offs + n1);
					ablas.rmatrixgemm(m - n1, n - n1, n1, -1.0f, a, offs + n1, offs, 0, a, offs, offs + n1, 0, 1.0f, a, offs + n1, offs + n1);
					rmatrixplurec(ref a, offs + n1, m - n1, n - n1, ref pivots, ref tmp);
					for (i = 0; i <= n2 - 1; i++)
					{
						if (offs + n1 + i != pivots[offs + n1 + i])
						{
							i1_ = (offs) - (0);
							for (i_ = 0; i_ <= n1 - 1; i_++)
							{
								tmp[i_] = a[offs + n1 + i, i_ + i1_];
							}
							for (i_ = offs; i_ <= offs + n1 - 1; i_++)
							{
								a[offs + n1 + i, i_] = a[pivots[offs + n1 + i], i_];
							}
							i1_ = (0) - (offs);
							for (i_ = offs; i_ <= offs + n1 - 1; i_++)
							{
								a[pivots[offs + n1 + i], i_] = tmp[i_ + i1_];
							}
						}
					}
				}
			}


			/*************************************************************************
			Complex LUP kernel

				-- ALGLIB routine --
					 10.01.2010
					 Bochkanov Sergey
			*************************************************************************/
			private static void cmatrixlup2(ref complex[,] a,
					int offs,
					int m,
					int n,
					ref int[] pivots,
					ref complex[] tmp)
			{
				int i = 0;
				int j = 0;
				int jp = 0;
				complex s = 0;
				int i_ = 0;
				int i1_ = 0;


				//
				// Quick return if possible
				//
				if (m == 0 || n == 0)
				{
					return;
				}

				//
				// main cycle
				//
				for (j = 0; j <= Math.Min(m - 1, n - 1); j++)
				{

					//
					// Find pivot, swap columns
					//
					jp = j;
					for (i = j + 1; i <= n - 1; i++)
					{
						if ((double)(math.abscomplex(a[offs + j, offs + i])) > (double)(math.abscomplex(a[offs + j, offs + jp])))
						{
							jp = i;
						}
					}
					pivots[offs + j] = offs + jp;
					if (jp != j)
					{
						i1_ = (offs) - (0);
						for (i_ = 0; i_ <= m - 1; i_++)
						{
							tmp[i_] = a[i_ + i1_, offs + j];
						}
						for (i_ = offs; i_ <= offs + m - 1; i_++)
						{
							a[i_, offs + j] = a[i_, offs + jp];
						}
						i1_ = (0) - (offs);
						for (i_ = offs; i_ <= offs + m - 1; i_++)
						{
							a[i_, offs + jp] = tmp[i_ + i1_];
						}
					}

					//
					// LU decomposition of 1x(N-J) matrix
					//
					if (a[offs + j, offs + j] != 0 && j + 1 <= n - 1)
					{
						s = 1 / a[offs + j, offs + j];
						for (i_ = offs + j + 1; i_ <= offs + n - 1; i_++)
						{
							a[offs + j, i_] = s * a[offs + j, i_];
						}
					}

					//
					// Update trailing (M-J-1)x(N-J-1) matrix
					//
					if (j < Math.Min(m - 1, n - 1))
					{
						i1_ = (offs + j + 1) - (0);
						for (i_ = 0; i_ <= m - j - 2; i_++)
						{
							tmp[i_] = a[i_ + i1_, offs + j];
						}
						i1_ = (offs + j + 1) - (m);
						for (i_ = m; i_ <= m + n - j - 2; i_++)
						{
							tmp[i_] = -a[offs + j, i_ + i1_];
						}
						ablas.cmatrixrank1(m - j - 1, n - j - 1, ref a, offs + j + 1, offs + j + 1, ref tmp, 0, ref tmp, m);
					}
				}
			}


			/*************************************************************************
			Real LUP kernel

				-- ALGLIB routine --
					 10.01.2010
					 Bochkanov Sergey
			*************************************************************************/
			private static void rmatrixlup2(ref double[,] a,
					int offs,
					int m,
					int n,
					ref int[] pivots,
					ref double[] tmp)
			{
				int i = 0;
				int j = 0;
				int jp = 0;
				double s = 0;
				int i_ = 0;
				int i1_ = 0;


				//
				// Quick return if possible
				//
				if (m == 0 || n == 0)
				{
					return;
				}

				//
				// main cycle
				//
				for (j = 0; j <= Math.Min(m - 1, n - 1); j++)
				{

					//
					// Find pivot, swap columns
					//
					jp = j;
					for (i = j + 1; i <= n - 1; i++)
					{
						if ((double)(Math.Abs(a[offs + j, offs + i])) > (double)(Math.Abs(a[offs + j, offs + jp])))
						{
							jp = i;
						}
					}
					pivots[offs + j] = offs + jp;
					if (jp != j)
					{
						i1_ = (offs) - (0);
						for (i_ = 0; i_ <= m - 1; i_++)
						{
							tmp[i_] = a[i_ + i1_, offs + j];
						}
						for (i_ = offs; i_ <= offs + m - 1; i_++)
						{
							a[i_, offs + j] = a[i_, offs + jp];
						}
						i1_ = (0) - (offs);
						for (i_ = offs; i_ <= offs + m - 1; i_++)
						{
							a[i_, offs + jp] = tmp[i_ + i1_];
						}
					}

					//
					// LU decomposition of 1x(N-J) matrix
					//
					if ((double)(a[offs + j, offs + j]) != (double)(0) && j + 1 <= n - 1)
					{
						s = 1 / a[offs + j, offs + j];
						for (i_ = offs + j + 1; i_ <= offs + n - 1; i_++)
						{
							a[offs + j, i_] = s * a[offs + j, i_];
						}
					}

					//
					// Update trailing (M-J-1)x(N-J-1) matrix
					//
					if (j < Math.Min(m - 1, n - 1))
					{
						i1_ = (offs + j + 1) - (0);
						for (i_ = 0; i_ <= m - j - 2; i_++)
						{
							tmp[i_] = a[i_ + i1_, offs + j];
						}
						i1_ = (offs + j + 1) - (m);
						for (i_ = m; i_ <= m + n - j - 2; i_++)
						{
							tmp[i_] = -a[offs + j, i_ + i1_];
						}
						ablas.rmatrixrank1(m - j - 1, n - j - 1, ref a, offs + j + 1, offs + j + 1, ref tmp, 0, ref tmp, m);
					}
				}
			}


			/*************************************************************************
			Complex PLU kernel

				-- LAPACK routine (version 3.0) --
					 Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
					 Courant Institute, Argonne National Lab, and Rice University
					 June 30, 1992
			*************************************************************************/
			private static void cmatrixplu2(ref complex[,] a,
					int offs,
					int m,
					int n,
					ref int[] pivots,
					ref complex[] tmp)
			{
				int i = 0;
				int j = 0;
				int jp = 0;
				complex s = 0;
				int i_ = 0;
				int i1_ = 0;


				//
				// Quick return if possible
				//
				if (m == 0 || n == 0)
				{
					return;
				}
				for (j = 0; j <= Math.Min(m - 1, n - 1); j++)
				{

					//
					// Find pivot and test for singularity.
					//
					jp = j;
					for (i = j + 1; i <= m - 1; i++)
					{
						if ((double)(math.abscomplex(a[offs + i, offs + j])) > (double)(math.abscomplex(a[offs + jp, offs + j])))
						{
							jp = i;
						}
					}
					pivots[offs + j] = offs + jp;
					if (a[offs + jp, offs + j] != 0)
					{

						//
						//Apply the interchange to rows
						//
						if (jp != j)
						{
							for (i = 0; i <= n - 1; i++)
							{
								s = a[offs + j, offs + i];
								a[offs + j, offs + i] = a[offs + jp, offs + i];
								a[offs + jp, offs + i] = s;
							}
						}

						//
						//Compute elements J+1:M of J-th column.
						//
						if (j + 1 <= m - 1)
						{
							s = 1 / a[offs + j, offs + j];
							for (i_ = offs + j + 1; i_ <= offs + m - 1; i_++)
							{
								a[i_, offs + j] = s * a[i_, offs + j];
							}
						}
					}
					if (j < Math.Min(m, n) - 1)
					{

						//
						//Update trailing submatrix.
						//
						i1_ = (offs + j + 1) - (0);
						for (i_ = 0; i_ <= m - j - 2; i_++)
						{
							tmp[i_] = a[i_ + i1_, offs + j];
						}
						i1_ = (offs + j + 1) - (m);
						for (i_ = m; i_ <= m + n - j - 2; i_++)
						{
							tmp[i_] = -a[offs + j, i_ + i1_];
						}
						ablas.cmatrixrank1(m - j - 1, n - j - 1, ref a, offs + j + 1, offs + j + 1, ref tmp, 0, ref tmp, m);
					}
				}
			}


			/*************************************************************************
			Real PLU kernel

				-- LAPACK routine (version 3.0) --
					 Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
					 Courant Institute, Argonne National Lab, and Rice University
					 June 30, 1992
			*************************************************************************/
			private static void rmatrixplu2(ref double[,] a,
					int offs,
					int m,
					int n,
					ref int[] pivots,
					ref double[] tmp)
			{
				int i = 0;
				int j = 0;
				int jp = 0;
				double s = 0;
				int i_ = 0;
				int i1_ = 0;


				//
				// Quick return if possible
				//
				if (m == 0 || n == 0)
				{
					return;
				}
				for (j = 0; j <= Math.Min(m - 1, n - 1); j++)
				{

					//
					// Find pivot and test for singularity.
					//
					jp = j;
					for (i = j + 1; i <= m - 1; i++)
					{
						if ((double)(Math.Abs(a[offs + i, offs + j])) > (double)(Math.Abs(a[offs + jp, offs + j])))
						{
							jp = i;
						}
					}
					pivots[offs + j] = offs + jp;
					if ((double)(a[offs + jp, offs + j]) != (double)(0))
					{

						//
						//Apply the interchange to rows
						//
						if (jp != j)
						{
							for (i = 0; i <= n - 1; i++)
							{
								s = a[offs + j, offs + i];
								a[offs + j, offs + i] = a[offs + jp, offs + i];
								a[offs + jp, offs + i] = s;
							}
						}

						//
						//Compute elements J+1:M of J-th column.
						//
						if (j + 1 <= m - 1)
						{
							s = 1 / a[offs + j, offs + j];
							for (i_ = offs + j + 1; i_ <= offs + m - 1; i_++)
							{
								a[i_, offs + j] = s * a[i_, offs + j];
							}
						}
					}
					if (j < Math.Min(m, n) - 1)
					{

						//
						//Update trailing submatrix.
						//
						i1_ = (offs + j + 1) - (0);
						for (i_ = 0; i_ <= m - j - 2; i_++)
						{
							tmp[i_] = a[i_ + i1_, offs + j];
						}
						i1_ = (offs + j + 1) - (m);
						for (i_ = m; i_ <= m + n - j - 2; i_++)
						{
							tmp[i_] = -a[offs + j, i_ + i1_];
						}
						ablas.rmatrixrank1(m - j - 1, n - j - 1, ref a, offs + j + 1, offs + j + 1, ref tmp, 0, ref tmp, m);
					}
				}
			}


			/*************************************************************************
			Recursive computational subroutine for HPDMatrixCholesky

				-- ALGLIB routine --
					 15.12.2009
					 Bochkanov Sergey
			*************************************************************************/
			private static bool hpdmatrixcholeskyrec(ref complex[,] a,
					int offs,
					int n,
					bool isupper,
					ref complex[] tmp)
			{
				bool result = new bool();
				int n1 = 0;
				int n2 = 0;


				//
				// check N
				//
				if (n < 1)
				{
					result = false;
					return result;
				}

				//
				// Prepare buffer
				//
				if (alglib.ap.len(tmp) < 2 * n)
				{
					tmp = new complex[2 * n];
				}

				//
				// special cases
				//
				if (n == 1)
				{
					if ((double)(a[offs, offs].x) > (double)(0))
					{
						a[offs, offs] = (double)Math.Sqrt(a[offs, offs].x);
						result = true;
					}
					else
					{
						result = false;
					}
					return result;
				}
				if (n <= ablas.ablascomplexblocksize(a))
				{
					result = hpdmatrixcholesky2(ref a, offs, n, isupper, ref tmp);
					return result;
				}

				//
				// general case: split task in cache-oblivious manner
				//
				result = true;
				ablas.ablascomplexsplitlength(a, n, ref n1, ref n2);
				result = hpdmatrixcholeskyrec(ref a, offs, n1, isupper, ref tmp);
				if (!result)
				{
					return result;
				}
				if (n2 > 0)
				{
					if (isupper)
					{
						ablas.cmatrixlefttrsm(n1, n2, a, offs, offs, isupper, false, 2, a, offs, offs + n1);
						ablas.cmatrixsyrk(n2, n1, -1.0f, a, offs, offs + n1, 2, 1.0f, a, offs + n1, offs + n1, isupper);
					}
					else
					{
						ablas.cmatrixrighttrsm(n2, n1, a, offs, offs, isupper, false, 2, a, offs + n1, offs);
						ablas.cmatrixsyrk(n2, n1, -1.0f, a, offs + n1, offs, 0, 1.0f, a, offs + n1, offs + n1, isupper);
					}
					result = hpdmatrixcholeskyrec(ref a, offs + n1, n2, isupper, ref tmp);
					if (!result)
					{
						return result;
					}
				}
				return result;
			}


			/*************************************************************************
			Level-2 Hermitian Cholesky subroutine.

				-- LAPACK routine (version 3.0) --
					 Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
					 Courant Institute, Argonne National Lab, and Rice University
					 February 29, 1992
			*************************************************************************/
			private static bool hpdmatrixcholesky2(ref complex[,] aaa,
					int offs,
					int n,
					bool isupper,
					ref complex[] tmp)
			{
				bool result = new bool();
				int i = 0;
				int j = 0;
				double ajj = 0;
				complex v = 0;
				double r = 0;
				int i_ = 0;
				int i1_ = 0;

				result = true;
				if (n < 0)
				{
					result = false;
					return result;
				}

				//
				// Quick return if possible
				//
				if (n == 0)
				{
					return result;
				}
				if (isupper)
				{

					//
					// Compute the Cholesky factorization A = U'*U.
					//
					for (j = 0; j <= n - 1; j++)
					{

						//
						// Compute U(J,J) and test for non-positive-definiteness.
						//
						v = 0.0f;
						for (i_ = offs; i_ <= offs + j - 1; i_++)
						{
							v += math.conj(aaa[i_, offs + j]) * aaa[i_, offs + j];
						}
						ajj = (aaa[offs + j, offs + j] - v).x;
						if ((double)(ajj) <= (double)(0))
						{
							aaa[offs + j, offs + j] = ajj;
							result = false;
							return result;
						}
						ajj = (double)Math.Sqrt(ajj);
						aaa[offs + j, offs + j] = ajj;

						//
						// Compute elements J+1:N-1 of row J.
						//
						if (j < n - 1)
						{
							if (j > 0)
							{
								i1_ = (offs) - (0);
								for (i_ = 0; i_ <= j - 1; i_++)
								{
									tmp[i_] = -math.conj(aaa[i_ + i1_, offs + j]);
								}
								ablas.cmatrixmv(n - j - 1, j, aaa, offs, offs + j + 1, 1, tmp, 0, ref tmp, n);
								i1_ = (n) - (offs + j + 1);
								for (i_ = offs + j + 1; i_ <= offs + n - 1; i_++)
								{
									aaa[offs + j, i_] = aaa[offs + j, i_] + tmp[i_ + i1_];
								}
							}
							r = 1 / ajj;
							for (i_ = offs + j + 1; i_ <= offs + n - 1; i_++)
							{
								aaa[offs + j, i_] = r * aaa[offs + j, i_];
							}
						}
					}
				}
				else
				{

					//
					// Compute the Cholesky factorization A = L*L'.
					//
					for (j = 0; j <= n - 1; j++)
					{

						//
						// Compute L(J+1,J+1) and test for non-positive-definiteness.
						//
						v = 0.0f;
						for (i_ = offs; i_ <= offs + j - 1; i_++)
						{
							v += math.conj(aaa[offs + j, i_]) * aaa[offs + j, i_];
						}
						ajj = (aaa[offs + j, offs + j] - v).x;
						if ((double)(ajj) <= (double)(0))
						{
							aaa[offs + j, offs + j] = ajj;
							result = false;
							return result;
						}
						ajj = (double)Math.Sqrt(ajj);
						aaa[offs + j, offs + j] = ajj;

						//
						// Compute elements J+1:N of column J.
						//
						if (j < n - 1)
						{
							if (j > 0)
							{
								i1_ = (offs) - (0);
								for (i_ = 0; i_ <= j - 1; i_++)
								{
									tmp[i_] = math.conj(aaa[offs + j, i_ + i1_]);
								}
								ablas.cmatrixmv(n - j - 1, j, aaa, offs + j + 1, offs, 0, tmp, 0, ref tmp, n);
								for (i = 0; i <= n - j - 2; i++)
								{
									aaa[offs + j + 1 + i, offs + j] = (aaa[offs + j + 1 + i, offs + j] - tmp[n + i]) / ajj;
								}
							}
							else
							{
								for (i = 0; i <= n - j - 2; i++)
								{
									aaa[offs + j + 1 + i, offs + j] = aaa[offs + j + 1 + i, offs + j] / ajj;
								}
							}
						}
					}
				}
				return result;
			}


			/*************************************************************************
			Level-2 Cholesky subroutine

				-- LAPACK routine (version 3.0) --
					 Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
					 Courant Institute, Argonne National Lab, and Rice University
					 February 29, 1992
			*************************************************************************/
			private static bool spdmatrixcholesky2(ref double[,] aaa,
					int offs,
					int n,
					bool isupper,
					ref double[] tmp)
			{
				bool result = new bool();
				int i = 0;
				int j = 0;
				double ajj = 0;
				double v = 0;
				double r = 0;
				int i_ = 0;
				int i1_ = 0;

				result = true;
				if (n < 0)
				{
					result = false;
					return result;
				}

				//
				// Quick return if possible
				//
				if (n == 0)
				{
					return result;
				}
				if (isupper)
				{

					//
					// Compute the Cholesky factorization A = U'*U.
					//
					for (j = 0; j <= n - 1; j++)
					{

						//
						// Compute U(J,J) and test for non-positive-definiteness.
						//
						v = 0.0f;
						for (i_ = offs; i_ <= offs + j - 1; i_++)
						{
							v += aaa[i_, offs + j] * aaa[i_, offs + j];
						}
						ajj = aaa[offs + j, offs + j] - v;
						if ((double)(ajj) <= (double)(0))
						{
							aaa[offs + j, offs + j] = ajj;
							result = false;
							return result;
						}
						ajj = (double)Math.Sqrt(ajj);
						aaa[offs + j, offs + j] = ajj;

						//
						// Compute elements J+1:N-1 of row J.
						//
						if (j < n - 1)
						{
							if (j > 0)
							{
								i1_ = (offs) - (0);
								for (i_ = 0; i_ <= j - 1; i_++)
								{
									tmp[i_] = -aaa[i_ + i1_, offs + j];
								}
								ablas.rmatrixmv(n - j - 1, j, aaa, offs, offs + j + 1, 1, tmp, 0, ref tmp, n);
								i1_ = (n) - (offs + j + 1);
								for (i_ = offs + j + 1; i_ <= offs + n - 1; i_++)
								{
									aaa[offs + j, i_] = aaa[offs + j, i_] + tmp[i_ + i1_];
								}
							}
							r = 1 / ajj;
							for (i_ = offs + j + 1; i_ <= offs + n - 1; i_++)
							{
								aaa[offs + j, i_] = r * aaa[offs + j, i_];
							}
						}
					}
				}
				else
				{

					//
					// Compute the Cholesky factorization A = L*L'.
					//
					for (j = 0; j <= n - 1; j++)
					{

						//
						// Compute L(J+1,J+1) and test for non-positive-definiteness.
						//
						v = 0.0f;
						for (i_ = offs; i_ <= offs + j - 1; i_++)
						{
							v += aaa[offs + j, i_] * aaa[offs + j, i_];
						}
						ajj = aaa[offs + j, offs + j] - v;
						if ((double)(ajj) <= (double)(0))
						{
							aaa[offs + j, offs + j] = ajj;
							result = false;
							return result;
						}
						ajj = (double)Math.Sqrt(ajj);
						aaa[offs + j, offs + j] = ajj;

						//
						// Compute elements J+1:N of column J.
						//
						if (j < n - 1)
						{
							if (j > 0)
							{
								i1_ = (offs) - (0);
								for (i_ = 0; i_ <= j - 1; i_++)
								{
									tmp[i_] = aaa[offs + j, i_ + i1_];
								}
								ablas.rmatrixmv(n - j - 1, j, aaa, offs + j + 1, offs, 0, tmp, 0, ref tmp, n);
								for (i = 0; i <= n - j - 2; i++)
								{
									aaa[offs + j + 1 + i, offs + j] = (aaa[offs + j + 1 + i, offs + j] - tmp[n + i]) / ajj;
								}
							}
							else
							{
								for (i = 0; i <= n - j - 2; i++)
								{
									aaa[offs + j + 1 + i, offs + j] = aaa[offs + j + 1 + i, offs + j] / ajj;
								}
							}
						}
					}
				}
				return result;
			}


		}
		public class rcond
		{
			/*************************************************************************
			Estimate of a matrix condition number (1-norm)

			The algorithm calculates a lower bound of the condition number. In this case,
			the algorithm does not return a lower bound of the condition number, but an
			inverse number (to avoid an overflow in case of a singular matrix).

			Input parameters:
					A   -   matrix. Array whose indexes range within [0..N-1, 0..N-1].
					N   -   size of matrix A.

			Result: 1/LowerBound(cond(A))

			NOTE:
					if k(A) is very large, then matrix is  assumed  degenerate,  k(A)=INF,
					0.0f is returned in such cases.
			*************************************************************************/
			public static double rmatrixrcond1(double[,] a,
					int n)
			{
				double result = 0;
				int i = 0;
				int j = 0;
				double v = 0;
				double nrm = 0;
				int[] pivots = new int[0];
				double[] t = new double[0];

				a = (double[,])a.Clone();

				alglib.ap.assert(n >= 1, "RMatrixRCond1: N<1!");
				t = new double[n];
				for (i = 0; i <= n - 1; i++)
				{
					t[i] = 0;
				}
				for (i = 0; i <= n - 1; i++)
				{
					for (j = 0; j <= n - 1; j++)
					{
						t[j] = t[j] + Math.Abs(a[i, j]);
					}
				}
				nrm = 0;
				for (i = 0; i <= n - 1; i++)
				{
					nrm = Math.Max(nrm, t[i]);
				}
				trfac.rmatrixlu(ref a, n, n, ref pivots);
				rmatrixrcondluinternal(a, n, true, true, nrm, ref v);
				result = v;
				return result;
			}


			/*************************************************************************
			Estimate of a matrix condition number (infinity-norm).

			The algorithm calculates a lower bound of the condition number. In this case,
			the algorithm does not return a lower bound of the condition number, but an
			inverse number (to avoid an overflow in case of a singular matrix).

			Input parameters:
					A   -   matrix. Array whose indexes range within [0..N-1, 0..N-1].
					N   -   size of matrix A.

			Result: 1/LowerBound(cond(A))

			NOTE:
					if k(A) is very large, then matrix is  assumed  degenerate,  k(A)=INF,
					0.0f is returned in such cases.
			*************************************************************************/
			public static double rmatrixrcondinf(double[,] a,
					int n)
			{
				double result = 0;
				int i = 0;
				int j = 0;
				double v = 0;
				double nrm = 0;
				int[] pivots = new int[0];

				a = (double[,])a.Clone();

				alglib.ap.assert(n >= 1, "RMatrixRCondInf: N<1!");
				nrm = 0;
				for (i = 0; i <= n - 1; i++)
				{
					v = 0;
					for (j = 0; j <= n - 1; j++)
					{
						v = v + Math.Abs(a[i, j]);
					}
					nrm = Math.Max(nrm, v);
				}
				trfac.rmatrixlu(ref a, n, n, ref pivots);
				rmatrixrcondluinternal(a, n, false, true, nrm, ref v);
				result = v;
				return result;
			}


			/*************************************************************************
			Condition number estimate of a symmetric positive definite matrix.

			The algorithm calculates a lower bound of the condition number. In this case,
			the algorithm does not return a lower bound of the condition number, but an
			inverse number (to avoid an overflow in case of a singular matrix).

			It should be noted that 1-norm and inf-norm of condition numbers of symmetric
			matrices are equal, so the algorithm doesn't take into account the
			differences between these types of norms.

			Input parameters:
					A       -   symmetric positive definite matrix which is given by its
											upper or lower triangle depending on the value of
											IsUpper. Array with elements [0..N-1, 0..N-1].
					N       -   size of matrix A.
					IsUpper -   storage format.

			Result:
					1/LowerBound(cond(A)), if matrix A is positive definite,
				 -1, if matrix A is not positive definite, and its condition number
					could not be found by this algorithm.

			NOTE:
					if k(A) is very large, then matrix is  assumed  degenerate,  k(A)=INF,
					0.0f is returned in such cases.
			*************************************************************************/
			public static double spdmatrixrcond(double[,] a,
					int n,
					bool isupper)
			{
				double result = 0;
				int i = 0;
				int j = 0;
				int j1 = 0;
				int j2 = 0;
				double v = 0;
				double nrm = 0;
				double[] t = new double[0];

				a = (double[,])a.Clone();

				t = new double[n];
				for (i = 0; i <= n - 1; i++)
				{
					t[i] = 0;
				}
				for (i = 0; i <= n - 1; i++)
				{
					if (isupper)
					{
						j1 = i;
						j2 = n - 1;
					}
					else
					{
						j1 = 0;
						j2 = i;
					}
					for (j = j1; j <= j2; j++)
					{
						if (i == j)
						{
							t[i] = t[i] + Math.Abs(a[i, i]);
						}
						else
						{
							t[i] = t[i] + Math.Abs(a[i, j]);
							t[j] = t[j] + Math.Abs(a[i, j]);
						}
					}
				}
				nrm = 0;
				for (i = 0; i <= n - 1; i++)
				{
					nrm = Math.Max(nrm, t[i]);
				}
				if (trfac.spdmatrixcholesky(ref a, n, isupper))
				{
					spdmatrixrcondcholeskyinternal(a, n, isupper, true, nrm, ref v);
					result = v;
				}
				else
				{
					result = -1;
				}
				return result;
			}


			/*************************************************************************
			Triangular matrix: estimate of a condition number (1-norm)

			The algorithm calculates a lower bound of the condition number. In this case,
			the algorithm does not return a lower bound of the condition number, but an
			inverse number (to avoid an overflow in case of a singular matrix).

			Input parameters:
					A       -   matrix. Array[0..N-1, 0..N-1].
					N       -   size of A.
					IsUpper -   True, if the matrix is upper triangular.
					IsUnit  -   True, if the matrix has a unit diagonal.

			Result: 1/LowerBound(cond(A))

			NOTE:
					if k(A) is very large, then matrix is  assumed  degenerate,  k(A)=INF,
					0.0f is returned in such cases.
			*************************************************************************/
			public static double rmatrixtrrcond1(double[,] a,
					int n,
					bool isupper,
					bool isunit)
			{
				double result = 0;
				int i = 0;
				int j = 0;
				double v = 0;
				double nrm = 0;
				int[] pivots = new int[0];
				double[] t = new double[0];
				int j1 = 0;
				int j2 = 0;

				alglib.ap.assert(n >= 1, "RMatrixTRRCond1: N<1!");
				t = new double[n];
				for (i = 0; i <= n - 1; i++)
				{
					t[i] = 0;
				}
				for (i = 0; i <= n - 1; i++)
				{
					if (isupper)
					{
						j1 = i + 1;
						j2 = n - 1;
					}
					else
					{
						j1 = 0;
						j2 = i - 1;
					}
					for (j = j1; j <= j2; j++)
					{
						t[j] = t[j] + Math.Abs(a[i, j]);
					}
					if (isunit)
					{
						t[i] = t[i] + 1;
					}
					else
					{
						t[i] = t[i] + Math.Abs(a[i, i]);
					}
				}
				nrm = 0;
				for (i = 0; i <= n - 1; i++)
				{
					nrm = Math.Max(nrm, t[i]);
				}
				rmatrixrcondtrinternal(a, n, isupper, isunit, true, nrm, ref v);
				result = v;
				return result;
			}


			/*************************************************************************
			Triangular matrix: estimate of a matrix condition number (infinity-norm).

			The algorithm calculates a lower bound of the condition number. In this case,
			the algorithm does not return a lower bound of the condition number, but an
			inverse number (to avoid an overflow in case of a singular matrix).

			Input parameters:
					A   -   matrix. Array whose indexes range within [0..N-1, 0..N-1].
					N   -   size of matrix A.
					IsUpper -   True, if the matrix is upper triangular.
					IsUnit  -   True, if the matrix has a unit diagonal.

			Result: 1/LowerBound(cond(A))

			NOTE:
					if k(A) is very large, then matrix is  assumed  degenerate,  k(A)=INF,
					0.0f is returned in such cases.
			*************************************************************************/
			public static double rmatrixtrrcondinf(double[,] a,
					int n,
					bool isupper,
					bool isunit)
			{
				double result = 0;
				int i = 0;
				int j = 0;
				double v = 0;
				double nrm = 0;
				int[] pivots = new int[0];
				int j1 = 0;
				int j2 = 0;

				alglib.ap.assert(n >= 1, "RMatrixTRRCondInf: N<1!");
				nrm = 0;
				for (i = 0; i <= n - 1; i++)
				{
					if (isupper)
					{
						j1 = i + 1;
						j2 = n - 1;
					}
					else
					{
						j1 = 0;
						j2 = i - 1;
					}
					v = 0;
					for (j = j1; j <= j2; j++)
					{
						v = v + Math.Abs(a[i, j]);
					}
					if (isunit)
					{
						v = v + 1;
					}
					else
					{
						v = v + Math.Abs(a[i, i]);
					}
					nrm = Math.Max(nrm, v);
				}
				rmatrixrcondtrinternal(a, n, isupper, isunit, false, nrm, ref v);
				result = v;
				return result;
			}


			/*************************************************************************
			Condition number estimate of a Hermitian positive definite matrix.

			The algorithm calculates a lower bound of the condition number. In this case,
			the algorithm does not return a lower bound of the condition number, but an
			inverse number (to avoid an overflow in case of a singular matrix).

			It should be noted that 1-norm and inf-norm of condition numbers of symmetric
			matrices are equal, so the algorithm doesn't take into account the
			differences between these types of norms.

			Input parameters:
					A       -   Hermitian positive definite matrix which is given by its
											upper or lower triangle depending on the value of
											IsUpper. Array with elements [0..N-1, 0..N-1].
					N       -   size of matrix A.
					IsUpper -   storage format.

			Result:
					1/LowerBound(cond(A)), if matrix A is positive definite,
				 -1, if matrix A is not positive definite, and its condition number
					could not be found by this algorithm.

			NOTE:
					if k(A) is very large, then matrix is  assumed  degenerate,  k(A)=INF,
					0.0f is returned in such cases.
			*************************************************************************/
			public static double hpdmatrixrcond(complex[,] a,
					int n,
					bool isupper)
			{
				double result = 0;
				int i = 0;
				int j = 0;
				int j1 = 0;
				int j2 = 0;
				double v = 0;
				double nrm = 0;
				double[] t = new double[0];

				a = (complex[,])a.Clone();

				t = new double[n];
				for (i = 0; i <= n - 1; i++)
				{
					t[i] = 0;
				}
				for (i = 0; i <= n - 1; i++)
				{
					if (isupper)
					{
						j1 = i;
						j2 = n - 1;
					}
					else
					{
						j1 = 0;
						j2 = i;
					}
					for (j = j1; j <= j2; j++)
					{
						if (i == j)
						{
							t[i] = t[i] + math.abscomplex(a[i, i]);
						}
						else
						{
							t[i] = t[i] + math.abscomplex(a[i, j]);
							t[j] = t[j] + math.abscomplex(a[i, j]);
						}
					}
				}
				nrm = 0;
				for (i = 0; i <= n - 1; i++)
				{
					nrm = Math.Max(nrm, t[i]);
				}
				if (trfac.hpdmatrixcholesky(ref a, n, isupper))
				{
					hpdmatrixrcondcholeskyinternal(a, n, isupper, true, nrm, ref v);
					result = v;
				}
				else
				{
					result = -1;
				}
				return result;
			}


			/*************************************************************************
			Estimate of a matrix condition number (1-norm)

			The algorithm calculates a lower bound of the condition number. In this case,
			the algorithm does not return a lower bound of the condition number, but an
			inverse number (to avoid an overflow in case of a singular matrix).

			Input parameters:
					A   -   matrix. Array whose indexes range within [0..N-1, 0..N-1].
					N   -   size of matrix A.

			Result: 1/LowerBound(cond(A))

			NOTE:
					if k(A) is very large, then matrix is  assumed  degenerate,  k(A)=INF,
					0.0f is returned in such cases.
			*************************************************************************/
			public static double cmatrixrcond1(complex[,] a,
					int n)
			{
				double result = 0;
				int i = 0;
				int j = 0;
				double v = 0;
				double nrm = 0;
				int[] pivots = new int[0];
				double[] t = new double[0];

				a = (complex[,])a.Clone();

				alglib.ap.assert(n >= 1, "CMatrixRCond1: N<1!");
				t = new double[n];
				for (i = 0; i <= n - 1; i++)
				{
					t[i] = 0;
				}
				for (i = 0; i <= n - 1; i++)
				{
					for (j = 0; j <= n - 1; j++)
					{
						t[j] = t[j] + math.abscomplex(a[i, j]);
					}
				}
				nrm = 0;
				for (i = 0; i <= n - 1; i++)
				{
					nrm = Math.Max(nrm, t[i]);
				}
				trfac.cmatrixlu(ref a, n, n, ref pivots);
				cmatrixrcondluinternal(a, n, true, true, nrm, ref v);
				result = v;
				return result;
			}


			/*************************************************************************
			Estimate of a matrix condition number (infinity-norm).

			The algorithm calculates a lower bound of the condition number. In this case,
			the algorithm does not return a lower bound of the condition number, but an
			inverse number (to avoid an overflow in case of a singular matrix).

			Input parameters:
					A   -   matrix. Array whose indexes range within [0..N-1, 0..N-1].
					N   -   size of matrix A.

			Result: 1/LowerBound(cond(A))

			NOTE:
					if k(A) is very large, then matrix is  assumed  degenerate,  k(A)=INF,
					0.0f is returned in such cases.
			*************************************************************************/
			public static double cmatrixrcondinf(complex[,] a,
					int n)
			{
				double result = 0;
				int i = 0;
				int j = 0;
				double v = 0;
				double nrm = 0;
				int[] pivots = new int[0];

				a = (complex[,])a.Clone();

				alglib.ap.assert(n >= 1, "CMatrixRCondInf: N<1!");
				nrm = 0;
				for (i = 0; i <= n - 1; i++)
				{
					v = 0;
					for (j = 0; j <= n - 1; j++)
					{
						v = v + math.abscomplex(a[i, j]);
					}
					nrm = Math.Max(nrm, v);
				}
				trfac.cmatrixlu(ref a, n, n, ref pivots);
				cmatrixrcondluinternal(a, n, false, true, nrm, ref v);
				result = v;
				return result;
			}


			/*************************************************************************
			Estimate of the condition number of a matrix given by its LU decomposition (1-norm)

			The algorithm calculates a lower bound of the condition number. In this case,
			the algorithm does not return a lower bound of the condition number, but an
			inverse number (to avoid an overflow in case of a singular matrix).

			Input parameters:
					LUA         -   LU decomposition of a matrix in compact form. Output of
													the RMatrixLU subroutine.
					N           -   size of matrix A.

			Result: 1/LowerBound(cond(A))

			NOTE:
					if k(A) is very large, then matrix is  assumed  degenerate,  k(A)=INF,
					0.0f is returned in such cases.
			*************************************************************************/
			public static double rmatrixlurcond1(double[,] lua,
					int n)
			{
				double result = 0;
				double v = 0;

				rmatrixrcondluinternal(lua, n, true, false, 0, ref v);
				result = v;
				return result;
			}


			/*************************************************************************
			Estimate of the condition number of a matrix given by its LU decomposition
			(infinity norm).

			The algorithm calculates a lower bound of the condition number. In this case,
			the algorithm does not return a lower bound of the condition number, but an
			inverse number (to avoid an overflow in case of a singular matrix).

			Input parameters:
					LUA     -   LU decomposition of a matrix in compact form. Output of
											the RMatrixLU subroutine.
					N       -   size of matrix A.

			Result: 1/LowerBound(cond(A))

			NOTE:
					if k(A) is very large, then matrix is  assumed  degenerate,  k(A)=INF,
					0.0f is returned in such cases.
			*************************************************************************/
			public static double rmatrixlurcondinf(double[,] lua,
					int n)
			{
				double result = 0;
				double v = 0;

				rmatrixrcondluinternal(lua, n, false, false, 0, ref v);
				result = v;
				return result;
			}


			/*************************************************************************
			Condition number estimate of a symmetric positive definite matrix given by
			Cholesky decomposition.

			The algorithm calculates a lower bound of the condition number. In this
			case, the algorithm does not return a lower bound of the condition number,
			but an inverse number (to avoid an overflow in case of a singular matrix).

			It should be noted that 1-norm and inf-norm condition numbers of symmetric
			matrices are equal, so the algorithm doesn't take into account the
			differences between these types of norms.

			Input parameters:
					CD  - Cholesky decomposition of matrix A,
								output of SMatrixCholesky subroutine.
					N   - size of matrix A.

			Result: 1/LowerBound(cond(A))

			NOTE:
					if k(A) is very large, then matrix is  assumed  degenerate,  k(A)=INF,
					0.0f is returned in such cases.
			*************************************************************************/
			public static double spdmatrixcholeskyrcond(double[,] a,
					int n,
					bool isupper)
			{
				double result = 0;
				double v = 0;

				spdmatrixrcondcholeskyinternal(a, n, isupper, false, 0, ref v);
				result = v;
				return result;
			}


			/*************************************************************************
			Condition number estimate of a Hermitian positive definite matrix given by
			Cholesky decomposition.

			The algorithm calculates a lower bound of the condition number. In this
			case, the algorithm does not return a lower bound of the condition number,
			but an inverse number (to avoid an overflow in case of a singular matrix).

			It should be noted that 1-norm and inf-norm condition numbers of symmetric
			matrices are equal, so the algorithm doesn't take into account the
			differences between these types of norms.

			Input parameters:
					CD  - Cholesky decomposition of matrix A,
								output of SMatrixCholesky subroutine.
					N   - size of matrix A.

			Result: 1/LowerBound(cond(A))

			NOTE:
					if k(A) is very large, then matrix is  assumed  degenerate,  k(A)=INF,
					0.0f is returned in such cases.
			*************************************************************************/
			public static double hpdmatrixcholeskyrcond(complex[,] a,
					int n,
					bool isupper)
			{
				double result = 0;
				double v = 0;

				hpdmatrixrcondcholeskyinternal(a, n, isupper, false, 0, ref v);
				result = v;
				return result;
			}


			/*************************************************************************
			Estimate of the condition number of a matrix given by its LU decomposition (1-norm)

			The algorithm calculates a lower bound of the condition number. In this case,
			the algorithm does not return a lower bound of the condition number, but an
			inverse number (to avoid an overflow in case of a singular matrix).

			Input parameters:
					LUA         -   LU decomposition of a matrix in compact form. Output of
													the CMatrixLU subroutine.
					N           -   size of matrix A.

			Result: 1/LowerBound(cond(A))

			NOTE:
					if k(A) is very large, then matrix is  assumed  degenerate,  k(A)=INF,
					0.0f is returned in such cases.
			*************************************************************************/
			public static double cmatrixlurcond1(complex[,] lua,
					int n)
			{
				double result = 0;
				double v = 0;

				alglib.ap.assert(n >= 1, "CMatrixLURCond1: N<1!");
				cmatrixrcondluinternal(lua, n, true, false, 0.0f, ref v);
				result = v;
				return result;
			}


			/*************************************************************************
			Estimate of the condition number of a matrix given by its LU decomposition
			(infinity norm).

			The algorithm calculates a lower bound of the condition number. In this case,
			the algorithm does not return a lower bound of the condition number, but an
			inverse number (to avoid an overflow in case of a singular matrix).

			Input parameters:
					LUA     -   LU decomposition of a matrix in compact form. Output of
											the CMatrixLU subroutine.
					N       -   size of matrix A.

			Result: 1/LowerBound(cond(A))

			NOTE:
					if k(A) is very large, then matrix is  assumed  degenerate,  k(A)=INF,
					0.0f is returned in such cases.
			*************************************************************************/
			public static double cmatrixlurcondinf(complex[,] lua,
					int n)
			{
				double result = 0;
				double v = 0;

				alglib.ap.assert(n >= 1, "CMatrixLURCondInf: N<1!");
				cmatrixrcondluinternal(lua, n, false, false, 0.0f, ref v);
				result = v;
				return result;
			}


			/*************************************************************************
			Triangular matrix: estimate of a condition number (1-norm)

			The algorithm calculates a lower bound of the condition number. In this case,
			the algorithm does not return a lower bound of the condition number, but an
			inverse number (to avoid an overflow in case of a singular matrix).

			Input parameters:
					A       -   matrix. Array[0..N-1, 0..N-1].
					N       -   size of A.
					IsUpper -   True, if the matrix is upper triangular.
					IsUnit  -   True, if the matrix has a unit diagonal.

			Result: 1/LowerBound(cond(A))

			NOTE:
					if k(A) is very large, then matrix is  assumed  degenerate,  k(A)=INF,
					0.0f is returned in such cases.
			*************************************************************************/
			public static double cmatrixtrrcond1(complex[,] a,
					int n,
					bool isupper,
					bool isunit)
			{
				double result = 0;
				int i = 0;
				int j = 0;
				double v = 0;
				double nrm = 0;
				int[] pivots = new int[0];
				double[] t = new double[0];
				int j1 = 0;
				int j2 = 0;

				alglib.ap.assert(n >= 1, "RMatrixTRRCond1: N<1!");
				t = new double[n];
				for (i = 0; i <= n - 1; i++)
				{
					t[i] = 0;
				}
				for (i = 0; i <= n - 1; i++)
				{
					if (isupper)
					{
						j1 = i + 1;
						j2 = n - 1;
					}
					else
					{
						j1 = 0;
						j2 = i - 1;
					}
					for (j = j1; j <= j2; j++)
					{
						t[j] = t[j] + math.abscomplex(a[i, j]);
					}
					if (isunit)
					{
						t[i] = t[i] + 1;
					}
					else
					{
						t[i] = t[i] + math.abscomplex(a[i, i]);
					}
				}
				nrm = 0;
				for (i = 0; i <= n - 1; i++)
				{
					nrm = Math.Max(nrm, t[i]);
				}
				cmatrixrcondtrinternal(a, n, isupper, isunit, true, nrm, ref v);
				result = v;
				return result;
			}


			/*************************************************************************
			Triangular matrix: estimate of a matrix condition number (infinity-norm).

			The algorithm calculates a lower bound of the condition number. In this case,
			the algorithm does not return a lower bound of the condition number, but an
			inverse number (to avoid an overflow in case of a singular matrix).

			Input parameters:
					A   -   matrix. Array whose indexes range within [0..N-1, 0..N-1].
					N   -   size of matrix A.
					IsUpper -   True, if the matrix is upper triangular.
					IsUnit  -   True, if the matrix has a unit diagonal.

			Result: 1/LowerBound(cond(A))

			NOTE:
					if k(A) is very large, then matrix is  assumed  degenerate,  k(A)=INF,
					0.0f is returned in such cases.
			*************************************************************************/
			public static double cmatrixtrrcondinf(complex[,] a,
					int n,
					bool isupper,
					bool isunit)
			{
				double result = 0;
				int i = 0;
				int j = 0;
				double v = 0;
				double nrm = 0;
				int[] pivots = new int[0];
				int j1 = 0;
				int j2 = 0;

				alglib.ap.assert(n >= 1, "RMatrixTRRCondInf: N<1!");
				nrm = 0;
				for (i = 0; i <= n - 1; i++)
				{
					if (isupper)
					{
						j1 = i + 1;
						j2 = n - 1;
					}
					else
					{
						j1 = 0;
						j2 = i - 1;
					}
					v = 0;
					for (j = j1; j <= j2; j++)
					{
						v = v + math.abscomplex(a[i, j]);
					}
					if (isunit)
					{
						v = v + 1;
					}
					else
					{
						v = v + math.abscomplex(a[i, i]);
					}
					nrm = Math.Max(nrm, v);
				}
				cmatrixrcondtrinternal(a, n, isupper, isunit, false, nrm, ref v);
				result = v;
				return result;
			}


			/*************************************************************************
			Threshold for rcond: matrices with condition number beyond this  threshold
			are considered singular.

			Threshold must be far enough from underflow, at least Sqr(Threshold)  must
			be greater than underflow.
			*************************************************************************/
			public static double rcondthreshold()
			{
				double result = 0;

				result = (double)Math.Sqrt(Math.Sqrt(math.minrealnumber));
				return result;
			}


			/*************************************************************************
			Internal subroutine for condition number estimation

				-- LAPACK routine (version 3.0) --
					 Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
					 Courant Institute, Argonne National Lab, and Rice University
					 February 29, 1992
			*************************************************************************/
			private static void rmatrixrcondtrinternal(double[,] a,
					int n,
					bool isupper,
					bool isunit,
					bool onenorm,
					double anorm,
					ref double rc)
			{
				double[] ex = new double[0];
				double[] ev = new double[0];
				int[] iwork = new int[0];
				double[] tmp = new double[0];
				int i = 0;
				int j = 0;
				int kase = 0;
				int kase1 = 0;
				int j1 = 0;
				int j2 = 0;
				double ainvnm = 0;
				double maxgrowth = 0;
				double s = 0;

				rc = 0;


				//
				// RC=0 if something happens
				//
				rc = 0;

				//
				// init
				//
				if (onenorm)
				{
					kase1 = 1;
				}
				else
				{
					kase1 = 2;
				}
				iwork = new int[n + 1];
				tmp = new double[n];

				//
				// prepare parameters for triangular solver
				//
				maxgrowth = 1 / rcondthreshold();
				s = 0;
				for (i = 0; i <= n - 1; i++)
				{
					if (isupper)
					{
						j1 = i + 1;
						j2 = n - 1;
					}
					else
					{
						j1 = 0;
						j2 = i - 1;
					}
					for (j = j1; j <= j2; j++)
					{
						s = Math.Max(s, Math.Abs(a[i, j]));
					}
					if (isunit)
					{
						s = Math.Max(s, 1);
					}
					else
					{
						s = Math.Max(s, Math.Abs(a[i, i]));
					}
				}
				if ((double)(s) == (double)(0))
				{
					s = 1;
				}
				s = 1 / s;

				//
				// Scale according to S
				//
				anorm = anorm * s;

				//
				// Quick return if possible
				// We assume that ANORM<>0 after this block
				//
				if ((double)(anorm) == (double)(0))
				{
					return;
				}
				if (n == 1)
				{
					rc = 1;
					return;
				}

				//
				// Estimate the norm of inv(A).
				//
				ainvnm = 0;
				kase = 0;
				while (true)
				{
					rmatrixestimatenorm(n, ref ev, ref ex, ref iwork, ref ainvnm, ref kase);
					if (kase == 0)
					{
						break;
					}

					//
					// from 1-based array to 0-based
					//
					for (i = 0; i <= n - 1; i++)
					{
						ex[i] = ex[i + 1];
					}

					//
					// multiply by inv(A) or inv(A')
					//
					if (kase == kase1)
					{

						//
						// multiply by inv(A)
						//
						if (!safesolve.rmatrixscaledtrsafesolve(a, s, n, ref ex, isupper, 0, isunit, maxgrowth))
						{
							return;
						}
					}
					else
					{

						//
						// multiply by inv(A')
						//
						if (!safesolve.rmatrixscaledtrsafesolve(a, s, n, ref ex, isupper, 1, isunit, maxgrowth))
						{
							return;
						}
					}

					//
					// from 0-based array to 1-based
					//
					for (i = n - 1; i >= 0; i--)
					{
						ex[i + 1] = ex[i];
					}
				}

				//
				// Compute the estimate of the reciprocal condition number.
				//
				if ((double)(ainvnm) != (double)(0))
				{
					rc = 1 / ainvnm;
					rc = rc / anorm;
					if ((double)(rc) < (double)(rcondthreshold()))
					{
						rc = 0;
					}
				}
			}


			/*************************************************************************
			Condition number estimation

				-- LAPACK routine (version 3.0) --
					 Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
					 Courant Institute, Argonne National Lab, and Rice University
					 March 31, 1993
			*************************************************************************/
			private static void cmatrixrcondtrinternal(complex[,] a,
					int n,
					bool isupper,
					bool isunit,
					bool onenorm,
					double anorm,
					ref double rc)
			{
				complex[] ex = new complex[0];
				complex[] cwork2 = new complex[0];
				complex[] cwork3 = new complex[0];
				complex[] cwork4 = new complex[0];
				int[] isave = new int[0];
				double[] rsave = new double[0];
				int kase = 0;
				int kase1 = 0;
				double ainvnm = 0;
				int i = 0;
				int j = 0;
				int j1 = 0;
				int j2 = 0;
				double s = 0;
				double maxgrowth = 0;

				rc = 0;


				//
				// RC=0 if something happens
				//
				rc = 0;

				//
				// init
				//
				if (n <= 0)
				{
					return;
				}
				if (n == 0)
				{
					rc = 1;
					return;
				}
				cwork2 = new complex[n + 1];

				//
				// prepare parameters for triangular solver
				//
				maxgrowth = 1 / rcondthreshold();
				s = 0;
				for (i = 0; i <= n - 1; i++)
				{
					if (isupper)
					{
						j1 = i + 1;
						j2 = n - 1;
					}
					else
					{
						j1 = 0;
						j2 = i - 1;
					}
					for (j = j1; j <= j2; j++)
					{
						s = Math.Max(s, math.abscomplex(a[i, j]));
					}
					if (isunit)
					{
						s = Math.Max(s, 1);
					}
					else
					{
						s = Math.Max(s, math.abscomplex(a[i, i]));
					}
				}
				if ((double)(s) == (double)(0))
				{
					s = 1;
				}
				s = 1 / s;

				//
				// Scale according to S
				//
				anorm = anorm * s;

				//
				// Quick return if possible
				//
				if ((double)(anorm) == (double)(0))
				{
					return;
				}

				//
				// Estimate the norm of inv(A).
				//
				ainvnm = 0;
				if (onenorm)
				{
					kase1 = 1;
				}
				else
				{
					kase1 = 2;
				}
				kase = 0;
				while (true)
				{
					cmatrixestimatenorm(n, ref cwork4, ref ex, ref ainvnm, ref kase, ref isave, ref rsave);
					if (kase == 0)
					{
						break;
					}

					//
					// From 1-based to 0-based
					//
					for (i = 0; i <= n - 1; i++)
					{
						ex[i] = ex[i + 1];
					}

					//
					// multiply by inv(A) or inv(A')
					//
					if (kase == kase1)
					{

						//
						// multiply by inv(A)
						//
						if (!safesolve.cmatrixscaledtrsafesolve(a, s, n, ref ex, isupper, 0, isunit, maxgrowth))
						{
							return;
						}
					}
					else
					{

						//
						// multiply by inv(A')
						//
						if (!safesolve.cmatrixscaledtrsafesolve(a, s, n, ref ex, isupper, 2, isunit, maxgrowth))
						{
							return;
						}
					}

					//
					// from 0-based to 1-based
					//
					for (i = n - 1; i >= 0; i--)
					{
						ex[i + 1] = ex[i];
					}
				}

				//
				// Compute the estimate of the reciprocal condition number.
				//
				if ((double)(ainvnm) != (double)(0))
				{
					rc = 1 / ainvnm;
					rc = rc / anorm;
					if ((double)(rc) < (double)(rcondthreshold()))
					{
						rc = 0;
					}
				}
			}


			/*************************************************************************
			Internal subroutine for condition number estimation

				-- LAPACK routine (version 3.0) --
					 Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
					 Courant Institute, Argonne National Lab, and Rice University
					 February 29, 1992
			*************************************************************************/
			private static void spdmatrixrcondcholeskyinternal(double[,] cha,
					int n,
					bool isupper,
					bool isnormprovided,
					double anorm,
					ref double rc)
			{
				int i = 0;
				int j = 0;
				int kase = 0;
				double ainvnm = 0;
				double[] ex = new double[0];
				double[] ev = new double[0];
				double[] tmp = new double[0];
				int[] iwork = new int[0];
				double sa = 0;
				double v = 0;
				double maxgrowth = 0;
				int i_ = 0;
				int i1_ = 0;

				rc = 0;

				alglib.ap.assert(n >= 1);
				tmp = new double[n];

				//
				// RC=0 if something happens
				//
				rc = 0;

				//
				// prepare parameters for triangular solver
				//
				maxgrowth = 1 / rcondthreshold();
				sa = 0;
				if (isupper)
				{
					for (i = 0; i <= n - 1; i++)
					{
						for (j = i; j <= n - 1; j++)
						{
							sa = Math.Max(sa, math.abscomplex(cha[i, j]));
						}
					}
				}
				else
				{
					for (i = 0; i <= n - 1; i++)
					{
						for (j = 0; j <= i; j++)
						{
							sa = Math.Max(sa, math.abscomplex(cha[i, j]));
						}
					}
				}
				if ((double)(sa) == (double)(0))
				{
					sa = 1;
				}
				sa = 1 / sa;

				//
				// Estimate the norm of A.
				//
				if (!isnormprovided)
				{
					kase = 0;
					anorm = 0;
					while (true)
					{
						rmatrixestimatenorm(n, ref ev, ref ex, ref iwork, ref anorm, ref kase);
						if (kase == 0)
						{
							break;
						}
						if (isupper)
						{

							//
							// Multiply by U
							//
							for (i = 1; i <= n; i++)
							{
								i1_ = (i) - (i - 1);
								v = 0.0f;
								for (i_ = i - 1; i_ <= n - 1; i_++)
								{
									v += cha[i - 1, i_] * ex[i_ + i1_];
								}
								ex[i] = v;
							}
							for (i_ = 1; i_ <= n; i_++)
							{
								ex[i_] = sa * ex[i_];
							}

							//
							// Multiply by U'
							//
							for (i = 0; i <= n - 1; i++)
							{
								tmp[i] = 0;
							}
							for (i = 0; i <= n - 1; i++)
							{
								v = ex[i + 1];
								for (i_ = i; i_ <= n - 1; i_++)
								{
									tmp[i_] = tmp[i_] + v * cha[i, i_];
								}
							}
							i1_ = (0) - (1);
							for (i_ = 1; i_ <= n; i_++)
							{
								ex[i_] = tmp[i_ + i1_];
							}
							for (i_ = 1; i_ <= n; i_++)
							{
								ex[i_] = sa * ex[i_];
							}
						}
						else
						{

							//
							// Multiply by L'
							//
							for (i = 0; i <= n - 1; i++)
							{
								tmp[i] = 0;
							}
							for (i = 0; i <= n - 1; i++)
							{
								v = ex[i + 1];
								for (i_ = 0; i_ <= i; i_++)
								{
									tmp[i_] = tmp[i_] + v * cha[i, i_];
								}
							}
							i1_ = (0) - (1);
							for (i_ = 1; i_ <= n; i_++)
							{
								ex[i_] = tmp[i_ + i1_];
							}
							for (i_ = 1; i_ <= n; i_++)
							{
								ex[i_] = sa * ex[i_];
							}

							//
							// Multiply by L
							//
							for (i = n; i >= 1; i--)
							{
								i1_ = (1) - (0);
								v = 0.0f;
								for (i_ = 0; i_ <= i - 1; i_++)
								{
									v += cha[i - 1, i_] * ex[i_ + i1_];
								}
								ex[i] = v;
							}
							for (i_ = 1; i_ <= n; i_++)
							{
								ex[i_] = sa * ex[i_];
							}
						}
					}
				}

				//
				// Quick return if possible
				//
				if ((double)(anorm) == (double)(0))
				{
					return;
				}
				if (n == 1)
				{
					rc = 1;
					return;
				}

				//
				// Estimate the 1-norm of inv(A).
				//
				kase = 0;
				while (true)
				{
					rmatrixestimatenorm(n, ref ev, ref ex, ref iwork, ref ainvnm, ref kase);
					if (kase == 0)
					{
						break;
					}
					for (i = 0; i <= n - 1; i++)
					{
						ex[i] = ex[i + 1];
					}
					if (isupper)
					{

						//
						// Multiply by inv(U').
						//
						if (!safesolve.rmatrixscaledtrsafesolve(cha, sa, n, ref ex, isupper, 1, false, maxgrowth))
						{
							return;
						}

						//
						// Multiply by inv(U).
						//
						if (!safesolve.rmatrixscaledtrsafesolve(cha, sa, n, ref ex, isupper, 0, false, maxgrowth))
						{
							return;
						}
					}
					else
					{

						//
						// Multiply by inv(L).
						//
						if (!safesolve.rmatrixscaledtrsafesolve(cha, sa, n, ref ex, isupper, 0, false, maxgrowth))
						{
							return;
						}

						//
						// Multiply by inv(L').
						//
						if (!safesolve.rmatrixscaledtrsafesolve(cha, sa, n, ref ex, isupper, 1, false, maxgrowth))
						{
							return;
						}
					}
					for (i = n - 1; i >= 0; i--)
					{
						ex[i + 1] = ex[i];
					}
				}

				//
				// Compute the estimate of the reciprocal condition number.
				//
				if ((double)(ainvnm) != (double)(0))
				{
					v = 1 / ainvnm;
					rc = v / anorm;
					if ((double)(rc) < (double)(rcondthreshold()))
					{
						rc = 0;
					}
				}
			}


			/*************************************************************************
			Internal subroutine for condition number estimation

				-- LAPACK routine (version 3.0) --
					 Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
					 Courant Institute, Argonne National Lab, and Rice University
					 February 29, 1992
			*************************************************************************/
			private static void hpdmatrixrcondcholeskyinternal(complex[,] cha,
					int n,
					bool isupper,
					bool isnormprovided,
					double anorm,
					ref double rc)
			{
				int[] isave = new int[0];
				double[] rsave = new double[0];
				complex[] ex = new complex[0];
				complex[] ev = new complex[0];
				complex[] tmp = new complex[0];
				int kase = 0;
				double ainvnm = 0;
				complex v = 0;
				int i = 0;
				int j = 0;
				double sa = 0;
				double maxgrowth = 0;
				int i_ = 0;
				int i1_ = 0;

				rc = 0;

				alglib.ap.assert(n >= 1);
				tmp = new complex[n];

				//
				// RC=0 if something happens
				//
				rc = 0;

				//
				// prepare parameters for triangular solver
				//
				maxgrowth = 1 / rcondthreshold();
				sa = 0;
				if (isupper)
				{
					for (i = 0; i <= n - 1; i++)
					{
						for (j = i; j <= n - 1; j++)
						{
							sa = Math.Max(sa, math.abscomplex(cha[i, j]));
						}
					}
				}
				else
				{
					for (i = 0; i <= n - 1; i++)
					{
						for (j = 0; j <= i; j++)
						{
							sa = Math.Max(sa, math.abscomplex(cha[i, j]));
						}
					}
				}
				if ((double)(sa) == (double)(0))
				{
					sa = 1;
				}
				sa = 1 / sa;

				//
				// Estimate the norm of A
				//
				if (!isnormprovided)
				{
					anorm = 0;
					kase = 0;
					while (true)
					{
						cmatrixestimatenorm(n, ref ev, ref ex, ref anorm, ref kase, ref isave, ref rsave);
						if (kase == 0)
						{
							break;
						}
						if (isupper)
						{

							//
							// Multiply by U
							//
							for (i = 1; i <= n; i++)
							{
								i1_ = (i) - (i - 1);
								v = 0.0f;
								for (i_ = i - 1; i_ <= n - 1; i_++)
								{
									v += cha[i - 1, i_] * ex[i_ + i1_];
								}
								ex[i] = v;
							}
							for (i_ = 1; i_ <= n; i_++)
							{
								ex[i_] = sa * ex[i_];
							}

							//
							// Multiply by U'
							//
							for (i = 0; i <= n - 1; i++)
							{
								tmp[i] = 0;
							}
							for (i = 0; i <= n - 1; i++)
							{
								v = ex[i + 1];
								for (i_ = i; i_ <= n - 1; i_++)
								{
									tmp[i_] = tmp[i_] + v * math.conj(cha[i, i_]);
								}
							}
							i1_ = (0) - (1);
							for (i_ = 1; i_ <= n; i_++)
							{
								ex[i_] = tmp[i_ + i1_];
							}
							for (i_ = 1; i_ <= n; i_++)
							{
								ex[i_] = sa * ex[i_];
							}
						}
						else
						{

							//
							// Multiply by L'
							//
							for (i = 0; i <= n - 1; i++)
							{
								tmp[i] = 0;
							}
							for (i = 0; i <= n - 1; i++)
							{
								v = ex[i + 1];
								for (i_ = 0; i_ <= i; i_++)
								{
									tmp[i_] = tmp[i_] + v * math.conj(cha[i, i_]);
								}
							}
							i1_ = (0) - (1);
							for (i_ = 1; i_ <= n; i_++)
							{
								ex[i_] = tmp[i_ + i1_];
							}
							for (i_ = 1; i_ <= n; i_++)
							{
								ex[i_] = sa * ex[i_];
							}

							//
							// Multiply by L
							//
							for (i = n; i >= 1; i--)
							{
								i1_ = (1) - (0);
								v = 0.0f;
								for (i_ = 0; i_ <= i - 1; i_++)
								{
									v += cha[i - 1, i_] * ex[i_ + i1_];
								}
								ex[i] = v;
							}
							for (i_ = 1; i_ <= n; i_++)
							{
								ex[i_] = sa * ex[i_];
							}
						}
					}
				}

				//
				// Quick return if possible
				// After this block we assume that ANORM<>0
				//
				if ((double)(anorm) == (double)(0))
				{
					return;
				}
				if (n == 1)
				{
					rc = 1;
					return;
				}

				//
				// Estimate the norm of inv(A).
				//
				ainvnm = 0;
				kase = 0;
				while (true)
				{
					cmatrixestimatenorm(n, ref ev, ref ex, ref ainvnm, ref kase, ref isave, ref rsave);
					if (kase == 0)
					{
						break;
					}
					for (i = 0; i <= n - 1; i++)
					{
						ex[i] = ex[i + 1];
					}
					if (isupper)
					{

						//
						// Multiply by inv(U').
						//
						if (!safesolve.cmatrixscaledtrsafesolve(cha, sa, n, ref ex, isupper, 2, false, maxgrowth))
						{
							return;
						}

						//
						// Multiply by inv(U).
						//
						if (!safesolve.cmatrixscaledtrsafesolve(cha, sa, n, ref ex, isupper, 0, false, maxgrowth))
						{
							return;
						}
					}
					else
					{

						//
						// Multiply by inv(L).
						//
						if (!safesolve.cmatrixscaledtrsafesolve(cha, sa, n, ref ex, isupper, 0, false, maxgrowth))
						{
							return;
						}

						//
						// Multiply by inv(L').
						//
						if (!safesolve.cmatrixscaledtrsafesolve(cha, sa, n, ref ex, isupper, 2, false, maxgrowth))
						{
							return;
						}
					}
					for (i = n - 1; i >= 0; i--)
					{
						ex[i + 1] = ex[i];
					}
				}

				//
				// Compute the estimate of the reciprocal condition number.
				//
				if ((double)(ainvnm) != (double)(0))
				{
					rc = 1 / ainvnm;
					rc = rc / anorm;
					if ((double)(rc) < (double)(rcondthreshold()))
					{
						rc = 0;
					}
				}
			}


			/*************************************************************************
			Internal subroutine for condition number estimation

				-- LAPACK routine (version 3.0) --
					 Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
					 Courant Institute, Argonne National Lab, and Rice University
					 February 29, 1992
			*************************************************************************/
			private static void rmatrixrcondluinternal(double[,] lua,
					int n,
					bool onenorm,
					bool isanormprovided,
					double anorm,
					ref double rc)
			{
				double[] ex = new double[0];
				double[] ev = new double[0];
				int[] iwork = new int[0];
				double[] tmp = new double[0];
				double v = 0;
				int i = 0;
				int j = 0;
				int kase = 0;
				int kase1 = 0;
				double ainvnm = 0;
				double maxgrowth = 0;
				double su = 0;
				double sl = 0;
				bool mupper = new bool();
				bool munit = new bool();
				int i_ = 0;
				int i1_ = 0;

				rc = 0;


				//
				// RC=0 if something happens
				//
				rc = 0;

				//
				// init
				//
				if (onenorm)
				{
					kase1 = 1;
				}
				else
				{
					kase1 = 2;
				}
				mupper = true;
				munit = true;
				iwork = new int[n + 1];
				tmp = new double[n];

				//
				// prepare parameters for triangular solver
				//
				maxgrowth = 1 / rcondthreshold();
				su = 0;
				sl = 1;
				for (i = 0; i <= n - 1; i++)
				{
					for (j = 0; j <= i - 1; j++)
					{
						sl = Math.Max(sl, Math.Abs(lua[i, j]));
					}
					for (j = i; j <= n - 1; j++)
					{
						su = Math.Max(su, Math.Abs(lua[i, j]));
					}
				}
				if ((double)(su) == (double)(0))
				{
					su = 1;
				}
				su = 1 / su;
				sl = 1 / sl;

				//
				// Estimate the norm of A.
				//
				if (!isanormprovided)
				{
					kase = 0;
					anorm = 0;
					while (true)
					{
						rmatrixestimatenorm(n, ref ev, ref ex, ref iwork, ref anorm, ref kase);
						if (kase == 0)
						{
							break;
						}
						if (kase == kase1)
						{

							//
							// Multiply by U
							//
							for (i = 1; i <= n; i++)
							{
								i1_ = (i) - (i - 1);
								v = 0.0f;
								for (i_ = i - 1; i_ <= n - 1; i_++)
								{
									v += lua[i - 1, i_] * ex[i_ + i1_];
								}
								ex[i] = v;
							}

							//
							// Multiply by L
							//
							for (i = n; i >= 1; i--)
							{
								if (i > 1)
								{
									i1_ = (1) - (0);
									v = 0.0f;
									for (i_ = 0; i_ <= i - 2; i_++)
									{
										v += lua[i - 1, i_] * ex[i_ + i1_];
									}
								}
								else
								{
									v = 0;
								}
								ex[i] = ex[i] + v;
							}
						}
						else
						{

							//
							// Multiply by L'
							//
							for (i = 0; i <= n - 1; i++)
							{
								tmp[i] = 0;
							}
							for (i = 0; i <= n - 1; i++)
							{
								v = ex[i + 1];
								if (i >= 1)
								{
									for (i_ = 0; i_ <= i - 1; i_++)
									{
										tmp[i_] = tmp[i_] + v * lua[i, i_];
									}
								}
								tmp[i] = tmp[i] + v;
							}
							i1_ = (0) - (1);
							for (i_ = 1; i_ <= n; i_++)
							{
								ex[i_] = tmp[i_ + i1_];
							}

							//
							// Multiply by U'
							//
							for (i = 0; i <= n - 1; i++)
							{
								tmp[i] = 0;
							}
							for (i = 0; i <= n - 1; i++)
							{
								v = ex[i + 1];
								for (i_ = i; i_ <= n - 1; i_++)
								{
									tmp[i_] = tmp[i_] + v * lua[i, i_];
								}
							}
							i1_ = (0) - (1);
							for (i_ = 1; i_ <= n; i_++)
							{
								ex[i_] = tmp[i_ + i1_];
							}
						}
					}
				}

				//
				// Scale according to SU/SL
				//
				anorm = anorm * su * sl;

				//
				// Quick return if possible
				// We assume that ANORM<>0 after this block
				//
				if ((double)(anorm) == (double)(0))
				{
					return;
				}
				if (n == 1)
				{
					rc = 1;
					return;
				}

				//
				// Estimate the norm of inv(A).
				//
				ainvnm = 0;
				kase = 0;
				while (true)
				{
					rmatrixestimatenorm(n, ref ev, ref ex, ref iwork, ref ainvnm, ref kase);
					if (kase == 0)
					{
						break;
					}

					//
					// from 1-based array to 0-based
					//
					for (i = 0; i <= n - 1; i++)
					{
						ex[i] = ex[i + 1];
					}

					//
					// multiply by inv(A) or inv(A')
					//
					if (kase == kase1)
					{

						//
						// Multiply by inv(L).
						//
						if (!safesolve.rmatrixscaledtrsafesolve(lua, sl, n, ref ex, !mupper, 0, munit, maxgrowth))
						{
							return;
						}

						//
						// Multiply by inv(U).
						//
						if (!safesolve.rmatrixscaledtrsafesolve(lua, su, n, ref ex, mupper, 0, !munit, maxgrowth))
						{
							return;
						}
					}
					else
					{

						//
						// Multiply by inv(U').
						//
						if (!safesolve.rmatrixscaledtrsafesolve(lua, su, n, ref ex, mupper, 1, !munit, maxgrowth))
						{
							return;
						}

						//
						// Multiply by inv(L').
						//
						if (!safesolve.rmatrixscaledtrsafesolve(lua, sl, n, ref ex, !mupper, 1, munit, maxgrowth))
						{
							return;
						}
					}

					//
					// from 0-based array to 1-based
					//
					for (i = n - 1; i >= 0; i--)
					{
						ex[i + 1] = ex[i];
					}
				}

				//
				// Compute the estimate of the reciprocal condition number.
				//
				if ((double)(ainvnm) != (double)(0))
				{
					rc = 1 / ainvnm;
					rc = rc / anorm;
					if ((double)(rc) < (double)(rcondthreshold()))
					{
						rc = 0;
					}
				}
			}


			/*************************************************************************
			Condition number estimation

				-- LAPACK routine (version 3.0) --
					 Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
					 Courant Institute, Argonne National Lab, and Rice University
					 March 31, 1993
			*************************************************************************/
			private static void cmatrixrcondluinternal(complex[,] lua,
					int n,
					bool onenorm,
					bool isanormprovided,
					double anorm,
					ref double rc)
			{
				complex[] ex = new complex[0];
				complex[] cwork2 = new complex[0];
				complex[] cwork3 = new complex[0];
				complex[] cwork4 = new complex[0];
				int[] isave = new int[0];
				double[] rsave = new double[0];
				int kase = 0;
				int kase1 = 0;
				double ainvnm = 0;
				complex v = 0;
				int i = 0;
				int j = 0;
				double su = 0;
				double sl = 0;
				double maxgrowth = 0;
				int i_ = 0;
				int i1_ = 0;

				rc = 0;

				if (n <= 0)
				{
					return;
				}
				cwork2 = new complex[n + 1];
				rc = 0;
				if (n == 0)
				{
					rc = 1;
					return;
				}

				//
				// prepare parameters for triangular solver
				//
				maxgrowth = 1 / rcondthreshold();
				su = 0;
				sl = 1;
				for (i = 0; i <= n - 1; i++)
				{
					for (j = 0; j <= i - 1; j++)
					{
						sl = Math.Max(sl, math.abscomplex(lua[i, j]));
					}
					for (j = i; j <= n - 1; j++)
					{
						su = Math.Max(su, math.abscomplex(lua[i, j]));
					}
				}
				if ((double)(su) == (double)(0))
				{
					su = 1;
				}
				su = 1 / su;
				sl = 1 / sl;

				//
				// Estimate the norm of SU*SL*A.
				//
				if (!isanormprovided)
				{
					anorm = 0;
					if (onenorm)
					{
						kase1 = 1;
					}
					else
					{
						kase1 = 2;
					}
					kase = 0;
					do
					{
						cmatrixestimatenorm(n, ref cwork4, ref ex, ref anorm, ref kase, ref isave, ref rsave);
						if (kase != 0)
						{
							if (kase == kase1)
							{

								//
								// Multiply by U
								//
								for (i = 1; i <= n; i++)
								{
									i1_ = (i) - (i - 1);
									v = 0.0f;
									for (i_ = i - 1; i_ <= n - 1; i_++)
									{
										v += lua[i - 1, i_] * ex[i_ + i1_];
									}
									ex[i] = v;
								}

								//
								// Multiply by L
								//
								for (i = n; i >= 1; i--)
								{
									v = 0;
									if (i > 1)
									{
										i1_ = (1) - (0);
										v = 0.0f;
										for (i_ = 0; i_ <= i - 2; i_++)
										{
											v += lua[i - 1, i_] * ex[i_ + i1_];
										}
									}
									ex[i] = v + ex[i];
								}
							}
							else
							{

								//
								// Multiply by L'
								//
								for (i = 1; i <= n; i++)
								{
									cwork2[i] = 0;
								}
								for (i = 1; i <= n; i++)
								{
									v = ex[i];
									if (i > 1)
									{
										i1_ = (0) - (1);
										for (i_ = 1; i_ <= i - 1; i_++)
										{
											cwork2[i_] = cwork2[i_] + v * math.conj(lua[i - 1, i_ + i1_]);
										}
									}
									cwork2[i] = cwork2[i] + v;
								}

								//
								// Multiply by U'
								//
								for (i = 1; i <= n; i++)
								{
									ex[i] = 0;
								}
								for (i = 1; i <= n; i++)
								{
									v = cwork2[i];
									i1_ = (i - 1) - (i);
									for (i_ = i; i_ <= n; i_++)
									{
										ex[i_] = ex[i_] + v * math.conj(lua[i - 1, i_ + i1_]);
									}
								}
							}
						}
					}
					while (kase != 0);
				}

				//
				// Scale according to SU/SL
				//
				anorm = anorm * su * sl;

				//
				// Quick return if possible
				//
				if ((double)(anorm) == (double)(0))
				{
					return;
				}

				//
				// Estimate the norm of inv(A).
				//
				ainvnm = 0;
				if (onenorm)
				{
					kase1 = 1;
				}
				else
				{
					kase1 = 2;
				}
				kase = 0;
				while (true)
				{
					cmatrixestimatenorm(n, ref cwork4, ref ex, ref ainvnm, ref kase, ref isave, ref rsave);
					if (kase == 0)
					{
						break;
					}

					//
					// From 1-based to 0-based
					//
					for (i = 0; i <= n - 1; i++)
					{
						ex[i] = ex[i + 1];
					}

					//
					// multiply by inv(A) or inv(A')
					//
					if (kase == kase1)
					{

						//
						// Multiply by inv(L).
						//
						if (!safesolve.cmatrixscaledtrsafesolve(lua, sl, n, ref ex, false, 0, true, maxgrowth))
						{
							rc = 0;
							return;
						}

						//
						// Multiply by inv(U).
						//
						if (!safesolve.cmatrixscaledtrsafesolve(lua, su, n, ref ex, true, 0, false, maxgrowth))
						{
							rc = 0;
							return;
						}
					}
					else
					{

						//
						// Multiply by inv(U').
						//
						if (!safesolve.cmatrixscaledtrsafesolve(lua, su, n, ref ex, true, 2, false, maxgrowth))
						{
							rc = 0;
							return;
						}

						//
						// Multiply by inv(L').
						//
						if (!safesolve.cmatrixscaledtrsafesolve(lua, sl, n, ref ex, false, 2, true, maxgrowth))
						{
							rc = 0;
							return;
						}
					}

					//
					// from 0-based to 1-based
					//
					for (i = n - 1; i >= 0; i--)
					{
						ex[i + 1] = ex[i];
					}
				}

				//
				// Compute the estimate of the reciprocal condition number.
				//
				if ((double)(ainvnm) != (double)(0))
				{
					rc = 1 / ainvnm;
					rc = rc / anorm;
					if ((double)(rc) < (double)(rcondthreshold()))
					{
						rc = 0;
					}
				}
			}


			/*************************************************************************
			Internal subroutine for matrix norm estimation

				-- LAPACK auxiliary routine (version 3.0) --
					 Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
					 Courant Institute, Argonne National Lab, and Rice University
					 February 29, 1992
			*************************************************************************/
			private static void rmatrixestimatenorm(int n,
					ref double[] v,
					ref double[] x,
					ref int[] isgn,
					ref double est,
					ref int kase)
			{
				int itmax = 0;
				int i = 0;
				double t = 0;
				bool flg = new bool();
				int positer = 0;
				int posj = 0;
				int posjlast = 0;
				int posjump = 0;
				int posaltsgn = 0;
				int posestold = 0;
				int postemp = 0;
				int i_ = 0;

				itmax = 5;
				posaltsgn = n + 1;
				posestold = n + 2;
				postemp = n + 3;
				positer = n + 1;
				posj = n + 2;
				posjlast = n + 3;
				posjump = n + 4;
				if (kase == 0)
				{
					v = new double[n + 4];
					x = new double[n + 1];
					isgn = new int[n + 5];
					t = (double)1 / (double)n;
					for (i = 1; i <= n; i++)
					{
						x[i] = t;
					}
					kase = 1;
					isgn[posjump] = 1;
					return;
				}

				//
				//     ................ ENTRY   (JUMP = 1)
				//     FIRST ITERATION.  X HAS BEEN OVERWRITTEN BY A*X.
				//
				if (isgn[posjump] == 1)
				{
					if (n == 1)
					{
						v[1] = x[1];
						est = Math.Abs(v[1]);
						kase = 0;
						return;
					}
					est = 0;
					for (i = 1; i <= n; i++)
					{
						est = est + Math.Abs(x[i]);
					}
					for (i = 1; i <= n; i++)
					{
						if ((double)(x[i]) >= (double)(0))
						{
							x[i] = 1;
						}
						else
						{
							x[i] = -1;
						}
						isgn[i] = Math.Sign(x[i]);
					}
					kase = 2;
					isgn[posjump] = 2;
					return;
				}

				//
				//     ................ ENTRY   (JUMP = 2)
				//     FIRST ITERATION.  X HAS BEEN OVERWRITTEN BY TRANDPOSE(A)*X.
				//
				if (isgn[posjump] == 2)
				{
					isgn[posj] = 1;
					for (i = 2; i <= n; i++)
					{
						if ((double)(Math.Abs(x[i])) > (double)(Math.Abs(x[isgn[posj]])))
						{
							isgn[posj] = i;
						}
					}
					isgn[positer] = 2;

					//
					// MAIN LOOP - ITERATIONS 2,3,...,ITMAX.
					//
					for (i = 1; i <= n; i++)
					{
						x[i] = 0;
					}
					x[isgn[posj]] = 1;
					kase = 1;
					isgn[posjump] = 3;
					return;
				}

				//
				//     ................ ENTRY   (JUMP = 3)
				//     X HAS BEEN OVERWRITTEN BY A*X.
				//
				if (isgn[posjump] == 3)
				{
					for (i_ = 1; i_ <= n; i_++)
					{
						v[i_] = x[i_];
					}
					v[posestold] = est;
					est = 0;
					for (i = 1; i <= n; i++)
					{
						est = est + Math.Abs(v[i]);
					}
					flg = false;
					for (i = 1; i <= n; i++)
					{
						if (((double)(x[i]) >= (double)(0) && isgn[i] < 0) || ((double)(x[i]) < (double)(0) && isgn[i] >= 0))
						{
							flg = true;
						}
					}

					//
					// REPEATED SIGN VECTOR DETECTED, HENCE ALGORITHM HAS CONVERGED.
					// OR MAY BE CYCLING.
					//
					if (!flg || (double)(est) <= (double)(v[posestold]))
					{
						v[posaltsgn] = 1;
						for (i = 1; i <= n; i++)
						{
							x[i] = v[posaltsgn] * (1 + (double)(i - 1) / (double)(n - 1));
							v[posaltsgn] = -v[posaltsgn];
						}
						kase = 1;
						isgn[posjump] = 5;
						return;
					}
					for (i = 1; i <= n; i++)
					{
						if ((double)(x[i]) >= (double)(0))
						{
							x[i] = 1;
							isgn[i] = 1;
						}
						else
						{
							x[i] = -1;
							isgn[i] = -1;
						}
					}
					kase = 2;
					isgn[posjump] = 4;
					return;
				}

				//
				//     ................ ENTRY   (JUMP = 4)
				//     X HAS BEEN OVERWRITTEN BY TRANDPOSE(A)*X.
				//
				if (isgn[posjump] == 4)
				{
					isgn[posjlast] = isgn[posj];
					isgn[posj] = 1;
					for (i = 2; i <= n; i++)
					{
						if ((double)(Math.Abs(x[i])) > (double)(Math.Abs(x[isgn[posj]])))
						{
							isgn[posj] = i;
						}
					}
					if ((double)(x[isgn[posjlast]]) != (double)(Math.Abs(x[isgn[posj]])) && isgn[positer] < itmax)
					{
						isgn[positer] = isgn[positer] + 1;
						for (i = 1; i <= n; i++)
						{
							x[i] = 0;
						}
						x[isgn[posj]] = 1;
						kase = 1;
						isgn[posjump] = 3;
						return;
					}

					//
					// ITERATION COMPLETE.  FINAL STAGE.
					//
					v[posaltsgn] = 1;
					for (i = 1; i <= n; i++)
					{
						x[i] = v[posaltsgn] * (1 + (double)(i - 1) / (double)(n - 1));
						v[posaltsgn] = -v[posaltsgn];
					}
					kase = 1;
					isgn[posjump] = 5;
					return;
				}

				//
				//     ................ ENTRY   (JUMP = 5)
				//     X HAS BEEN OVERWRITTEN BY A*X.
				//
				if (isgn[posjump] == 5)
				{
					v[postemp] = 0;
					for (i = 1; i <= n; i++)
					{
						v[postemp] = v[postemp] + Math.Abs(x[i]);
					}
					v[postemp] = 2 * v[postemp] / (3 * n);
					if ((double)(v[postemp]) > (double)(est))
					{
						for (i_ = 1; i_ <= n; i_++)
						{
							v[i_] = x[i_];
						}
						est = v[postemp];
					}
					kase = 0;
					return;
				}
			}


			private static void cmatrixestimatenorm(int n,
					ref complex[] v,
					ref complex[] x,
					ref double est,
					ref int kase,
					ref int[] isave,
					ref double[] rsave)
			{
				int itmax = 0;
				int i = 0;
				int iter = 0;
				int j = 0;
				int jlast = 0;
				int jump = 0;
				double absxi = 0;
				double altsgn = 0;
				double estold = 0;
				double safmin = 0;
				double temp = 0;
				int i_ = 0;


				//
				//Executable Statements ..
				//
				itmax = 5;
				safmin = math.minrealnumber;
				if (kase == 0)
				{
					v = new complex[n + 1];
					x = new complex[n + 1];
					isave = new int[5];
					rsave = new double[4];
					for (i = 1; i <= n; i++)
					{
						x[i] = (double)1 / (double)n;
					}
					kase = 1;
					jump = 1;
					internalcomplexrcondsaveall(ref isave, ref rsave, ref i, ref iter, ref j, ref jlast, ref jump, ref absxi, ref altsgn, ref estold, ref temp);
					return;
				}
				internalcomplexrcondloadall(ref isave, ref rsave, ref i, ref iter, ref j, ref jlast, ref jump, ref absxi, ref altsgn, ref estold, ref temp);

				//
				// ENTRY   (JUMP = 1)
				// FIRST ITERATION.  X HAS BEEN OVERWRITTEN BY A*X.
				//
				if (jump == 1)
				{
					if (n == 1)
					{
						v[1] = x[1];
						est = math.abscomplex(v[1]);
						kase = 0;
						internalcomplexrcondsaveall(ref isave, ref rsave, ref i, ref iter, ref j, ref jlast, ref jump, ref absxi, ref altsgn, ref estold, ref temp);
						return;
					}
					est = internalcomplexrcondscsum1(x, n);
					for (i = 1; i <= n; i++)
					{
						absxi = math.abscomplex(x[i]);
						if ((double)(absxi) > (double)(safmin))
						{
							x[i] = x[i] / absxi;
						}
						else
						{
							x[i] = 1;
						}
					}
					kase = 2;
					jump = 2;
					internalcomplexrcondsaveall(ref isave, ref rsave, ref i, ref iter, ref j, ref jlast, ref jump, ref absxi, ref altsgn, ref estold, ref temp);
					return;
				}

				//
				// ENTRY   (JUMP = 2)
				// FIRST ITERATION.  X HAS BEEN OVERWRITTEN BY CTRANS(A)*X.
				//
				if (jump == 2)
				{
					j = internalcomplexrcondicmax1(x, n);
					iter = 2;

					//
					// MAIN LOOP - ITERATIONS 2,3,...,ITMAX.
					//
					for (i = 1; i <= n; i++)
					{
						x[i] = 0;
					}
					x[j] = 1;
					kase = 1;
					jump = 3;
					internalcomplexrcondsaveall(ref isave, ref rsave, ref i, ref iter, ref j, ref jlast, ref jump, ref absxi, ref altsgn, ref estold, ref temp);
					return;
				}

				//
				// ENTRY   (JUMP = 3)
				// X HAS BEEN OVERWRITTEN BY A*X.
				//
				if (jump == 3)
				{
					for (i_ = 1; i_ <= n; i_++)
					{
						v[i_] = x[i_];
					}
					estold = est;
					est = internalcomplexrcondscsum1(v, n);

					//
					// TEST FOR CYCLING.
					//
					if ((double)(est) <= (double)(estold))
					{

						//
						// ITERATION COMPLETE.  FINAL STAGE.
						//
						altsgn = 1;
						for (i = 1; i <= n; i++)
						{
							x[i] = altsgn * (1 + (double)(i - 1) / (double)(n - 1));
							altsgn = -altsgn;
						}
						kase = 1;
						jump = 5;
						internalcomplexrcondsaveall(ref isave, ref rsave, ref i, ref iter, ref j, ref jlast, ref jump, ref absxi, ref altsgn, ref estold, ref temp);
						return;
					}
					for (i = 1; i <= n; i++)
					{
						absxi = math.abscomplex(x[i]);
						if ((double)(absxi) > (double)(safmin))
						{
							x[i] = x[i] / absxi;
						}
						else
						{
							x[i] = 1;
						}
					}
					kase = 2;
					jump = 4;
					internalcomplexrcondsaveall(ref isave, ref rsave, ref i, ref iter, ref j, ref jlast, ref jump, ref absxi, ref altsgn, ref estold, ref temp);
					return;
				}

				//
				// ENTRY   (JUMP = 4)
				// X HAS BEEN OVERWRITTEN BY CTRANS(A)*X.
				//
				if (jump == 4)
				{
					jlast = j;
					j = internalcomplexrcondicmax1(x, n);
					if ((double)(math.abscomplex(x[jlast])) != (double)(math.abscomplex(x[j])) && iter < itmax)
					{
						iter = iter + 1;

						//
						// MAIN LOOP - ITERATIONS 2,3,...,ITMAX.
						//
						for (i = 1; i <= n; i++)
						{
							x[i] = 0;
						}
						x[j] = 1;
						kase = 1;
						jump = 3;
						internalcomplexrcondsaveall(ref isave, ref rsave, ref i, ref iter, ref j, ref jlast, ref jump, ref absxi, ref altsgn, ref estold, ref temp);
						return;
					}

					//
					// ITERATION COMPLETE.  FINAL STAGE.
					//
					altsgn = 1;
					for (i = 1; i <= n; i++)
					{
						x[i] = altsgn * (1 + (double)(i - 1) / (double)(n - 1));
						altsgn = -altsgn;
					}
					kase = 1;
					jump = 5;
					internalcomplexrcondsaveall(ref isave, ref rsave, ref i, ref iter, ref j, ref jlast, ref jump, ref absxi, ref altsgn, ref estold, ref temp);
					return;
				}

				//
				// ENTRY   (JUMP = 5)
				// X HAS BEEN OVERWRITTEN BY A*X.
				//
				if (jump == 5)
				{
					temp = 2 * (internalcomplexrcondscsum1(x, n) / (3 * n));
					if ((double)(temp) > (double)(est))
					{
						for (i_ = 1; i_ <= n; i_++)
						{
							v[i_] = x[i_];
						}
						est = temp;
					}
					kase = 0;
					internalcomplexrcondsaveall(ref isave, ref rsave, ref i, ref iter, ref j, ref jlast, ref jump, ref absxi, ref altsgn, ref estold, ref temp);
					return;
				}
			}


			private static double internalcomplexrcondscsum1(complex[] x,
					int n)
			{
				double result = 0;
				int i = 0;

				result = 0;
				for (i = 1; i <= n; i++)
				{
					result = result + math.abscomplex(x[i]);
				}
				return result;
			}


			private static int internalcomplexrcondicmax1(complex[] x,
					int n)
			{
				int result = 0;
				int i = 0;
				double m = 0;

				result = 1;
				m = math.abscomplex(x[1]);
				for (i = 2; i <= n; i++)
				{
					if ((double)(math.abscomplex(x[i])) > (double)(m))
					{
						result = i;
						m = math.abscomplex(x[i]);
					}
				}
				return result;
			}


			private static void internalcomplexrcondsaveall(ref int[] isave,
					ref double[] rsave,
					ref int i,
					ref int iter,
					ref int j,
					ref int jlast,
					ref int jump,
					ref double absxi,
					ref double altsgn,
					ref double estold,
					ref double temp)
			{
				isave[0] = i;
				isave[1] = iter;
				isave[2] = j;
				isave[3] = jlast;
				isave[4] = jump;
				rsave[0] = absxi;
				rsave[1] = altsgn;
				rsave[2] = estold;
				rsave[3] = temp;
			}


			private static void internalcomplexrcondloadall(ref int[] isave,
					ref double[] rsave,
					ref int i,
					ref int iter,
					ref int j,
					ref int jlast,
					ref int jump,
					ref double absxi,
					ref double altsgn,
					ref double estold,
					ref double temp)
			{
				i = isave[0];
				iter = isave[1];
				j = isave[2];
				jlast = isave[3];
				jump = isave[4];
				absxi = rsave[0];
				altsgn = rsave[1];
				estold = rsave[2];
				temp = rsave[3];
			}


		}
		public class matinv
		{
			/*************************************************************************
			Matrix inverse report:
			* R1    reciprocal of condition number in 1-norm
			* RInf  reciprocal of condition number in inf-norm
			*************************************************************************/
			public class matinvreport : apobject
			{
				public double r1;
				public double rinf;
				public matinvreport()
				{
					init();
				}
				public override void init()
				{
				}
				public override alglib.apobject make_copy()
				{
					matinvreport _result = new matinvreport();
					_result.r1 = r1;
					_result.rinf = rinf;
					return _result;
				}
			};




			/*************************************************************************
			Inversion of a matrix given by its LU decomposition.

			INPUT PARAMETERS:
					A       -   LU decomposition of the matrix
											(output of RMatrixLU subroutine).
					Pivots  -   table of permutations
											(the output of RMatrixLU subroutine).
					N       -   size of matrix A (optional) :
											* if given, only principal NxN submatrix is processed  and
												overwritten. other elements are unchanged.
											* if not given,  size  is  automatically  determined  from
												matrix size (A must be square matrix)

			OUTPUT PARAMETERS:
					Info    -   return code:
											* -3    A is singular, or VERY close to singular.
															it is filled by zeros in such cases.
											*  1    task is solved (but matrix A may be ill-conditioned,
															check R1/RInf parameters for condition numbers).
					Rep     -   solver report, see below for more info
					A       -   inverse of matrix A.
											Array whose indexes range within [0..N-1, 0..N-1].

			SOLVER REPORT

			Subroutine sets following fields of the Rep structure:
			* R1        reciprocal of condition number: 1/cond(A), 1-norm.
			* RInf      reciprocal of condition number: 1/cond(A), inf-norm.

				-- ALGLIB routine --
					 05.02.2010
					 Bochkanov Sergey
			*************************************************************************/
			public static void rmatrixluinverse(ref double[,] a,
					int[] pivots,
					int n,
					ref int info,
					matinvreport rep)
			{
				double[] work = new double[0];
				int i = 0;
				int j = 0;
				int k = 0;
				double v = 0;

				info = 0;

				alglib.ap.assert(n > 0, "RMatrixLUInverse: N<=0!");
				alglib.ap.assert(alglib.ap.cols(a) >= n, "RMatrixLUInverse: cols(A)<N!");
				alglib.ap.assert(alglib.ap.rows(a) >= n, "RMatrixLUInverse: rows(A)<N!");
				alglib.ap.assert(alglib.ap.len(pivots) >= n, "RMatrixLUInverse: len(Pivots)<N!");
				alglib.ap.assert(apserv.apservisfinitematrix(a, n, n), "RMatrixLUInverse: A contains infinite or NaN values!");
				info = 1;
				for (i = 0; i <= n - 1; i++)
				{
					if (pivots[i] > n - 1 || pivots[i] < i)
					{
						info = -1;
					}
				}
				alglib.ap.assert(info > 0, "RMatrixLUInverse: incorrect Pivots array!");

				//
				// calculate condition numbers
				//
				rep.r1 = rcond.rmatrixlurcond1(a, n);
				rep.rinf = rcond.rmatrixlurcondinf(a, n);
				if ((double)(rep.r1) < (double)(rcond.rcondthreshold()) || (double)(rep.rinf) < (double)(rcond.rcondthreshold()))
				{
					for (i = 0; i <= n - 1; i++)
					{
						for (j = 0; j <= n - 1; j++)
						{
							a[i, j] = 0;
						}
					}
					rep.r1 = 0;
					rep.rinf = 0;
					info = -3;
					return;
				}

				//
				// Call cache-oblivious code
				//
				work = new double[n];
				rmatrixluinverserec(ref a, 0, n, ref work, ref info, rep);

				//
				// apply permutations
				//
				for (i = 0; i <= n - 1; i++)
				{
					for (j = n - 2; j >= 0; j--)
					{
						k = pivots[j];
						v = a[i, j];
						a[i, j] = a[i, k];
						a[i, k] = v;
					}
				}
			}


			/*************************************************************************
			Inversion of a general matrix.

			Input parameters:
					A       -   matrix.
					N       -   size of matrix A (optional) :
											* if given, only principal NxN submatrix is processed  and
												overwritten. other elements are unchanged.
											* if not given,  size  is  automatically  determined  from
												matrix size (A must be square matrix)

			Output parameters:
					Info    -   return code, same as in RMatrixLUInverse
					Rep     -   solver report, same as in RMatrixLUInverse
					A       -   inverse of matrix A, same as in RMatrixLUInverse

			Result:
					True, if the matrix is not singular.
					False, if the matrix is singular.

				-- ALGLIB --
					 Copyright 2005-2010 by Bochkanov Sergey
			*************************************************************************/
			public static void rmatrixinverse(ref double[,] a,
					int n,
					ref int info,
					matinvreport rep)
			{
				int[] pivots = new int[0];

				info = 0;

				alglib.ap.assert(n > 0, "RMatrixInverse: N<=0!");
				alglib.ap.assert(alglib.ap.cols(a) >= n, "RMatrixInverse: cols(A)<N!");
				alglib.ap.assert(alglib.ap.rows(a) >= n, "RMatrixInverse: rows(A)<N!");
				alglib.ap.assert(apserv.apservisfinitematrix(a, n, n), "RMatrixInverse: A contains infinite or NaN values!");
				trfac.rmatrixlu(ref a, n, n, ref pivots);
				rmatrixluinverse(ref a, pivots, n, ref info, rep);
			}


			/*************************************************************************
			Inversion of a matrix given by its LU decomposition.

			INPUT PARAMETERS:
					A       -   LU decomposition of the matrix
											(output of CMatrixLU subroutine).
					Pivots  -   table of permutations
											(the output of CMatrixLU subroutine).
					N       -   size of matrix A (optional) :
											* if given, only principal NxN submatrix is processed  and
												overwritten. other elements are unchanged.
											* if not given,  size  is  automatically  determined  from
												matrix size (A must be square matrix)

			OUTPUT PARAMETERS:
					Info    -   return code, same as in RMatrixLUInverse
					Rep     -   solver report, same as in RMatrixLUInverse
					A       -   inverse of matrix A, same as in RMatrixLUInverse

				-- ALGLIB routine --
					 05.02.2010
					 Bochkanov Sergey
			*************************************************************************/
			public static void cmatrixluinverse(ref complex[,] a,
					int[] pivots,
					int n,
					ref int info,
					matinvreport rep)
			{
				complex[] work = new complex[0];
				int i = 0;
				int j = 0;
				int k = 0;
				complex v = 0;

				info = 0;

				alglib.ap.assert(n > 0, "CMatrixLUInverse: N<=0!");
				alglib.ap.assert(alglib.ap.cols(a) >= n, "CMatrixLUInverse: cols(A)<N!");
				alglib.ap.assert(alglib.ap.rows(a) >= n, "CMatrixLUInverse: rows(A)<N!");
				alglib.ap.assert(alglib.ap.len(pivots) >= n, "CMatrixLUInverse: len(Pivots)<N!");
				alglib.ap.assert(apserv.apservisfinitecmatrix(a, n, n), "CMatrixLUInverse: A contains infinite or NaN values!");
				info = 1;
				for (i = 0; i <= n - 1; i++)
				{
					if (pivots[i] > n - 1 || pivots[i] < i)
					{
						info = -1;
					}
				}
				alglib.ap.assert(info > 0, "CMatrixLUInverse: incorrect Pivots array!");

				//
				// calculate condition numbers
				//
				rep.r1 = rcond.cmatrixlurcond1(a, n);
				rep.rinf = rcond.cmatrixlurcondinf(a, n);
				if ((double)(rep.r1) < (double)(rcond.rcondthreshold()) || (double)(rep.rinf) < (double)(rcond.rcondthreshold()))
				{
					for (i = 0; i <= n - 1; i++)
					{
						for (j = 0; j <= n - 1; j++)
						{
							a[i, j] = 0;
						}
					}
					rep.r1 = 0;
					rep.rinf = 0;
					info = -3;
					return;
				}

				//
				// Call cache-oblivious code
				//
				work = new complex[n];
				cmatrixluinverserec(ref a, 0, n, ref work, ref info, rep);

				//
				// apply permutations
				//
				for (i = 0; i <= n - 1; i++)
				{
					for (j = n - 2; j >= 0; j--)
					{
						k = pivots[j];
						v = a[i, j];
						a[i, j] = a[i, k];
						a[i, k] = v;
					}
				}
			}


			/*************************************************************************
			Inversion of a general matrix.

			Input parameters:
					A       -   matrix
					N       -   size of matrix A (optional) :
											* if given, only principal NxN submatrix is processed  and
												overwritten. other elements are unchanged.
											* if not given,  size  is  automatically  determined  from
												matrix size (A must be square matrix)

			Output parameters:
					Info    -   return code, same as in RMatrixLUInverse
					Rep     -   solver report, same as in RMatrixLUInverse
					A       -   inverse of matrix A, same as in RMatrixLUInverse

				-- ALGLIB --
					 Copyright 2005 by Bochkanov Sergey
			*************************************************************************/
			public static void cmatrixinverse(ref complex[,] a,
					int n,
					ref int info,
					matinvreport rep)
			{
				int[] pivots = new int[0];

				info = 0;

				alglib.ap.assert(n > 0, "CRMatrixInverse: N<=0!");
				alglib.ap.assert(alglib.ap.cols(a) >= n, "CRMatrixInverse: cols(A)<N!");
				alglib.ap.assert(alglib.ap.rows(a) >= n, "CRMatrixInverse: rows(A)<N!");
				alglib.ap.assert(apserv.apservisfinitecmatrix(a, n, n), "CMatrixInverse: A contains infinite or NaN values!");
				trfac.cmatrixlu(ref a, n, n, ref pivots);
				cmatrixluinverse(ref a, pivots, n, ref info, rep);
			}


			/*************************************************************************
			Inversion of a symmetric positive definite matrix which is given
			by Cholesky decomposition.

			Input parameters:
					A       -   Cholesky decomposition of the matrix to be inverted:
											A=U’*U or A = L*L'.
											Output of  SPDMatrixCholesky subroutine.
					N       -   size of matrix A (optional) :
											* if given, only principal NxN submatrix is processed  and
												overwritten. other elements are unchanged.
											* if not given,  size  is  automatically  determined  from
												matrix size (A must be square matrix)
					IsUpper -   storage type (optional):
											* if True, symmetric  matrix  A  is  given  by  its  upper
												triangle, and the lower triangle isn’t  used/changed  by
												function
											* if False,  symmetric matrix  A  is  given  by  its lower
												triangle, and the  upper triangle isn’t used/changed  by
												function
											* if not given, lower half is used.

			Output parameters:
					Info    -   return code, same as in RMatrixLUInverse
					Rep     -   solver report, same as in RMatrixLUInverse
					A       -   inverse of matrix A, same as in RMatrixLUInverse

				-- ALGLIB routine --
					 10.02.2010
					 Bochkanov Sergey
			*************************************************************************/
			public static void spdmatrixcholeskyinverse(ref double[,] a,
					int n,
					bool isupper,
					ref int info,
					matinvreport rep)
			{
				int i = 0;
				int j = 0;
				double[] tmp = new double[0];
				matinvreport rep2 = new matinvreport();
				bool f = new bool();

				info = 0;

				alglib.ap.assert(n > 0, "SPDMatrixCholeskyInverse: N<=0!");
				alglib.ap.assert(alglib.ap.cols(a) >= n, "SPDMatrixCholeskyInverse: cols(A)<N!");
				alglib.ap.assert(alglib.ap.rows(a) >= n, "SPDMatrixCholeskyInverse: rows(A)<N!");
				info = 1;
				f = true;
				for (i = 0; i <= n - 1; i++)
				{
					f = f && math.isfinite(a[i, i]);
				}
				alglib.ap.assert(f, "SPDMatrixCholeskyInverse: A contains infinite or NaN values!");

				//
				// calculate condition numbers
				//
				rep.r1 = rcond.spdmatrixcholeskyrcond(a, n, isupper);
				rep.rinf = rep.r1;
				if ((double)(rep.r1) < (double)(rcond.rcondthreshold()) || (double)(rep.rinf) < (double)(rcond.rcondthreshold()))
				{
					if (isupper)
					{
						for (i = 0; i <= n - 1; i++)
						{
							for (j = i; j <= n - 1; j++)
							{
								a[i, j] = 0;
							}
						}
					}
					else
					{
						for (i = 0; i <= n - 1; i++)
						{
							for (j = 0; j <= i; j++)
							{
								a[i, j] = 0;
							}
						}
					}
					rep.r1 = 0;
					rep.rinf = 0;
					info = -3;
					return;
				}

				//
				// Inverse
				//
				tmp = new double[n];
				spdmatrixcholeskyinverserec(ref a, 0, n, isupper, ref tmp);
			}


			/*************************************************************************
			Inversion of a symmetric positive definite matrix.

			Given an upper or lower triangle of a symmetric positive definite matrix,
			the algorithm generates matrix A^-1 and saves the upper or lower triangle
			depending on the input.

			Input parameters:
					A       -   matrix to be inverted (upper or lower triangle).
											Array with elements [0..N-1,0..N-1].
					N       -   size of matrix A (optional) :
											* if given, only principal NxN submatrix is processed  and
												overwritten. other elements are unchanged.
											* if not given,  size  is  automatically  determined  from
												matrix size (A must be square matrix)
					IsUpper -   storage type (optional):
											* if True, symmetric  matrix  A  is  given  by  its  upper
												triangle, and the lower triangle isn’t  used/changed  by
												function
											* if False,  symmetric matrix  A  is  given  by  its lower
												triangle, and the  upper triangle isn’t used/changed  by
												function
											* if not given,  both lower and upper  triangles  must  be
												filled.

			Output parameters:
					Info    -   return code, same as in RMatrixLUInverse
					Rep     -   solver report, same as in RMatrixLUInverse
					A       -   inverse of matrix A, same as in RMatrixLUInverse

				-- ALGLIB routine --
					 10.02.2010
					 Bochkanov Sergey
			*************************************************************************/
			public static void spdmatrixinverse(ref double[,] a,
					int n,
					bool isupper,
					ref int info,
					matinvreport rep)
			{
				info = 0;

				alglib.ap.assert(n > 0, "SPDMatrixInverse: N<=0!");
				alglib.ap.assert(alglib.ap.cols(a) >= n, "SPDMatrixInverse: cols(A)<N!");
				alglib.ap.assert(alglib.ap.rows(a) >= n, "SPDMatrixInverse: rows(A)<N!");
				alglib.ap.assert(apserv.isfinitertrmatrix(a, n, isupper), "SPDMatrixInverse: A contains infinite or NaN values!");
				info = 1;
				if (trfac.spdmatrixcholesky(ref a, n, isupper))
				{
					spdmatrixcholeskyinverse(ref a, n, isupper, ref info, rep);
				}
				else
				{
					info = -3;
				}
			}


			/*************************************************************************
			Inversion of a Hermitian positive definite matrix which is given
			by Cholesky decomposition.

			Input parameters:
					A       -   Cholesky decomposition of the matrix to be inverted:
											A=U’*U or A = L*L'.
											Output of  HPDMatrixCholesky subroutine.
					N       -   size of matrix A (optional) :
											* if given, only principal NxN submatrix is processed  and
												overwritten. other elements are unchanged.
											* if not given,  size  is  automatically  determined  from
												matrix size (A must be square matrix)
					IsUpper -   storage type (optional):
											* if True, symmetric  matrix  A  is  given  by  its  upper
												triangle, and the lower triangle isn’t  used/changed  by
												function
											* if False,  symmetric matrix  A  is  given  by  its lower
												triangle, and the  upper triangle isn’t used/changed  by
												function
											* if not given, lower half is used.

			Output parameters:
					Info    -   return code, same as in RMatrixLUInverse
					Rep     -   solver report, same as in RMatrixLUInverse
					A       -   inverse of matrix A, same as in RMatrixLUInverse

				-- ALGLIB routine --
					 10.02.2010
					 Bochkanov Sergey
			*************************************************************************/
			public static void hpdmatrixcholeskyinverse(ref complex[,] a,
					int n,
					bool isupper,
					ref int info,
					matinvreport rep)
			{
				int i = 0;
				int j = 0;
				matinvreport rep2 = new matinvreport();
				complex[] tmp = new complex[0];
				bool f = new bool();

				info = 0;

				alglib.ap.assert(n > 0, "HPDMatrixCholeskyInverse: N<=0!");
				alglib.ap.assert(alglib.ap.cols(a) >= n, "HPDMatrixCholeskyInverse: cols(A)<N!");
				alglib.ap.assert(alglib.ap.rows(a) >= n, "HPDMatrixCholeskyInverse: rows(A)<N!");
				f = true;
				for (i = 0; i <= n - 1; i++)
				{
					f = (f && math.isfinite(a[i, i].x)) && math.isfinite(a[i, i].y);
				}
				alglib.ap.assert(f, "HPDMatrixCholeskyInverse: A contains infinite or NaN values!");
				info = 1;

				//
				// calculate condition numbers
				//
				rep.r1 = rcond.hpdmatrixcholeskyrcond(a, n, isupper);
				rep.rinf = rep.r1;
				if ((double)(rep.r1) < (double)(rcond.rcondthreshold()) || (double)(rep.rinf) < (double)(rcond.rcondthreshold()))
				{
					if (isupper)
					{
						for (i = 0; i <= n - 1; i++)
						{
							for (j = i; j <= n - 1; j++)
							{
								a[i, j] = 0;
							}
						}
					}
					else
					{
						for (i = 0; i <= n - 1; i++)
						{
							for (j = 0; j <= i; j++)
							{
								a[i, j] = 0;
							}
						}
					}
					rep.r1 = 0;
					rep.rinf = 0;
					info = -3;
					return;
				}

				//
				// Inverse
				//
				tmp = new complex[n];
				hpdmatrixcholeskyinverserec(ref a, 0, n, isupper, ref tmp);
			}


			/*************************************************************************
			Inversion of a Hermitian positive definite matrix.

			Given an upper or lower triangle of a Hermitian positive definite matrix,
			the algorithm generates matrix A^-1 and saves the upper or lower triangle
			depending on the input.

			Input parameters:
					A       -   matrix to be inverted (upper or lower triangle).
											Array with elements [0..N-1,0..N-1].
					N       -   size of matrix A (optional) :
											* if given, only principal NxN submatrix is processed  and
												overwritten. other elements are unchanged.
											* if not given,  size  is  automatically  determined  from
												matrix size (A must be square matrix)
					IsUpper -   storage type (optional):
											* if True, symmetric  matrix  A  is  given  by  its  upper
												triangle, and the lower triangle isn’t  used/changed  by
												function
											* if False,  symmetric matrix  A  is  given  by  its lower
												triangle, and the  upper triangle isn’t used/changed  by
												function
											* if not given,  both lower and upper  triangles  must  be
												filled.

			Output parameters:
					Info    -   return code, same as in RMatrixLUInverse
					Rep     -   solver report, same as in RMatrixLUInverse
					A       -   inverse of matrix A, same as in RMatrixLUInverse

				-- ALGLIB routine --
					 10.02.2010
					 Bochkanov Sergey
			*************************************************************************/
			public static void hpdmatrixinverse(ref complex[,] a,
					int n,
					bool isupper,
					ref int info,
					matinvreport rep)
			{
				info = 0;

				alglib.ap.assert(n > 0, "HPDMatrixInverse: N<=0!");
				alglib.ap.assert(alglib.ap.cols(a) >= n, "HPDMatrixInverse: cols(A)<N!");
				alglib.ap.assert(alglib.ap.rows(a) >= n, "HPDMatrixInverse: rows(A)<N!");
				alglib.ap.assert(apserv.apservisfinitectrmatrix(a, n, isupper), "HPDMatrixInverse: A contains infinite or NaN values!");
				info = 1;
				if (trfac.hpdmatrixcholesky(ref a, n, isupper))
				{
					hpdmatrixcholeskyinverse(ref a, n, isupper, ref info, rep);
				}
				else
				{
					info = -3;
				}
			}


			/*************************************************************************
			Triangular matrix inverse (real)

			The subroutine inverts the following types of matrices:
					* upper triangular
					* upper triangular with unit diagonal
					* lower triangular
					* lower triangular with unit diagonal

			In case of an upper (lower) triangular matrix,  the  inverse  matrix  will
			also be upper (lower) triangular, and after the end of the algorithm,  the
			inverse matrix replaces the source matrix. The elements  below (above) the
			main diagonal are not changed by the algorithm.

			If  the matrix  has a unit diagonal, the inverse matrix also  has  a  unit
			diagonal, and the diagonal elements are not passed to the algorithm.

			Input parameters:
					A       -   matrix, array[0..N-1, 0..N-1].
					N       -   size of matrix A (optional) :
											* if given, only principal NxN submatrix is processed  and
												overwritten. other elements are unchanged.
											* if not given,  size  is  automatically  determined  from
												matrix size (A must be square matrix)
					IsUpper -   True, if the matrix is upper triangular.
					IsUnit  -   diagonal type (optional):
											* if True, matrix has unit diagonal (a[i,i] are NOT used)
											* if False, matrix diagonal is arbitrary
											* if not given, False is assumed

			Output parameters:
					Info    -   same as for RMatrixLUInverse
					Rep     -   same as for RMatrixLUInverse
					A       -   same as for RMatrixLUInverse.

				-- ALGLIB --
					 Copyright 05.02.2010 by Bochkanov Sergey
			*************************************************************************/
			public static void rmatrixtrinverse(ref double[,] a,
					int n,
					bool isupper,
					bool isunit,
					ref int info,
					matinvreport rep)
			{
				int i = 0;
				int j = 0;
				double[] tmp = new double[0];

				info = 0;

				alglib.ap.assert(n > 0, "RMatrixTRInverse: N<=0!");
				alglib.ap.assert(alglib.ap.cols(a) >= n, "RMatrixTRInverse: cols(A)<N!");
				alglib.ap.assert(alglib.ap.rows(a) >= n, "RMatrixTRInverse: rows(A)<N!");
				alglib.ap.assert(apserv.isfinitertrmatrix(a, n, isupper), "RMatrixTRInverse: A contains infinite or NaN values!");
				info = 1;

				//
				// calculate condition numbers
				//
				rep.r1 = rcond.rmatrixtrrcond1(a, n, isupper, isunit);
				rep.rinf = rcond.rmatrixtrrcondinf(a, n, isupper, isunit);
				if ((double)(rep.r1) < (double)(rcond.rcondthreshold()) || (double)(rep.rinf) < (double)(rcond.rcondthreshold()))
				{
					for (i = 0; i <= n - 1; i++)
					{
						for (j = 0; j <= n - 1; j++)
						{
							a[i, j] = 0;
						}
					}
					rep.r1 = 0;
					rep.rinf = 0;
					info = -3;
					return;
				}

				//
				// Invert
				//
				tmp = new double[n];
				rmatrixtrinverserec(ref a, 0, n, isupper, isunit, ref tmp, ref info, rep);
			}


			/*************************************************************************
			Triangular matrix inverse (complex)

			The subroutine inverts the following types of matrices:
					* upper triangular
					* upper triangular with unit diagonal
					* lower triangular
					* lower triangular with unit diagonal

			In case of an upper (lower) triangular matrix,  the  inverse  matrix  will
			also be upper (lower) triangular, and after the end of the algorithm,  the
			inverse matrix replaces the source matrix. The elements  below (above) the
			main diagonal are not changed by the algorithm.

			If  the matrix  has a unit diagonal, the inverse matrix also  has  a  unit
			diagonal, and the diagonal elements are not passed to the algorithm.

			Input parameters:
					A       -   matrix, array[0..N-1, 0..N-1].
					N       -   size of matrix A (optional) :
											* if given, only principal NxN submatrix is processed  and
												overwritten. other elements are unchanged.
											* if not given,  size  is  automatically  determined  from
												matrix size (A must be square matrix)
					IsUpper -   True, if the matrix is upper triangular.
					IsUnit  -   diagonal type (optional):
											* if True, matrix has unit diagonal (a[i,i] are NOT used)
											* if False, matrix diagonal is arbitrary
											* if not given, False is assumed

			Output parameters:
					Info    -   same as for RMatrixLUInverse
					Rep     -   same as for RMatrixLUInverse
					A       -   same as for RMatrixLUInverse.

				-- ALGLIB --
					 Copyright 05.02.2010 by Bochkanov Sergey
			*************************************************************************/
			public static void cmatrixtrinverse(ref complex[,] a,
					int n,
					bool isupper,
					bool isunit,
					ref int info,
					matinvreport rep)
			{
				int i = 0;
				int j = 0;
				complex[] tmp = new complex[0];

				info = 0;

				alglib.ap.assert(n > 0, "CMatrixTRInverse: N<=0!");
				alglib.ap.assert(alglib.ap.cols(a) >= n, "CMatrixTRInverse: cols(A)<N!");
				alglib.ap.assert(alglib.ap.rows(a) >= n, "CMatrixTRInverse: rows(A)<N!");
				alglib.ap.assert(apserv.apservisfinitectrmatrix(a, n, isupper), "CMatrixTRInverse: A contains infinite or NaN values!");
				info = 1;

				//
				// calculate condition numbers
				//
				rep.r1 = rcond.cmatrixtrrcond1(a, n, isupper, isunit);
				rep.rinf = rcond.cmatrixtrrcondinf(a, n, isupper, isunit);
				if ((double)(rep.r1) < (double)(rcond.rcondthreshold()) || (double)(rep.rinf) < (double)(rcond.rcondthreshold()))
				{
					for (i = 0; i <= n - 1; i++)
					{
						for (j = 0; j <= n - 1; j++)
						{
							a[i, j] = 0;
						}
					}
					rep.r1 = 0;
					rep.rinf = 0;
					info = -3;
					return;
				}

				//
				// Invert
				//
				tmp = new complex[n];
				cmatrixtrinverserec(ref a, 0, n, isupper, isunit, ref tmp, ref info, rep);
			}


			/*************************************************************************
			Triangular matrix inversion, recursive subroutine

				-- ALGLIB --
					 05.02.2010, Bochkanov Sergey.
					 Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
					 Courant Institute, Argonne National Lab, and Rice University
					 February 29, 1992.
			*************************************************************************/
			private static void rmatrixtrinverserec(ref double[,] a,
					int offs,
					int n,
					bool isupper,
					bool isunit,
					ref double[] tmp,
					ref int info,
					matinvreport rep)
			{
				int n1 = 0;
				int n2 = 0;
				int i = 0;
				int j = 0;
				double v = 0;
				double ajj = 0;
				int i_ = 0;
				int i1_ = 0;

				if (n < 1)
				{
					info = -1;
					return;
				}

				//
				// Base case
				//
				if (n <= ablas.ablasblocksize(a))
				{
					if (isupper)
					{

						//
						// Compute inverse of upper triangular matrix.
						//
						for (j = 0; j <= n - 1; j++)
						{
							if (!isunit)
							{
								if ((double)(a[offs + j, offs + j]) == (double)(0))
								{
									info = -3;
									return;
								}
								a[offs + j, offs + j] = 1 / a[offs + j, offs + j];
								ajj = -a[offs + j, offs + j];
							}
							else
							{
								ajj = -1;
							}

							//
							// Compute elements 1:j-1 of j-th column.
							//
							if (j > 0)
							{
								i1_ = (offs + 0) - (0);
								for (i_ = 0; i_ <= j - 1; i_++)
								{
									tmp[i_] = a[i_ + i1_, offs + j];
								}
								for (i = 0; i <= j - 1; i++)
								{
									if (i < j - 1)
									{
										i1_ = (i + 1) - (offs + i + 1);
										v = 0.0f;
										for (i_ = offs + i + 1; i_ <= offs + j - 1; i_++)
										{
											v += a[offs + i, i_] * tmp[i_ + i1_];
										}
									}
									else
									{
										v = 0;
									}
									if (!isunit)
									{
										a[offs + i, offs + j] = v + a[offs + i, offs + i] * tmp[i];
									}
									else
									{
										a[offs + i, offs + j] = v + tmp[i];
									}
								}
								for (i_ = offs + 0; i_ <= offs + j - 1; i_++)
								{
									a[i_, offs + j] = ajj * a[i_, offs + j];
								}
							}
						}
					}
					else
					{

						//
						// Compute inverse of lower triangular matrix.
						//
						for (j = n - 1; j >= 0; j--)
						{
							if (!isunit)
							{
								if ((double)(a[offs + j, offs + j]) == (double)(0))
								{
									info = -3;
									return;
								}
								a[offs + j, offs + j] = 1 / a[offs + j, offs + j];
								ajj = -a[offs + j, offs + j];
							}
							else
							{
								ajj = -1;
							}
							if (j < n - 1)
							{

								//
								// Compute elements j+1:n of j-th column.
								//
								i1_ = (offs + j + 1) - (j + 1);
								for (i_ = j + 1; i_ <= n - 1; i_++)
								{
									tmp[i_] = a[i_ + i1_, offs + j];
								}
								for (i = j + 1; i <= n - 1; i++)
								{
									if (i > j + 1)
									{
										i1_ = (j + 1) - (offs + j + 1);
										v = 0.0f;
										for (i_ = offs + j + 1; i_ <= offs + i - 1; i_++)
										{
											v += a[offs + i, i_] * tmp[i_ + i1_];
										}
									}
									else
									{
										v = 0;
									}
									if (!isunit)
									{
										a[offs + i, offs + j] = v + a[offs + i, offs + i] * tmp[i];
									}
									else
									{
										a[offs + i, offs + j] = v + tmp[i];
									}
								}
								for (i_ = offs + j + 1; i_ <= offs + n - 1; i_++)
								{
									a[i_, offs + j] = ajj * a[i_, offs + j];
								}
							}
						}
					}
					return;
				}

				//
				// Recursive case
				//
				ablas.ablassplitlength(a, n, ref n1, ref n2);
				if (n2 > 0)
				{
					if (isupper)
					{
						for (i = 0; i <= n1 - 1; i++)
						{
							for (i_ = offs + n1; i_ <= offs + n - 1; i_++)
							{
								a[offs + i, i_] = -1 * a[offs + i, i_];
							}
						}
						ablas.rmatrixlefttrsm(n1, n2, a, offs, offs, isupper, isunit, 0, a, offs, offs + n1);
						ablas.rmatrixrighttrsm(n1, n2, a, offs + n1, offs + n1, isupper, isunit, 0, a, offs, offs + n1);
					}
					else
					{
						for (i = 0; i <= n2 - 1; i++)
						{
							for (i_ = offs; i_ <= offs + n1 - 1; i_++)
							{
								a[offs + n1 + i, i_] = -1 * a[offs + n1 + i, i_];
							}
						}
						ablas.rmatrixrighttrsm(n2, n1, a, offs, offs, isupper, isunit, 0, a, offs + n1, offs);
						ablas.rmatrixlefttrsm(n2, n1, a, offs + n1, offs + n1, isupper, isunit, 0, a, offs + n1, offs);
					}
					rmatrixtrinverserec(ref a, offs + n1, n2, isupper, isunit, ref tmp, ref info, rep);
				}
				rmatrixtrinverserec(ref a, offs, n1, isupper, isunit, ref tmp, ref info, rep);
			}


			/*************************************************************************
			Triangular matrix inversion, recursive subroutine

				-- ALGLIB --
					 05.02.2010, Bochkanov Sergey.
					 Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
					 Courant Institute, Argonne National Lab, and Rice University
					 February 29, 1992.
			*************************************************************************/
			private static void cmatrixtrinverserec(ref complex[,] a,
					int offs,
					int n,
					bool isupper,
					bool isunit,
					ref complex[] tmp,
					ref int info,
					matinvreport rep)
			{
				int n1 = 0;
				int n2 = 0;
				int i = 0;
				int j = 0;
				complex v = 0;
				complex ajj = 0;
				int i_ = 0;
				int i1_ = 0;

				if (n < 1)
				{
					info = -1;
					return;
				}

				//
				// Base case
				//
				if (n <= ablas.ablascomplexblocksize(a))
				{
					if (isupper)
					{

						//
						// Compute inverse of upper triangular matrix.
						//
						for (j = 0; j <= n - 1; j++)
						{
							if (!isunit)
							{
								if (a[offs + j, offs + j] == 0)
								{
									info = -3;
									return;
								}
								a[offs + j, offs + j] = 1 / a[offs + j, offs + j];
								ajj = -a[offs + j, offs + j];
							}
							else
							{
								ajj = -1;
							}

							//
							// Compute elements 1:j-1 of j-th column.
							//
							if (j > 0)
							{
								i1_ = (offs + 0) - (0);
								for (i_ = 0; i_ <= j - 1; i_++)
								{
									tmp[i_] = a[i_ + i1_, offs + j];
								}
								for (i = 0; i <= j - 1; i++)
								{
									if (i < j - 1)
									{
										i1_ = (i + 1) - (offs + i + 1);
										v = 0.0f;
										for (i_ = offs + i + 1; i_ <= offs + j - 1; i_++)
										{
											v += a[offs + i, i_] * tmp[i_ + i1_];
										}
									}
									else
									{
										v = 0;
									}
									if (!isunit)
									{
										a[offs + i, offs + j] = v + a[offs + i, offs + i] * tmp[i];
									}
									else
									{
										a[offs + i, offs + j] = v + tmp[i];
									}
								}
								for (i_ = offs + 0; i_ <= offs + j - 1; i_++)
								{
									a[i_, offs + j] = ajj * a[i_, offs + j];
								}
							}
						}
					}
					else
					{

						//
						// Compute inverse of lower triangular matrix.
						//
						for (j = n - 1; j >= 0; j--)
						{
							if (!isunit)
							{
								if (a[offs + j, offs + j] == 0)
								{
									info = -3;
									return;
								}
								a[offs + j, offs + j] = 1 / a[offs + j, offs + j];
								ajj = -a[offs + j, offs + j];
							}
							else
							{
								ajj = -1;
							}
							if (j < n - 1)
							{

								//
								// Compute elements j+1:n of j-th column.
								//
								i1_ = (offs + j + 1) - (j + 1);
								for (i_ = j + 1; i_ <= n - 1; i_++)
								{
									tmp[i_] = a[i_ + i1_, offs + j];
								}
								for (i = j + 1; i <= n - 1; i++)
								{
									if (i > j + 1)
									{
										i1_ = (j + 1) - (offs + j + 1);
										v = 0.0f;
										for (i_ = offs + j + 1; i_ <= offs + i - 1; i_++)
										{
											v += a[offs + i, i_] * tmp[i_ + i1_];
										}
									}
									else
									{
										v = 0;
									}
									if (!isunit)
									{
										a[offs + i, offs + j] = v + a[offs + i, offs + i] * tmp[i];
									}
									else
									{
										a[offs + i, offs + j] = v + tmp[i];
									}
								}
								for (i_ = offs + j + 1; i_ <= offs + n - 1; i_++)
								{
									a[i_, offs + j] = ajj * a[i_, offs + j];
								}
							}
						}
					}
					return;
				}

				//
				// Recursive case
				//
				ablas.ablascomplexsplitlength(a, n, ref n1, ref n2);
				if (n2 > 0)
				{
					if (isupper)
					{
						for (i = 0; i <= n1 - 1; i++)
						{
							for (i_ = offs + n1; i_ <= offs + n - 1; i_++)
							{
								a[offs + i, i_] = -1 * a[offs + i, i_];
							}
						}
						ablas.cmatrixlefttrsm(n1, n2, a, offs, offs, isupper, isunit, 0, a, offs, offs + n1);
						ablas.cmatrixrighttrsm(n1, n2, a, offs + n1, offs + n1, isupper, isunit, 0, a, offs, offs + n1);
					}
					else
					{
						for (i = 0; i <= n2 - 1; i++)
						{
							for (i_ = offs; i_ <= offs + n1 - 1; i_++)
							{
								a[offs + n1 + i, i_] = -1 * a[offs + n1 + i, i_];
							}
						}
						ablas.cmatrixrighttrsm(n2, n1, a, offs, offs, isupper, isunit, 0, a, offs + n1, offs);
						ablas.cmatrixlefttrsm(n2, n1, a, offs + n1, offs + n1, isupper, isunit, 0, a, offs + n1, offs);
					}
					cmatrixtrinverserec(ref a, offs + n1, n2, isupper, isunit, ref tmp, ref info, rep);
				}
				cmatrixtrinverserec(ref a, offs, n1, isupper, isunit, ref tmp, ref info, rep);
			}


			private static void rmatrixluinverserec(ref double[,] a,
					int offs,
					int n,
					ref double[] work,
					ref int info,
					matinvreport rep)
			{
				int i = 0;
				int j = 0;
				double v = 0;
				int n1 = 0;
				int n2 = 0;
				int i_ = 0;
				int i1_ = 0;

				if (n < 1)
				{
					info = -1;
					return;
				}

				//
				// Base case
				//
				if (n <= ablas.ablasblocksize(a))
				{

					//
					// Form inv(U)
					//
					rmatrixtrinverserec(ref a, offs, n, true, false, ref work, ref info, rep);
					if (info <= 0)
					{
						return;
					}

					//
					// Solve the equation inv(A)*L = inv(U) for inv(A).
					//
					for (j = n - 1; j >= 0; j--)
					{

						//
						// Copy current column of L to WORK and replace with zeros.
						//
						for (i = j + 1; i <= n - 1; i++)
						{
							work[i] = a[offs + i, offs + j];
							a[offs + i, offs + j] = 0;
						}

						//
						// Compute current column of inv(A).
						//
						if (j < n - 1)
						{
							for (i = 0; i <= n - 1; i++)
							{
								i1_ = (j + 1) - (offs + j + 1);
								v = 0.0f;
								for (i_ = offs + j + 1; i_ <= offs + n - 1; i_++)
								{
									v += a[offs + i, i_] * work[i_ + i1_];
								}
								a[offs + i, offs + j] = a[offs + i, offs + j] - v;
							}
						}
					}
					return;
				}

				//
				// Recursive code:
				//
				//         ( L1      )   ( U1  U12 )
				// A    =  (         ) * (         )
				//         ( L12  L2 )   (     U2  )
				//
				//         ( W   X )
				// A^-1 =  (       )
				//         ( Y   Z )
				//
				ablas.ablassplitlength(a, n, ref n1, ref n2);
				alglib.ap.assert(n2 > 0, "LUInverseRec: internal error!");

				//
				// X := inv(U1)*U12*inv(U2)
				//
				ablas.rmatrixlefttrsm(n1, n2, a, offs, offs, true, false, 0, a, offs, offs + n1);
				ablas.rmatrixrighttrsm(n1, n2, a, offs + n1, offs + n1, true, false, 0, a, offs, offs + n1);

				//
				// Y := inv(L2)*L12*inv(L1)
				//
				ablas.rmatrixlefttrsm(n2, n1, a, offs + n1, offs + n1, false, true, 0, a, offs + n1, offs);
				ablas.rmatrixrighttrsm(n2, n1, a, offs, offs, false, true, 0, a, offs + n1, offs);

				//
				// W := inv(L1*U1)+X*Y
				//
				rmatrixluinverserec(ref a, offs, n1, ref work, ref info, rep);
				if (info <= 0)
				{
					return;
				}
				ablas.rmatrixgemm(n1, n1, n2, 1.0f, a, offs, offs + n1, 0, a, offs + n1, offs, 0, 1.0f, a, offs, offs);

				//
				// X := -X*inv(L2)
				// Y := -inv(U2)*Y
				//
				ablas.rmatrixrighttrsm(n1, n2, a, offs + n1, offs + n1, false, true, 0, a, offs, offs + n1);
				for (i = 0; i <= n1 - 1; i++)
				{
					for (i_ = offs + n1; i_ <= offs + n - 1; i_++)
					{
						a[offs + i, i_] = -1 * a[offs + i, i_];
					}
				}
				ablas.rmatrixlefttrsm(n2, n1, a, offs + n1, offs + n1, true, false, 0, a, offs + n1, offs);
				for (i = 0; i <= n2 - 1; i++)
				{
					for (i_ = offs; i_ <= offs + n1 - 1; i_++)
					{
						a[offs + n1 + i, i_] = -1 * a[offs + n1 + i, i_];
					}
				}

				//
				// Z := inv(L2*U2)
				//
				rmatrixluinverserec(ref a, offs + n1, n2, ref work, ref info, rep);
			}


			private static void cmatrixluinverserec(ref complex[,] a,
					int offs,
					int n,
					ref complex[] work,
					ref int info,
					matinvreport rep)
			{
				int i = 0;
				int j = 0;
				complex v = 0;
				int n1 = 0;
				int n2 = 0;
				int i_ = 0;
				int i1_ = 0;

				if (n < 1)
				{
					info = -1;
					return;
				}

				//
				// Base case
				//
				if (n <= ablas.ablascomplexblocksize(a))
				{

					//
					// Form inv(U)
					//
					cmatrixtrinverserec(ref a, offs, n, true, false, ref work, ref info, rep);
					if (info <= 0)
					{
						return;
					}

					//
					// Solve the equation inv(A)*L = inv(U) for inv(A).
					//
					for (j = n - 1; j >= 0; j--)
					{

						//
						// Copy current column of L to WORK and replace with zeros.
						//
						for (i = j + 1; i <= n - 1; i++)
						{
							work[i] = a[offs + i, offs + j];
							a[offs + i, offs + j] = 0;
						}

						//
						// Compute current column of inv(A).
						//
						if (j < n - 1)
						{
							for (i = 0; i <= n - 1; i++)
							{
								i1_ = (j + 1) - (offs + j + 1);
								v = 0.0f;
								for (i_ = offs + j + 1; i_ <= offs + n - 1; i_++)
								{
									v += a[offs + i, i_] * work[i_ + i1_];
								}
								a[offs + i, offs + j] = a[offs + i, offs + j] - v;
							}
						}
					}
					return;
				}

				//
				// Recursive code:
				//
				//         ( L1      )   ( U1  U12 )
				// A    =  (         ) * (         )
				//         ( L12  L2 )   (     U2  )
				//
				//         ( W   X )
				// A^-1 =  (       )
				//         ( Y   Z )
				//
				ablas.ablascomplexsplitlength(a, n, ref n1, ref n2);
				alglib.ap.assert(n2 > 0, "LUInverseRec: internal error!");

				//
				// X := inv(U1)*U12*inv(U2)
				//
				ablas.cmatrixlefttrsm(n1, n2, a, offs, offs, true, false, 0, a, offs, offs + n1);
				ablas.cmatrixrighttrsm(n1, n2, a, offs + n1, offs + n1, true, false, 0, a, offs, offs + n1);

				//
				// Y := inv(L2)*L12*inv(L1)
				//
				ablas.cmatrixlefttrsm(n2, n1, a, offs + n1, offs + n1, false, true, 0, a, offs + n1, offs);
				ablas.cmatrixrighttrsm(n2, n1, a, offs, offs, false, true, 0, a, offs + n1, offs);

				//
				// W := inv(L1*U1)+X*Y
				//
				cmatrixluinverserec(ref a, offs, n1, ref work, ref info, rep);
				if (info <= 0)
				{
					return;
				}
				ablas.cmatrixgemm(n1, n1, n2, 1.0f, a, offs, offs + n1, 0, a, offs + n1, offs, 0, 1.0f, a, offs, offs);

				//
				// X := -X*inv(L2)
				// Y := -inv(U2)*Y
				//
				ablas.cmatrixrighttrsm(n1, n2, a, offs + n1, offs + n1, false, true, 0, a, offs, offs + n1);
				for (i = 0; i <= n1 - 1; i++)
				{
					for (i_ = offs + n1; i_ <= offs + n - 1; i_++)
					{
						a[offs + i, i_] = -1 * a[offs + i, i_];
					}
				}
				ablas.cmatrixlefttrsm(n2, n1, a, offs + n1, offs + n1, true, false, 0, a, offs + n1, offs);
				for (i = 0; i <= n2 - 1; i++)
				{
					for (i_ = offs; i_ <= offs + n1 - 1; i_++)
					{
						a[offs + n1 + i, i_] = -1 * a[offs + n1 + i, i_];
					}
				}

				//
				// Z := inv(L2*U2)
				//
				cmatrixluinverserec(ref a, offs + n1, n2, ref work, ref info, rep);
			}


			/*************************************************************************
			Recursive subroutine for SPD inversion.

				-- ALGLIB routine --
					 10.02.2010
					 Bochkanov Sergey
			*************************************************************************/
			private static void spdmatrixcholeskyinverserec(ref double[,] a,
					int offs,
					int n,
					bool isupper,
					ref double[] tmp)
			{
				int i = 0;
				int j = 0;
				double v = 0;
				int n1 = 0;
				int n2 = 0;
				int info2 = 0;
				matinvreport rep2 = new matinvreport();
				int i_ = 0;
				int i1_ = 0;

				if (n < 1)
				{
					return;
				}

				//
				// Base case
				//
				if (n <= ablas.ablasblocksize(a))
				{
					rmatrixtrinverserec(ref a, offs, n, isupper, false, ref tmp, ref info2, rep2);
					if (isupper)
					{

						//
						// Compute the product U * U'.
						// NOTE: we never assume that diagonal of U is real
						//
						for (i = 0; i <= n - 1; i++)
						{
							if (i == 0)
							{

								//
								// 1x1 matrix
								//
								a[offs + i, offs + i] = math.sqr(a[offs + i, offs + i]);
							}
							else
							{

								//
								// (I+1)x(I+1) matrix,
								//
								// ( A11  A12 )   ( A11^H        )   ( A11*A11^H+A12*A12^H  A12*A22^H )
								// (          ) * (              ) = (                                )
								// (      A22 )   ( A12^H  A22^H )   ( A22*A12^H            A22*A22^H )
								//
								// A11 is IxI, A22 is 1x1.
								//
								i1_ = (offs) - (0);
								for (i_ = 0; i_ <= i - 1; i_++)
								{
									tmp[i_] = a[i_ + i1_, offs + i];
								}
								for (j = 0; j <= i - 1; j++)
								{
									v = a[offs + j, offs + i];
									i1_ = (j) - (offs + j);
									for (i_ = offs + j; i_ <= offs + i - 1; i_++)
									{
										a[offs + j, i_] = a[offs + j, i_] + v * tmp[i_ + i1_];
									}
								}
								v = a[offs + i, offs + i];
								for (i_ = offs; i_ <= offs + i - 1; i_++)
								{
									a[i_, offs + i] = v * a[i_, offs + i];
								}
								a[offs + i, offs + i] = math.sqr(a[offs + i, offs + i]);
							}
						}
					}
					else
					{

						//
						// Compute the product L' * L
						// NOTE: we never assume that diagonal of L is real
						//
						for (i = 0; i <= n - 1; i++)
						{
							if (i == 0)
							{

								//
								// 1x1 matrix
								//
								a[offs + i, offs + i] = math.sqr(a[offs + i, offs + i]);
							}
							else
							{

								//
								// (I+1)x(I+1) matrix,
								//
								// ( A11^H  A21^H )   ( A11      )   ( A11^H*A11+A21^H*A21  A21^H*A22 )
								// (              ) * (          ) = (                                )
								// (        A22^H )   ( A21  A22 )   ( A22^H*A21            A22^H*A22 )
								//
								// A11 is IxI, A22 is 1x1.
								//
								i1_ = (offs) - (0);
								for (i_ = 0; i_ <= i - 1; i_++)
								{
									tmp[i_] = a[offs + i, i_ + i1_];
								}
								for (j = 0; j <= i - 1; j++)
								{
									v = a[offs + i, offs + j];
									i1_ = (0) - (offs);
									for (i_ = offs; i_ <= offs + j; i_++)
									{
										a[offs + j, i_] = a[offs + j, i_] + v * tmp[i_ + i1_];
									}
								}
								v = a[offs + i, offs + i];
								for (i_ = offs; i_ <= offs + i - 1; i_++)
								{
									a[offs + i, i_] = v * a[offs + i, i_];
								}
								a[offs + i, offs + i] = math.sqr(a[offs + i, offs + i]);
							}
						}
					}
					return;
				}

				//
				// Recursive code: triangular factor inversion merged with
				// UU' or L'L multiplication
				//
				ablas.ablassplitlength(a, n, ref n1, ref n2);

				//
				// form off-diagonal block of trangular inverse
				//
				if (isupper)
				{
					for (i = 0; i <= n1 - 1; i++)
					{
						for (i_ = offs + n1; i_ <= offs + n - 1; i_++)
						{
							a[offs + i, i_] = -1 * a[offs + i, i_];
						}
					}
					ablas.rmatrixlefttrsm(n1, n2, a, offs, offs, isupper, false, 0, a, offs, offs + n1);
					ablas.rmatrixrighttrsm(n1, n2, a, offs + n1, offs + n1, isupper, false, 0, a, offs, offs + n1);
				}
				else
				{
					for (i = 0; i <= n2 - 1; i++)
					{
						for (i_ = offs; i_ <= offs + n1 - 1; i_++)
						{
							a[offs + n1 + i, i_] = -1 * a[offs + n1 + i, i_];
						}
					}
					ablas.rmatrixrighttrsm(n2, n1, a, offs, offs, isupper, false, 0, a, offs + n1, offs);
					ablas.rmatrixlefttrsm(n2, n1, a, offs + n1, offs + n1, isupper, false, 0, a, offs + n1, offs);
				}

				//
				// invert first diagonal block
				//
				spdmatrixcholeskyinverserec(ref a, offs, n1, isupper, ref tmp);

				//
				// update first diagonal block with off-diagonal block,
				// update off-diagonal block
				//
				if (isupper)
				{
					ablas.rmatrixsyrk(n1, n2, 1.0f, a, offs, offs + n1, 0, 1.0f, a, offs, offs, isupper);
					ablas.rmatrixrighttrsm(n1, n2, a, offs + n1, offs + n1, isupper, false, 1, a, offs, offs + n1);
				}
				else
				{
					ablas.rmatrixsyrk(n1, n2, 1.0f, a, offs + n1, offs, 1, 1.0f, a, offs, offs, isupper);
					ablas.rmatrixlefttrsm(n2, n1, a, offs + n1, offs + n1, isupper, false, 1, a, offs + n1, offs);
				}

				//
				// invert second diagonal block
				//
				spdmatrixcholeskyinverserec(ref a, offs + n1, n2, isupper, ref tmp);
			}


			/*************************************************************************
			Recursive subroutine for HPD inversion.

				-- ALGLIB routine --
					 10.02.2010
					 Bochkanov Sergey
			*************************************************************************/
			private static void hpdmatrixcholeskyinverserec(ref complex[,] a,
					int offs,
					int n,
					bool isupper,
					ref complex[] tmp)
			{
				int i = 0;
				int j = 0;
				complex v = 0;
				int n1 = 0;
				int n2 = 0;
				int info2 = 0;
				matinvreport rep2 = new matinvreport();
				int i_ = 0;
				int i1_ = 0;

				if (n < 1)
				{
					return;
				}

				//
				// Base case
				//
				if (n <= ablas.ablascomplexblocksize(a))
				{
					cmatrixtrinverserec(ref a, offs, n, isupper, false, ref tmp, ref info2, rep2);
					if (isupper)
					{

						//
						// Compute the product U * U'.
						// NOTE: we never assume that diagonal of U is real
						//
						for (i = 0; i <= n - 1; i++)
						{
							if (i == 0)
							{

								//
								// 1x1 matrix
								//
								a[offs + i, offs + i] = math.sqr(a[offs + i, offs + i].x) + math.sqr(a[offs + i, offs + i].y);
							}
							else
							{

								//
								// (I+1)x(I+1) matrix,
								//
								// ( A11  A12 )   ( A11^H        )   ( A11*A11^H+A12*A12^H  A12*A22^H )
								// (          ) * (              ) = (                                )
								// (      A22 )   ( A12^H  A22^H )   ( A22*A12^H            A22*A22^H )
								//
								// A11 is IxI, A22 is 1x1.
								//
								i1_ = (offs) - (0);
								for (i_ = 0; i_ <= i - 1; i_++)
								{
									tmp[i_] = math.conj(a[i_ + i1_, offs + i]);
								}
								for (j = 0; j <= i - 1; j++)
								{
									v = a[offs + j, offs + i];
									i1_ = (j) - (offs + j);
									for (i_ = offs + j; i_ <= offs + i - 1; i_++)
									{
										a[offs + j, i_] = a[offs + j, i_] + v * tmp[i_ + i1_];
									}
								}
								v = math.conj(a[offs + i, offs + i]);
								for (i_ = offs; i_ <= offs + i - 1; i_++)
								{
									a[i_, offs + i] = v * a[i_, offs + i];
								}
								a[offs + i, offs + i] = math.sqr(a[offs + i, offs + i].x) + math.sqr(a[offs + i, offs + i].y);
							}
						}
					}
					else
					{

						//
						// Compute the product L' * L
						// NOTE: we never assume that diagonal of L is real
						//
						for (i = 0; i <= n - 1; i++)
						{
							if (i == 0)
							{

								//
								// 1x1 matrix
								//
								a[offs + i, offs + i] = math.sqr(a[offs + i, offs + i].x) + math.sqr(a[offs + i, offs + i].y);
							}
							else
							{

								//
								// (I+1)x(I+1) matrix,
								//
								// ( A11^H  A21^H )   ( A11      )   ( A11^H*A11+A21^H*A21  A21^H*A22 )
								// (              ) * (          ) = (                                )
								// (        A22^H )   ( A21  A22 )   ( A22^H*A21            A22^H*A22 )
								//
								// A11 is IxI, A22 is 1x1.
								//
								i1_ = (offs) - (0);
								for (i_ = 0; i_ <= i - 1; i_++)
								{
									tmp[i_] = a[offs + i, i_ + i1_];
								}
								for (j = 0; j <= i - 1; j++)
								{
									v = math.conj(a[offs + i, offs + j]);
									i1_ = (0) - (offs);
									for (i_ = offs; i_ <= offs + j; i_++)
									{
										a[offs + j, i_] = a[offs + j, i_] + v * tmp[i_ + i1_];
									}
								}
								v = math.conj(a[offs + i, offs + i]);
								for (i_ = offs; i_ <= offs + i - 1; i_++)
								{
									a[offs + i, i_] = v * a[offs + i, i_];
								}
								a[offs + i, offs + i] = math.sqr(a[offs + i, offs + i].x) + math.sqr(a[offs + i, offs + i].y);
							}
						}
					}
					return;
				}

				//
				// Recursive code: triangular factor inversion merged with
				// UU' or L'L multiplication
				//
				ablas.ablascomplexsplitlength(a, n, ref n1, ref n2);

				//
				// form off-diagonal block of trangular inverse
				//
				if (isupper)
				{
					for (i = 0; i <= n1 - 1; i++)
					{
						for (i_ = offs + n1; i_ <= offs + n - 1; i_++)
						{
							a[offs + i, i_] = -1 * a[offs + i, i_];
						}
					}
					ablas.cmatrixlefttrsm(n1, n2, a, offs, offs, isupper, false, 0, a, offs, offs + n1);
					ablas.cmatrixrighttrsm(n1, n2, a, offs + n1, offs + n1, isupper, false, 0, a, offs, offs + n1);
				}
				else
				{
					for (i = 0; i <= n2 - 1; i++)
					{
						for (i_ = offs; i_ <= offs + n1 - 1; i_++)
						{
							a[offs + n1 + i, i_] = -1 * a[offs + n1 + i, i_];
						}
					}
					ablas.cmatrixrighttrsm(n2, n1, a, offs, offs, isupper, false, 0, a, offs + n1, offs);
					ablas.cmatrixlefttrsm(n2, n1, a, offs + n1, offs + n1, isupper, false, 0, a, offs + n1, offs);
				}

				//
				// invert first diagonal block
				//
				hpdmatrixcholeskyinverserec(ref a, offs, n1, isupper, ref tmp);

				//
				// update first diagonal block with off-diagonal block,
				// update off-diagonal block
				//
				if (isupper)
				{
					ablas.cmatrixsyrk(n1, n2, 1.0f, a, offs, offs + n1, 0, 1.0f, a, offs, offs, isupper);
					ablas.cmatrixrighttrsm(n1, n2, a, offs + n1, offs + n1, isupper, false, 2, a, offs, offs + n1);
				}
				else
				{
					ablas.cmatrixsyrk(n1, n2, 1.0f, a, offs + n1, offs, 2, 1.0f, a, offs, offs, isupper);
					ablas.cmatrixlefttrsm(n2, n1, a, offs + n1, offs + n1, isupper, false, 2, a, offs + n1, offs);
				}

				//
				// invert second diagonal block
				//
				hpdmatrixcholeskyinverserec(ref a, offs + n1, n2, isupper, ref tmp);
			}


		}
		public class sparse
		{
			/*************************************************************************
			Sparse matrix

			You should use ALGLIB functions to work with sparse matrix.
			Never try to access its fields directly!
			*************************************************************************/
			public class sparsematrix : apobject
			{
				public double[] vals;
				public int[] idx;
				public int[] ridx;
				public int[] didx;
				public int[] uidx;
				public int matrixtype;
				public int m;
				public int n;
				public int nfree;
				public int ninitialized;
				public sparsematrix()
				{
					init();
				}
				public override void init()
				{
					vals = new double[0];
					idx = new int[0];
					ridx = new int[0];
					didx = new int[0];
					uidx = new int[0];
				}
				public override alglib.apobject make_copy()
				{
					sparsematrix _result = new sparsematrix();
					_result.vals = (double[])vals.Clone();
					_result.idx = (int[])idx.Clone();
					_result.ridx = (int[])ridx.Clone();
					_result.didx = (int[])didx.Clone();
					_result.uidx = (int[])uidx.Clone();
					_result.matrixtype = matrixtype;
					_result.m = m;
					_result.n = n;
					_result.nfree = nfree;
					_result.ninitialized = ninitialized;
					return _result;
				}
			};




			public const double desiredloadfactor = 0.66f;
			public const double maxloadfactor = 0.75f;
			public const double growfactor = 2.00f;
			public const int additional = 10;
			public const int linalgswitch = 16;


			/*************************************************************************
			This function creates sparse matrix in a Hash-Table format.

			This function creates Hast-Table matrix, which can be  converted  to  CRS
			format after its initialization is over. Typical  usage  scenario  for  a
			sparse matrix is:
			1. creation in a Hash-Table format
			2. insertion of the matrix elements
			3. conversion to the CRS representation
			4. matrix is passed to some linear algebra algorithm

			Some  information  about  different matrix formats can be found below, in
			the "NOTES" section.

			INPUT PARAMETERS
					M           -   number of rows in a matrix, M>=1
					N           -   number of columns in a matrix, N>=1
					K           -   K>=0, expected number of non-zero elements in a matrix.
													K can be inexact approximation, can be less than actual
													number  of  elements  (table will grow when needed) or 
													even zero).
													It is important to understand that although hash-table
													may grow automatically, it is better to  provide  good
													estimate of data size.

			OUTPUT PARAMETERS
					S           -   sparse M*N matrix in Hash-Table representation.
													All elements of the matrix are zero.

			NOTE 1.

			Sparse matrices can be stored using either Hash-Table  representation  or
			Compressed  Row  Storage  representation. Hast-table is better suited for
			querying   and   dynamic   operations   (thus,  it  is  used  for  matrix
			initialization), but it is inefficient when you want to make some  linear 
			algebra operations.

			From the other side, CRS is better suited for linear algebra  operations,
			but initialization is less convenient - you have to tell row sizes at the
			initialization,  and  you  can  fill matrix only row by row, from left to 
			right. CRS is also very inefficient when you want to find matrix  element 
			by its index.

			Thus,  Hash-Table  representation   does   not   support  linear  algebra
			operations, while CRS format does not support modification of the  table.
			Tables below outline information about these two formats:

					OPERATIONS WITH MATRIX      HASH        CRS
					create                      +           +
					read element                +           +
					modify element              +           
					add value to element        +
					A*x  (dense vector)                     +
					A'*x (dense vector)                     +
					A*X  (dense matrix)                     +
					A'*X (dense matrix)                     +

			NOTE 2.

			Hash-tables use memory inefficiently, and they have to keep  some  amount
			of the "spare memory" in order to have good performance. Hash  table  for
			matrix with K non-zero elements will  need  C*K*(8+2*sizeof(int))  bytes,
			where C is a small constant, about 1.5-2 in magnitude.

			CRS storage, from the other side, is  more  memory-efficient,  and  needs
			just K*(8+sizeof(int))+M*sizeof(int) bytes, where M is a number  of  rows
			in a matrix.

			When you convert from the Hash-Table to CRS  representation, all unneeded
			memory will be freed.

				-- ALGLIB PROJECT --
					 Copyright 14.10.2011 by Bochkanov Sergey
			*************************************************************************/
			public static void sparsecreate(int m,
					int n,
					int k,
					sparsematrix s)
			{
				int i = 0;
				int sz = 0;

				alglib.ap.assert(m > 0, "SparseCreate: M<=0");
				alglib.ap.assert(n > 0, "SparseCreate: N<=0");
				alglib.ap.assert(k >= 0, "SparseCreate: K<0");
				sz = (int)Math.Round(k / desiredloadfactor + additional);
				s.matrixtype = 0;
				s.m = m;
				s.n = n;
				s.nfree = sz;
				s.vals = new double[sz];
				s.idx = new int[2 * sz];
				for (i = 0; i <= sz - 1; i++)
				{
					s.idx[2 * i] = -1;
				}
			}


			/*************************************************************************
			This function creates sparse matrix in a CRS format (expert function for
			situations when you are running out of memory).

			This function creates CRS matrix. Typical usage scenario for a CRS matrix 
			is:
			1. creation (you have to tell number of non-zero elements at each row  at 
				 this moment)
			2. insertion of the matrix elements (row by row, from left to right) 
			3. matrix is passed to some linear algebra algorithm

			This function is a memory-efficient alternative to SparseCreate(), but it
			is more complex because it requires you to know in advance how large your
			matrix is. Some  information about  different matrix formats can be found 
			below, in the "NOTES" section.

			INPUT PARAMETERS
					M           -   number of rows in a matrix, M>=1
					N           -   number of columns in a matrix, N>=1
					NER         -   number of elements at each row, array[M], NER[I]>=0

			OUTPUT PARAMETERS
					S           -   sparse M*N matrix in CRS representation.
													You have to fill ALL non-zero elements by calling
													SparseSet() BEFORE you try to use this matrix.

			NOTE 1.

			Sparse matrices can be stored using either Hash-Table  representation  or
			Compressed  Row  Storage  representation. Hast-table is better suited for
			querying   and   dynamic   operations   (thus,  it  is  used  for  matrix
			initialization), but it is inefficient when you want to make some  linear 
			algebra operations.

			From the other side, CRS is better suited for linear algebra  operations,
			but initialization is less convenient - you have to tell row sizes at the
			initialization,  and  you  can  fill matrix only row by row, from left to 
			right. CRS is also very inefficient when you want to find matrix  element 
			by its index.

			Thus,  Hash-Table  representation   does   not   support  linear  algebra
			operations, while CRS format does not support modification of the  table.
			Tables below outline information about these two formats:

					OPERATIONS WITH MATRIX      HASH        CRS
					create                      +           +
					read element                +           +
					modify element              +           
					add value to element        +
					A*x  (dense vector)                     +
					A'*x (dense vector)                     +
					A*X  (dense matrix)                     +
					A'*X (dense matrix)                     +

			NOTE 2.

			Hash-tables use memory inefficiently, and they have to keep  some  amount
			of the "spare memory" in order to have good performance. Hash  table  for
			matrix with K non-zero elements will  need  C*K*(8+2*sizeof(int))  bytes,
			where C is a small constant, about 1.5-2 in magnitude.

			CRS storage, from the other side, is  more  memory-efficient,  and  needs
			just K*(8+sizeof(int))+M*sizeof(int) bytes, where M is a number  of  rows
			in a matrix.

			When you convert from the Hash-Table to CRS  representation, all unneeded
			memory will be freed.

				-- ALGLIB PROJECT --
					 Copyright 14.10.2011 by Bochkanov Sergey
			*************************************************************************/
			public static void sparsecreatecrs(int m,
					int n,
					int[] ner,
					sparsematrix s)
			{
				int i = 0;
				int noe = 0;

				alglib.ap.assert(m > 0, "SparseCreateCRS: M<=0");
				alglib.ap.assert(n > 0, "SparseCreateCRS: N<=0");
				alglib.ap.assert(alglib.ap.len(ner) >= m, "SparseCreateCRS: Length(NER)<M");
				noe = 0;
				s.matrixtype = 1;
				s.ninitialized = 0;
				s.m = m;
				s.n = n;
				s.ridx = new int[s.m + 1];
				s.ridx[0] = 0;
				for (i = 0; i <= s.m - 1; i++)
				{
					alglib.ap.assert(ner[i] >= 0, "SparseCreateCRS: NER[] contains negative elements");
					noe = noe + ner[i];
					s.ridx[i + 1] = s.ridx[i] + ner[i];
				}
				s.vals = new double[noe];
				s.idx = new int[noe];
				if (noe == 0)
				{
					sparseinitduidx(s);
				}
			}


			/*************************************************************************
			This function copies S0 to S1.

			NOTE:  this  function  does  not verify its arguments, it just copies all
			fields of the structure.

				-- ALGLIB PROJECT --
					 Copyright 14.10.2011 by Bochkanov Sergey
			*************************************************************************/
			public static void sparsecopy(sparsematrix s0,
					sparsematrix s1)
			{
				int l = 0;
				int i = 0;

				s1.matrixtype = s0.matrixtype;
				s1.m = s0.m;
				s1.n = s0.n;
				s1.nfree = s0.nfree;
				s1.ninitialized = s0.ninitialized;

				//
				// Initialization for arrays
				//
				l = alglib.ap.len(s0.vals);
				s1.vals = new double[l];
				for (i = 0; i <= l - 1; i++)
				{
					s1.vals[i] = s0.vals[i];
				}
				l = alglib.ap.len(s0.ridx);
				s1.ridx = new int[l];
				for (i = 0; i <= l - 1; i++)
				{
					s1.ridx[i] = s0.ridx[i];
				}
				l = alglib.ap.len(s0.idx);
				s1.idx = new int[l];
				for (i = 0; i <= l - 1; i++)
				{
					s1.idx[i] = s0.idx[i];
				}

				//
				// Initalization for CRS-parameters
				//
				l = alglib.ap.len(s0.uidx);
				s1.uidx = new int[l];
				for (i = 0; i <= l - 1; i++)
				{
					s1.uidx[i] = s0.uidx[i];
				}
				l = alglib.ap.len(s0.didx);
				s1.didx = new int[l];
				for (i = 0; i <= l - 1; i++)
				{
					s1.didx[i] = s0.didx[i];
				}
			}


			/*************************************************************************
			This function adds value to S[i,j] - element of the sparse matrix. Matrix
			must be in a Hash-Table mode.

			In case S[i,j] already exists in the table, V i added to  its  value.  In
			case  S[i,j]  is  non-existent,  it  is  inserted  in  the  table.  Table
			automatically grows when necessary.

			INPUT PARAMETERS
					S           -   sparse M*N matrix in Hash-Table representation.
													Exception will be thrown for CRS matrix.
					I           -   row index of the element to modify, 0<=I<M
					J           -   column index of the element to modify, 0<=J<N
					V           -   value to add, must be finite number

			OUTPUT PARAMETERS
					S           -   modified matrix
            
			NOTE 1:  when  S[i,j]  is exactly zero after modification, it is  deleted
			from the table.

				-- ALGLIB PROJECT --
					 Copyright 14.10.2011 by Bochkanov Sergey
			*************************************************************************/
			public static void sparseadd(sparsematrix s,
					int i,
					int j,
					double v)
			{
				int hashcode = 0;
				int tcode = 0;
				int k = 0;

				alglib.ap.assert(s.matrixtype == 0, "SparseAdd: matrix must be in the Hash-Table mode to do this operation");
				alglib.ap.assert(i >= 0, "SparseAdd: I<0");
				alglib.ap.assert(i < s.m, "SparseAdd: I>=M");
				alglib.ap.assert(j >= 0, "SparseAdd: J<0");
				alglib.ap.assert(j < s.n, "SparseAdd: J>=N");
				alglib.ap.assert(math.isfinite(v), "SparseAdd: V is not finite number");
				if ((double)(v) == (double)(0))
				{
					return;
				}
				tcode = -1;
				k = alglib.ap.len(s.vals);
				if ((double)((1 - maxloadfactor) * k) >= (double)(s.nfree))
				{
					sparseresizematrix(s);
					k = alglib.ap.len(s.vals);
				}
				hashcode = hash(i, j, k);
				while (true)
				{
					if (s.idx[2 * hashcode] == -1)
					{
						if (tcode != -1)
						{
							hashcode = tcode;
						}
						s.vals[hashcode] = v;
						s.idx[2 * hashcode] = i;
						s.idx[2 * hashcode + 1] = j;
						if (tcode == -1)
						{
							s.nfree = s.nfree - 1;
						}
						return;
					}
					else
					{
						if (s.idx[2 * hashcode] == i && s.idx[2 * hashcode + 1] == j)
						{
							s.vals[hashcode] = s.vals[hashcode] + v;
							if ((double)(s.vals[hashcode]) == (double)(0))
							{
								s.idx[2 * hashcode] = -2;
							}
							return;
						}

						//
						// Is it deleted element?
						//
						if (tcode == -1 && s.idx[2 * hashcode] == -2)
						{
							tcode = hashcode;
						}

						//
						// Next step
						//
						hashcode = (hashcode + 1) % k;
					}
				}
			}


			/*************************************************************************
			This function modifies S[i,j] - element of the sparse matrix.

			For Hash-based storage format:
			* new value can be zero or non-zero.  In case new value of S[i,j] is zero,
				this element is deleted from the table.
			* this  function  has  no  effect when called with zero V for non-existent
				element.

			For CRS-bases storage format:
			* new value MUST be non-zero. Exception will be thrown for zero V.
			* elements must be initialized in correct order -  from top row to bottom,
				within row - from left to right.

			INPUT PARAMETERS
					S           -   sparse M*N matrix in Hash-Table or CRS representation.
					I           -   row index of the element to modify, 0<=I<M
					J           -   column index of the element to modify, 0<=J<N
					V           -   value to set, must be finite number, can be zero

			OUTPUT PARAMETERS
					S           -   modified matrix

				-- ALGLIB PROJECT --
					 Copyright 14.10.2011 by Bochkanov Sergey
			*************************************************************************/
			public static void sparseset(sparsematrix s,
					int i,
					int j,
					double v)
			{
				int hashcode = 0;
				int tcode = 0;
				int k = 0;

				alglib.ap.assert(i >= 0, "SparseSet: I<0");
				alglib.ap.assert(i < s.m, "SparseSet: I>=M");
				alglib.ap.assert(j >= 0, "SparseSet: J<0");
				alglib.ap.assert(j < s.n, "SparseSet: J>=N");
				alglib.ap.assert(math.isfinite(v), "SparseSet: V is not finite number");

				//
				// Hash-table matrix
				//
				if (s.matrixtype == 0)
				{
					tcode = -1;
					k = alglib.ap.len(s.vals);
					if ((double)((1 - maxloadfactor) * k) >= (double)(s.nfree))
					{
						sparseresizematrix(s);
						k = alglib.ap.len(s.vals);
					}
					hashcode = hash(i, j, k);
					while (true)
					{
						if (s.idx[2 * hashcode] == -1)
						{
							if ((double)(v) != (double)(0))
							{
								if (tcode != -1)
								{
									hashcode = tcode;
								}
								s.vals[hashcode] = v;
								s.idx[2 * hashcode] = i;
								s.idx[2 * hashcode + 1] = j;
								if (tcode == -1)
								{
									s.nfree = s.nfree - 1;
								}
							}
							return;
						}
						else
						{
							if (s.idx[2 * hashcode] == i && s.idx[2 * hashcode + 1] == j)
							{
								if ((double)(v) == (double)(0))
								{
									s.idx[2 * hashcode] = -2;
								}
								else
								{
									s.vals[hashcode] = v;
								}
								return;
							}
							if (tcode == -1 && s.idx[2 * hashcode] == -2)
							{
								tcode = hashcode;
							}

							//
							// Next step
							//
							hashcode = (hashcode + 1) % k;
						}
					}
				}

				//
				// CRS matrix
				//
				if (s.matrixtype == 1)
				{
					alglib.ap.assert((double)(v) != (double)(0), "SparseSet: CRS format does not allow you to write zero elements");
					alglib.ap.assert(s.ridx[i] <= s.ninitialized, "SparseSet: too few initialized elements at some row (you have promised more when called SparceCreateCRS)");
					alglib.ap.assert(s.ridx[i + 1] > s.ninitialized, "SparseSet: too many initialized elements at some row (you have promised less when called SparceCreateCRS)");
					alglib.ap.assert(s.ninitialized == s.ridx[i] || s.idx[s.ninitialized - 1] < j, "SparseSet: incorrect column order (you must fill every row from left to right)");
					s.vals[s.ninitialized] = v;
					s.idx[s.ninitialized] = j;
					s.ninitialized = s.ninitialized + 1;

					//
					// If matrix has been created then
					// initiale 'S.UIdx' and 'S.DIdx'
					//
					if (s.ninitialized == s.ridx[s.m])
					{
						sparseinitduidx(s);
					}
				}
			}


			/*************************************************************************
			This function returns S[i,j] - element of the sparse matrix.  Matrix  can
			be in any mode (Hash-Table or CRS), but this function is  less  efficient
			for CRS matrices.  Hash-Table  matrices can  find element  in O(1)  time, 
			while  CRS  matrices  need O(log(RS)) time, where RS is an number of non-
			zero elements in a row.

			INPUT PARAMETERS
					S           -   sparse M*N matrix in Hash-Table representation.
													Exception will be thrown for CRS matrix.
					I           -   row index of the element to modify, 0<=I<M
					J           -   column index of the element to modify, 0<=J<N

			RESULT
					value of S[I,J] or zero (in case no element with such index is found)

				-- ALGLIB PROJECT --
					 Copyright 14.10.2011 by Bochkanov Sergey
			*************************************************************************/
			public static double sparseget(sparsematrix s,
					int i,
					int j)
			{
				double result = 0;
				int hashcode = 0;
				int k = 0;
				int k0 = 0;
				int k1 = 0;

				alglib.ap.assert(i >= 0, "SparseGet: I<0");
				alglib.ap.assert(i < s.m, "SparseGet: I>=M");
				alglib.ap.assert(j >= 0, "SparseGet: J<0");
				alglib.ap.assert(j < s.n, "SparseGet: J>=N");
				k = alglib.ap.len(s.vals);
				result = 0;
				if (s.matrixtype == 0)
				{
					hashcode = hash(i, j, k);
					while (true)
					{
						if (s.idx[2 * hashcode] == -1)
						{
							return result;
						}
						if (s.idx[2 * hashcode] == i && s.idx[2 * hashcode + 1] == j)
						{
							result = s.vals[hashcode];
							return result;
						}
						hashcode = (hashcode + 1) % k;
					}
				}
				if (s.matrixtype == 1)
				{
					alglib.ap.assert(s.ninitialized == s.ridx[s.m], "SparseGet: some rows/elements of the CRS matrix were not initialized (you must initialize everything you promised to SparseCreateCRS)");
					k0 = s.ridx[i];
					k1 = s.ridx[i + 1] - 1;
					while (k0 <= k1)
					{
						k = (k0 + k1) / 2;
						if (s.idx[k] == j)
						{
							result = s.vals[k];
							return result;
						}
						if (s.idx[k] < j)
						{
							k0 = k + 1;
						}
						else
						{
							k1 = k - 1;
						}
					}
					return result;
				}
				return result;
			}


			/*************************************************************************
			This function returns I-th diagonal element of the sparse matrix.

			Matrix can be in any mode (Hash-Table or CRS storage), but this  function
			is most efficient for CRS matrices - it requires less than 50 CPU  cycles
			to extract diagonal element. For Hash-Table matrices we still  have  O(1)
			query time, but function is many times slower.

			INPUT PARAMETERS
					S           -   sparse M*N matrix in Hash-Table representation.
													Exception will be thrown for CRS matrix.
					I           -   index of the element to modify, 0<=I<min(M,N)

			RESULT
					value of S[I,I] or zero (in case no element with such index is found)

				-- ALGLIB PROJECT --
					 Copyright 14.10.2011 by Bochkanov Sergey
			*************************************************************************/
			public static double sparsegetdiagonal(sparsematrix s,
					int i)
			{
				double result = 0;

				alglib.ap.assert(i >= 0, "SparseGetDiagonal: I<0");
				alglib.ap.assert(i < s.m, "SparseGetDiagonal: I>=M");
				alglib.ap.assert(i < s.n, "SparseGetDiagonal: I>=N");
				result = 0;
				if (s.matrixtype == 0)
				{
					result = sparseget(s, i, i);
					return result;
				}
				if (s.matrixtype == 1)
				{
					if (s.didx[i] != s.uidx[i])
					{
						result = s.vals[s.didx[i]];
					}
					return result;
				}
				return result;
			}


			/*************************************************************************
			This function converts matrix to CRS format.

			Some  algorithms  (linear  algebra ones, for example) require matrices in
			CRS format.

			INPUT PARAMETERS
					S           -   sparse M*N matrix in any format

			OUTPUT PARAMETERS
					S           -   matrix in CRS format
            
			NOTE:  this  function  has  no  effect  when  called with matrix which is 
			already in CRS mode.

				-- ALGLIB PROJECT --
					 Copyright 14.10.2011 by Bochkanov Sergey
			*************************************************************************/
			public static void sparseconverttocrs(sparsematrix s)
			{
				int i = 0;
				double[] tvals = new double[0];
				int[] tidx = new int[0];
				int[] temp = new int[0];
				int nonne = 0;
				int k = 0;

				alglib.ap.assert(s.matrixtype == 0 || s.matrixtype == 1, "SparseConvertToCRS: invalid matrix type");
				if (s.matrixtype == 1)
				{
					return;
				}
				s.matrixtype = 1;
				nonne = 0;
				k = alglib.ap.len(s.vals);
				alglib.ap.swap(ref s.vals, ref tvals);
				alglib.ap.swap(ref s.idx, ref tidx);
				s.ridx = new int[s.m + 1];
				for (i = 0; i <= s.m; i++)
				{
					s.ridx[i] = 0;
				}
				temp = new int[s.m];
				for (i = 0; i <= s.m - 1; i++)
				{
					temp[i] = 0;
				}

				//
				// Number of elements per row
				//
				for (i = 0; i <= k - 1; i++)
				{
					if (tidx[2 * i] >= 0)
					{
						s.ridx[tidx[2 * i] + 1] = s.ridx[tidx[2 * i] + 1] + 1;
						nonne = nonne + 1;
					}
				}

				//
				// Fill RIdx (offsets of rows)
				//
				for (i = 0; i <= s.m - 1; i++)
				{
					s.ridx[i + 1] = s.ridx[i + 1] + s.ridx[i];
				}

				//
				// Allocate memory
				//
				s.vals = new double[nonne];
				s.idx = new int[nonne];
				for (i = 0; i <= k - 1; i++)
				{
					if (tidx[2 * i] >= 0)
					{
						s.vals[s.ridx[tidx[2 * i]] + temp[tidx[2 * i]]] = tvals[i];
						s.idx[s.ridx[tidx[2 * i]] + temp[tidx[2 * i]]] = tidx[2 * i + 1];
						temp[tidx[2 * i]] = temp[tidx[2 * i]] + 1;
					}
				}

				//
				// Set NInitialized
				//
				s.ninitialized = s.ridx[s.m];

				//
				// Sorting of elements
				//
				for (i = 0; i <= s.m - 1; i++)
				{
					tsort.tagsortmiddleir(ref s.idx, ref s.vals, s.ridx[i], s.ridx[i + 1] - s.ridx[i]);
				}

				//
				// Initialization 'S.UIdx' and 'S.DIdx'
				//
				sparseinitduidx(s);
			}


			/*************************************************************************
			This function calculates matrix-vector product  S*x.  Matrix  S  must  be
			stored in CRS format (exception will be thrown otherwise).

			INPUT PARAMETERS
					S           -   sparse M*N matrix in CRS format (you MUST convert  it
													to CRS before calling this function).
					X           -   array[N], input vector. For  performance  reasons  we 
													make only quick checks - we check that array size  is
													at least N, but we do not check for NAN's or INF's.
					Y           -   output buffer, possibly preallocated. In case  buffer
													size is too small to store  result,  this  buffer  is
													automatically resized.
            
			OUTPUT PARAMETERS
					Y           -   array[M], S*x
            
			NOTE: this function throws exception when called for non-CRS matrix.  You
			must convert your matrix  with  SparseConvertToCRS()  before  using  this
			function.

				-- ALGLIB PROJECT --
					 Copyright 14.10.2011 by Bochkanov Sergey
			*************************************************************************/
			public static void sparsemv(sparsematrix s,
					double[] x,
					ref double[] y)
			{
				double tval = 0;
				int i = 0;
				int j = 0;
				int lt = 0;
				int rt = 0;

				alglib.ap.assert(s.matrixtype == 1, "SparseMV: incorrect matrix type (convert your matrix to CRS)");
				alglib.ap.assert(s.ninitialized == s.ridx[s.m], "SparseMV: some rows/elements of the CRS matrix were not initialized (you must initialize everything you promised to SparseCreateCRS)");
				alglib.ap.assert(alglib.ap.len(x) >= s.n, "SparseMV: length(X)<N");
				apserv.rvectorsetlengthatleast(ref y, s.m);
				for (i = 0; i <= s.m - 1; i++)
				{
					tval = 0;
					lt = s.ridx[i];
					rt = s.ridx[i + 1];
					for (j = lt; j <= rt - 1; j++)
					{
						tval = tval + x[s.idx[j]] * s.vals[j];
					}
					y[i] = tval;
				}
			}


			/*************************************************************************
			This function calculates matrix-vector product  S^T*x. Matrix S  must  be
			stored in CRS format (exception will be thrown otherwise).

			INPUT PARAMETERS
					S           -   sparse M*N matrix in CRS format (you MUST convert  it
													to CRS before calling this function).
					X           -   array[M], input vector. For  performance  reasons  we 
													make only quick checks - we check that array size  is
													at least M, but we do not check for NAN's or INF's.
					Y           -   output buffer, possibly preallocated. In case  buffer
													size is too small to store  result,  this  buffer  is
													automatically resized.
            
			OUTPUT PARAMETERS
					Y           -   array[N], S^T*x
            
			NOTE: this function throws exception when called for non-CRS matrix.  You
			must convert your matrix  with  SparseConvertToCRS()  before  using  this
			function.

				-- ALGLIB PROJECT --
					 Copyright 14.10.2011 by Bochkanov Sergey
			*************************************************************************/
			public static void sparsemtv(sparsematrix s,
					double[] x,
					ref double[] y)
			{
				int i = 0;
				int j = 0;
				int lt = 0;
				int rt = 0;
				int ct = 0;
				double v = 0;

				alglib.ap.assert(s.matrixtype == 1, "SparseMTV: incorrect matrix type (convert your matrix to CRS)");
				alglib.ap.assert(s.ninitialized == s.ridx[s.m], "SparseMTV: some rows/elements of the CRS matrix were not initialized (you must initialize everything you promised to SparseCreateCRS)");
				alglib.ap.assert(alglib.ap.len(x) >= s.m, "SparseMTV: Length(X)<M");
				apserv.rvectorsetlengthatleast(ref y, s.n);
				for (i = 0; i <= s.n - 1; i++)
				{
					y[i] = 0;
				}
				for (i = 0; i <= s.m - 1; i++)
				{
					lt = s.ridx[i];
					rt = s.ridx[i + 1];
					v = x[i];
					for (j = lt; j <= rt - 1; j++)
					{
						ct = s.idx[j];
						y[ct] = y[ct] + v * s.vals[j];
					}
				}
			}


			/*************************************************************************
			This function simultaneously calculates two matrix-vector products:
					S*x and S^T*x.
			S must be square (non-rectangular) matrix stored in CRS format (exception  
			will be thrown otherwise).

			INPUT PARAMETERS
					S           -   sparse N*N matrix in CRS format (you MUST convert  it
													to CRS before calling this function).
					X           -   array[N], input vector. For  performance  reasons  we 
													make only quick checks - we check that array size  is
													at least N, but we do not check for NAN's or INF's.
					Y0          -   output buffer, possibly preallocated. In case  buffer
													size is too small to store  result,  this  buffer  is
													automatically resized.
					Y1          -   output buffer, possibly preallocated. In case  buffer
													size is too small to store  result,  this  buffer  is
													automatically resized.
            
			OUTPUT PARAMETERS
					Y0          -   array[N], S*x
					Y1          -   array[N], S^T*x
            
			NOTE: this function throws exception when called for non-CRS matrix.  You
			must convert your matrix  with  SparseConvertToCRS()  before  using  this
			function. It also throws exception when S is non-square.

				-- ALGLIB PROJECT --
					 Copyright 14.10.2011 by Bochkanov Sergey
			*************************************************************************/
			public static void sparsemv2(sparsematrix s,
					double[] x,
					ref double[] y0,
					ref double[] y1)
			{
				int l = 0;
				double tval = 0;
				int i = 0;
				int j = 0;
				double vx = 0;
				double vs = 0;
				int vi = 0;
				int j0 = 0;
				int j1 = 0;

				alglib.ap.assert(s.matrixtype == 1, "SparseMV2: incorrect matrix type (convert your matrix to CRS)");
				alglib.ap.assert(s.ninitialized == s.ridx[s.m], "SparseMV: some rows/elements of the CRS matrix were not initialized (you must initialize everything you promised to SparseCreateCRS)");
				alglib.ap.assert(s.m == s.n, "SparseMV2: matrix is non-square");
				l = alglib.ap.len(x);
				alglib.ap.assert(l >= s.n, "SparseMV2: Length(X)<N");
				apserv.rvectorsetlengthatleast(ref y0, l);
				apserv.rvectorsetlengthatleast(ref y1, l);
				for (i = 0; i <= s.n - 1; i++)
				{
					y1[i] = 0;
				}
				for (i = 0; i <= s.m - 1; i++)
				{
					tval = 0;
					vx = x[i];
					j0 = s.ridx[i];
					j1 = s.ridx[i + 1] - 1;
					for (j = j0; j <= j1; j++)
					{
						vi = s.idx[j];
						vs = s.vals[j];
						tval = tval + x[vi] * vs;
						y1[vi] = y1[vi] + vx * vs;
					}
					y0[i] = tval;
				}
			}


			/*************************************************************************
			This function calculates matrix-vector product  S*x, when S is  symmetric
			matrix.  Matrix  S  must  be stored in  CRS  format  (exception  will  be
			thrown otherwise).

			INPUT PARAMETERS
					S           -   sparse M*M matrix in CRS format (you MUST convert  it
													to CRS before calling this function).
					IsUpper     -   whether upper or lower triangle of S is given:
													* if upper triangle is given,  only   S[i,j] for j>=i
														are used, and lower triangle is ignored (it can  be
														empty - these elements are not referenced at all).
													* if lower triangle is given,  only   S[i,j] for j<=i
														are used, and upper triangle is ignored.
					X           -   array[N], input vector. For  performance  reasons  we 
													make only quick checks - we check that array size  is
													at least N, but we do not check for NAN's or INF's.
					Y           -   output buffer, possibly preallocated. In case  buffer
													size is too small to store  result,  this  buffer  is
													automatically resized.
            
			OUTPUT PARAMETERS
					Y           -   array[M], S*x
            
			NOTE: this function throws exception when called for non-CRS matrix.  You
			must convert your matrix  with  SparseConvertToCRS()  before  using  this
			function.

				-- ALGLIB PROJECT --
					 Copyright 14.10.2011 by Bochkanov Sergey
			*************************************************************************/
			public static void sparsesmv(sparsematrix s,
					bool isupper,
					double[] x,
					ref double[] y)
			{
				int i = 0;
				int j = 0;
				int id = 0;
				int lt = 0;
				int rt = 0;
				double v = 0;
				double vy = 0;
				double vx = 0;

				alglib.ap.assert(s.matrixtype == 1, "SparseSMV: incorrect matrix type (convert your matrix to CRS)");
				alglib.ap.assert(s.ninitialized == s.ridx[s.m], "SparseSMV: some rows/elements of the CRS matrix were not initialized (you must initialize everything you promised to SparseCreateCRS)");
				alglib.ap.assert(alglib.ap.len(x) >= s.n, "SparseSMV: length(X)<N");
				alglib.ap.assert(s.m == s.n, "SparseSMV: non-square matrix");
				apserv.rvectorsetlengthatleast(ref y, s.m);
				for (i = 0; i <= s.m - 1; i++)
				{
					y[i] = 0;
				}
				for (i = 0; i <= s.m - 1; i++)
				{
					if (s.didx[i] != s.uidx[i])
					{
						y[i] = y[i] + s.vals[s.didx[i]] * x[s.idx[s.didx[i]]];
					}
					if (isupper)
					{
						lt = s.uidx[i];
						rt = s.ridx[i + 1];
						vy = 0;
						vx = x[i];
						for (j = lt; j <= rt - 1; j++)
						{
							id = s.idx[j];
							v = s.vals[j];
							vy = vy + x[id] * v;
							y[id] = y[id] + vx * v;
						}
						y[i] = y[i] + vy;
					}
					else
					{
						lt = s.ridx[i];
						rt = s.didx[i];
						vy = 0;
						vx = x[i];
						for (j = lt; j <= rt - 1; j++)
						{
							id = s.idx[j];
							v = s.vals[j];
							vy = vy + x[id] * v;
							y[id] = y[id] + vx * v;
						}
						y[i] = y[i] + vy;
					}
				}
			}


			/*************************************************************************
			This function calculates matrix-matrix product  S*A.  Matrix  S  must  be
			stored in CRS format (exception will be thrown otherwise).

			INPUT PARAMETERS
					S           -   sparse M*N matrix in CRS format (you MUST convert  it
													to CRS before calling this function).
					A           -   array[N][K], input dense matrix. For  performance reasons
													we make only quick checks - we check that array size  
													is at least N, but we do not check for NAN's or INF's.
					K           -   number of columns of matrix (A).
					B           -   output buffer, possibly preallocated. In case  buffer
													size is too small to store  result,  this  buffer  is
													automatically resized.
            
			OUTPUT PARAMETERS
					B           -   array[M][K], S*A
            
			NOTE: this function throws exception when called for non-CRS matrix.  You
			must convert your matrix  with  SparseConvertToCRS()  before  using  this
			function.

				-- ALGLIB PROJECT --
					 Copyright 14.10.2011 by Bochkanov Sergey
			*************************************************************************/
			public static void sparsemm(sparsematrix s,
					double[,] a,
					int k,
					ref double[,] b)
			{
				double tval = 0;
				double v = 0;
				int id = 0;
				int i = 0;
				int j = 0;
				int k0 = 0;
				int lt = 0;
				int rt = 0;
				int i_ = 0;

				alglib.ap.assert(s.matrixtype == 1, "SparseMV: incorrect matrix type (convert your matrix to CRS)");
				alglib.ap.assert(s.ninitialized == s.ridx[s.m], "SparseMV: some rows/elements of the CRS matrix were not initialized (you must initialize everything you promised to SparseCreateCRS)");
				alglib.ap.assert(alglib.ap.rows(a) >= s.n, "SparseMV: Rows(A)<N");
				alglib.ap.assert(k > 0, "SparseMV: K<=0");
				apserv.rmatrixsetlengthatleast(ref b, s.m, k);
				if (k < linalgswitch)
				{
					for (i = 0; i <= s.m - 1; i++)
					{
						for (j = 0; j <= k - 1; j++)
						{
							tval = 0;
							lt = s.ridx[i];
							rt = s.ridx[i + 1];
							for (k0 = lt; k0 <= rt - 1; k0++)
							{
								tval = tval + s.vals[k0] * a[s.idx[k0], j];
							}
							b[i, j] = tval;
						}
					}
				}
				else
				{
					for (i = 0; i <= s.m - 1; i++)
					{
						for (j = 0; j <= k - 1; j++)
						{
							b[i, j] = 0;
						}
					}
					for (i = 0; i <= s.m - 1; i++)
					{
						lt = s.ridx[i];
						rt = s.ridx[i + 1];
						for (j = lt; j <= rt - 1; j++)
						{
							id = s.idx[j];
							v = s.vals[j];
							for (i_ = 0; i_ <= k - 1; i_++)
							{
								b[i, i_] = b[i, i_] + v * a[id, i_];
							}
						}
					}
				}
			}


			/*************************************************************************
			This function calculates matrix-matrix product  S^T*A. Matrix S  must  be
			stored in CRS format (exception will be thrown otherwise).

			INPUT PARAMETERS
					S           -   sparse M*N matrix in CRS format (you MUST convert  it
													to CRS before calling this function).
					A           -   array[M][K], input dense matrix. For performance reasons
													we make only quick checks - we check that array size  is
													at least M, but we do not check for NAN's or INF's.
					K           -   number of columns of matrix (A).                    
					B           -   output buffer, possibly preallocated. In case  buffer
													size is too small to store  result,  this  buffer  is
													automatically resized.
            
			OUTPUT PARAMETERS
					B           -   array[N][K], S^T*A
            
			NOTE: this function throws exception when called for non-CRS matrix.  You
			must convert your matrix  with  SparseConvertToCRS()  before  using  this
			function.

				-- ALGLIB PROJECT --
					 Copyright 14.10.2011 by Bochkanov Sergey
			*************************************************************************/
			public static void sparsemtm(sparsematrix s,
					double[,] a,
					int k,
					ref double[,] b)
			{
				int i = 0;
				int j = 0;
				int k0 = 0;
				int lt = 0;
				int rt = 0;
				int ct = 0;
				double v = 0;
				int i_ = 0;

				alglib.ap.assert(s.matrixtype == 1, "SparseMTM: incorrect matrix type (convert your matrix to CRS)");
				alglib.ap.assert(s.ninitialized == s.ridx[s.m], "SparseMTM: some rows/elements of the CRS matrix were not initialized (you must initialize everything you promised to SparseCreateCRS)");
				alglib.ap.assert(alglib.ap.rows(a) >= s.m, "SparseMTM: Rows(A)<M");
				alglib.ap.assert(k > 0, "SparseMTM: K<=0");
				apserv.rmatrixsetlengthatleast(ref b, s.n, k);
				for (i = 0; i <= s.n - 1; i++)
				{
					for (j = 0; j <= k - 1; j++)
					{
						b[i, j] = 0;
					}
				}
				if (k < linalgswitch)
				{
					for (i = 0; i <= s.m - 1; i++)
					{
						lt = s.ridx[i];
						rt = s.ridx[i + 1];
						for (k0 = lt; k0 <= rt - 1; k0++)
						{
							v = s.vals[k0];
							ct = s.idx[k0];
							for (j = 0; j <= k - 1; j++)
							{
								b[ct, j] = b[ct, j] + v * a[i, j];
							}
						}
					}
				}
				else
				{
					for (i = 0; i <= s.m - 1; i++)
					{
						lt = s.ridx[i];
						rt = s.ridx[i + 1];
						for (j = lt; j <= rt - 1; j++)
						{
							v = s.vals[j];
							ct = s.idx[j];
							for (i_ = 0; i_ <= k - 1; i_++)
							{
								b[ct, i_] = b[ct, i_] + v * a[i, i_];
							}
						}
					}
				}
			}


			/*************************************************************************
			This function simultaneously calculates two matrix-matrix products:
					S*A and S^T*A.
			S must be square (non-rectangular) matrix stored in CRS format (exception  
			will be thrown otherwise).

			INPUT PARAMETERS
					S           -   sparse N*N matrix in CRS format (you MUST convert  it
													to CRS before calling this function).
					A           -   array[N][K], input dense matrix. For performance reasons
													we make only quick checks - we check that array size  is
													at least N, but we do not check for NAN's or INF's.
					K           -   number of columns of matrix (A).                    
					B0          -   output buffer, possibly preallocated. In case  buffer
													size is too small to store  result,  this  buffer  is
													automatically resized.
					B1          -   output buffer, possibly preallocated. In case  buffer
													size is too small to store  result,  this  buffer  is
													automatically resized.
            
			OUTPUT PARAMETERS
					B0          -   array[N][K], S*A
					B1          -   array[N][K], S^T*A
            
			NOTE: this function throws exception when called for non-CRS matrix.  You
			must convert your matrix  with  SparseConvertToCRS()  before  using  this
			function. It also throws exception when S is non-square.

				-- ALGLIB PROJECT --
					 Copyright 14.10.2011 by Bochkanov Sergey
			*************************************************************************/
			public static void sparsemm2(sparsematrix s,
					double[,] a,
					int k,
					ref double[,] b0,
					ref double[,] b1)
			{
				int i = 0;
				int j = 0;
				int k0 = 0;
				int lt = 0;
				int rt = 0;
				int ct = 0;
				double v = 0;
				double tval = 0;
				int i_ = 0;

				alglib.ap.assert(s.matrixtype == 1, "SparseMM2: incorrect matrix type (convert your matrix to CRS)");
				alglib.ap.assert(s.ninitialized == s.ridx[s.m], "SparseMM2: some rows/elements of the CRS matrix were not initialized (you must initialize everything you promised to SparseCreateCRS)");
				alglib.ap.assert(s.m == s.n, "SparseMM2: matrix is non-square");
				alglib.ap.assert(alglib.ap.rows(a) >= s.n, "SparseMM2: Rows(A)<N");
				alglib.ap.assert(k > 0, "SparseMM2: K<=0");
				apserv.rmatrixsetlengthatleast(ref b0, s.m, k);
				apserv.rmatrixsetlengthatleast(ref b1, s.n, k);
				for (i = 0; i <= s.n - 1; i++)
				{
					for (j = 0; j <= k - 1; j++)
					{
						b1[i, j] = 0;
					}
				}
				if (k < linalgswitch)
				{
					for (i = 0; i <= s.m - 1; i++)
					{
						for (j = 0; j <= k - 1; j++)
						{
							tval = 0;
							lt = s.ridx[i];
							rt = s.ridx[i + 1];
							v = a[i, j];
							for (k0 = lt; k0 <= rt - 1; k0++)
							{
								ct = s.idx[k0];
								b1[ct, j] = b1[ct, j] + s.vals[k0] * v;
								tval = tval + s.vals[k0] * a[ct, j];
							}
							b0[i, j] = tval;
						}
					}
				}
				else
				{
					for (i = 0; i <= s.m - 1; i++)
					{
						for (j = 0; j <= k - 1; j++)
						{
							b0[i, j] = 0;
						}
					}
					for (i = 0; i <= s.m - 1; i++)
					{
						lt = s.ridx[i];
						rt = s.ridx[i + 1];
						for (j = lt; j <= rt - 1; j++)
						{
							v = s.vals[j];
							ct = s.idx[j];
							for (i_ = 0; i_ <= k - 1; i_++)
							{
								b0[i, i_] = b0[i, i_] + v * a[ct, i_];
							}
							for (i_ = 0; i_ <= k - 1; i_++)
							{
								b1[ct, i_] = b1[ct, i_] + v * a[i, i_];
							}
						}
					}
				}
			}


			/*************************************************************************
			This function calculates matrix-matrix product  S*A, when S  is  symmetric
			matrix.  Matrix  S  must  be stored  in  CRS  format  (exception  will  be
			thrown otherwise).

			INPUT PARAMETERS
					S           -   sparse M*M matrix in CRS format (you MUST convert  it
													to CRS before calling this function).
					IsUpper     -   whether upper or lower triangle of S is given:
													* if upper triangle is given,  only   S[i,j] for j>=i
														are used, and lower triangle is ignored (it can  be
														empty - these elements are not referenced at all).
													* if lower triangle is given,  only   S[i,j] for j<=i
														are used, and upper triangle is ignored.
					A           -   array[N][K], input dense matrix. For performance reasons
													we make only quick checks - we check that array size is
													at least N, but we do not check for NAN's or INF's.
					K           -   number of columns of matrix (A).  
					B           -   output buffer, possibly preallocated. In case  buffer
													size is too small to store  result,  this  buffer  is
													automatically resized.
            
			OUTPUT PARAMETERS
					B           -   array[M][K], S*A
            
			NOTE: this function throws exception when called for non-CRS matrix.  You
			must convert your matrix  with  SparseConvertToCRS()  before  using  this
			function.

				-- ALGLIB PROJECT --
					 Copyright 14.10.2011 by Bochkanov Sergey
			*************************************************************************/
			public static void sparsesmm(sparsematrix s,
					bool isupper,
					double[,] a,
					int k,
					ref double[,] b)
			{
				int i = 0;
				int j = 0;
				int k0 = 0;
				int id = 0;
				int lt = 0;
				int rt = 0;
				double v = 0;
				double vb = 0;
				double va = 0;
				int i_ = 0;

				alglib.ap.assert(s.matrixtype == 1, "SparseSMM: incorrect matrix type (convert your matrix to CRS)");
				alglib.ap.assert(s.ninitialized == s.ridx[s.m], "SparseSMM: some rows/elements of the CRS matrix were not initialized (you must initialize everything you promised to SparseCreateCRS)");
				alglib.ap.assert(alglib.ap.rows(a) >= s.n, "SparseSMM: Rows(X)<N");
				alglib.ap.assert(s.m == s.n, "SparseSMM: matrix is non-square");
				apserv.rmatrixsetlengthatleast(ref b, s.m, k);
				for (i = 0; i <= s.m - 1; i++)
				{
					for (j = 0; j <= k - 1; j++)
					{
						b[i, j] = 0;
					}
				}
				if (k > linalgswitch)
				{
					for (i = 0; i <= s.m - 1; i++)
					{
						for (j = 0; j <= k - 1; j++)
						{
							if (s.didx[i] != s.uidx[i])
							{
								id = s.didx[i];
								b[i, j] = b[i, j] + s.vals[id] * a[s.idx[id], j];
							}
							if (isupper)
							{
								lt = s.uidx[i];
								rt = s.ridx[i + 1];
								vb = 0;
								va = a[i, j];
								for (k0 = lt; k0 <= rt - 1; k0++)
								{
									id = s.idx[k0];
									v = s.vals[k0];
									vb = vb + a[id, j] * v;
									b[id, j] = b[id, j] + va * v;
								}
								b[i, j] = b[i, j] + vb;
							}
							else
							{
								lt = s.ridx[i];
								rt = s.didx[i];
								vb = 0;
								va = a[i, j];
								for (k0 = lt; k0 <= rt - 1; k0++)
								{
									id = s.idx[k0];
									v = s.vals[k0];
									vb = vb + a[id, j] * v;
									b[id, j] = b[id, j] + va * v;
								}
								b[i, j] = b[i, j] + vb;
							}
						}
					}
				}
				else
				{
					for (i = 0; i <= s.m - 1; i++)
					{
						if (s.didx[i] != s.uidx[i])
						{
							id = s.didx[i];
							v = s.vals[id];
							for (i_ = 0; i_ <= k - 1; i_++)
							{
								b[i, i_] = b[i, i_] + v * a[s.idx[id], i_];
							}
						}
						if (isupper)
						{
							lt = s.uidx[i];
							rt = s.ridx[i + 1];
							for (j = lt; j <= rt - 1; j++)
							{
								id = s.idx[j];
								v = s.vals[j];
								for (i_ = 0; i_ <= k - 1; i_++)
								{
									b[i, i_] = b[i, i_] + v * a[id, i_];
								}
								for (i_ = 0; i_ <= k - 1; i_++)
								{
									b[id, i_] = b[id, i_] + v * a[i, i_];
								}
							}
						}
						else
						{
							lt = s.ridx[i];
							rt = s.didx[i];
							for (j = lt; j <= rt - 1; j++)
							{
								id = s.idx[j];
								v = s.vals[j];
								for (i_ = 0; i_ <= k - 1; i_++)
								{
									b[i, i_] = b[i, i_] + v * a[id, i_];
								}
								for (i_ = 0; i_ <= k - 1; i_++)
								{
									b[id, i_] = b[id, i_] + v * a[i, i_];
								}
							}
						}
					}
				}
			}


			/*************************************************************************
			This procedure resizes Hash-Table matrix. It can be called when you  have
			deleted too many elements from the matrix, and you want to  free unneeded
			memory.

				-- ALGLIB PROJECT --
					 Copyright 14.10.2011 by Bochkanov Sergey
			*************************************************************************/
			public static void sparseresizematrix(sparsematrix s)
			{
				int k = 0;
				int k1 = 0;
				int i = 0;
				double[] tvals = new double[0];
				int[] tidx = new int[0];

				alglib.ap.assert(s.matrixtype == 0, "SparseResizeMatrix: incorrect matrix type");

				//
				// Initialization for length and number of non-null elementd
				//
				k = alglib.ap.len(s.vals);
				k1 = 0;

				//
				// Calculating number of non-null elements
				//
				for (i = 0; i <= k - 1; i++)
				{
					if (s.idx[2 * i] >= 0)
					{
						k1 = k1 + 1;
					}
				}

				//
				// Initialization value for free space
				//
				s.nfree = (int)Math.Round(k1 / desiredloadfactor * growfactor + additional) - k1;
				tvals = new double[s.nfree + k1];
				tidx = new int[2 * (s.nfree + k1)];
				alglib.ap.swap(ref s.vals, ref tvals);
				alglib.ap.swap(ref s.idx, ref tidx);
				for (i = 0; i <= s.nfree + k1 - 1; i++)
				{
					s.idx[2 * i] = -1;
				}
				for (i = 0; i <= k - 1; i++)
				{
					if (tidx[2 * i] >= 0)
					{
						sparseset(s, tidx[2 * i], tidx[2 * i + 1], tvals[i]);
					}
				}
			}


			/*************************************************************************
			This function return average length of chain at hash-table.

				-- ALGLIB PROJECT --
					 Copyright 14.10.2011 by Bochkanov Sergey
			*************************************************************************/
			public static double sparsegetaveragelengthofchain(sparsematrix s)
			{
				double result = 0;
				int nchains = 0;
				int talc = 0;
				int l = 0;
				int i = 0;
				int ind0 = 0;
				int ind1 = 0;
				int hashcode = 0;


				//
				// If matrix represent in CRS then return zero and exit
				//
				if (s.matrixtype == 1)
				{
					result = 0;
					return result;
				}
				nchains = 0;
				talc = 0;
				l = alglib.ap.len(s.vals);
				for (i = 0; i <= l - 1; i++)
				{
					ind0 = 2 * i;
					if (s.idx[ind0] != -1)
					{
						nchains = nchains + 1;
						hashcode = hash(s.idx[ind0], s.idx[ind0 + 1], l);
						while (true)
						{
							talc = talc + 1;
							ind1 = 2 * hashcode;
							if (s.idx[ind0] == s.idx[ind1] && s.idx[ind0 + 1] == s.idx[ind1 + 1])
							{
								break;
							}
							hashcode = (hashcode + 1) % l;
						}
					}
				}
				if (nchains == 0)
				{
					result = 0;
				}
				else
				{
					result = (double)talc / (double)nchains;
				}
				return result;
			}


			/*************************************************************************
			This  function  is  used  to enumerate all elements of the sparse matrix.
			Before  first  call  user  initializes  T0 and T1 counters by zero. These
			counters are used to remember current position in a  matrix;  after  each
			call they are updated by the function.

			Subsequent calls to this function return non-zero elements of the  sparse
			matrix, one by one. If you enumerate CRS matrix, matrix is traversed from
			left to right, from top to bottom. In case you enumerate matrix stored as
			Hash table, elements are returned in random order.

			EXAMPLE
					> T0=0
					> T1=0
					> while SparseEnumerate(S,T0,T1,I,J,V) do
					>     ....do something with I,J,V

			INPUT PARAMETERS
					S           -   sparse M*N matrix in Hash-Table or CRS representation.
					T0          -   internal counter
					T1          -   internal counter
            
			OUTPUT PARAMETERS
					T0          -   new value of the internal counter
					T1          -   new value of the internal counter
					I           -   row index of non-zero element, 0<=I<M.
					J           -   column index of non-zero element, 0<=J<N
					V           -   value of the T-th element
            
			RESULT
					True in case of success (next non-zero element was retrieved)
					False in case all non-zero elements were enumerated

				-- ALGLIB PROJECT --
					 Copyright 14.03.2012 by Bochkanov Sergey
			*************************************************************************/
			public static bool sparseenumerate(sparsematrix s,
					ref int t0,
					ref int t1,
					ref int i,
					ref int j,
					ref double v)
			{
				bool result = new bool();
				int sz = 0;
				int i0 = 0;

				i = 0;
				j = 0;
				v = 0;

				if (t0 < 0 || (s.matrixtype == 1 && t1 < 0))
				{
					result = false;
					return result;
				}

				//
				// Hash-table matrix
				//
				if (s.matrixtype == 0)
				{
					sz = alglib.ap.len(s.vals);
					for (i0 = t0; i0 <= sz - 1; i0++)
					{
						if (s.idx[2 * i0] == -1 || s.idx[2 * i0] == -2)
						{
							continue;
						}
						else
						{
							i = s.idx[2 * i0];
							j = s.idx[2 * i0 + 1];
							v = s.vals[i0];
							t0 = i0 + 1;
							result = true;
							return result;
						}
					}
					t0 = 0;
					result = false;
					return result;
				}

				//
				// CRS matrix
				//
				if (s.matrixtype == 1 && t0 < s.ninitialized)
				{
					alglib.ap.assert(s.ninitialized == s.ridx[s.m], "SparseEnumerate: some rows/elements of the CRS matrix were not initialized (you must initialize everything you promised to SparseCreateCRS)");
					while (t0 > s.ridx[t1 + 1] - 1 && t1 < s.m)
					{
						t1 = t1 + 1;
					}
					i = t1;
					j = s.idx[t0];
					v = s.vals[t0];
					t0 = t0 + 1;
					result = true;
					return result;
				}
				t0 = 0;
				t1 = 0;
				result = false;
				return result;
			}


			/*************************************************************************
			This function rewrites existing (non-zero) element. It  returns  True   if
			element  exists  or  False,  when  it  is  called for non-existing  (zero)
			element.

			The purpose of this function is to provide convenient thread-safe  way  to
			modify  sparse  matrix.  Such  modification  (already  existing element is
			rewritten) is guaranteed to be thread-safe without any synchronization, as
			long as different threads modify different elements.

			INPUT PARAMETERS
					S           -   sparse M*N matrix in Hash-Table or CRS representation.
					I           -   row index of non-zero element to modify, 0<=I<M
					J           -   column index of non-zero element to modify, 0<=J<N
					V           -   value to rewrite, must be finite number

			OUTPUT PARAMETERS
					S           -   modified matrix
			RESULT
					True in case when element exists
					False in case when element doesn't exist or it is zero
            
				-- ALGLIB PROJECT --
					 Copyright 14.03.2012 by Bochkanov Sergey
			*************************************************************************/
			public static bool sparserewriteexisting(sparsematrix s,
					int i,
					int j,
					double v)
			{
				bool result = new bool();
				int hashcode = 0;
				int k = 0;
				int k0 = 0;
				int k1 = 0;

				alglib.ap.assert(0 <= i && i < s.m, "SparseRewriteExisting: invalid argument I(either I<0 or I>=S.M)");
				alglib.ap.assert(0 <= j && j < s.n, "SparseRewriteExisting: invalid argument J(either J<0 or J>=S.N)");
				alglib.ap.assert(math.isfinite(v), "SparseRewriteExisting: invalid argument V(either V is infinite or V is NaN)");
				result = false;

				//
				// Hash-table matrix
				//
				if (s.matrixtype == 0)
				{
					k = alglib.ap.len(s.vals);
					hashcode = hash(i, j, k);
					while (true)
					{
						if (s.idx[2 * hashcode] == -1)
						{
							return result;
						}
						if (s.idx[2 * hashcode] == i && s.idx[2 * hashcode + 1] == j)
						{
							s.vals[hashcode] = v;
							result = true;
							return result;
						}
						hashcode = (hashcode + 1) % k;
					}
				}

				//
				// CRS matrix
				//
				if (s.matrixtype == 1)
				{
					alglib.ap.assert(s.ninitialized == s.ridx[s.m], "SparseRewriteExisting: some rows/elements of the CRS matrix were not initialized (you must initialize everything you promised to SparseCreateCRS)");
					k0 = s.ridx[i];
					k1 = s.ridx[i + 1] - 1;
					while (k0 <= k1)
					{
						k = (k0 + k1) / 2;
						if (s.idx[k] == j)
						{
							s.vals[k] = v;
							result = true;
							return result;
						}
						if (s.idx[k] < j)
						{
							k0 = k + 1;
						}
						else
						{
							k1 = k - 1;
						}
					}
				}
				return result;
			}


			/*************************************************************************
			This function returns I-th row of the sparse matrix stored in CRS format.

			NOTE: when  incorrect  I  (outside  of  [0,M-1]) or  matrix (non-CRS)  are
						passed, this function throws exception.

			INPUT PARAMETERS:
					S           -   sparse M*N matrix in CRS format
					I           -   row index, 0<=I<M
					IRow        -   output buffer, can be  preallocated.  In  case  buffer
													size  is  too  small  to  store  I-th   row,   it   is
													automatically reallocated.
         
			OUTPUT PARAMETERS:
					IRow        -   array[M], I-th row.


				-- ALGLIB PROJECT --
					 Copyright 20.07.2012 by Bochkanov Sergey
			*************************************************************************/
			public static void sparsegetrow(sparsematrix s,
					int i,
					ref double[] irow)
			{
				int i0 = 0;

				alglib.ap.assert(s.matrixtype == 1, "SparseGetRow: S must be CRS-based matrix");
				alglib.ap.assert(i >= 0 && i < s.m, "SparseGetRow: I<0 or I>=M");
				apserv.rvectorsetlengthatleast(ref irow, s.n);
				for (i0 = 0; i0 <= s.n - 1; i0++)
				{
					irow[i0] = 0;
				}
				for (i0 = s.ridx[i]; i0 <= s.ridx[i + 1] - 1; i0++)
				{
					irow[s.idx[i0]] = s.vals[i0];
				}
			}


			/*************************************************************************
			This function performs in-place conversion from CRS format to  Hash  table
			storage.

			INPUT PARAMETERS
					S           -   sparse matrix in CRS format.

			OUTPUT PARAMETERS
					S           -   sparse matrix in Hash table format.

			NOTE:  this  function  has  no  effect  when  called with matrix which is 
			already in Hash table mode.
            
				-- ALGLIB PROJECT --
					 Copyright 20.07.2012 by Bochkanov Sergey
			*************************************************************************/
			public static void sparseconverttohash(sparsematrix s)
			{
				int[] tidx = new int[0];
				int[] tridx = new int[0];
				double[] tvals = new double[0];
				int tn = 0;
				int tm = 0;
				int i = 0;
				int j = 0;

				alglib.ap.assert(s.matrixtype == 0 || s.matrixtype == 1, "SparseConvertToHash: invalid matrix type");
				if (s.matrixtype == 0)
				{
					return;
				}
				s.matrixtype = 0;
				tm = s.m;
				tn = s.n;
				alglib.ap.swap(ref s.idx, ref tidx);
				alglib.ap.swap(ref s.ridx, ref tridx);
				alglib.ap.swap(ref s.vals, ref tvals);

				//
				// Delete RIdx
				//
				s.ridx = new int[0];
				sparsecreate(tm, tn, tridx[tm], s);

				//
				// Fill the matrix
				//
				for (i = 0; i <= tm - 1; i++)
				{
					for (j = tridx[i]; j <= tridx[i + 1] - 1; j++)
					{
						sparseset(s, i, tidx[j], tvals[j]);
					}
				}
			}


			/*************************************************************************
			This  function  performs  out-of-place  conversion  to  Hash table storage
			format. S0 is copied to S1 and converted on-the-fly.

			INPUT PARAMETERS
					S0          -   sparse matrix in any format.

			OUTPUT PARAMETERS
					S1          -   sparse matrix in Hash table format.

			NOTE: if S0 is stored as Hash-table, it is just copied without conversion.

				-- ALGLIB PROJECT --
					 Copyright 20.07.2012 by Bochkanov Sergey
			*************************************************************************/
			public static void sparsecopytohash(sparsematrix s0,
					sparsematrix s1)
			{
				double val = 0;
				int t0 = 0;
				int t1 = 0;
				int i = 0;
				int j = 0;

				alglib.ap.assert(s0.matrixtype == 0 || s0.matrixtype == 1, "SparseCopyToHash: invalid matrix type");
				if (s0.matrixtype == 0)
				{
					sparsecopy(s0, s1);
				}
				else
				{
					t0 = 0;
					t1 = 0;
					sparsecreate(s0.m, s0.n, s0.ridx[s0.m], s1);
					while (sparseenumerate(s0, ref t0, ref t1, ref i, ref j, ref val))
					{
						sparseset(s1, i, j, val);
					}
				}
			}


			/*************************************************************************
			This  function  performs  out-of-place  conversion  to  CRS format.  S0 is
			copied to S1 and converted on-the-fly.

			INPUT PARAMETERS
					S0          -   sparse matrix in any format.

			OUTPUT PARAMETERS
					S1          -   sparse matrix in CRS format.
            
			NOTE: if S0 is stored as CRS, it is just copied without conversion.

				-- ALGLIB PROJECT --
					 Copyright 20.07.2012 by Bochkanov Sergey
			*************************************************************************/
			public static void sparsecopytocrs(sparsematrix s0,
					sparsematrix s1)
			{
				int[] temp = new int[0];
				int nonne = 0;
				int i = 0;
				int k = 0;

				alglib.ap.assert(s0.matrixtype == 0 || s0.matrixtype == 1, "SparseCopyToCRS: invalid matrix type");
				if (s0.matrixtype == 1)
				{
					sparsecopy(s0, s1);
				}
				else
				{

					//
					// Done like ConvertToCRS function
					//
					s1.matrixtype = 1;
					s1.m = s0.m;
					s1.n = s0.n;
					s1.nfree = s0.nfree;
					nonne = 0;
					k = alglib.ap.len(s0.vals);
					s1.ridx = new int[s1.m + 1];
					for (i = 0; i <= s1.m; i++)
					{
						s1.ridx[i] = 0;
					}
					temp = new int[s1.m];
					for (i = 0; i <= s1.m - 1; i++)
					{
						temp[i] = 0;
					}

					//
					// Number of elements per row
					//
					for (i = 0; i <= k - 1; i++)
					{
						if (s0.idx[2 * i] >= 0)
						{
							s1.ridx[s0.idx[2 * i] + 1] = s1.ridx[s0.idx[2 * i] + 1] + 1;
							nonne = nonne + 1;
						}
					}

					//
					// Fill RIdx (offsets of rows)
					//
					for (i = 0; i <= s1.m - 1; i++)
					{
						s1.ridx[i + 1] = s1.ridx[i + 1] + s1.ridx[i];
					}

					//
					// Allocate memory
					//
					s1.vals = new double[nonne];
					s1.idx = new int[nonne];
					for (i = 0; i <= k - 1; i++)
					{
						if (s0.idx[2 * i] >= 0)
						{
							s1.vals[s1.ridx[s0.idx[2 * i]] + temp[s0.idx[2 * i]]] = s0.vals[i];
							s1.idx[s1.ridx[s0.idx[2 * i]] + temp[s0.idx[2 * i]]] = s0.idx[2 * i + 1];
							temp[s0.idx[2 * i]] = temp[s0.idx[2 * i]] + 1;
						}
					}

					//
					// Set NInitialized
					//
					s1.ninitialized = s1.ridx[s1.m];

					//
					// Sorting of elements
					//
					for (i = 0; i <= s1.m - 1; i++)
					{
						tsort.tagsortmiddleir(ref s1.idx, ref s1.vals, s1.ridx[i], s1.ridx[i + 1] - s1.ridx[i]);
					}

					//
					// Initialization 'S.UIdx' and 'S.DIdx'
					//
					sparseinitduidx(s1);
				}
			}


			/*************************************************************************
			This function returns type of the matrix storage format.

			INPUT PARAMETERS:
					S           -   sparse matrix.

			RESULT:
					sparse storage format used by matrix:
							0   -   Hash-table
							1   -   CRS-format

			NOTE: future  versions  of  ALGLIB  may  include additional sparse storage
						formats.

            
				-- ALGLIB PROJECT --
					 Copyright 20.07.2012 by Bochkanov Sergey
			*************************************************************************/
			public static int sparsegetmatrixtype(sparsematrix s)
			{
				int result = 0;

				alglib.ap.assert(s.matrixtype == 0 || s.matrixtype == 1, "SparseGetMatrixType: invalid matrix type");
				result = s.matrixtype;
				return result;
			}


			/*************************************************************************
			This function checks matrix storage format and returns True when matrix is
			stored using Hash table representation.

			INPUT PARAMETERS:
					S   -   sparse matrix.

			RESULT:
					True if matrix type is Hash table
					False if matrix type is not Hash table 
            
				-- ALGLIB PROJECT --
					 Copyright 20.07.2012 by Bochkanov Sergey
			*************************************************************************/
			public static bool sparseishash(sparsematrix s)
			{
				bool result = new bool();

				alglib.ap.assert(s.matrixtype == 0 || s.matrixtype == 1, "SparseIsHash: invalid matrix type");
				result = s.matrixtype == 0;
				return result;
			}


			/*************************************************************************
			This function checks matrix storage format and returns True when matrix is
			stored using CRS representation.

			INPUT PARAMETERS:
					S   -   sparse matrix.

			RESULT:
					True if matrix type is CRS
					False if matrix type is not CRS
            
				-- ALGLIB PROJECT --
					 Copyright 20.07.2012 by Bochkanov Sergey
			*************************************************************************/
			public static bool sparseiscrs(sparsematrix s)
			{
				bool result = new bool();

				alglib.ap.assert(s.matrixtype == 0 || s.matrixtype == 1, "SparseIsCRS: invalid matrix type");
				result = s.matrixtype == 1;
				return result;
			}


			/*************************************************************************
			The function frees all memory occupied by  sparse  matrix.  Sparse  matrix
			structure becomes unusable after this call.

			OUTPUT PARAMETERS
					S   -   sparse matrix to delete
            
				-- ALGLIB PROJECT --
					 Copyright 24.07.2012 by Bochkanov Sergey
			*************************************************************************/
			public static void sparsefree(sparsematrix s)
			{
				s.matrixtype = -1;
				s.m = 0;
				s.n = 0;
				s.nfree = 0;
				s.ninitialized = 0;
			}


			/*************************************************************************
			The function returns number of rows of a sparse matrix.

			RESULT: number of rows of a sparse matrix.
            
				-- ALGLIB PROJECT --
					 Copyright 23.08.2012 by Bochkanov Sergey
			*************************************************************************/
			public static int sparsegetnrows(sparsematrix s)
			{
				int result = 0;

				result = s.m;
				return result;
			}


			/*************************************************************************
			The function returns number of columns of a sparse matrix.

			RESULT: number of columns of a sparse matrix.
            
				-- ALGLIB PROJECT --
					 Copyright 23.08.2012 by Bochkanov Sergey
			*************************************************************************/
			public static int sparsegetncols(sparsematrix s)
			{
				int result = 0;

				result = s.n;
				return result;
			}


			/*************************************************************************
			Procedure for initialization 'S.DIdx' and 'S.UIdx'


				-- ALGLIB PROJECT --
					 Copyright 14.10.2011 by Bochkanov Sergey
			*************************************************************************/
			private static void sparseinitduidx(sparsematrix s)
			{
				int i = 0;
				int j = 0;
				int lt = 0;
				int rt = 0;

				s.didx = new int[s.m];
				s.uidx = new int[s.m];
				for (i = 0; i <= s.m - 1; i++)
				{
					s.uidx[i] = -1;
					s.didx[i] = -1;
					lt = s.ridx[i];
					rt = s.ridx[i + 1];
					for (j = lt; j <= rt - 1; j++)
					{
						if (i < s.idx[j] && s.uidx[i] == -1)
						{
							s.uidx[i] = j;
							break;
						}
						else
						{
							if (i == s.idx[j])
							{
								s.didx[i] = j;
							}
						}
					}
					if (s.uidx[i] == -1)
					{
						s.uidx[i] = s.ridx[i + 1];
					}
					if (s.didx[i] == -1)
					{
						s.didx[i] = s.uidx[i];
					}
				}
			}


			/*************************************************************************
			This is hash function.

				-- ALGLIB PROJECT --
					 Copyright 14.10.2011 by Bochkanov Sergey
			*************************************************************************/
			private static int hash(int i,
					int j,
					int tabsize)
			{
				int result = 0;
				hqrnd.hqrndstate r = new hqrnd.hqrndstate();

				hqrnd.hqrndseed(i, j, r);
				result = hqrnd.hqrnduniformi(r, tabsize);
				return result;
			}


		}
		public class fbls
		{
			/*************************************************************************
			Structure which stores state of linear CG solver between subsequent calls
			of FBLSCgIteration(). Initialized with FBLSCGCreate().

			USAGE:
			1. call to FBLSCGCreate()
			2. F:=FBLSCgIteration(State)
			3. if F is False, iterations are over
			4. otherwise, fill State.AX with A*x, State.XAX with x'*A*x
			5. goto 2

			If you want to rerminate iterations, pass zero or negative value to XAX.

			FIELDS:
					E1      -   2-norm of residual at the start
					E2      -   2-norm of residual at the end
					X       -   on return from FBLSCgIteration() it contains vector for
											matrix-vector product
					AX      -   must be filled with A*x if FBLSCgIteration() returned True
					XAX     -   must be filled with x'*A*x
					XK      -   contains result (if FBLSCgIteration() returned False)
            
			Other fields are private and should not be used by outsiders.
			*************************************************************************/
			public class fblslincgstate : apobject
			{
				public double e1;
				public double e2;
				public double[] x;
				public double[] ax;
				public double xax;
				public int n;
				public double[] rk;
				public double[] rk1;
				public double[] xk;
				public double[] xk1;
				public double[] pk;
				public double[] pk1;
				public double[] b;
				public rcommstate rstate;
				public double[] tmp2;
				public fblslincgstate()
				{
					init();
				}
				public override void init()
				{
					x = new double[0];
					ax = new double[0];
					rk = new double[0];
					rk1 = new double[0];
					xk = new double[0];
					xk1 = new double[0];
					pk = new double[0];
					pk1 = new double[0];
					b = new double[0];
					rstate = new rcommstate();
					tmp2 = new double[0];
				}
				public override alglib.apobject make_copy()
				{
					fblslincgstate _result = new fblslincgstate();
					_result.e1 = e1;
					_result.e2 = e2;
					_result.x = (double[])x.Clone();
					_result.ax = (double[])ax.Clone();
					_result.xax = xax;
					_result.n = n;
					_result.rk = (double[])rk.Clone();
					_result.rk1 = (double[])rk1.Clone();
					_result.xk = (double[])xk.Clone();
					_result.xk1 = (double[])xk1.Clone();
					_result.pk = (double[])pk.Clone();
					_result.pk1 = (double[])pk1.Clone();
					_result.b = (double[])b.Clone();
					_result.rstate = (rcommstate)rstate.make_copy();
					_result.tmp2 = (double[])tmp2.Clone();
					return _result;
				}
			};




			/*************************************************************************
			Basic Cholesky solver for ScaleA*Cholesky(A)'*x = y.

			This subroutine assumes that:
			* A*ScaleA is well scaled
			* A is well-conditioned, so no zero divisions or overflow may occur

			INPUT PARAMETERS:
					CHA     -   Cholesky decomposition of A
					SqrtScaleA- square root of scale factor ScaleA
					N       -   matrix size, N>=0.
					IsUpper -   storage type
					XB      -   right part
					Tmp     -   buffer; function automatically allocates it, if it is  too
											small.  It  can  be  reused  if function is called several
											times.
                        
			OUTPUT PARAMETERS:
					XB      -   solution

			NOTE 1: no assertion or tests are done during algorithm operation
			NOTE 2: N=0 will force algorithm to silently return

				-- ALGLIB --
					 Copyright 13.10.2010 by Bochkanov Sergey
			*************************************************************************/
			public static void fblscholeskysolve(double[,] cha,
					double sqrtscalea,
					int n,
					bool isupper,
					ref double[] xb,
					ref double[] tmp)
			{
				int i = 0;
				double v = 0;
				int i_ = 0;

				if (n == 0)
				{
					return;
				}
				if (alglib.ap.len(tmp) < n)
				{
					tmp = new double[n];
				}

				//
				// A = L*L' or A=U'*U
				//
				if (isupper)
				{

					//
					// Solve U'*y=b first.
					//
					for (i = 0; i <= n - 1; i++)
					{
						xb[i] = xb[i] / (sqrtscalea * cha[i, i]);
						if (i < n - 1)
						{
							v = xb[i];
							for (i_ = i + 1; i_ <= n - 1; i_++)
							{
								tmp[i_] = sqrtscalea * cha[i, i_];
							}
							for (i_ = i + 1; i_ <= n - 1; i_++)
							{
								xb[i_] = xb[i_] - v * tmp[i_];
							}
						}
					}

					//
					// Solve U*x=y then.
					//
					for (i = n - 1; i >= 0; i--)
					{
						if (i < n - 1)
						{
							for (i_ = i + 1; i_ <= n - 1; i_++)
							{
								tmp[i_] = sqrtscalea * cha[i, i_];
							}
							v = 0.0f;
							for (i_ = i + 1; i_ <= n - 1; i_++)
							{
								v += tmp[i_] * xb[i_];
							}
							xb[i] = xb[i] - v;
						}
						xb[i] = xb[i] / (sqrtscalea * cha[i, i]);
					}
				}
				else
				{

					//
					// Solve L*y=b first
					//
					for (i = 0; i <= n - 1; i++)
					{
						if (i > 0)
						{
							for (i_ = 0; i_ <= i - 1; i_++)
							{
								tmp[i_] = sqrtscalea * cha[i, i_];
							}
							v = 0.0f;
							for (i_ = 0; i_ <= i - 1; i_++)
							{
								v += tmp[i_] * xb[i_];
							}
							xb[i] = xb[i] - v;
						}
						xb[i] = xb[i] / (sqrtscalea * cha[i, i]);
					}

					//
					// Solve L'*x=y then.
					//
					for (i = n - 1; i >= 0; i--)
					{
						xb[i] = xb[i] / (sqrtscalea * cha[i, i]);
						if (i > 0)
						{
							v = xb[i];
							for (i_ = 0; i_ <= i - 1; i_++)
							{
								tmp[i_] = sqrtscalea * cha[i, i_];
							}
							for (i_ = 0; i_ <= i - 1; i_++)
							{
								xb[i_] = xb[i_] - v * tmp[i_];
							}
						}
					}
				}
			}


			/*************************************************************************
			Fast basic linear solver: linear SPD CG

			Solves (A^T*A + alpha*I)*x = b where:
			* A is MxN matrix
			* alpha>0 is a scalar
			* I is NxN identity matrix
			* b is Nx1 vector
			* X is Nx1 unknown vector.

			N iterations of linear conjugate gradient are used to solve problem.

			INPUT PARAMETERS:
					A   -   array[M,N], matrix
					M   -   number of rows
					N   -   number of unknowns
					B   -   array[N], right part
					X   -   initial approxumation, array[N]
					Buf -   buffer; function automatically allocates it, if it is too
									small. It can be reused if function is called several times
									with same M and N.
                    
			OUTPUT PARAMETERS:
					X   -   improved solution
            
			NOTES:
			*   solver checks quality of improved solution. If (because of problem
					condition number, numerical noise, etc.) new solution is WORSE than
					original approximation, then original approximation is returned.
			*   solver assumes that both A, B, Alpha are well scaled (i.e. they are
					less than sqrt(overflow) and greater than sqrt(underflow)).
            
				-- ALGLIB --
					 Copyright 20.08.2009 by Bochkanov Sergey
			*************************************************************************/
			public static void fblssolvecgx(double[,] a,
					int m,
					int n,
					double alpha,
					double[] b,
					ref double[] x,
					ref double[] buf)
			{
				int k = 0;
				int offsrk = 0;
				int offsrk1 = 0;
				int offsxk = 0;
				int offsxk1 = 0;
				int offspk = 0;
				int offspk1 = 0;
				int offstmp1 = 0;
				int offstmp2 = 0;
				int bs = 0;
				double e1 = 0;
				double e2 = 0;
				double rk2 = 0;
				double rk12 = 0;
				double pap = 0;
				double s = 0;
				double betak = 0;
				double v1 = 0;
				double v2 = 0;
				int i_ = 0;
				int i1_ = 0;


				//
				// Test for special case: B=0
				//
				v1 = 0.0f;
				for (i_ = 0; i_ <= n - 1; i_++)
				{
					v1 += b[i_] * b[i_];
				}
				if ((double)(v1) == (double)(0))
				{
					for (k = 0; k <= n - 1; k++)
					{
						x[k] = 0;
					}
					return;
				}

				//
				// Offsets inside Buf for:
				// * R[K], R[K+1]
				// * X[K], X[K+1]
				// * P[K], P[K+1]
				// * Tmp1 - array[M], Tmp2 - array[N]
				//
				offsrk = 0;
				offsrk1 = offsrk + n;
				offsxk = offsrk1 + n;
				offsxk1 = offsxk + n;
				offspk = offsxk1 + n;
				offspk1 = offspk + n;
				offstmp1 = offspk1 + n;
				offstmp2 = offstmp1 + m;
				bs = offstmp2 + n;
				if (alglib.ap.len(buf) < bs)
				{
					buf = new double[bs];
				}

				//
				// x(0) = x
				//
				i1_ = (0) - (offsxk);
				for (i_ = offsxk; i_ <= offsxk + n - 1; i_++)
				{
					buf[i_] = x[i_ + i1_];
				}

				//
				// r(0) = b-A*x(0)
				// RK2 = r(0)'*r(0)
				//
				ablas.rmatrixmv(m, n, a, 0, 0, 0, buf, offsxk, ref buf, offstmp1);
				ablas.rmatrixmv(n, m, a, 0, 0, 1, buf, offstmp1, ref buf, offstmp2);
				i1_ = (offsxk) - (offstmp2);
				for (i_ = offstmp2; i_ <= offstmp2 + n - 1; i_++)
				{
					buf[i_] = buf[i_] + alpha * buf[i_ + i1_];
				}
				i1_ = (0) - (offsrk);
				for (i_ = offsrk; i_ <= offsrk + n - 1; i_++)
				{
					buf[i_] = b[i_ + i1_];
				}
				i1_ = (offstmp2) - (offsrk);
				for (i_ = offsrk; i_ <= offsrk + n - 1; i_++)
				{
					buf[i_] = buf[i_] - buf[i_ + i1_];
				}
				rk2 = 0.0f;
				for (i_ = offsrk; i_ <= offsrk + n - 1; i_++)
				{
					rk2 += buf[i_] * buf[i_];
				}
				i1_ = (offsrk) - (offspk);
				for (i_ = offspk; i_ <= offspk + n - 1; i_++)
				{
					buf[i_] = buf[i_ + i1_];
				}
				e1 =(double) Math.Sqrt(rk2);

				//
				// Cycle
				//
				for (k = 0; k <= n - 1; k++)
				{

					//
					// Calculate A*p(k) - store in Buf[OffsTmp2:OffsTmp2+N-1]
					// and p(k)'*A*p(k)  - store in PAP
					//
					// If PAP=0, break (iteration is over)
					//
					ablas.rmatrixmv(m, n, a, 0, 0, 0, buf, offspk, ref buf, offstmp1);
					v1 = 0.0f;
					for (i_ = offstmp1; i_ <= offstmp1 + m - 1; i_++)
					{
						v1 += buf[i_] * buf[i_];
					}
					v2 = 0.0f;
					for (i_ = offspk; i_ <= offspk + n - 1; i_++)
					{
						v2 += buf[i_] * buf[i_];
					}
					pap = v1 + alpha * v2;
					ablas.rmatrixmv(n, m, a, 0, 0, 1, buf, offstmp1, ref buf, offstmp2);
					i1_ = (offspk) - (offstmp2);
					for (i_ = offstmp2; i_ <= offstmp2 + n - 1; i_++)
					{
						buf[i_] = buf[i_] + alpha * buf[i_ + i1_];
					}
					if ((double)(pap) == (double)(0))
					{
						break;
					}

					//
					// S = (r(k)'*r(k))/(p(k)'*A*p(k))
					//
					s = rk2 / pap;

					//
					// x(k+1) = x(k) + S*p(k)
					//
					i1_ = (offsxk) - (offsxk1);
					for (i_ = offsxk1; i_ <= offsxk1 + n - 1; i_++)
					{
						buf[i_] = buf[i_ + i1_];
					}
					i1_ = (offspk) - (offsxk1);
					for (i_ = offsxk1; i_ <= offsxk1 + n - 1; i_++)
					{
						buf[i_] = buf[i_] + s * buf[i_ + i1_];
					}

					//
					// r(k+1) = r(k) - S*A*p(k)
					// RK12 = r(k+1)'*r(k+1)
					//
					// Break if r(k+1) small enough (when compared to r(k))
					//
					i1_ = (offsrk) - (offsrk1);
					for (i_ = offsrk1; i_ <= offsrk1 + n - 1; i_++)
					{
						buf[i_] = buf[i_ + i1_];
					}
					i1_ = (offstmp2) - (offsrk1);
					for (i_ = offsrk1; i_ <= offsrk1 + n - 1; i_++)
					{
						buf[i_] = buf[i_] - s * buf[i_ + i1_];
					}
					rk12 = 0.0f;
					for (i_ = offsrk1; i_ <= offsrk1 + n - 1; i_++)
					{
						rk12 += buf[i_] * buf[i_];
					}
					if ((double)(Math.Sqrt(rk12)) <= (double)(100 * math.machineepsilon * Math.Sqrt(rk2)))
					{

						//
						// X(k) = x(k+1) before exit -
						// - because we expect to find solution at x(k)
						//
						i1_ = (offsxk1) - (offsxk);
						for (i_ = offsxk; i_ <= offsxk + n - 1; i_++)
						{
							buf[i_] = buf[i_ + i1_];
						}
						break;
					}

					//
					// BetaK = RK12/RK2
					// p(k+1) = r(k+1)+betak*p(k)
					//
					betak = rk12 / rk2;
					i1_ = (offsrk1) - (offspk1);
					for (i_ = offspk1; i_ <= offspk1 + n - 1; i_++)
					{
						buf[i_] = buf[i_ + i1_];
					}
					i1_ = (offspk) - (offspk1);
					for (i_ = offspk1; i_ <= offspk1 + n - 1; i_++)
					{
						buf[i_] = buf[i_] + betak * buf[i_ + i1_];
					}

					//
					// r(k) := r(k+1)
					// x(k) := x(k+1)
					// p(k) := p(k+1)
					//
					i1_ = (offsrk1) - (offsrk);
					for (i_ = offsrk; i_ <= offsrk + n - 1; i_++)
					{
						buf[i_] = buf[i_ + i1_];
					}
					i1_ = (offsxk1) - (offsxk);
					for (i_ = offsxk; i_ <= offsxk + n - 1; i_++)
					{
						buf[i_] = buf[i_ + i1_];
					}
					i1_ = (offspk1) - (offspk);
					for (i_ = offspk; i_ <= offspk + n - 1; i_++)
					{
						buf[i_] = buf[i_ + i1_];
					}
					rk2 = rk12;
				}

				//
				// Calculate E2
				//
				ablas.rmatrixmv(m, n, a, 0, 0, 0, buf, offsxk, ref buf, offstmp1);
				ablas.rmatrixmv(n, m, a, 0, 0, 1, buf, offstmp1, ref buf, offstmp2);
				i1_ = (offsxk) - (offstmp2);
				for (i_ = offstmp2; i_ <= offstmp2 + n - 1; i_++)
				{
					buf[i_] = buf[i_] + alpha * buf[i_ + i1_];
				}
				i1_ = (0) - (offsrk);
				for (i_ = offsrk; i_ <= offsrk + n - 1; i_++)
				{
					buf[i_] = b[i_ + i1_];
				}
				i1_ = (offstmp2) - (offsrk);
				for (i_ = offsrk; i_ <= offsrk + n - 1; i_++)
				{
					buf[i_] = buf[i_] - buf[i_ + i1_];
				}
				v1 = 0.0f;
				for (i_ = offsrk; i_ <= offsrk + n - 1; i_++)
				{
					v1 += buf[i_] * buf[i_];
				}
				e2 = (double)Math.Sqrt(v1);

				//
				// Output result (if it was improved)
				//
				if ((double)(e2) < (double)(e1))
				{
					i1_ = (offsxk) - (0);
					for (i_ = 0; i_ <= n - 1; i_++)
					{
						x[i_] = buf[i_ + i1_];
					}
				}
			}


			/*************************************************************************
			Construction of linear conjugate gradient solver.

			State parameter passed using "var" semantics (i.e. previous state  is  NOT
			erased). When it is already initialized, we can reause prevously allocated
			memory.

			INPUT PARAMETERS:
					X       -   initial solution
					B       -   right part
					N       -   system size
					State   -   structure; may be preallocated, if we want to reuse memory

			OUTPUT PARAMETERS:
					State   -   structure which is used by FBLSCGIteration() to store
											algorithm state between subsequent calls.

			NOTE: no error checking is done; caller must check all parameters, prevent
						overflows, and so on.

				-- ALGLIB --
					 Copyright 22.10.2009 by Bochkanov Sergey
			*************************************************************************/
			public static void fblscgcreate(double[] x,
					double[] b,
					int n,
					fblslincgstate state)
			{
				int i_ = 0;

				if (alglib.ap.len(state.b) < n)
				{
					state.b = new double[n];
				}
				if (alglib.ap.len(state.rk) < n)
				{
					state.rk = new double[n];
				}
				if (alglib.ap.len(state.rk1) < n)
				{
					state.rk1 = new double[n];
				}
				if (alglib.ap.len(state.xk) < n)
				{
					state.xk = new double[n];
				}
				if (alglib.ap.len(state.xk1) < n)
				{
					state.xk1 = new double[n];
				}
				if (alglib.ap.len(state.pk) < n)
				{
					state.pk = new double[n];
				}
				if (alglib.ap.len(state.pk1) < n)
				{
					state.pk1 = new double[n];
				}
				if (alglib.ap.len(state.tmp2) < n)
				{
					state.tmp2 = new double[n];
				}
				if (alglib.ap.len(state.x) < n)
				{
					state.x = new double[n];
				}
				if (alglib.ap.len(state.ax) < n)
				{
					state.ax = new double[n];
				}
				state.n = n;
				for (i_ = 0; i_ <= n - 1; i_++)
				{
					state.xk[i_] = x[i_];
				}
				for (i_ = 0; i_ <= n - 1; i_++)
				{
					state.b[i_] = b[i_];
				}
				state.rstate.ia = new int[1 + 1];
				state.rstate.ra = new double[6 + 1];
				state.rstate.stage = -1;
			}


			/*************************************************************************
			Linear CG solver, function relying on reverse communication to calculate
			matrix-vector products.

			See comments for FBLSLinCGState structure for more info.

				-- ALGLIB --
					 Copyright 22.10.2009 by Bochkanov Sergey
			*************************************************************************/
			public static bool fblscgiteration(fblslincgstate state)
			{
				bool result = new bool();
				int n = 0;
				int k = 0;
				double rk2 = 0;
				double rk12 = 0;
				double pap = 0;
				double s = 0;
				double betak = 0;
				double v1 = 0;
				double v2 = 0;
				int i_ = 0;


				//
				// Reverse communication preparations
				// I know it looks ugly, but it works the same way
				// anywhere from C++ to Python.
				//
				// This code initializes locals by:
				// * random values determined during code
				//   generation - on first subroutine call
				// * values from previous call - on subsequent calls
				//
				if (state.rstate.stage >= 0)
				{
					n = state.rstate.ia[0];
					k = state.rstate.ia[1];
					rk2 = state.rstate.ra[0];
					rk12 = state.rstate.ra[1];
					pap = state.rstate.ra[2];
					s = state.rstate.ra[3];
					betak = state.rstate.ra[4];
					v1 = state.rstate.ra[5];
					v2 = state.rstate.ra[6];
				}
				else
				{
					n = -983;
					k = -989;
					rk2 = -834;
					rk12 = 900;
					pap = -287;
					s = 364;
					betak = 214;
					v1 = -338;
					v2 = -686;
				}
				if (state.rstate.stage == 0)
				{
					goto lbl_0;
				}
				if (state.rstate.stage == 1)
				{
					goto lbl_1;
				}
				if (state.rstate.stage == 2)
				{
					goto lbl_2;
				}

				//
				// Routine body
				//

				//
				// prepare locals
				//
				n = state.n;

				//
				// Test for special case: B=0
				//
				v1 = 0.0f;
				for (i_ = 0; i_ <= n - 1; i_++)
				{
					v1 += state.b[i_] * state.b[i_];
				}
				if ((double)(v1) == (double)(0))
				{
					for (k = 0; k <= n - 1; k++)
					{
						state.xk[k] = 0;
					}
					result = false;
					return result;
				}

				//
				// r(0) = b-A*x(0)
				// RK2 = r(0)'*r(0)
				//
				for (i_ = 0; i_ <= n - 1; i_++)
				{
					state.x[i_] = state.xk[i_];
				}
				state.rstate.stage = 0;
				goto lbl_rcomm;
			lbl_0:
				for (i_ = 0; i_ <= n - 1; i_++)
				{
					state.rk[i_] = state.b[i_];
				}
				for (i_ = 0; i_ <= n - 1; i_++)
				{
					state.rk[i_] = state.rk[i_] - state.ax[i_];
				}
				rk2 = 0.0f;
				for (i_ = 0; i_ <= n - 1; i_++)
				{
					rk2 += state.rk[i_] * state.rk[i_];
				}
				for (i_ = 0; i_ <= n - 1; i_++)
				{
					state.pk[i_] = state.rk[i_];
				}
				state.e1 = (double)Math.Sqrt(rk2);

				//
				// Cycle
				//
				k = 0;
			lbl_3:
				if (k > n - 1)
				{
					goto lbl_5;
				}

				//
				// Calculate A*p(k) - store in State.Tmp2
				// and p(k)'*A*p(k)  - store in PAP
				//
				// If PAP=0, break (iteration is over)
				//
				for (i_ = 0; i_ <= n - 1; i_++)
				{
					state.x[i_] = state.pk[i_];
				}
				state.rstate.stage = 1;
				goto lbl_rcomm;
			lbl_1:
				for (i_ = 0; i_ <= n - 1; i_++)
				{
					state.tmp2[i_] = state.ax[i_];
				}
				pap = state.xax;
				if (!math.isfinite(pap))
				{
					goto lbl_5;
				}
				if ((double)(pap) <= (double)(0))
				{
					goto lbl_5;
				}

				//
				// S = (r(k)'*r(k))/(p(k)'*A*p(k))
				//
				s = rk2 / pap;

				//
				// x(k+1) = x(k) + S*p(k)
				//
				for (i_ = 0; i_ <= n - 1; i_++)
				{
					state.xk1[i_] = state.xk[i_];
				}
				for (i_ = 0; i_ <= n - 1; i_++)
				{
					state.xk1[i_] = state.xk1[i_] + s * state.pk[i_];
				}

				//
				// r(k+1) = r(k) - S*A*p(k)
				// RK12 = r(k+1)'*r(k+1)
				//
				// Break if r(k+1) small enough (when compared to r(k))
				//
				for (i_ = 0; i_ <= n - 1; i_++)
				{
					state.rk1[i_] = state.rk[i_];
				}
				for (i_ = 0; i_ <= n - 1; i_++)
				{
					state.rk1[i_] = state.rk1[i_] - s * state.tmp2[i_];
				}
				rk12 = 0.0f;
				for (i_ = 0; i_ <= n - 1; i_++)
				{
					rk12 += state.rk1[i_] * state.rk1[i_];
				}
				if ((double)(Math.Sqrt(rk12)) <= (double)(100 * math.machineepsilon * state.e1))
				{

					//
					// X(k) = x(k+1) before exit -
					// - because we expect to find solution at x(k)
					//
					for (i_ = 0; i_ <= n - 1; i_++)
					{
						state.xk[i_] = state.xk1[i_];
					}
					goto lbl_5;
				}

				//
				// BetaK = RK12/RK2
				// p(k+1) = r(k+1)+betak*p(k)
				//
				// NOTE: we expect that BetaK won't overflow because of
				// "Sqrt(RK12)<=100*MachineEpsilon*E1" test above.
				//
				betak = rk12 / rk2;
				for (i_ = 0; i_ <= n - 1; i_++)
				{
					state.pk1[i_] = state.rk1[i_];
				}
				for (i_ = 0; i_ <= n - 1; i_++)
				{
					state.pk1[i_] = state.pk1[i_] + betak * state.pk[i_];
				}

				//
				// r(k) := r(k+1)
				// x(k) := x(k+1)
				// p(k) := p(k+1)
				//
				for (i_ = 0; i_ <= n - 1; i_++)
				{
					state.rk[i_] = state.rk1[i_];
				}
				for (i_ = 0; i_ <= n - 1; i_++)
				{
					state.xk[i_] = state.xk1[i_];
				}
				for (i_ = 0; i_ <= n - 1; i_++)
				{
					state.pk[i_] = state.pk1[i_];
				}
				rk2 = rk12;
				k = k + 1;
				goto lbl_3;
			lbl_5:

				//
				// Calculate E2
				//
				for (i_ = 0; i_ <= n - 1; i_++)
				{
					state.x[i_] = state.xk[i_];
				}
				state.rstate.stage = 2;
				goto lbl_rcomm;
			lbl_2:
				for (i_ = 0; i_ <= n - 1; i_++)
				{
					state.rk[i_] = state.b[i_];
				}
				for (i_ = 0; i_ <= n - 1; i_++)
				{
					state.rk[i_] = state.rk[i_] - state.ax[i_];
				}
				v1 = 0.0f;
				for (i_ = 0; i_ <= n - 1; i_++)
				{
					v1 += state.rk[i_] * state.rk[i_];
				}
				state.e2 = (double)Math.Sqrt(v1);
				result = false;
				return result;

					//
			// Saving state
			//
			lbl_rcomm:
				result = true;
				state.rstate.ia[0] = n;
				state.rstate.ia[1] = k;
				state.rstate.ra[0] = rk2;
				state.rstate.ra[1] = rk12;
				state.rstate.ra[2] = pap;
				state.rstate.ra[3] = s;
				state.rstate.ra[4] = betak;
				state.rstate.ra[5] = v1;
				state.rstate.ra[6] = v2;
				return result;
			}


			/*************************************************************************
			Fast  least  squares  solver,  solves  well  conditioned  system   without
			performing  any  checks  for  degeneracy,  and using user-provided buffers
			(which are automatically reallocated if too small).

			This  function  is  intended  for solution of moderately sized systems. It
			uses factorization algorithms based on Level 2 BLAS  operations,  thus  it
			won't work efficiently on large scale systems.

			INPUT PARAMETERS:
					A       -   array[M,N], system matrix.
											Contents of A is destroyed during solution.
					B       -   array[M], right part
					M       -   number of equations
					N       -   number of variables, N<=M
					Tmp0, Tmp1, Tmp2-
											buffers; function automatically allocates them, if they are
											too  small. They can  be  reused  if  function  is   called 
											several times.
                        
			OUTPUT PARAMETERS:
					B       -   solution (first N components, next M-N are zero)

				-- ALGLIB --
					 Copyright 20.01.2012 by Bochkanov Sergey
			*************************************************************************/
			public static void fblssolvels(ref double[,] a,
					ref double[] b,
					int m,
					int n,
					ref double[] tmp0,
					ref double[] tmp1,
					ref double[] tmp2)
			{
				int i = 0;
				int k = 0;
				double v = 0;
				int i_ = 0;

				alglib.ap.assert(n > 0, "FBLSSolveLS: N<=0");
				alglib.ap.assert(m >= n, "FBLSSolveLS: M<N");
				alglib.ap.assert(alglib.ap.rows(a) >= m, "FBLSSolveLS: Rows(A)<M");
				alglib.ap.assert(alglib.ap.cols(a) >= n, "FBLSSolveLS: Cols(A)<N");
				alglib.ap.assert(alglib.ap.len(b) >= m, "FBLSSolveLS: Length(B)<M");

				//
				// Allocate temporaries
				//
				apserv.rvectorsetlengthatleast(ref tmp0, Math.Max(m, n) + 1);
				apserv.rvectorsetlengthatleast(ref tmp1, Math.Max(m, n) + 1);
				apserv.rvectorsetlengthatleast(ref tmp2, Math.Min(m, n));

				//
				// Call basecase QR
				//
				ortfac.rmatrixqrbasecase(ref a, m, n, ref tmp0, ref tmp1, ref tmp2);

				//
				// Multiply B by Q'
				//
				for (k = 0; k <= n - 1; k++)
				{
					for (i = 0; i <= k - 1; i++)
					{
						tmp0[i] = 0;
					}
					for (i_ = k; i_ <= m - 1; i_++)
					{
						tmp0[i_] = a[i_, k];
					}
					tmp0[k] = 1;
					v = 0.0f;
					for (i_ = k; i_ <= m - 1; i_++)
					{
						v += tmp0[i_] * b[i_];
					}
					v = v * tmp2[k];
					for (i_ = k; i_ <= m - 1; i_++)
					{
						b[i_] = b[i_] - v * tmp0[i_];
					}
				}

				//
				// Solve triangular system
				//
				b[n - 1] = b[n - 1] / a[n - 1, n - 1];
				for (i = n - 2; i >= 0; i--)
				{
					v = 0.0f;
					for (i_ = i + 1; i_ <= n - 1; i_++)
					{
						v += a[i, i_] * b[i_];
					}
					b[i] = (b[i] - v) / a[i, i];
				}
				for (i = n; i <= m - 1; i++)
				{
					b[i] = 0.0f;
				}
			}


		}
		public class normestimator
		{
			/*************************************************************************
			This object stores state of the iterative norm estimation algorithm.

			You should use ALGLIB functions to work with this object.
			*************************************************************************/
			public class normestimatorstate : apobject
			{
				public int n;
				public int m;
				public int nstart;
				public int nits;
				public int seedval;
				public double[] x0;
				public double[] x1;
				public double[] t;
				public double[] xbest;
				public hqrnd.hqrndstate r;
				public double[] x;
				public double[] mv;
				public double[] mtv;
				public bool needmv;
				public bool needmtv;
				public double repnorm;
				public rcommstate rstate;
				public normestimatorstate()
				{
					init();
				}
				public override void init()
				{
					x0 = new double[0];
					x1 = new double[0];
					t = new double[0];
					xbest = new double[0];
					r = new hqrnd.hqrndstate();
					x = new double[0];
					mv = new double[0];
					mtv = new double[0];
					rstate = new rcommstate();
				}
				public override alglib.apobject make_copy()
				{
					normestimatorstate _result = new normestimatorstate();
					_result.n = n;
					_result.m = m;
					_result.nstart = nstart;
					_result.nits = nits;
					_result.seedval = seedval;
					_result.x0 = (double[])x0.Clone();
					_result.x1 = (double[])x1.Clone();
					_result.t = (double[])t.Clone();
					_result.xbest = (double[])xbest.Clone();
					_result.r = (hqrnd.hqrndstate)r.make_copy();
					_result.x = (double[])x.Clone();
					_result.mv = (double[])mv.Clone();
					_result.mtv = (double[])mtv.Clone();
					_result.needmv = needmv;
					_result.needmtv = needmtv;
					_result.repnorm = repnorm;
					_result.rstate = (rcommstate)rstate.make_copy();
					return _result;
				}
			};




			/*************************************************************************
			This procedure initializes matrix norm estimator.

			USAGE:
			1. User initializes algorithm state with NormEstimatorCreate() call
			2. User calls NormEstimatorEstimateSparse() (or NormEstimatorIteration())
			3. User calls NormEstimatorResults() to get solution.
           
			INPUT PARAMETERS:
					M       -   number of rows in the matrix being estimated, M>0
					N       -   number of columns in the matrix being estimated, N>0
					NStart  -   number of random starting vectors
											recommended value - at least 5.
					NIts    -   number of iterations to do with best starting vector
											recommended value - at least 5.

			OUTPUT PARAMETERS:
					State   -   structure which stores algorithm state

            
			NOTE: this algorithm is effectively deterministic, i.e. it always  returns
			same result when repeatedly called for the same matrix. In fact, algorithm
			uses randomized starting vectors, but internal  random  numbers  generator
			always generates same sequence of the random values (it is a  feature, not
			bug).

			Algorithm can be made non-deterministic with NormEstimatorSetSeed(0) call.

				-- ALGLIB --
					 Copyright 06.12.2011 by Bochkanov Sergey
			*************************************************************************/
			public static void normestimatorcreate(int m,
					int n,
					int nstart,
					int nits,
					normestimatorstate state)
			{
				alglib.ap.assert(m > 0, "NormEstimatorCreate: M<=0");
				alglib.ap.assert(n > 0, "NormEstimatorCreate: N<=0");
				alglib.ap.assert(nstart > 0, "NormEstimatorCreate: NStart<=0");
				alglib.ap.assert(nits > 0, "NormEstimatorCreate: NIts<=0");
				state.m = m;
				state.n = n;
				state.nstart = nstart;
				state.nits = nits;
				state.seedval = 11;
				hqrnd.hqrndrandomize(state.r);
				state.x0 = new double[state.n];
				state.t = new double[state.m];
				state.x1 = new double[state.n];
				state.xbest = new double[state.n];
				state.x = new double[Math.Max(state.n, state.m)];
				state.mv = new double[state.m];
				state.mtv = new double[state.n];
				state.rstate.ia = new int[3 + 1];
				state.rstate.ra = new double[2 + 1];
				state.rstate.stage = -1;
			}


			/*************************************************************************
			This function changes seed value used by algorithm. In some cases we  need
			deterministic processing, i.e. subsequent calls must return equal results,
			in other cases we need non-deterministic algorithm which returns different
			results for the same matrix on every pass.

			Setting zero seed will lead to non-deterministic algorithm, while non-zero 
			value will make our algorithm deterministic.

			INPUT PARAMETERS:
					State       -   norm estimator state, must be initialized with a  call
													to NormEstimatorCreate()
					SeedVal     -   seed value, >=0. Zero value = non-deterministic algo.

				-- ALGLIB --
					 Copyright 06.12.2011 by Bochkanov Sergey
			*************************************************************************/
			public static void normestimatorsetseed(normestimatorstate state,
					int seedval)
			{
				alglib.ap.assert(seedval >= 0, "NormEstimatorSetSeed: SeedVal<0");
				state.seedval = seedval;
			}


			/*************************************************************************

				-- ALGLIB --
					 Copyright 06.12.2011 by Bochkanov Sergey
			*************************************************************************/
			public static bool normestimatoriteration(normestimatorstate state)
			{
				bool result = new bool();
				int n = 0;
				int m = 0;
				int i = 0;
				int itcnt = 0;
				double v = 0;
				double growth = 0;
				double bestgrowth = 0;
				int i_ = 0;


				//
				// Reverse communication preparations
				// I know it looks ugly, but it works the same way
				// anywhere from C++ to Python.
				//
				// This code initializes locals by:
				// * random values determined during code
				//   generation - on first subroutine call
				// * values from previous call - on subsequent calls
				//
				if (state.rstate.stage >= 0)
				{
					n = state.rstate.ia[0];
					m = state.rstate.ia[1];
					i = state.rstate.ia[2];
					itcnt = state.rstate.ia[3];
					v = state.rstate.ra[0];
					growth = state.rstate.ra[1];
					bestgrowth = state.rstate.ra[2];
				}
				else
				{
					n = -983;
					m = -989;
					i = -834;
					itcnt = 900;
					v = -287;
					growth = 364;
					bestgrowth = 214;
				}
				if (state.rstate.stage == 0)
				{
					goto lbl_0;
				}
				if (state.rstate.stage == 1)
				{
					goto lbl_1;
				}
				if (state.rstate.stage == 2)
				{
					goto lbl_2;
				}
				if (state.rstate.stage == 3)
				{
					goto lbl_3;
				}

				//
				// Routine body
				//
				n = state.n;
				m = state.m;
				if (state.seedval > 0)
				{
					hqrnd.hqrndseed(state.seedval, state.seedval + 2, state.r);
				}
				bestgrowth = 0;
				state.xbest[0] = 1;
				for (i = 1; i <= n - 1; i++)
				{
					state.xbest[i] = 0;
				}
				itcnt = 0;
			lbl_4:
				if (itcnt > state.nstart - 1)
				{
					goto lbl_6;
				}
				do
				{
					v = 0;
					for (i = 0; i <= n - 1; i++)
					{
						state.x0[i] = hqrnd.hqrndnormal(state.r);
						v = v + math.sqr(state.x0[i]);
					}
				}
				while ((double)(v) == (double)(0));
				v = (double)(1 / Math.Sqrt(v));
				for (i_ = 0; i_ <= n - 1; i_++)
				{
					state.x0[i_] = v * state.x0[i_];
				}
				for (i_ = 0; i_ <= n - 1; i_++)
				{
					state.x[i_] = state.x0[i_];
				}
				state.needmv = true;
				state.needmtv = false;
				state.rstate.stage = 0;
				goto lbl_rcomm;
			lbl_0:
				for (i_ = 0; i_ <= m - 1; i_++)
				{
					state.x[i_] = state.mv[i_];
				}
				state.needmv = false;
				state.needmtv = true;
				state.rstate.stage = 1;
				goto lbl_rcomm;
			lbl_1:
				for (i_ = 0; i_ <= n - 1; i_++)
				{
					state.x1[i_] = state.mtv[i_];
				}
				v = 0;
				for (i = 0; i <= n - 1; i++)
				{
					v = v + math.sqr(state.x1[i]);
				}
				growth = (double)Math.Sqrt(Math.Sqrt(v));
				if ((double)(growth) > (double)(bestgrowth))
				{
					v = (double)(1 / Math.Sqrt(v));
					for (i_ = 0; i_ <= n - 1; i_++)
					{
						state.xbest[i_] = v * state.x1[i_];
					}
					bestgrowth = growth;
				}
				itcnt = itcnt + 1;
				goto lbl_4;
			lbl_6:
				for (i_ = 0; i_ <= n - 1; i_++)
				{
					state.x0[i_] = state.xbest[i_];
				}
				itcnt = 0;
			lbl_7:
				if (itcnt > state.nits - 1)
				{
					goto lbl_9;
				}
				for (i_ = 0; i_ <= n - 1; i_++)
				{
					state.x[i_] = state.x0[i_];
				}
				state.needmv = true;
				state.needmtv = false;
				state.rstate.stage = 2;
				goto lbl_rcomm;
			lbl_2:
				for (i_ = 0; i_ <= m - 1; i_++)
				{
					state.x[i_] = state.mv[i_];
				}
				state.needmv = false;
				state.needmtv = true;
				state.rstate.stage = 3;
				goto lbl_rcomm;
			lbl_3:
				for (i_ = 0; i_ <= n - 1; i_++)
				{
					state.x1[i_] = state.mtv[i_];
				}
				v = 0;
				for (i = 0; i <= n - 1; i++)
				{
					v = v + math.sqr(state.x1[i]);
				}
				state.repnorm = (double)Math.Sqrt(Math.Sqrt(v));
				if ((double)(v) != (double)(0))
				{
					v = (double)(1 / Math.Sqrt(v));
					for (i_ = 0; i_ <= n - 1; i_++)
					{
						state.x0[i_] = v * state.x1[i_];
					}
				}
				itcnt = itcnt + 1;
				goto lbl_7;
			lbl_9:
				result = false;
				return result;

					//
			// Saving state
			//
			lbl_rcomm:
				result = true;
				state.rstate.ia[0] = n;
				state.rstate.ia[1] = m;
				state.rstate.ia[2] = i;
				state.rstate.ia[3] = itcnt;
				state.rstate.ra[0] = v;
				state.rstate.ra[1] = growth;
				state.rstate.ra[2] = bestgrowth;
				return result;
			}


			/*************************************************************************
			This function estimates norm of the sparse M*N matrix A.

			INPUT PARAMETERS:
					State       -   norm estimator state, must be initialized with a  call
													to NormEstimatorCreate()
					A           -   sparse M*N matrix, must be converted to CRS format
													prior to calling this function.

			After this function  is  over  you can call NormEstimatorResults() to get 
			estimate of the norm(A).

				-- ALGLIB --
					 Copyright 06.12.2011 by Bochkanov Sergey
			*************************************************************************/
			public static void normestimatorestimatesparse(normestimatorstate state,
					sparse.sparsematrix a)
			{
				normestimatorrestart(state);
				while (normestimatoriteration(state))
				{
					if (state.needmv)
					{
						sparse.sparsemv(a, state.x, ref state.mv);
						continue;
					}
					if (state.needmtv)
					{
						sparse.sparsemtv(a, state.x, ref state.mtv);
						continue;
					}
				}
			}


			/*************************************************************************
			Matrix norm estimation results

			INPUT PARAMETERS:
					State   -   algorithm state

			OUTPUT PARAMETERS:
					Nrm     -   estimate of the matrix norm, Nrm>=0

				-- ALGLIB --
					 Copyright 06.12.2011 by Bochkanov Sergey
			*************************************************************************/
			public static void normestimatorresults(normestimatorstate state,
					ref double nrm)
			{
				nrm = 0;

				nrm = state.repnorm;
			}


			/*************************************************************************
			This  function  restarts estimator and prepares it for the next estimation
			round.

			INPUT PARAMETERS:
					State   -   algorithm state
				-- ALGLIB --
					 Copyright 06.12.2011 by Bochkanov Sergey
			*************************************************************************/
			public static void normestimatorrestart(normestimatorstate state)
			{
				state.rstate.ia = new int[3 + 1];
				state.rstate.ra = new double[2 + 1];
				state.rstate.stage = -1;
			}


		}
		public class matdet
		{
			/*************************************************************************
			Determinant calculation of the matrix given by its LU decomposition.

			Input parameters:
					A       -   LU decomposition of the matrix (output of
											RMatrixLU subroutine).
					Pivots  -   table of permutations which were made during
											the LU decomposition.
											Output of RMatrixLU subroutine.
					N       -   (optional) size of matrix A:
											* if given, only principal NxN submatrix is processed and
												overwritten. other elements are unchanged.
											* if not given, automatically determined from matrix size
												(A must be square matrix)

			Result: matrix determinant.

				-- ALGLIB --
					 Copyright 2005 by Bochkanov Sergey
			*************************************************************************/
			public static double rmatrixludet(double[,] a,
					int[] pivots,
					int n)
			{
				double result = 0;
				int i = 0;
				int s = 0;

				alglib.ap.assert(n >= 1, "RMatrixLUDet: N<1!");
				alglib.ap.assert(alglib.ap.len(pivots) >= n, "RMatrixLUDet: Pivots array is too short!");
				alglib.ap.assert(alglib.ap.rows(a) >= n, "RMatrixLUDet: rows(A)<N!");
				alglib.ap.assert(alglib.ap.cols(a) >= n, "RMatrixLUDet: cols(A)<N!");
				alglib.ap.assert(apserv.apservisfinitematrix(a, n, n), "RMatrixLUDet: A contains infinite or NaN values!");
				result = 1;
				s = 1;
				for (i = 0; i <= n - 1; i++)
				{
					result = result * a[i, i];
					if (pivots[i] != i)
					{
						s = -s;
					}
				}
				result = result * s;
				return result;
			}


			/*************************************************************************
			Calculation of the determinant of a general matrix

			Input parameters:
					A       -   matrix, array[0..N-1, 0..N-1]
					N       -   (optional) size of matrix A:
											* if given, only principal NxN submatrix is processed and
												overwritten. other elements are unchanged.
											* if not given, automatically determined from matrix size
												(A must be square matrix)

			Result: determinant of matrix A.

				-- ALGLIB --
					 Copyright 2005 by Bochkanov Sergey
			*************************************************************************/
			public static double rmatrixdet(double[,] a,
					int n)
			{
				double result = 0;
				int[] pivots = new int[0];

				a = (double[,])a.Clone();

				alglib.ap.assert(n >= 1, "RMatrixDet: N<1!");
				alglib.ap.assert(alglib.ap.rows(a) >= n, "RMatrixDet: rows(A)<N!");
				alglib.ap.assert(alglib.ap.cols(a) >= n, "RMatrixDet: cols(A)<N!");
				alglib.ap.assert(apserv.apservisfinitematrix(a, n, n), "RMatrixDet: A contains infinite or NaN values!");
				trfac.rmatrixlu(ref a, n, n, ref pivots);
				result = rmatrixludet(a, pivots, n);
				return result;
			}


			/*************************************************************************
			Determinant calculation of the matrix given by its LU decomposition.

			Input parameters:
					A       -   LU decomposition of the matrix (output of
											RMatrixLU subroutine).
					Pivots  -   table of permutations which were made during
											the LU decomposition.
											Output of RMatrixLU subroutine.
					N       -   (optional) size of matrix A:
											* if given, only principal NxN submatrix is processed and
												overwritten. other elements are unchanged.
											* if not given, automatically determined from matrix size
												(A must be square matrix)

			Result: matrix determinant.

				-- ALGLIB --
					 Copyright 2005 by Bochkanov Sergey
			*************************************************************************/
			public static complex cmatrixludet(complex[,] a,
					int[] pivots,
					int n)
			{
				complex result = 0;
				int i = 0;
				int s = 0;

				alglib.ap.assert(n >= 1, "CMatrixLUDet: N<1!");
				alglib.ap.assert(alglib.ap.len(pivots) >= n, "CMatrixLUDet: Pivots array is too short!");
				alglib.ap.assert(alglib.ap.rows(a) >= n, "CMatrixLUDet: rows(A)<N!");
				alglib.ap.assert(alglib.ap.cols(a) >= n, "CMatrixLUDet: cols(A)<N!");
				alglib.ap.assert(apserv.apservisfinitecmatrix(a, n, n), "CMatrixLUDet: A contains infinite or NaN values!");
				result = 1;
				s = 1;
				for (i = 0; i <= n - 1; i++)
				{
					result = result * a[i, i];
					if (pivots[i] != i)
					{
						s = -s;
					}
				}
				result = result * s;
				return result;
			}


			/*************************************************************************
			Calculation of the determinant of a general matrix

			Input parameters:
					A       -   matrix, array[0..N-1, 0..N-1]
					N       -   (optional) size of matrix A:
											* if given, only principal NxN submatrix is processed and
												overwritten. other elements are unchanged.
											* if not given, automatically determined from matrix size
												(A must be square matrix)

			Result: determinant of matrix A.

				-- ALGLIB --
					 Copyright 2005 by Bochkanov Sergey
			*************************************************************************/
			public static complex cmatrixdet(complex[,] a,
					int n)
			{
				complex result = 0;
				int[] pivots = new int[0];

				a = (complex[,])a.Clone();

				alglib.ap.assert(n >= 1, "CMatrixDet: N<1!");
				alglib.ap.assert(alglib.ap.rows(a) >= n, "CMatrixDet: rows(A)<N!");
				alglib.ap.assert(alglib.ap.cols(a) >= n, "CMatrixDet: cols(A)<N!");
				alglib.ap.assert(apserv.apservisfinitecmatrix(a, n, n), "CMatrixDet: A contains infinite or NaN values!");
				trfac.cmatrixlu(ref a, n, n, ref pivots);
				result = cmatrixludet(a, pivots, n);
				return result;
			}


			/*************************************************************************
			Determinant calculation of the matrix given by the Cholesky decomposition.

			Input parameters:
					A       -   Cholesky decomposition,
											output of SMatrixCholesky subroutine.
					N       -   (optional) size of matrix A:
											* if given, only principal NxN submatrix is processed and
												overwritten. other elements are unchanged.
											* if not given, automatically determined from matrix size
												(A must be square matrix)

			As the determinant is equal to the product of squares of diagonal elements,
			it’s not necessary to specify which triangle - lower or upper - the matrix
			is stored in.

			Result:
					matrix determinant.

				-- ALGLIB --
					 Copyright 2005-2008 by Bochkanov Sergey
			*************************************************************************/
			public static double spdmatrixcholeskydet(double[,] a,
					int n)
			{
				double result = 0;
				int i = 0;
				bool f = new bool();

				alglib.ap.assert(n >= 1, "SPDMatrixCholeskyDet: N<1!");
				alglib.ap.assert(alglib.ap.rows(a) >= n, "SPDMatrixCholeskyDet: rows(A)<N!");
				alglib.ap.assert(alglib.ap.cols(a) >= n, "SPDMatrixCholeskyDet: cols(A)<N!");
				f = true;
				for (i = 0; i <= n - 1; i++)
				{
					f = f && math.isfinite(a[i, i]);
				}
				alglib.ap.assert(f, "SPDMatrixCholeskyDet: A contains infinite or NaN values!");
				result = 1;
				for (i = 0; i <= n - 1; i++)
				{
					result = result * math.sqr(a[i, i]);
				}
				return result;
			}


			/*************************************************************************
			Determinant calculation of the symmetric positive definite matrix.

			Input parameters:
					A       -   matrix. Array with elements [0..N-1, 0..N-1].
					N       -   (optional) size of matrix A:
											* if given, only principal NxN submatrix is processed and
												overwritten. other elements are unchanged.
											* if not given, automatically determined from matrix size
												(A must be square matrix)
					IsUpper -   (optional) storage type:
											* if True, symmetric matrix  A  is  given  by  its  upper
												triangle, and the lower triangle isn’t used/changed  by
												function
											* if False, symmetric matrix  A  is  given  by  its lower
												triangle, and the upper triangle isn’t used/changed  by
												function
											* if not given, both lower and upper  triangles  must  be
												filled.

			Result:
					determinant of matrix A.
					If matrix A is not positive definite, exception is thrown.

				-- ALGLIB --
					 Copyright 2005-2008 by Bochkanov Sergey
			*************************************************************************/
			public static double spdmatrixdet(double[,] a,
					int n,
					bool isupper)
			{
				double result = 0;
				bool b = new bool();

				a = (double[,])a.Clone();

				alglib.ap.assert(n >= 1, "SPDMatrixDet: N<1!");
				alglib.ap.assert(alglib.ap.rows(a) >= n, "SPDMatrixDet: rows(A)<N!");
				alglib.ap.assert(alglib.ap.cols(a) >= n, "SPDMatrixDet: cols(A)<N!");
				alglib.ap.assert(apserv.isfinitertrmatrix(a, n, isupper), "SPDMatrixDet: A contains infinite or NaN values!");
				b = trfac.spdmatrixcholesky(ref a, n, isupper);
				alglib.ap.assert(b, "SPDMatrixDet: A is not SPD!");
				result = spdmatrixcholeskydet(a, n);
				return result;
			}


		}
		public class spdgevd
		{
			/*************************************************************************
			Algorithm for solving the following generalized symmetric positive-definite
			eigenproblem:
					A*x = lambda*B*x (1) or
					A*B*x = lambda*x (2) or
					B*A*x = lambda*x (3).
			where A is a symmetric matrix, B - symmetric positive-definite matrix.
			The problem is solved by reducing it to an ordinary  symmetric  eigenvalue
			problem.

			Input parameters:
					A           -   symmetric matrix which is given by its upper or lower
													triangular part.
													Array whose indexes range within [0..N-1, 0..N-1].
					N           -   size of matrices A and B.
					IsUpperA    -   storage format of matrix A.
					B           -   symmetric positive-definite matrix which is given by
													its upper or lower triangular part.
													Array whose indexes range within [0..N-1, 0..N-1].
					IsUpperB    -   storage format of matrix B.
					ZNeeded     -   if ZNeeded is equal to:
													 * 0, the eigenvectors are not returned;
													 * 1, the eigenvectors are returned.
					ProblemType -   if ProblemType is equal to:
													 * 1, the following problem is solved: A*x = lambda*B*x;
													 * 2, the following problem is solved: A*B*x = lambda*x;
													 * 3, the following problem is solved: B*A*x = lambda*x.

			Output parameters:
					D           -   eigenvalues in ascending order.
													Array whose index ranges within [0..N-1].
					Z           -   if ZNeeded is equal to:
													 * 0, Z hasn’t changed;
													 * 1, Z contains eigenvectors.
													Array whose indexes range within [0..N-1, 0..N-1].
													The eigenvectors are stored in matrix columns. It should
													be noted that the eigenvectors in such problems do not
													form an orthogonal system.

			Result:
					True, if the problem was solved successfully.
					False, if the error occurred during the Cholesky decomposition of matrix
					B (the matrix isn’t positive-definite) or during the work of the iterative
					algorithm for solving the symmetric eigenproblem.

			See also the GeneralizedSymmetricDefiniteEVDReduce subroutine.

				-- ALGLIB --
					 Copyright 1.28.2006 by Bochkanov Sergey
			*************************************************************************/
			public static bool smatrixgevd(double[,] a,
					int n,
					bool isuppera,
					double[,] b,
					bool isupperb,
					int zneeded,
					int problemtype,
					ref double[] d,
					ref double[,] z)
			{
				bool result = new bool();
				double[,] r = new double[0, 0];
				double[,] t = new double[0, 0];
				bool isupperr = new bool();
				int j1 = 0;
				int j2 = 0;
				int j1inc = 0;
				int j2inc = 0;
				int i = 0;
				int j = 0;
				double v = 0;
				int i_ = 0;

				a = (double[,])a.Clone();
				d = new double[0];
				z = new double[0, 0];


				//
				// Reduce and solve
				//
				result = smatrixgevdreduce(ref a, n, isuppera, b, isupperb, problemtype, ref r, ref isupperr);
				if (!result)
				{
					return result;
				}
				result = evd.smatrixevd(a, n, zneeded, isuppera, ref d, ref t);
				if (!result)
				{
					return result;
				}

				//
				// Transform eigenvectors if needed
				//
				if (zneeded != 0)
				{

					//
					// fill Z with zeros
					//
					z = new double[n - 1 + 1, n - 1 + 1];
					for (j = 0; j <= n - 1; j++)
					{
						z[0, j] = 0.0f;
					}
					for (i = 1; i <= n - 1; i++)
					{
						for (i_ = 0; i_ <= n - 1; i_++)
						{
							z[i, i_] = z[0, i_];
						}
					}

					//
					// Setup R properties
					//
					if (isupperr)
					{
						j1 = 0;
						j2 = n - 1;
						j1inc = 1;
						j2inc = 0;
					}
					else
					{
						j1 = 0;
						j2 = 0;
						j1inc = 0;
						j2inc = 1;
					}

					//
					// Calculate R*Z
					//
					for (i = 0; i <= n - 1; i++)
					{
						for (j = j1; j <= j2; j++)
						{
							v = r[i, j];
							for (i_ = 0; i_ <= n - 1; i_++)
							{
								z[i, i_] = z[i, i_] + v * t[j, i_];
							}
						}
						j1 = j1 + j1inc;
						j2 = j2 + j2inc;
					}
				}
				return result;
			}


			/*************************************************************************
			Algorithm for reduction of the following generalized symmetric positive-
			definite eigenvalue problem:
					A*x = lambda*B*x (1) or
					A*B*x = lambda*x (2) or
					B*A*x = lambda*x (3)
			to the symmetric eigenvalues problem C*y = lambda*y (eigenvalues of this and
			the given problems are the same, and the eigenvectors of the given problem
			could be obtained by multiplying the obtained eigenvectors by the
			transformation matrix x = R*y).

			Here A is a symmetric matrix, B - symmetric positive-definite matrix.

			Input parameters:
					A           -   symmetric matrix which is given by its upper or lower
													triangular part.
													Array whose indexes range within [0..N-1, 0..N-1].
					N           -   size of matrices A and B.
					IsUpperA    -   storage format of matrix A.
					B           -   symmetric positive-definite matrix which is given by
													its upper or lower triangular part.
													Array whose indexes range within [0..N-1, 0..N-1].
					IsUpperB    -   storage format of matrix B.
					ProblemType -   if ProblemType is equal to:
													 * 1, the following problem is solved: A*x = lambda*B*x;
													 * 2, the following problem is solved: A*B*x = lambda*x;
													 * 3, the following problem is solved: B*A*x = lambda*x.

			Output parameters:
					A           -   symmetric matrix which is given by its upper or lower
													triangle depending on IsUpperA. Contains matrix C.
													Array whose indexes range within [0..N-1, 0..N-1].
					R           -   upper triangular or low triangular transformation matrix
													which is used to obtain the eigenvectors of a given problem
													as the product of eigenvectors of C (from the right) and
													matrix R (from the left). If the matrix is upper
													triangular, the elements below the main diagonal
													are equal to 0 (and vice versa). Thus, we can perform
													the multiplication without taking into account the
													internal structure (which is an easier though less
													effective way).
													Array whose indexes range within [0..N-1, 0..N-1].
					IsUpperR    -   type of matrix R (upper or lower triangular).

			Result:
					True, if the problem was reduced successfully.
					False, if the error occurred during the Cholesky decomposition of
							matrix B (the matrix is not positive-definite).

				-- ALGLIB --
					 Copyright 1.28.2006 by Bochkanov Sergey
			*************************************************************************/
			public static bool smatrixgevdreduce(ref double[,] a,
					int n,
					bool isuppera,
					double[,] b,
					bool isupperb,
					int problemtype,
					ref double[,] r,
					ref bool isupperr)
			{
				bool result = new bool();
				double[,] t = new double[0, 0];
				double[] w1 = new double[0];
				double[] w2 = new double[0];
				double[] w3 = new double[0];
				int i = 0;
				int j = 0;
				double v = 0;
				matinv.matinvreport rep = new matinv.matinvreport();
				int info = 0;
				int i_ = 0;
				int i1_ = 0;

				r = new double[0, 0];
				isupperr = new bool();

				alglib.ap.assert(n > 0, "SMatrixGEVDReduce: N<=0!");
				alglib.ap.assert((problemtype == 1 || problemtype == 2) || problemtype == 3, "SMatrixGEVDReduce: incorrect ProblemType!");
				result = true;

				//
				// Problem 1:  A*x = lambda*B*x
				//
				// Reducing to:
				//     C*y = lambda*y
				//     C = L^(-1) * A * L^(-T)
				//     x = L^(-T) * y
				//
				if (problemtype == 1)
				{

					//
					// Factorize B in T: B = LL'
					//
					t = new double[n - 1 + 1, n - 1 + 1];
					if (isupperb)
					{
						for (i = 0; i <= n - 1; i++)
						{
							for (i_ = i; i_ <= n - 1; i_++)
							{
								t[i_, i] = b[i, i_];
							}
						}
					}
					else
					{
						for (i = 0; i <= n - 1; i++)
						{
							for (i_ = 0; i_ <= i; i_++)
							{
								t[i, i_] = b[i, i_];
							}
						}
					}
					if (!trfac.spdmatrixcholesky(ref t, n, false))
					{
						result = false;
						return result;
					}

					//
					// Invert L in T
					//
					matinv.rmatrixtrinverse(ref t, n, false, false, ref info, rep);
					if (info <= 0)
					{
						result = false;
						return result;
					}

					//
					// Build L^(-1) * A * L^(-T) in R
					//
					w1 = new double[n + 1];
					w2 = new double[n + 1];
					r = new double[n - 1 + 1, n - 1 + 1];
					for (j = 1; j <= n; j++)
					{

						//
						// Form w2 = A * l'(j) (here l'(j) is j-th column of L^(-T))
						//
						i1_ = (0) - (1);
						for (i_ = 1; i_ <= j; i_++)
						{
							w1[i_] = t[j - 1, i_ + i1_];
						}
						sblas.symmetricmatrixvectormultiply(a, isuppera, 0, j - 1, w1, 1.0f, ref w2);
						if (isuppera)
						{
							blas.matrixvectormultiply(a, 0, j - 1, j, n - 1, true, w1, 1, j, 1.0f, ref w2, j + 1, n, 0.0f);
						}
						else
						{
							blas.matrixvectormultiply(a, j, n - 1, 0, j - 1, false, w1, 1, j, 1.0f, ref w2, j + 1, n, 0.0f);
						}

						//
						// Form l(i)*w2 (here l(i) is i-th row of L^(-1))
						//
						for (i = 1; i <= n; i++)
						{
							i1_ = (1) - (0);
							v = 0.0f;
							for (i_ = 0; i_ <= i - 1; i_++)
							{
								v += t[i - 1, i_] * w2[i_ + i1_];
							}
							r[i - 1, j - 1] = v;
						}
					}

					//
					// Copy R to A
					//
					for (i = 0; i <= n - 1; i++)
					{
						for (i_ = 0; i_ <= n - 1; i_++)
						{
							a[i, i_] = r[i, i_];
						}
					}

					//
					// Copy L^(-1) from T to R and transpose
					//
					isupperr = true;
					for (i = 0; i <= n - 1; i++)
					{
						for (j = 0; j <= i - 1; j++)
						{
							r[i, j] = 0;
						}
					}
					for (i = 0; i <= n - 1; i++)
					{
						for (i_ = i; i_ <= n - 1; i_++)
						{
							r[i, i_] = t[i_, i];
						}
					}
					return result;
				}

				//
				// Problem 2:  A*B*x = lambda*x
				// or
				// problem 3:  B*A*x = lambda*x
				//
				// Reducing to:
				//     C*y = lambda*y
				//     C = U * A * U'
				//     B = U'* U
				//
				if (problemtype == 2 || problemtype == 3)
				{

					//
					// Factorize B in T: B = U'*U
					//
					t = new double[n - 1 + 1, n - 1 + 1];
					if (isupperb)
					{
						for (i = 0; i <= n - 1; i++)
						{
							for (i_ = i; i_ <= n - 1; i_++)
							{
								t[i, i_] = b[i, i_];
							}
						}
					}
					else
					{
						for (i = 0; i <= n - 1; i++)
						{
							for (i_ = i; i_ <= n - 1; i_++)
							{
								t[i, i_] = b[i_, i];
							}
						}
					}
					if (!trfac.spdmatrixcholesky(ref t, n, true))
					{
						result = false;
						return result;
					}

					//
					// Build U * A * U' in R
					//
					w1 = new double[n + 1];
					w2 = new double[n + 1];
					w3 = new double[n + 1];
					r = new double[n - 1 + 1, n - 1 + 1];
					for (j = 1; j <= n; j++)
					{

						//
						// Form w2 = A * u'(j) (here u'(j) is j-th column of U')
						//
						i1_ = (j - 1) - (1);
						for (i_ = 1; i_ <= n - j + 1; i_++)
						{
							w1[i_] = t[j - 1, i_ + i1_];
						}
						sblas.symmetricmatrixvectormultiply(a, isuppera, j - 1, n - 1, w1, 1.0f, ref w3);
						i1_ = (1) - (j);
						for (i_ = j; i_ <= n; i_++)
						{
							w2[i_] = w3[i_ + i1_];
						}
						i1_ = (j - 1) - (j);
						for (i_ = j; i_ <= n; i_++)
						{
							w1[i_] = t[j - 1, i_ + i1_];
						}
						if (isuppera)
						{
							blas.matrixvectormultiply(a, 0, j - 2, j - 1, n - 1, false, w1, j, n, 1.0f, ref w2, 1, j - 1, 0.0f);
						}
						else
						{
							blas.matrixvectormultiply(a, j - 1, n - 1, 0, j - 2, true, w1, j, n, 1.0f, ref w2, 1, j - 1, 0.0f);
						}

						//
						// Form u(i)*w2 (here u(i) is i-th row of U)
						//
						for (i = 1; i <= n; i++)
						{
							i1_ = (i) - (i - 1);
							v = 0.0f;
							for (i_ = i - 1; i_ <= n - 1; i_++)
							{
								v += t[i - 1, i_] * w2[i_ + i1_];
							}
							r[i - 1, j - 1] = v;
						}
					}

					//
					// Copy R to A
					//
					for (i = 0; i <= n - 1; i++)
					{
						for (i_ = 0; i_ <= n - 1; i_++)
						{
							a[i, i_] = r[i, i_];
						}
					}
					if (problemtype == 2)
					{

						//
						// Invert U in T
						//
						matinv.rmatrixtrinverse(ref t, n, true, false, ref info, rep);
						if (info <= 0)
						{
							result = false;
							return result;
						}

						//
						// Copy U^-1 from T to R
						//
						isupperr = true;
						for (i = 0; i <= n - 1; i++)
						{
							for (j = 0; j <= i - 1; j++)
							{
								r[i, j] = 0;
							}
						}
						for (i = 0; i <= n - 1; i++)
						{
							for (i_ = i; i_ <= n - 1; i_++)
							{
								r[i, i_] = t[i, i_];
							}
						}
					}
					else
					{

						//
						// Copy U from T to R and transpose
						//
						isupperr = false;
						for (i = 0; i <= n - 1; i++)
						{
							for (j = i + 1; j <= n - 1; j++)
							{
								r[i, j] = 0;
							}
						}
						for (i = 0; i <= n - 1; i++)
						{
							for (i_ = i; i_ <= n - 1; i_++)
							{
								r[i_, i] = t[i, i_];
							}
						}
					}
				}
				return result;
			}


		}
		public class inverseupdate
		{
			/*************************************************************************
			Inverse matrix update by the Sherman-Morrison formula

			The algorithm updates matrix A^-1 when adding a number to an element
			of matrix A.

			Input parameters:
					InvA    -   inverse of matrix A.
											Array whose indexes range within [0..N-1, 0..N-1].
					N       -   size of matrix A.
					UpdRow  -   row where the element to be updated is stored.
					UpdColumn - column where the element to be updated is stored.
					UpdVal  -   a number to be added to the element.


			Output parameters:
					InvA    -   inverse of modified matrix A.

				-- ALGLIB --
					 Copyright 2005 by Bochkanov Sergey
			*************************************************************************/
			public static void rmatrixinvupdatesimple(ref double[,] inva,
					int n,
					int updrow,
					int updcolumn,
					double updval)
			{
				double[] t1 = new double[0];
				double[] t2 = new double[0];
				int i = 0;
				double lambdav = 0;
				double vt = 0;
				int i_ = 0;

				alglib.ap.assert(updrow >= 0 && updrow < n, "RMatrixInvUpdateSimple: incorrect UpdRow!");
				alglib.ap.assert(updcolumn >= 0 && updcolumn < n, "RMatrixInvUpdateSimple: incorrect UpdColumn!");
				t1 = new double[n - 1 + 1];
				t2 = new double[n - 1 + 1];

				//
				// T1 = InvA * U
				//
				for (i_ = 0; i_ <= n - 1; i_++)
				{
					t1[i_] = inva[i_, updrow];
				}

				//
				// T2 = v*InvA
				//
				for (i_ = 0; i_ <= n - 1; i_++)
				{
					t2[i_] = inva[updcolumn, i_];
				}

				//
				// Lambda = v * InvA * U
				//
				lambdav = updval * inva[updcolumn, updrow];

				//
				// InvA = InvA - correction
				//
				for (i = 0; i <= n - 1; i++)
				{
					vt = updval * t1[i];
					vt = vt / (1 + lambdav);
					for (i_ = 0; i_ <= n - 1; i_++)
					{
						inva[i, i_] = inva[i, i_] - vt * t2[i_];
					}
				}
			}


			/*************************************************************************
			Inverse matrix update by the Sherman-Morrison formula

			The algorithm updates matrix A^-1 when adding a vector to a row
			of matrix A.

			Input parameters:
					InvA    -   inverse of matrix A.
											Array whose indexes range within [0..N-1, 0..N-1].
					N       -   size of matrix A.
					UpdRow  -   the row of A whose vector V was added.
											0 <= Row <= N-1
					V       -   the vector to be added to a row.
											Array whose index ranges within [0..N-1].

			Output parameters:
					InvA    -   inverse of modified matrix A.

				-- ALGLIB --
					 Copyright 2005 by Bochkanov Sergey
			*************************************************************************/
			public static void rmatrixinvupdaterow(ref double[,] inva,
					int n,
					int updrow,
					double[] v)
			{
				double[] t1 = new double[0];
				double[] t2 = new double[0];
				int i = 0;
				int j = 0;
				double lambdav = 0;
				double vt = 0;
				int i_ = 0;

				t1 = new double[n - 1 + 1];
				t2 = new double[n - 1 + 1];

				//
				// T1 = InvA * U
				//
				for (i_ = 0; i_ <= n - 1; i_++)
				{
					t1[i_] = inva[i_, updrow];
				}

				//
				// T2 = v*InvA
				// Lambda = v * InvA * U
				//
				for (j = 0; j <= n - 1; j++)
				{
					vt = 0.0f;
					for (i_ = 0; i_ <= n - 1; i_++)
					{
						vt += v[i_] * inva[i_, j];
					}
					t2[j] = vt;
				}
				lambdav = t2[updrow];

				//
				// InvA = InvA - correction
				//
				for (i = 0; i <= n - 1; i++)
				{
					vt = t1[i] / (1 + lambdav);
					for (i_ = 0; i_ <= n - 1; i_++)
					{
						inva[i, i_] = inva[i, i_] - vt * t2[i_];
					}
				}
			}


			/*************************************************************************
			Inverse matrix update by the Sherman-Morrison formula

			The algorithm updates matrix A^-1 when adding a vector to a column
			of matrix A.

			Input parameters:
					InvA        -   inverse of matrix A.
													Array whose indexes range within [0..N-1, 0..N-1].
					N           -   size of matrix A.
					UpdColumn   -   the column of A whose vector U was added.
													0 <= UpdColumn <= N-1
					U           -   the vector to be added to a column.
													Array whose index ranges within [0..N-1].

			Output parameters:
					InvA        -   inverse of modified matrix A.

				-- ALGLIB --
					 Copyright 2005 by Bochkanov Sergey
			*************************************************************************/
			public static void rmatrixinvupdatecolumn(ref double[,] inva,
					int n,
					int updcolumn,
					double[] u)
			{
				double[] t1 = new double[0];
				double[] t2 = new double[0];
				int i = 0;
				double lambdav = 0;
				double vt = 0;
				int i_ = 0;

				t1 = new double[n - 1 + 1];
				t2 = new double[n - 1 + 1];

				//
				// T1 = InvA * U
				// Lambda = v * InvA * U
				//
				for (i = 0; i <= n - 1; i++)
				{
					vt = 0.0f;
					for (i_ = 0; i_ <= n - 1; i_++)
					{
						vt += inva[i, i_] * u[i_];
					}
					t1[i] = vt;
				}
				lambdav = t1[updcolumn];

				//
				// T2 = v*InvA
				//
				for (i_ = 0; i_ <= n - 1; i_++)
				{
					t2[i_] = inva[updcolumn, i_];
				}

				//
				// InvA = InvA - correction
				//
				for (i = 0; i <= n - 1; i++)
				{
					vt = t1[i] / (1 + lambdav);
					for (i_ = 0; i_ <= n - 1; i_++)
					{
						inva[i, i_] = inva[i, i_] - vt * t2[i_];
					}
				}
			}


			/*************************************************************************
			Inverse matrix update by the Sherman-Morrison formula

			The algorithm computes the inverse of matrix A+u*v’ by using the given matrix
			A^-1 and the vectors u and v.

			Input parameters:
					InvA    -   inverse of matrix A.
											Array whose indexes range within [0..N-1, 0..N-1].
					N       -   size of matrix A.
					U       -   the vector modifying the matrix.
											Array whose index ranges within [0..N-1].
					V       -   the vector modifying the matrix.
											Array whose index ranges within [0..N-1].

			Output parameters:
					InvA - inverse of matrix A + u*v'.

				-- ALGLIB --
					 Copyright 2005 by Bochkanov Sergey
			*************************************************************************/
			public static void rmatrixinvupdateuv(ref double[,] inva,
					int n,
					double[] u,
					double[] v)
			{
				double[] t1 = new double[0];
				double[] t2 = new double[0];
				int i = 0;
				int j = 0;
				double lambdav = 0;
				double vt = 0;
				int i_ = 0;

				t1 = new double[n - 1 + 1];
				t2 = new double[n - 1 + 1];

				//
				// T1 = InvA * U
				// Lambda = v * T1
				//
				for (i = 0; i <= n - 1; i++)
				{
					vt = 0.0f;
					for (i_ = 0; i_ <= n - 1; i_++)
					{
						vt += inva[i, i_] * u[i_];
					}
					t1[i] = vt;
				}
				lambdav = 0.0f;
				for (i_ = 0; i_ <= n - 1; i_++)
				{
					lambdav += v[i_] * t1[i_];
				}

				//
				// T2 = v*InvA
				//
				for (j = 0; j <= n - 1; j++)
				{
					vt = 0.0f;
					for (i_ = 0; i_ <= n - 1; i_++)
					{
						vt += v[i_] * inva[i_, j];
					}
					t2[j] = vt;
				}

				//
				// InvA = InvA - correction
				//
				for (i = 0; i <= n - 1; i++)
				{
					vt = t1[i] / (1 + lambdav);
					for (i_ = 0; i_ <= n - 1; i_++)
					{
						inva[i, i_] = inva[i, i_] - vt * t2[i_];
					}
				}
			}


		}
		public class schur
		{
			/*************************************************************************
			Subroutine performing the Schur decomposition of a general matrix by using
			the QR algorithm with multiple shifts.

			The source matrix A is represented as S'*A*S = T, where S is an orthogonal
			matrix (Schur vectors), T - upper quasi-triangular matrix (with blocks of
			sizes 1x1 and 2x2 on the main diagonal).

			Input parameters:
					A   -   matrix to be decomposed.
									Array whose indexes range within [0..N-1, 0..N-1].
					N   -   size of A, N>=0.


			Output parameters:
					A   -   contains matrix T.
									Array whose indexes range within [0..N-1, 0..N-1].
					S   -   contains Schur vectors.
									Array whose indexes range within [0..N-1, 0..N-1].

			Note 1:
					The block structure of matrix T can be easily recognized: since all
					the elements below the blocks are zeros, the elements a[i+1,i] which
					are equal to 0 show the block border.

			Note 2:
					The algorithm performance depends on the value of the internal parameter
					NS of the InternalSchurDecomposition subroutine which defines the number
					of shifts in the QR algorithm (similarly to the block width in block-matrix
					algorithms in linear algebra). If you require maximum performance on
					your machine, it is recommended to adjust this parameter manually.

			Result:
					True,
							if the algorithm has converged and parameters A and S contain the result.
					False,
							if the algorithm has not converged.

			Algorithm implemented on the basis of the DHSEQR subroutine (LAPACK 3.0 library).
			*************************************************************************/
			public static bool rmatrixschur(ref double[,] a,
					int n,
					ref double[,] s)
			{
				bool result = new bool();
				double[] tau = new double[0];
				double[] wi = new double[0];
				double[] wr = new double[0];
				double[,] a1 = new double[0, 0];
				double[,] s1 = new double[0, 0];
				int info = 0;
				int i = 0;
				int j = 0;

				s = new double[0, 0];


				//
				// Upper Hessenberg form of the 0-based matrix
				//
				ortfac.rmatrixhessenberg(ref a, n, ref tau);
				ortfac.rmatrixhessenbergunpackq(a, n, tau, ref s);

				//
				// Convert from 0-based arrays to 1-based,
				// then call InternalSchurDecomposition
				// Awkward, of course, but Schur decompisiton subroutine
				// is too complex to fix it.
				//
				//
				a1 = new double[n + 1, n + 1];
				s1 = new double[n + 1, n + 1];
				for (i = 1; i <= n; i++)
				{
					for (j = 1; j <= n; j++)
					{
						a1[i, j] = a[i - 1, j - 1];
						s1[i, j] = s[i - 1, j - 1];
					}
				}
				hsschur.internalschurdecomposition(ref a1, n, 1, 1, ref wr, ref wi, ref s1, ref info);
				result = info == 0;

				//
				// convert from 1-based arrays to -based
				//
				for (i = 1; i <= n; i++)
				{
					for (j = 1; j <= n; j++)
					{
						a[i - 1, j - 1] = a1[i, j];
						s[i - 1, j - 1] = s1[i, j];
					}
				}
				return result;
			}


		}
		public class ablasf
		{
			/*************************************************************************
			Fast kernel

				-- ALGLIB routine --
					 19.01.2010
					 Bochkanov Sergey
			*************************************************************************/
			public static bool cmatrixrank1f(int m,
					int n,
					ref complex[,] a,
					int ia,
					int ja,
					ref complex[] u,
					int iu,
					ref complex[] v,
					int iv)
			{
				bool result = new bool();

				result = false;
				return result;
			}


			/*************************************************************************
			Fast kernel

				-- ALGLIB routine --
					 19.01.2010
					 Bochkanov Sergey
			*************************************************************************/
			public static bool rmatrixrank1f(int m,
					int n,
					ref double[,] a,
					int ia,
					int ja,
					ref double[] u,
					int iu,
					ref double[] v,
					int iv)
			{
				bool result = new bool();

				result = false;
				return result;
			}


			/*************************************************************************
			Fast kernel

				-- ALGLIB routine --
					 19.01.2010
					 Bochkanov Sergey
			*************************************************************************/
			public static bool cmatrixmvf(int m,
					int n,
					complex[,] a,
					int ia,
					int ja,
					int opa,
					complex[] x,
					int ix,
					ref complex[] y,
					int iy)
			{
				bool result = new bool();

				result = false;
				return result;
			}


			/*************************************************************************
			Fast kernel

				-- ALGLIB routine --
					 19.01.2010
					 Bochkanov Sergey
			*************************************************************************/
			public static bool rmatrixmvf(int m,
					int n,
					double[,] a,
					int ia,
					int ja,
					int opa,
					double[] x,
					int ix,
					ref double[] y,
					int iy)
			{
				bool result = new bool();

				result = false;
				return result;
			}


			/*************************************************************************
			Fast kernel

				-- ALGLIB routine --
					 19.01.2010
					 Bochkanov Sergey
			*************************************************************************/
			public static bool cmatrixrighttrsmf(int m,
					int n,
					complex[,] a,
					int i1,
					int j1,
					bool isupper,
					bool isunit,
					int optype,
					complex[,] x,
					int i2,
					int j2)
			{
				bool result = new bool();

				result = false;
				return result;
			}


			/*************************************************************************
			Fast kernel

				-- ALGLIB routine --
					 19.01.2010
					 Bochkanov Sergey
			*************************************************************************/
			public static bool cmatrixlefttrsmf(int m,
					int n,
					complex[,] a,
					int i1,
					int j1,
					bool isupper,
					bool isunit,
					int optype,
					complex[,] x,
					int i2,
					int j2)
			{
				bool result = new bool();

				result = false;
				return result;
			}


			/*************************************************************************
			Fast kernel

				-- ALGLIB routine --
					 19.01.2010
					 Bochkanov Sergey
			*************************************************************************/
			public static bool rmatrixrighttrsmf(int m,
					int n,
					double[,] a,
					int i1,
					int j1,
					bool isupper,
					bool isunit,
					int optype,
					double[,] x,
					int i2,
					int j2)
			{
				bool result = new bool();

				result = false;
				return result;
			}


			/*************************************************************************
			Fast kernel

				-- ALGLIB routine --
					 19.01.2010
					 Bochkanov Sergey
			*************************************************************************/
			public static bool rmatrixlefttrsmf(int m,
					int n,
					double[,] a,
					int i1,
					int j1,
					bool isupper,
					bool isunit,
					int optype,
					double[,] x,
					int i2,
					int j2)
			{
				bool result = new bool();

				result = false;
				return result;
			}


			/*************************************************************************
			Fast kernel

				-- ALGLIB routine --
					 19.01.2010
					 Bochkanov Sergey
			*************************************************************************/
			public static bool cmatrixsyrkf(int n,
					int k,
					double alpha,
					complex[,] a,
					int ia,
					int ja,
					int optypea,
					double beta,
					complex[,] c,
					int ic,
					int jc,
					bool isupper)
			{
				bool result = new bool();

				result = false;
				return result;
			}


			/*************************************************************************
			Fast kernel

				-- ALGLIB routine --
					 19.01.2010
					 Bochkanov Sergey
			*************************************************************************/
			public static bool rmatrixsyrkf(int n,
					int k,
					double alpha,
					double[,] a,
					int ia,
					int ja,
					int optypea,
					double beta,
					double[,] c,
					int ic,
					int jc,
					bool isupper)
			{
				bool result = new bool();

				result = false;
				return result;
			}


			/*************************************************************************
			Fast kernel

				-- ALGLIB routine --
					 19.01.2010
					 Bochkanov Sergey
			*************************************************************************/
			public static bool rmatrixgemmf(int m,
					int n,
					int k,
					double alpha,
					double[,] a,
					int ia,
					int ja,
					int optypea,
					double[,] b,
					int ib,
					int jb,
					int optypeb,
					double beta,
					double[,] c,
					int ic,
					int jc)
			{
				bool result = new bool();

				result = false;
				return result;
			}


			/*************************************************************************
			Fast kernel

				-- ALGLIB routine --
					 19.01.2010
					 Bochkanov Sergey
			*************************************************************************/
			public static bool cmatrixgemmf(int m,
					int n,
					int k,
					complex alpha,
					complex[,] a,
					int ia,
					int ja,
					int optypea,
					complex[,] b,
					int ib,
					int jb,
					int optypeb,
					complex beta,
					complex[,] c,
					int ic,
					int jc)
			{
				bool result = new bool();

				result = false;
				return result;
			}


			/*************************************************************************
			CMatrixGEMM kernel, basecase code for CMatrixGEMM.

			This subroutine calculates C = alpha*op1(A)*op2(B) +beta*C where:
			* C is MxN general matrix
			* op1(A) is MxK matrix
			* op2(B) is KxN matrix
			* "op" may be identity transformation, transposition, conjugate transposition

			Additional info:
			* multiplication result replaces C. If Beta=0, C elements are not used in
				calculations (not multiplied by zero - just not referenced)
			* if Alpha=0, A is not used (not multiplied by zero - just not referenced)
			* if both Beta and Alpha are zero, C is filled by zeros.

			IMPORTANT:

			This function does NOT preallocate output matrix C, it MUST be preallocated
			by caller prior to calling this function. In case C does not have  enough
			space to store result, exception will be generated.

			INPUT PARAMETERS
					M       -   matrix size, M>0
					N       -   matrix size, N>0
					K       -   matrix size, K>0
					Alpha   -   coefficient
					A       -   matrix
					IA      -   submatrix offset
					JA      -   submatrix offset
					OpTypeA -   transformation type:
											* 0 - no transformation
											* 1 - transposition
											* 2 - conjugate transposition
					B       -   matrix
					IB      -   submatrix offset
					JB      -   submatrix offset
					OpTypeB -   transformation type:
											* 0 - no transformation
											* 1 - transposition
											* 2 - conjugate transposition
					Beta    -   coefficient
					C       -   PREALLOCATED output matrix
					IC      -   submatrix offset
					JC      -   submatrix offset

				-- ALGLIB routine --
					 27.03.2013
					 Bochkanov Sergey
			*************************************************************************/
			public static void cmatrixgemmk(int m,
					int n,
					int k,
					complex alpha,
					complex[,] a,
					int ia,
					int ja,
					int optypea,
					complex[,] b,
					int ib,
					int jb,
					int optypeb,
					complex beta,
					complex[,] c,
					int ic,
					int jc)
			{
				int i = 0;
				int j = 0;
				complex v = 0;
				complex v00 = 0;
				complex v01 = 0;
				complex v10 = 0;
				complex v11 = 0;
				double v00x = 0;
				double v00y = 0;
				double v01x = 0;
				double v01y = 0;
				double v10x = 0;
				double v10y = 0;
				double v11x = 0;
				double v11y = 0;
				double a0x = 0;
				double a0y = 0;
				double a1x = 0;
				double a1y = 0;
				double b0x = 0;
				double b0y = 0;
				double b1x = 0;
				double b1y = 0;
				int idxa0 = 0;
				int idxa1 = 0;
				int idxb0 = 0;
				int idxb1 = 0;
				int i0 = 0;
				int i1 = 0;
				int ik = 0;
				int j0 = 0;
				int j1 = 0;
				int jk = 0;
				int t = 0;
				int offsa = 0;
				int offsb = 0;
				int i_ = 0;
				int i1_ = 0;


				//
				// if matrix size is zero
				//
				if (m == 0 || n == 0)
				{
					return;
				}

				//
				// Try optimized code
				//
				if (cmatrixgemmf(m, n, k, alpha, a, ia, ja, optypea, b, ib, jb, optypeb, beta, c, ic, jc))
				{
					return;
				}

				//
				// if K=0, then C=Beta*C
				//
				if (k == 0)
				{
					if (beta != 1)
					{
						if (beta != 0)
						{
							for (i = 0; i <= m - 1; i++)
							{
								for (j = 0; j <= n - 1; j++)
								{
									c[ic + i, jc + j] = beta * c[ic + i, jc + j];
								}
							}
						}
						else
						{
							for (i = 0; i <= m - 1; i++)
							{
								for (j = 0; j <= n - 1; j++)
								{
									c[ic + i, jc + j] = 0;
								}
							}
						}
					}
					return;
				}

				//
				// This phase is not really necessary, but compiler complains
				// about "possibly uninitialized variables"
				//
				a0x = 0;
				a0y = 0;
				a1x = 0;
				a1y = 0;
				b0x = 0;
				b0y = 0;
				b1x = 0;
				b1y = 0;

				//
				// General case
				//
				i = 0;
				while (i < m)
				{
					j = 0;
					while (j < n)
					{

						//
						// Choose between specialized 4x4 code and general code
						//
						if (i + 2 <= m && j + 2 <= n)
						{

							//
							// Specialized 4x4 code for [I..I+3]x[J..J+3] submatrix of C.
							//
							// This submatrix is calculated as sum of K rank-1 products,
							// with operands cached in local variables in order to speed
							// up operations with arrays.
							//
							v00x = 0.0f;
							v00y = 0.0f;
							v01x = 0.0f;
							v01y = 0.0f;
							v10x = 0.0f;
							v10y = 0.0f;
							v11x = 0.0f;
							v11y = 0.0f;
							if (optypea == 0)
							{
								idxa0 = ia + i + 0;
								idxa1 = ia + i + 1;
								offsa = ja;
							}
							else
							{
								idxa0 = ja + i + 0;
								idxa1 = ja + i + 1;
								offsa = ia;
							}
							if (optypeb == 0)
							{
								idxb0 = jb + j + 0;
								idxb1 = jb + j + 1;
								offsb = ib;
							}
							else
							{
								idxb0 = ib + j + 0;
								idxb1 = ib + j + 1;
								offsb = jb;
							}
							for (t = 0; t <= k - 1; t++)
							{
								if (optypea == 0)
								{
									a0x = a[idxa0, offsa].x;
									a0y = a[idxa0, offsa].y;
									a1x = a[idxa1, offsa].x;
									a1y = a[idxa1, offsa].y;
								}
								if (optypea == 1)
								{
									a0x = a[offsa, idxa0].x;
									a0y = a[offsa, idxa0].y;
									a1x = a[offsa, idxa1].x;
									a1y = a[offsa, idxa1].y;
								}
								if (optypea == 2)
								{
									a0x = a[offsa, idxa0].x;
									a0y = -a[offsa, idxa0].y;
									a1x = a[offsa, idxa1].x;
									a1y = -a[offsa, idxa1].y;
								}
								if (optypeb == 0)
								{
									b0x = b[offsb, idxb0].x;
									b0y = b[offsb, idxb0].y;
									b1x = b[offsb, idxb1].x;
									b1y = b[offsb, idxb1].y;
								}
								if (optypeb == 1)
								{
									b0x = b[idxb0, offsb].x;
									b0y = b[idxb0, offsb].y;
									b1x = b[idxb1, offsb].x;
									b1y = b[idxb1, offsb].y;
								}
								if (optypeb == 2)
								{
									b0x = b[idxb0, offsb].x;
									b0y = -b[idxb0, offsb].y;
									b1x = b[idxb1, offsb].x;
									b1y = -b[idxb1, offsb].y;
								}
								v00x = v00x + a0x * b0x - a0y * b0y;
								v00y = v00y + a0x * b0y + a0y * b0x;
								v01x = v01x + a0x * b1x - a0y * b1y;
								v01y = v01y + a0x * b1y + a0y * b1x;
								v10x = v10x + a1x * b0x - a1y * b0y;
								v10y = v10y + a1x * b0y + a1y * b0x;
								v11x = v11x + a1x * b1x - a1y * b1y;
								v11y = v11y + a1x * b1y + a1y * b1x;
								offsa = offsa + 1;
								offsb = offsb + 1;
							}
							v00.x = v00x;
							v00.y = v00y;
							v10.x = v10x;
							v10.y = v10y;
							v01.x = v01x;
							v01.y = v01y;
							v11.x = v11x;
							v11.y = v11y;
							if (beta == 0)
							{
								c[ic + i + 0, jc + j + 0] = alpha * v00;
								c[ic + i + 0, jc + j + 1] = alpha * v01;
								c[ic + i + 1, jc + j + 0] = alpha * v10;
								c[ic + i + 1, jc + j + 1] = alpha * v11;
							}
							else
							{
								c[ic + i + 0, jc + j + 0] = beta * c[ic + i + 0, jc + j + 0] + alpha * v00;
								c[ic + i + 0, jc + j + 1] = beta * c[ic + i + 0, jc + j + 1] + alpha * v01;
								c[ic + i + 1, jc + j + 0] = beta * c[ic + i + 1, jc + j + 0] + alpha * v10;
								c[ic + i + 1, jc + j + 1] = beta * c[ic + i + 1, jc + j + 1] + alpha * v11;
							}
						}
						else
						{

							//
							// Determine submatrix [I0..I1]x[J0..J1] to process
							//
							i0 = i;
							i1 = Math.Min(i + 1, m - 1);
							j0 = j;
							j1 = Math.Min(j + 1, n - 1);

							//
							// Process submatrix
							//
							for (ik = i0; ik <= i1; ik++)
							{
								for (jk = j0; jk <= j1; jk++)
								{
									if (k == 0 || alpha == 0)
									{
										v = 0;
									}
									else
									{
										v = 0.0f;
										if (optypea == 0 && optypeb == 0)
										{
											i1_ = (ib) - (ja);
											v = 0.0f;
											for (i_ = ja; i_ <= ja + k - 1; i_++)
											{
												v += a[ia + ik, i_] * b[i_ + i1_, jb + jk];
											}
										}
										if (optypea == 0 && optypeb == 1)
										{
											i1_ = (jb) - (ja);
											v = 0.0f;
											for (i_ = ja; i_ <= ja + k - 1; i_++)
											{
												v += a[ia + ik, i_] * b[ib + jk, i_ + i1_];
											}
										}
										if (optypea == 0 && optypeb == 2)
										{
											i1_ = (jb) - (ja);
											v = 0.0f;
											for (i_ = ja; i_ <= ja + k - 1; i_++)
											{
												v += a[ia + ik, i_] * math.conj(b[ib + jk, i_ + i1_]);
											}
										}
										if (optypea == 1 && optypeb == 0)
										{
											i1_ = (ib) - (ia);
											v = 0.0f;
											for (i_ = ia; i_ <= ia + k - 1; i_++)
											{
												v += a[i_, ja + ik] * b[i_ + i1_, jb + jk];
											}
										}
										if (optypea == 1 && optypeb == 1)
										{
											i1_ = (jb) - (ia);
											v = 0.0f;
											for (i_ = ia; i_ <= ia + k - 1; i_++)
											{
												v += a[i_, ja + ik] * b[ib + jk, i_ + i1_];
											}
										}
										if (optypea == 1 && optypeb == 2)
										{
											i1_ = (jb) - (ia);
											v = 0.0f;
											for (i_ = ia; i_ <= ia + k - 1; i_++)
											{
												v += a[i_, ja + ik] * math.conj(b[ib + jk, i_ + i1_]);
											}
										}
										if (optypea == 2 && optypeb == 0)
										{
											i1_ = (ib) - (ia);
											v = 0.0f;
											for (i_ = ia; i_ <= ia + k - 1; i_++)
											{
												v += math.conj(a[i_, ja + ik]) * b[i_ + i1_, jb + jk];
											}
										}
										if (optypea == 2 && optypeb == 1)
										{
											i1_ = (jb) - (ia);
											v = 0.0f;
											for (i_ = ia; i_ <= ia + k - 1; i_++)
											{
												v += math.conj(a[i_, ja + ik]) * b[ib + jk, i_ + i1_];
											}
										}
										if (optypea == 2 && optypeb == 2)
										{
											i1_ = (jb) - (ia);
											v = 0.0f;
											for (i_ = ia; i_ <= ia + k - 1; i_++)
											{
												v += math.conj(a[i_, ja + ik]) * math.conj(b[ib + jk, i_ + i1_]);
											}
										}
									}
									if (beta == 0)
									{
										c[ic + ik, jc + jk] = alpha * v;
									}
									else
									{
										c[ic + ik, jc + jk] = beta * c[ic + ik, jc + jk] + alpha * v;
									}
								}
							}
						}
						j = j + 2;
					}
					i = i + 2;
				}
			}


			/*************************************************************************
			RMatrixGEMM kernel, basecase code for RMatrixGEMM.

			This subroutine calculates C = alpha*op1(A)*op2(B) +beta*C where:
			* C is MxN general matrix
			* op1(A) is MxK matrix
			* op2(B) is KxN matrix
			* "op" may be identity transformation, transposition

			Additional info:
			* multiplication result replaces C. If Beta=0, C elements are not used in
				calculations (not multiplied by zero - just not referenced)
			* if Alpha=0, A is not used (not multiplied by zero - just not referenced)
			* if both Beta and Alpha are zero, C is filled by zeros.

			IMPORTANT:

			This function does NOT preallocate output matrix C, it MUST be preallocated
			by caller prior to calling this function. In case C does not have  enough
			space to store result, exception will be generated.

			INPUT PARAMETERS
					M       -   matrix size, M>0
					N       -   matrix size, N>0
					K       -   matrix size, K>0
					Alpha   -   coefficient
					A       -   matrix
					IA      -   submatrix offset
					JA      -   submatrix offset
					OpTypeA -   transformation type:
											* 0 - no transformation
											* 1 - transposition
					B       -   matrix
					IB      -   submatrix offset
					JB      -   submatrix offset
					OpTypeB -   transformation type:
											* 0 - no transformation
											* 1 - transposition
					Beta    -   coefficient
					C       -   PREALLOCATED output matrix
					IC      -   submatrix offset
					JC      -   submatrix offset

				-- ALGLIB routine --
					 27.03.2013
					 Bochkanov Sergey
			*************************************************************************/
			public static void rmatrixgemmk(int m,
					int n,
					int k,
					double alpha,
					double[,] a,
					int ia,
					int ja,
					int optypea,
					double[,] b,
					int ib,
					int jb,
					int optypeb,
					double beta,
					double[,] c,
					int ic,
					int jc)
			{
				int i = 0;
				int j = 0;


				//
				// if matrix size is zero
				//
				if (m == 0 || n == 0)
				{
					return;
				}

				//
				// Try optimized code
				//
				if (rmatrixgemmf(m, n, k, alpha, a, ia, ja, optypea, b, ib, jb, optypeb, beta, c, ic, jc))
				{
					return;
				}

				//
				// if K=0, then C=Beta*C
				//
				if (k == 0 || (double)(alpha) == (double)(0))
				{
					if ((double)(beta) != (double)(1))
					{
						if ((double)(beta) != (double)(0))
						{
							for (i = 0; i <= m - 1; i++)
							{
								for (j = 0; j <= n - 1; j++)
								{
									c[ic + i, jc + j] = beta * c[ic + i, jc + j];
								}
							}
						}
						else
						{
							for (i = 0; i <= m - 1; i++)
							{
								for (j = 0; j <= n - 1; j++)
								{
									c[ic + i, jc + j] = 0;
								}
							}
						}
					}
					return;
				}

				//
				// Call specialized code.
				//
				// NOTE: specialized code was moved to separate function because of strange
				//       issues with instructions cache on some systems; Having too long
				//       functions significantly slows down internal loop of the algorithm.
				//
				if (optypea == 0 && optypeb == 0)
				{
					rmatrixgemmk44v00(m, n, k, alpha, a, ia, ja, b, ib, jb, beta, c, ic, jc);
				}
				if (optypea == 0 && optypeb != 0)
				{
					rmatrixgemmk44v01(m, n, k, alpha, a, ia, ja, b, ib, jb, beta, c, ic, jc);
				}
				if (optypea != 0 && optypeb == 0)
				{
					rmatrixgemmk44v10(m, n, k, alpha, a, ia, ja, b, ib, jb, beta, c, ic, jc);
				}
				if (optypea != 0 && optypeb != 0)
				{
					rmatrixgemmk44v11(m, n, k, alpha, a, ia, ja, b, ib, jb, beta, c, ic, jc);
				}
			}


			/*************************************************************************
			RMatrixGEMM kernel, basecase code for RMatrixGEMM, specialized for sitation
			with OpTypeA=0 and OpTypeB=0.

			Additional info:
			* this function requires that Alpha<>0 (assertion is thrown otherwise)

			INPUT PARAMETERS
					M       -   matrix size, M>0
					N       -   matrix size, N>0
					K       -   matrix size, K>0
					Alpha   -   coefficient
					A       -   matrix
					IA      -   submatrix offset
					JA      -   submatrix offset
					B       -   matrix
					IB      -   submatrix offset
					JB      -   submatrix offset
					Beta    -   coefficient
					C       -   PREALLOCATED output matrix
					IC      -   submatrix offset
					JC      -   submatrix offset

				-- ALGLIB routine --
					 27.03.2013
					 Bochkanov Sergey
			*************************************************************************/
			public static void rmatrixgemmk44v00(int m,
					int n,
					int k,
					double alpha,
					double[,] a,
					int ia,
					int ja,
					double[,] b,
					int ib,
					int jb,
					double beta,
					double[,] c,
					int ic,
					int jc)
			{
				int i = 0;
				int j = 0;
				double v = 0;
				double v00 = 0;
				double v01 = 0;
				double v02 = 0;
				double v03 = 0;
				double v10 = 0;
				double v11 = 0;
				double v12 = 0;
				double v13 = 0;
				double v20 = 0;
				double v21 = 0;
				double v22 = 0;
				double v23 = 0;
				double v30 = 0;
				double v31 = 0;
				double v32 = 0;
				double v33 = 0;
				double a0 = 0;
				double a1 = 0;
				double a2 = 0;
				double a3 = 0;
				double b0 = 0;
				double b1 = 0;
				double b2 = 0;
				double b3 = 0;
				int idxa0 = 0;
				int idxa1 = 0;
				int idxa2 = 0;
				int idxa3 = 0;
				int idxb0 = 0;
				int idxb1 = 0;
				int idxb2 = 0;
				int idxb3 = 0;
				int i0 = 0;
				int i1 = 0;
				int ik = 0;
				int j0 = 0;
				int j1 = 0;
				int jk = 0;
				int t = 0;
				int offsa = 0;
				int offsb = 0;
				int i_ = 0;
				int i1_ = 0;

				alglib.ap.assert((double)(alpha) != (double)(0), "RMatrixGEMMK44V00: internal error (Alpha=0)");

				//
				// if matrix size is zero
				//
				if (m == 0 || n == 0)
				{
					return;
				}

				//
				// A*B
				//
				i = 0;
				while (i < m)
				{
					j = 0;
					while (j < n)
					{

						//
						// Choose between specialized 4x4 code and general code
						//
						if (i + 4 <= m && j + 4 <= n)
						{

							//
							// Specialized 4x4 code for [I..I+3]x[J..J+3] submatrix of C.
							//
							// This submatrix is calculated as sum of K rank-1 products,
							// with operands cached in local variables in order to speed
							// up operations with arrays.
							//
							idxa0 = ia + i + 0;
							idxa1 = ia + i + 1;
							idxa2 = ia + i + 2;
							idxa3 = ia + i + 3;
							offsa = ja;
							idxb0 = jb + j + 0;
							idxb1 = jb + j + 1;
							idxb2 = jb + j + 2;
							idxb3 = jb + j + 3;
							offsb = ib;
							v00 = 0.0f;
							v01 = 0.0f;
							v02 = 0.0f;
							v03 = 0.0f;
							v10 = 0.0f;
							v11 = 0.0f;
							v12 = 0.0f;
							v13 = 0.0f;
							v20 = 0.0f;
							v21 = 0.0f;
							v22 = 0.0f;
							v23 = 0.0f;
							v30 = 0.0f;
							v31 = 0.0f;
							v32 = 0.0f;
							v33 = 0.0f;

							//
							// Different variants of internal loop
							//
							for (t = 0; t <= k - 1; t++)
							{
								a0 = a[idxa0, offsa];
								a1 = a[idxa1, offsa];
								b0 = b[offsb, idxb0];
								b1 = b[offsb, idxb1];
								v00 = v00 + a0 * b0;
								v01 = v01 + a0 * b1;
								v10 = v10 + a1 * b0;
								v11 = v11 + a1 * b1;
								a2 = a[idxa2, offsa];
								a3 = a[idxa3, offsa];
								v20 = v20 + a2 * b0;
								v21 = v21 + a2 * b1;
								v30 = v30 + a3 * b0;
								v31 = v31 + a3 * b1;
								b2 = b[offsb, idxb2];
								b3 = b[offsb, idxb3];
								v22 = v22 + a2 * b2;
								v23 = v23 + a2 * b3;
								v32 = v32 + a3 * b2;
								v33 = v33 + a3 * b3;
								v02 = v02 + a0 * b2;
								v03 = v03 + a0 * b3;
								v12 = v12 + a1 * b2;
								v13 = v13 + a1 * b3;
								offsa = offsa + 1;
								offsb = offsb + 1;
							}
							if ((double)(beta) == (double)(0))
							{
								c[ic + i + 0, jc + j + 0] = alpha * v00;
								c[ic + i + 0, jc + j + 1] = alpha * v01;
								c[ic + i + 0, jc + j + 2] = alpha * v02;
								c[ic + i + 0, jc + j + 3] = alpha * v03;
								c[ic + i + 1, jc + j + 0] = alpha * v10;
								c[ic + i + 1, jc + j + 1] = alpha * v11;
								c[ic + i + 1, jc + j + 2] = alpha * v12;
								c[ic + i + 1, jc + j + 3] = alpha * v13;
								c[ic + i + 2, jc + j + 0] = alpha * v20;
								c[ic + i + 2, jc + j + 1] = alpha * v21;
								c[ic + i + 2, jc + j + 2] = alpha * v22;
								c[ic + i + 2, jc + j + 3] = alpha * v23;
								c[ic + i + 3, jc + j + 0] = alpha * v30;
								c[ic + i + 3, jc + j + 1] = alpha * v31;
								c[ic + i + 3, jc + j + 2] = alpha * v32;
								c[ic + i + 3, jc + j + 3] = alpha * v33;
							}
							else
							{
								c[ic + i + 0, jc + j + 0] = beta * c[ic + i + 0, jc + j + 0] + alpha * v00;
								c[ic + i + 0, jc + j + 1] = beta * c[ic + i + 0, jc + j + 1] + alpha * v01;
								c[ic + i + 0, jc + j + 2] = beta * c[ic + i + 0, jc + j + 2] + alpha * v02;
								c[ic + i + 0, jc + j + 3] = beta * c[ic + i + 0, jc + j + 3] + alpha * v03;
								c[ic + i + 1, jc + j + 0] = beta * c[ic + i + 1, jc + j + 0] + alpha * v10;
								c[ic + i + 1, jc + j + 1] = beta * c[ic + i + 1, jc + j + 1] + alpha * v11;
								c[ic + i + 1, jc + j + 2] = beta * c[ic + i + 1, jc + j + 2] + alpha * v12;
								c[ic + i + 1, jc + j + 3] = beta * c[ic + i + 1, jc + j + 3] + alpha * v13;
								c[ic + i + 2, jc + j + 0] = beta * c[ic + i + 2, jc + j + 0] + alpha * v20;
								c[ic + i + 2, jc + j + 1] = beta * c[ic + i + 2, jc + j + 1] + alpha * v21;
								c[ic + i + 2, jc + j + 2] = beta * c[ic + i + 2, jc + j + 2] + alpha * v22;
								c[ic + i + 2, jc + j + 3] = beta * c[ic + i + 2, jc + j + 3] + alpha * v23;
								c[ic + i + 3, jc + j + 0] = beta * c[ic + i + 3, jc + j + 0] + alpha * v30;
								c[ic + i + 3, jc + j + 1] = beta * c[ic + i + 3, jc + j + 1] + alpha * v31;
								c[ic + i + 3, jc + j + 2] = beta * c[ic + i + 3, jc + j + 2] + alpha * v32;
								c[ic + i + 3, jc + j + 3] = beta * c[ic + i + 3, jc + j + 3] + alpha * v33;
							}
						}
						else
						{

							//
							// Determine submatrix [I0..I1]x[J0..J1] to process
							//
							i0 = i;
							i1 = Math.Min(i + 3, m - 1);
							j0 = j;
							j1 = Math.Min(j + 3, n - 1);

							//
							// Process submatrix
							//
							for (ik = i0; ik <= i1; ik++)
							{
								for (jk = j0; jk <= j1; jk++)
								{
									if (k == 0 || (double)(alpha) == (double)(0))
									{
										v = 0;
									}
									else
									{
										i1_ = (ib) - (ja);
										v = 0.0f;
										for (i_ = ja; i_ <= ja + k - 1; i_++)
										{
											v += a[ia + ik, i_] * b[i_ + i1_, jb + jk];
										}
									}
									if ((double)(beta) == (double)(0))
									{
										c[ic + ik, jc + jk] = alpha * v;
									}
									else
									{
										c[ic + ik, jc + jk] = beta * c[ic + ik, jc + jk] + alpha * v;
									}
								}
							}
						}
						j = j + 4;
					}
					i = i + 4;
				}
			}


			/*************************************************************************
			RMatrixGEMM kernel, basecase code for RMatrixGEMM, specialized for sitation
			with OpTypeA=0 and OpTypeB=1.

			Additional info:
			* this function requires that Alpha<>0 (assertion is thrown otherwise)

			INPUT PARAMETERS
					M       -   matrix size, M>0
					N       -   matrix size, N>0
					K       -   matrix size, K>0
					Alpha   -   coefficient
					A       -   matrix
					IA      -   submatrix offset
					JA      -   submatrix offset
					B       -   matrix
					IB      -   submatrix offset
					JB      -   submatrix offset
					Beta    -   coefficient
					C       -   PREALLOCATED output matrix
					IC      -   submatrix offset
					JC      -   submatrix offset

				-- ALGLIB routine --
					 27.03.2013
					 Bochkanov Sergey
			*************************************************************************/
			public static void rmatrixgemmk44v01(int m,
					int n,
					int k,
					double alpha,
					double[,] a,
					int ia,
					int ja,
					double[,] b,
					int ib,
					int jb,
					double beta,
					double[,] c,
					int ic,
					int jc)
			{
				int i = 0;
				int j = 0;
				double v = 0;
				double v00 = 0;
				double v01 = 0;
				double v02 = 0;
				double v03 = 0;
				double v10 = 0;
				double v11 = 0;
				double v12 = 0;
				double v13 = 0;
				double v20 = 0;
				double v21 = 0;
				double v22 = 0;
				double v23 = 0;
				double v30 = 0;
				double v31 = 0;
				double v32 = 0;
				double v33 = 0;
				double a0 = 0;
				double a1 = 0;
				double a2 = 0;
				double a3 = 0;
				double b0 = 0;
				double b1 = 0;
				double b2 = 0;
				double b3 = 0;
				int idxa0 = 0;
				int idxa1 = 0;
				int idxa2 = 0;
				int idxa3 = 0;
				int idxb0 = 0;
				int idxb1 = 0;
				int idxb2 = 0;
				int idxb3 = 0;
				int i0 = 0;
				int i1 = 0;
				int ik = 0;
				int j0 = 0;
				int j1 = 0;
				int jk = 0;
				int t = 0;
				int offsa = 0;
				int offsb = 0;
				int i_ = 0;
				int i1_ = 0;

				alglib.ap.assert((double)(alpha) != (double)(0), "RMatrixGEMMK44V00: internal error (Alpha=0)");

				//
				// if matrix size is zero
				//
				if (m == 0 || n == 0)
				{
					return;
				}

				//
				// A*B'
				//
				i = 0;
				while (i < m)
				{
					j = 0;
					while (j < n)
					{

						//
						// Choose between specialized 4x4 code and general code
						//
						if (i + 4 <= m && j + 4 <= n)
						{

							//
							// Specialized 4x4 code for [I..I+3]x[J..J+3] submatrix of C.
							//
							// This submatrix is calculated as sum of K rank-1 products,
							// with operands cached in local variables in order to speed
							// up operations with arrays.
							//
							idxa0 = ia + i + 0;
							idxa1 = ia + i + 1;
							idxa2 = ia + i + 2;
							idxa3 = ia + i + 3;
							offsa = ja;
							idxb0 = ib + j + 0;
							idxb1 = ib + j + 1;
							idxb2 = ib + j + 2;
							idxb3 = ib + j + 3;
							offsb = jb;
							v00 = 0.0f;
							v01 = 0.0f;
							v02 = 0.0f;
							v03 = 0.0f;
							v10 = 0.0f;
							v11 = 0.0f;
							v12 = 0.0f;
							v13 = 0.0f;
							v20 = 0.0f;
							v21 = 0.0f;
							v22 = 0.0f;
							v23 = 0.0f;
							v30 = 0.0f;
							v31 = 0.0f;
							v32 = 0.0f;
							v33 = 0.0f;
							for (t = 0; t <= k - 1; t++)
							{
								a0 = a[idxa0, offsa];
								a1 = a[idxa1, offsa];
								b0 = b[idxb0, offsb];
								b1 = b[idxb1, offsb];
								v00 = v00 + a0 * b0;
								v01 = v01 + a0 * b1;
								v10 = v10 + a1 * b0;
								v11 = v11 + a1 * b1;
								a2 = a[idxa2, offsa];
								a3 = a[idxa3, offsa];
								v20 = v20 + a2 * b0;
								v21 = v21 + a2 * b1;
								v30 = v30 + a3 * b0;
								v31 = v31 + a3 * b1;
								b2 = b[idxb2, offsb];
								b3 = b[idxb3, offsb];
								v22 = v22 + a2 * b2;
								v23 = v23 + a2 * b3;
								v32 = v32 + a3 * b2;
								v33 = v33 + a3 * b3;
								v02 = v02 + a0 * b2;
								v03 = v03 + a0 * b3;
								v12 = v12 + a1 * b2;
								v13 = v13 + a1 * b3;
								offsa = offsa + 1;
								offsb = offsb + 1;
							}
							if ((double)(beta) == (double)(0))
							{
								c[ic + i + 0, jc + j + 0] = alpha * v00;
								c[ic + i + 0, jc + j + 1] = alpha * v01;
								c[ic + i + 0, jc + j + 2] = alpha * v02;
								c[ic + i + 0, jc + j + 3] = alpha * v03;
								c[ic + i + 1, jc + j + 0] = alpha * v10;
								c[ic + i + 1, jc + j + 1] = alpha * v11;
								c[ic + i + 1, jc + j + 2] = alpha * v12;
								c[ic + i + 1, jc + j + 3] = alpha * v13;
								c[ic + i + 2, jc + j + 0] = alpha * v20;
								c[ic + i + 2, jc + j + 1] = alpha * v21;
								c[ic + i + 2, jc + j + 2] = alpha * v22;
								c[ic + i + 2, jc + j + 3] = alpha * v23;
								c[ic + i + 3, jc + j + 0] = alpha * v30;
								c[ic + i + 3, jc + j + 1] = alpha * v31;
								c[ic + i + 3, jc + j + 2] = alpha * v32;
								c[ic + i + 3, jc + j + 3] = alpha * v33;
							}
							else
							{
								c[ic + i + 0, jc + j + 0] = beta * c[ic + i + 0, jc + j + 0] + alpha * v00;
								c[ic + i + 0, jc + j + 1] = beta * c[ic + i + 0, jc + j + 1] + alpha * v01;
								c[ic + i + 0, jc + j + 2] = beta * c[ic + i + 0, jc + j + 2] + alpha * v02;
								c[ic + i + 0, jc + j + 3] = beta * c[ic + i + 0, jc + j + 3] + alpha * v03;
								c[ic + i + 1, jc + j + 0] = beta * c[ic + i + 1, jc + j + 0] + alpha * v10;
								c[ic + i + 1, jc + j + 1] = beta * c[ic + i + 1, jc + j + 1] + alpha * v11;
								c[ic + i + 1, jc + j + 2] = beta * c[ic + i + 1, jc + j + 2] + alpha * v12;
								c[ic + i + 1, jc + j + 3] = beta * c[ic + i + 1, jc + j + 3] + alpha * v13;
								c[ic + i + 2, jc + j + 0] = beta * c[ic + i + 2, jc + j + 0] + alpha * v20;
								c[ic + i + 2, jc + j + 1] = beta * c[ic + i + 2, jc + j + 1] + alpha * v21;
								c[ic + i + 2, jc + j + 2] = beta * c[ic + i + 2, jc + j + 2] + alpha * v22;
								c[ic + i + 2, jc + j + 3] = beta * c[ic + i + 2, jc + j + 3] + alpha * v23;
								c[ic + i + 3, jc + j + 0] = beta * c[ic + i + 3, jc + j + 0] + alpha * v30;
								c[ic + i + 3, jc + j + 1] = beta * c[ic + i + 3, jc + j + 1] + alpha * v31;
								c[ic + i + 3, jc + j + 2] = beta * c[ic + i + 3, jc + j + 2] + alpha * v32;
								c[ic + i + 3, jc + j + 3] = beta * c[ic + i + 3, jc + j + 3] + alpha * v33;
							}
						}
						else
						{

							//
							// Determine submatrix [I0..I1]x[J0..J1] to process
							//
							i0 = i;
							i1 = Math.Min(i + 3, m - 1);
							j0 = j;
							j1 = Math.Min(j + 3, n - 1);

							//
							// Process submatrix
							//
							for (ik = i0; ik <= i1; ik++)
							{
								for (jk = j0; jk <= j1; jk++)
								{
									if (k == 0 || (double)(alpha) == (double)(0))
									{
										v = 0;
									}
									else
									{
										i1_ = (jb) - (ja);
										v = 0.0f;
										for (i_ = ja; i_ <= ja + k - 1; i_++)
										{
											v += a[ia + ik, i_] * b[ib + jk, i_ + i1_];
										}
									}
									if ((double)(beta) == (double)(0))
									{
										c[ic + ik, jc + jk] = alpha * v;
									}
									else
									{
										c[ic + ik, jc + jk] = beta * c[ic + ik, jc + jk] + alpha * v;
									}
								}
							}
						}
						j = j + 4;
					}
					i = i + 4;
				}
			}


			/*************************************************************************
			RMatrixGEMM kernel, basecase code for RMatrixGEMM, specialized for sitation
			with OpTypeA=1 and OpTypeB=0.

			Additional info:
			* this function requires that Alpha<>0 (assertion is thrown otherwise)

			INPUT PARAMETERS
					M       -   matrix size, M>0
					N       -   matrix size, N>0
					K       -   matrix size, K>0
					Alpha   -   coefficient
					A       -   matrix
					IA      -   submatrix offset
					JA      -   submatrix offset
					B       -   matrix
					IB      -   submatrix offset
					JB      -   submatrix offset
					Beta    -   coefficient
					C       -   PREALLOCATED output matrix
					IC      -   submatrix offset
					JC      -   submatrix offset

				-- ALGLIB routine --
					 27.03.2013
					 Bochkanov Sergey
			*************************************************************************/
			public static void rmatrixgemmk44v10(int m,
					int n,
					int k,
					double alpha,
					double[,] a,
					int ia,
					int ja,
					double[,] b,
					int ib,
					int jb,
					double beta,
					double[,] c,
					int ic,
					int jc)
			{
				int i = 0;
				int j = 0;
				double v = 0;
				double v00 = 0;
				double v01 = 0;
				double v02 = 0;
				double v03 = 0;
				double v10 = 0;
				double v11 = 0;
				double v12 = 0;
				double v13 = 0;
				double v20 = 0;
				double v21 = 0;
				double v22 = 0;
				double v23 = 0;
				double v30 = 0;
				double v31 = 0;
				double v32 = 0;
				double v33 = 0;
				double a0 = 0;
				double a1 = 0;
				double a2 = 0;
				double a3 = 0;
				double b0 = 0;
				double b1 = 0;
				double b2 = 0;
				double b3 = 0;
				int idxa0 = 0;
				int idxa1 = 0;
				int idxa2 = 0;
				int idxa3 = 0;
				int idxb0 = 0;
				int idxb1 = 0;
				int idxb2 = 0;
				int idxb3 = 0;
				int i0 = 0;
				int i1 = 0;
				int ik = 0;
				int j0 = 0;
				int j1 = 0;
				int jk = 0;
				int t = 0;
				int offsa = 0;
				int offsb = 0;
				int i_ = 0;
				int i1_ = 0;

				alglib.ap.assert((double)(alpha) != (double)(0), "RMatrixGEMMK44V00: internal error (Alpha=0)");

				//
				// if matrix size is zero
				//
				if (m == 0 || n == 0)
				{
					return;
				}

				//
				// A'*B
				//
				i = 0;
				while (i < m)
				{
					j = 0;
					while (j < n)
					{

						//
						// Choose between specialized 4x4 code and general code
						//
						if (i + 4 <= m && j + 4 <= n)
						{

							//
							// Specialized 4x4 code for [I..I+3]x[J..J+3] submatrix of C.
							//
							// This submatrix is calculated as sum of K rank-1 products,
							// with operands cached in local variables in order to speed
							// up operations with arrays.
							//
							idxa0 = ja + i + 0;
							idxa1 = ja + i + 1;
							idxa2 = ja + i + 2;
							idxa3 = ja + i + 3;
							offsa = ia;
							idxb0 = jb + j + 0;
							idxb1 = jb + j + 1;
							idxb2 = jb + j + 2;
							idxb3 = jb + j + 3;
							offsb = ib;
							v00 = 0.0f;
							v01 = 0.0f;
							v02 = 0.0f;
							v03 = 0.0f;
							v10 = 0.0f;
							v11 = 0.0f;
							v12 = 0.0f;
							v13 = 0.0f;
							v20 = 0.0f;
							v21 = 0.0f;
							v22 = 0.0f;
							v23 = 0.0f;
							v30 = 0.0f;
							v31 = 0.0f;
							v32 = 0.0f;
							v33 = 0.0f;
							for (t = 0; t <= k - 1; t++)
							{
								a0 = a[offsa, idxa0];
								a1 = a[offsa, idxa1];
								b0 = b[offsb, idxb0];
								b1 = b[offsb, idxb1];
								v00 = v00 + a0 * b0;
								v01 = v01 + a0 * b1;
								v10 = v10 + a1 * b0;
								v11 = v11 + a1 * b1;
								a2 = a[offsa, idxa2];
								a3 = a[offsa, idxa3];
								v20 = v20 + a2 * b0;
								v21 = v21 + a2 * b1;
								v30 = v30 + a3 * b0;
								v31 = v31 + a3 * b1;
								b2 = b[offsb, idxb2];
								b3 = b[offsb, idxb3];
								v22 = v22 + a2 * b2;
								v23 = v23 + a2 * b3;
								v32 = v32 + a3 * b2;
								v33 = v33 + a3 * b3;
								v02 = v02 + a0 * b2;
								v03 = v03 + a0 * b3;
								v12 = v12 + a1 * b2;
								v13 = v13 + a1 * b3;
								offsa = offsa + 1;
								offsb = offsb + 1;
							}
							if ((double)(beta) == (double)(0))
							{
								c[ic + i + 0, jc + j + 0] = alpha * v00;
								c[ic + i + 0, jc + j + 1] = alpha * v01;
								c[ic + i + 0, jc + j + 2] = alpha * v02;
								c[ic + i + 0, jc + j + 3] = alpha * v03;
								c[ic + i + 1, jc + j + 0] = alpha * v10;
								c[ic + i + 1, jc + j + 1] = alpha * v11;
								c[ic + i + 1, jc + j + 2] = alpha * v12;
								c[ic + i + 1, jc + j + 3] = alpha * v13;
								c[ic + i + 2, jc + j + 0] = alpha * v20;
								c[ic + i + 2, jc + j + 1] = alpha * v21;
								c[ic + i + 2, jc + j + 2] = alpha * v22;
								c[ic + i + 2, jc + j + 3] = alpha * v23;
								c[ic + i + 3, jc + j + 0] = alpha * v30;
								c[ic + i + 3, jc + j + 1] = alpha * v31;
								c[ic + i + 3, jc + j + 2] = alpha * v32;
								c[ic + i + 3, jc + j + 3] = alpha * v33;
							}
							else
							{
								c[ic + i + 0, jc + j + 0] = beta * c[ic + i + 0, jc + j + 0] + alpha * v00;
								c[ic + i + 0, jc + j + 1] = beta * c[ic + i + 0, jc + j + 1] + alpha * v01;
								c[ic + i + 0, jc + j + 2] = beta * c[ic + i + 0, jc + j + 2] + alpha * v02;
								c[ic + i + 0, jc + j + 3] = beta * c[ic + i + 0, jc + j + 3] + alpha * v03;
								c[ic + i + 1, jc + j + 0] = beta * c[ic + i + 1, jc + j + 0] + alpha * v10;
								c[ic + i + 1, jc + j + 1] = beta * c[ic + i + 1, jc + j + 1] + alpha * v11;
								c[ic + i + 1, jc + j + 2] = beta * c[ic + i + 1, jc + j + 2] + alpha * v12;
								c[ic + i + 1, jc + j + 3] = beta * c[ic + i + 1, jc + j + 3] + alpha * v13;
								c[ic + i + 2, jc + j + 0] = beta * c[ic + i + 2, jc + j + 0] + alpha * v20;
								c[ic + i + 2, jc + j + 1] = beta * c[ic + i + 2, jc + j + 1] + alpha * v21;
								c[ic + i + 2, jc + j + 2] = beta * c[ic + i + 2, jc + j + 2] + alpha * v22;
								c[ic + i + 2, jc + j + 3] = beta * c[ic + i + 2, jc + j + 3] + alpha * v23;
								c[ic + i + 3, jc + j + 0] = beta * c[ic + i + 3, jc + j + 0] + alpha * v30;
								c[ic + i + 3, jc + j + 1] = beta * c[ic + i + 3, jc + j + 1] + alpha * v31;
								c[ic + i + 3, jc + j + 2] = beta * c[ic + i + 3, jc + j + 2] + alpha * v32;
								c[ic + i + 3, jc + j + 3] = beta * c[ic + i + 3, jc + j + 3] + alpha * v33;
							}
						}
						else
						{

							//
							// Determine submatrix [I0..I1]x[J0..J1] to process
							//
							i0 = i;
							i1 = Math.Min(i + 3, m - 1);
							j0 = j;
							j1 = Math.Min(j + 3, n - 1);

							//
							// Process submatrix
							//
							for (ik = i0; ik <= i1; ik++)
							{
								for (jk = j0; jk <= j1; jk++)
								{
									if (k == 0 || (double)(alpha) == (double)(0))
									{
										v = 0;
									}
									else
									{
										v = 0.0f;
										i1_ = (ib) - (ia);
										v = 0.0f;
										for (i_ = ia; i_ <= ia + k - 1; i_++)
										{
											v += a[i_, ja + ik] * b[i_ + i1_, jb + jk];
										}
									}
									if ((double)(beta) == (double)(0))
									{
										c[ic + ik, jc + jk] = alpha * v;
									}
									else
									{
										c[ic + ik, jc + jk] = beta * c[ic + ik, jc + jk] + alpha * v;
									}
								}
							}
						}
						j = j + 4;
					}
					i = i + 4;
				}
			}


			/*************************************************************************
			RMatrixGEMM kernel, basecase code for RMatrixGEMM, specialized for sitation
			with OpTypeA=1 and OpTypeB=1.

			Additional info:
			* this function requires that Alpha<>0 (assertion is thrown otherwise)

			INPUT PARAMETERS
					M       -   matrix size, M>0
					N       -   matrix size, N>0
					K       -   matrix size, K>0
					Alpha   -   coefficient
					A       -   matrix
					IA      -   submatrix offset
					JA      -   submatrix offset
					B       -   matrix
					IB      -   submatrix offset
					JB      -   submatrix offset
					Beta    -   coefficient
					C       -   PREALLOCATED output matrix
					IC      -   submatrix offset
					JC      -   submatrix offset

				-- ALGLIB routine --
					 27.03.2013
					 Bochkanov Sergey
			*************************************************************************/
			public static void rmatrixgemmk44v11(int m,
					int n,
					int k,
					double alpha,
					double[,] a,
					int ia,
					int ja,
					double[,] b,
					int ib,
					int jb,
					double beta,
					double[,] c,
					int ic,
					int jc)
			{
				int i = 0;
				int j = 0;
				double v = 0;
				double v00 = 0;
				double v01 = 0;
				double v02 = 0;
				double v03 = 0;
				double v10 = 0;
				double v11 = 0;
				double v12 = 0;
				double v13 = 0;
				double v20 = 0;
				double v21 = 0;
				double v22 = 0;
				double v23 = 0;
				double v30 = 0;
				double v31 = 0;
				double v32 = 0;
				double v33 = 0;
				double a0 = 0;
				double a1 = 0;
				double a2 = 0;
				double a3 = 0;
				double b0 = 0;
				double b1 = 0;
				double b2 = 0;
				double b3 = 0;
				int idxa0 = 0;
				int idxa1 = 0;
				int idxa2 = 0;
				int idxa3 = 0;
				int idxb0 = 0;
				int idxb1 = 0;
				int idxb2 = 0;
				int idxb3 = 0;
				int i0 = 0;
				int i1 = 0;
				int ik = 0;
				int j0 = 0;
				int j1 = 0;
				int jk = 0;
				int t = 0;
				int offsa = 0;
				int offsb = 0;
				int i_ = 0;
				int i1_ = 0;

				alglib.ap.assert((double)(alpha) != (double)(0), "RMatrixGEMMK44V00: internal error (Alpha=0)");

				//
				// if matrix size is zero
				//
				if (m == 0 || n == 0)
				{
					return;
				}

				//
				// A'*B'
				//
				i = 0;
				while (i < m)
				{
					j = 0;
					while (j < n)
					{

						//
						// Choose between specialized 4x4 code and general code
						//
						if (i + 4 <= m && j + 4 <= n)
						{

							//
							// Specialized 4x4 code for [I..I+3]x[J..J+3] submatrix of C.
							//
							// This submatrix is calculated as sum of K rank-1 products,
							// with operands cached in local variables in order to speed
							// up operations with arrays.
							//
							idxa0 = ja + i + 0;
							idxa1 = ja + i + 1;
							idxa2 = ja + i + 2;
							idxa3 = ja + i + 3;
							offsa = ia;
							idxb0 = ib + j + 0;
							idxb1 = ib + j + 1;
							idxb2 = ib + j + 2;
							idxb3 = ib + j + 3;
							offsb = jb;
							v00 = 0.0f;
							v01 = 0.0f;
							v02 = 0.0f;
							v03 = 0.0f;
							v10 = 0.0f;
							v11 = 0.0f;
							v12 = 0.0f;
							v13 = 0.0f;
							v20 = 0.0f;
							v21 = 0.0f;
							v22 = 0.0f;
							v23 = 0.0f;
							v30 = 0.0f;
							v31 = 0.0f;
							v32 = 0.0f;
							v33 = 0.0f;
							for (t = 0; t <= k - 1; t++)
							{
								a0 = a[offsa, idxa0];
								a1 = a[offsa, idxa1];
								b0 = b[idxb0, offsb];
								b1 = b[idxb1, offsb];
								v00 = v00 + a0 * b0;
								v01 = v01 + a0 * b1;
								v10 = v10 + a1 * b0;
								v11 = v11 + a1 * b1;
								a2 = a[offsa, idxa2];
								a3 = a[offsa, idxa3];
								v20 = v20 + a2 * b0;
								v21 = v21 + a2 * b1;
								v30 = v30 + a3 * b0;
								v31 = v31 + a3 * b1;
								b2 = b[idxb2, offsb];
								b3 = b[idxb3, offsb];
								v22 = v22 + a2 * b2;
								v23 = v23 + a2 * b3;
								v32 = v32 + a3 * b2;
								v33 = v33 + a3 * b3;
								v02 = v02 + a0 * b2;
								v03 = v03 + a0 * b3;
								v12 = v12 + a1 * b2;
								v13 = v13 + a1 * b3;
								offsa = offsa + 1;
								offsb = offsb + 1;
							}
							if ((double)(beta) == (double)(0))
							{
								c[ic + i + 0, jc + j + 0] = alpha * v00;
								c[ic + i + 0, jc + j + 1] = alpha * v01;
								c[ic + i + 0, jc + j + 2] = alpha * v02;
								c[ic + i + 0, jc + j + 3] = alpha * v03;
								c[ic + i + 1, jc + j + 0] = alpha * v10;
								c[ic + i + 1, jc + j + 1] = alpha * v11;
								c[ic + i + 1, jc + j + 2] = alpha * v12;
								c[ic + i + 1, jc + j + 3] = alpha * v13;
								c[ic + i + 2, jc + j + 0] = alpha * v20;
								c[ic + i + 2, jc + j + 1] = alpha * v21;
								c[ic + i + 2, jc + j + 2] = alpha * v22;
								c[ic + i + 2, jc + j + 3] = alpha * v23;
								c[ic + i + 3, jc + j + 0] = alpha * v30;
								c[ic + i + 3, jc + j + 1] = alpha * v31;
								c[ic + i + 3, jc + j + 2] = alpha * v32;
								c[ic + i + 3, jc + j + 3] = alpha * v33;
							}
							else
							{
								c[ic + i + 0, jc + j + 0] = beta * c[ic + i + 0, jc + j + 0] + alpha * v00;
								c[ic + i + 0, jc + j + 1] = beta * c[ic + i + 0, jc + j + 1] + alpha * v01;
								c[ic + i + 0, jc + j + 2] = beta * c[ic + i + 0, jc + j + 2] + alpha * v02;
								c[ic + i + 0, jc + j + 3] = beta * c[ic + i + 0, jc + j + 3] + alpha * v03;
								c[ic + i + 1, jc + j + 0] = beta * c[ic + i + 1, jc + j + 0] + alpha * v10;
								c[ic + i + 1, jc + j + 1] = beta * c[ic + i + 1, jc + j + 1] + alpha * v11;
								c[ic + i + 1, jc + j + 2] = beta * c[ic + i + 1, jc + j + 2] + alpha * v12;
								c[ic + i + 1, jc + j + 3] = beta * c[ic + i + 1, jc + j + 3] + alpha * v13;
								c[ic + i + 2, jc + j + 0] = beta * c[ic + i + 2, jc + j + 0] + alpha * v20;
								c[ic + i + 2, jc + j + 1] = beta * c[ic + i + 2, jc + j + 1] + alpha * v21;
								c[ic + i + 2, jc + j + 2] = beta * c[ic + i + 2, jc + j + 2] + alpha * v22;
								c[ic + i + 2, jc + j + 3] = beta * c[ic + i + 2, jc + j + 3] + alpha * v23;
								c[ic + i + 3, jc + j + 0] = beta * c[ic + i + 3, jc + j + 0] + alpha * v30;
								c[ic + i + 3, jc + j + 1] = beta * c[ic + i + 3, jc + j + 1] + alpha * v31;
								c[ic + i + 3, jc + j + 2] = beta * c[ic + i + 3, jc + j + 2] + alpha * v32;
								c[ic + i + 3, jc + j + 3] = beta * c[ic + i + 3, jc + j + 3] + alpha * v33;
							}
						}
						else
						{

							//
							// Determine submatrix [I0..I1]x[J0..J1] to process
							//
							i0 = i;
							i1 = Math.Min(i + 3, m - 1);
							j0 = j;
							j1 = Math.Min(j + 3, n - 1);

							//
							// Process submatrix
							//
							for (ik = i0; ik <= i1; ik++)
							{
								for (jk = j0; jk <= j1; jk++)
								{
									if (k == 0 || (double)(alpha) == (double)(0))
									{
										v = 0;
									}
									else
									{
										v = 0.0f;
										i1_ = (jb) - (ia);
										v = 0.0f;
										for (i_ = ia; i_ <= ia + k - 1; i_++)
										{
											v += a[i_, ja + ik] * b[ib + jk, i_ + i1_];
										}
									}
									if ((double)(beta) == (double)(0))
									{
										c[ic + ik, jc + jk] = alpha * v;
									}
									else
									{
										c[ic + ik, jc + jk] = beta * c[ic + ik, jc + jk] + alpha * v;
									}
								}
							}
						}
						j = j + 4;
					}
					i = i + 4;
				}
			}


		}
		public class hqrnd
		{
			/*************************************************************************
			Portable high quality random number generator state.
			Initialized with HQRNDRandomize() or HQRNDSeed().

			Fields:
					S1, S2      -   seed values
					V           -   precomputed value
					MagicV      -   'magic' value used to determine whether State structure
													was correctly initialized.
			*************************************************************************/
			public class hqrndstate : apobject
			{
				public int s1;
				public int s2;
				public int magicv;
				public hqrndstate()
				{
					init();
				}
				public override void init()
				{
				}
				public override alglib.apobject make_copy()
				{
					hqrndstate _result = new hqrndstate();
					_result.s1 = s1;
					_result.s2 = s2;
					_result.magicv = magicv;
					return _result;
				}
			};




			public const int hqrndmax = 2147483561;
			public const int hqrndm1 = 2147483563;
			public const int hqrndm2 = 2147483399;
			public const int hqrndmagic = 1634357784;


			/*************************************************************************
			HQRNDState  initialization  with  random  values  which come from standard
			RNG.

				-- ALGLIB --
					 Copyright 02.12.2009 by Bochkanov Sergey
			*************************************************************************/
			public static void hqrndrandomize(hqrndstate state)
			{
				int s0 = 0;
				int s1 = 0;

				s0 = math.randominteger(hqrndm1);
				s1 = math.randominteger(hqrndm2);
				hqrndseed(s0, s1, state);
			}


			/*************************************************************************
			HQRNDState initialization with seed values

				-- ALGLIB --
					 Copyright 02.12.2009 by Bochkanov Sergey
			*************************************************************************/
			public static void hqrndseed(int s1,
					int s2,
					hqrndstate state)
			{

				//
				// Protection against negative seeds:
				//
				//     SEED := -(SEED+1)
				//
				// We can use just "-SEED" because there exists such integer number  N
				// that N<0, -N=N<0 too. (This number is equal to 0x800...000).   Need
				// to handle such seed correctly forces us to use  a  bit  complicated
				// formula.
				//
				if (s1 < 0)
				{
					s1 = -(s1 + 1);
				}
				if (s2 < 0)
				{
					s2 = -(s2 + 1);
				}
				state.s1 = s1 % (hqrndm1 - 1) + 1;
				state.s2 = s2 % (hqrndm2 - 1) + 1;
				state.magicv = hqrndmagic;
			}


			/*************************************************************************
			This function generates random real number in (0,1),
			not including interval boundaries

			State structure must be initialized with HQRNDRandomize() or HQRNDSeed().

				-- ALGLIB --
					 Copyright 02.12.2009 by Bochkanov Sergey
			*************************************************************************/
			public static double hqrnduniformr(hqrndstate state)
			{
				double result = 0;

				result = (double)(hqrndintegerbase(state) + 1) / (double)(hqrndmax + 2);
				return result;
			}


			/*************************************************************************
			This function generates random integer number in [0, N)

			1. State structure must be initialized with HQRNDRandomize() or HQRNDSeed()
			2. N can be any positive number except for very large numbers:
				 * close to 2^31 on 32-bit systems
				 * close to 2^62 on 64-bit systems
				 An exception will be generated if N is too large.

				-- ALGLIB --
					 Copyright 02.12.2009 by Bochkanov Sergey
			*************************************************************************/
			public static int hqrnduniformi(hqrndstate state,
					int n)
			{
				int result = 0;
				int maxcnt = 0;
				int mx = 0;
				int a = 0;
				int b = 0;

				alglib.ap.assert(n > 0, "HQRNDUniformI: N<=0!");
				maxcnt = hqrndmax + 1;

				//
				// Two branches: one for N<=MaxCnt, another for N>MaxCnt.
				//
				if (n > maxcnt)
				{

					//
					// N>=MaxCnt.
					//
					// We have two options here:
					// a) N is exactly divisible by MaxCnt
					// b) N is not divisible by MaxCnt
					//
					// In both cases we reduce problem on interval spanning [0,N)
					// to several subproblems on intervals spanning [0,MaxCnt).
					//
					if (n % maxcnt == 0)
					{

						//
						// N is exactly divisible by MaxCnt.
						//
						// [0,N) range is dividided into N/MaxCnt bins,
						// each of them having length equal to MaxCnt.
						//
						// We generate:
						// * random bin number B
						// * random offset within bin A
						// Both random numbers are generated by recursively
						// calling HQRNDUniformI().
						//
						// Result is equal to A+MaxCnt*B.
						//
						alglib.ap.assert(n / maxcnt <= maxcnt, "HQRNDUniformI: N is too large");
						a = hqrnduniformi(state, maxcnt);
						b = hqrnduniformi(state, n / maxcnt);
						result = a + maxcnt * b;
					}
					else
					{

						//
						// N is NOT exactly divisible by MaxCnt.
						//
						// [0,N) range is dividided into Ceil(N/MaxCnt) bins,
						// each of them having length equal to MaxCnt.
						//
						// We generate:
						// * random bin number B in [0, Ceil(N/MaxCnt)-1]
						// * random offset within bin A
						// * if both of what is below is true
						//   1) bin number B is that of the last bin
						//   2) A >= N mod MaxCnt
						//   then we repeat generation of A/B.
						//   This stage is essential in order to avoid bias in the result.
						// * otherwise, we return A*MaxCnt+N
						//
						alglib.ap.assert(n / maxcnt + 1 <= maxcnt, "HQRNDUniformI: N is too large");
						result = -1;
						do
						{
							a = hqrnduniformi(state, maxcnt);
							b = hqrnduniformi(state, n / maxcnt + 1);
							if (b == n / maxcnt && a >= n % maxcnt)
							{
								continue;
							}
							result = a + maxcnt * b;
						}
						while (result < 0);
					}
				}
				else
				{

					//
					// N<=MaxCnt
					//
					// Code below is a bit complicated because we can not simply
					// return "HQRNDIntegerBase() mod N" - it will be skewed for
					// large N's in [0.1*HQRNDMax...HQRNDMax].
					//
					mx = maxcnt - maxcnt % n;
					do
					{
						result = hqrndintegerbase(state);
					}
					while (result >= mx);
					result = result % n;
				}
				return result;
			}


			/*************************************************************************
			Random number generator: normal numbers

			This function generates one random number from normal distribution.
			Its performance is equal to that of HQRNDNormal2()

			State structure must be initialized with HQRNDRandomize() or HQRNDSeed().

				-- ALGLIB --
					 Copyright 02.12.2009 by Bochkanov Sergey
			*************************************************************************/
			public static double hqrndnormal(hqrndstate state)
			{
				double result = 0;
				double v1 = 0;
				double v2 = 0;

				hqrndnormal2(state, ref v1, ref v2);
				result = v1;
				return result;
			}


			/*************************************************************************
			Random number generator: random X and Y such that X^2+Y^2=1

			State structure must be initialized with HQRNDRandomize() or HQRNDSeed().

				-- ALGLIB --
					 Copyright 02.12.2009 by Bochkanov Sergey
			*************************************************************************/
			public static void hqrndunit2(hqrndstate state,
					ref double x,
					ref double y)
			{
				double v = 0;
				double mx = 0;
				double mn = 0;

				x = 0;
				y = 0;

				do
				{
					hqrndnormal2(state, ref x, ref y);
				}
				while (!((double)(x) != (double)(0) || (double)(y) != (double)(0)));
				mx = Math.Max(Math.Abs(x), Math.Abs(y));
				mn = Math.Min(Math.Abs(x), Math.Abs(y));
				v = (double)(mx * Math.Sqrt(1 + math.sqr(mn / mx)));
				x = x / v;
				y = y / v;
			}


			/*************************************************************************
			Random number generator: normal numbers

			This function generates two independent random numbers from normal
			distribution. Its performance is equal to that of HQRNDNormal()

			State structure must be initialized with HQRNDRandomize() or HQRNDSeed().

				-- ALGLIB --
					 Copyright 02.12.2009 by Bochkanov Sergey
			*************************************************************************/
			public static void hqrndnormal2(hqrndstate state,
					ref double x1,
					ref double x2)
			{
				double u = 0;
				double v = 0;
				double s = 0;

				x1 = 0;
				x2 = 0;

				while (true)
				{
					u = 2 * hqrnduniformr(state) - 1;
					v = 2 * hqrnduniformr(state) - 1;
					s = math.sqr(u) + math.sqr(v);
					if ((double)(s) > (double)(0) && (double)(s) < (double)(1))
					{

						//
						// two Sqrt's instead of one to
						// avoid overflow when S is too small
						//
						s = (double)(Math.Sqrt(-(2 * Math.Log(s))) / Math.Sqrt(s));
						x1 = u * s;
						x2 = v * s;
						return;
					}
				}
			}


			/*************************************************************************
			Random number generator: exponential distribution

			State structure must be initialized with HQRNDRandomize() or HQRNDSeed().

				-- ALGLIB --
					 Copyright 11.08.2007 by Bochkanov Sergey
			*************************************************************************/
			public static double hqrndexponential(hqrndstate state,
					double lambdav)
			{
				double result = 0;

				alglib.ap.assert((double)(lambdav) > (double)(0), "HQRNDExponential: LambdaV<=0!");
				result = (double)(-(Math.Log(hqrnduniformr(state)) / lambdav));
				return result;
			}


			/*************************************************************************
			This function generates  random number from discrete distribution given by
			finite sample X.

			INPUT PARAMETERS
					State   -   high quality random number generator, must be
											initialized with HQRNDRandomize() or HQRNDSeed().
							X   -   finite sample
							N   -   number of elements to use, N>=1

			RESULT
					this function returns one of the X[i] for random i=0..N-1

				-- ALGLIB --
					 Copyright 08.11.2011 by Bochkanov Sergey
			*************************************************************************/
			public static double hqrnddiscrete(hqrndstate state,
					double[] x,
					int n)
			{
				double result = 0;

				alglib.ap.assert(n > 0, "HQRNDDiscrete: N<=0");
				alglib.ap.assert(n <= alglib.ap.len(x), "HQRNDDiscrete: Length(X)<N");
				result = x[hqrnduniformi(state, n)];
				return result;
			}


			/*************************************************************************
			This function generates random number from continuous  distribution  given
			by finite sample X.

			INPUT PARAMETERS
					State   -   high quality random number generator, must be
											initialized with HQRNDRandomize() or HQRNDSeed().
							X   -   finite sample, array[N] (can be larger, in this  case only
											leading N elements are used). THIS ARRAY MUST BE SORTED BY
											ASCENDING.
							N   -   number of elements to use, N>=1

			RESULT
					this function returns random number from continuous distribution which  
					tries to approximate X as mush as possible. min(X)<=Result<=max(X).

				-- ALGLIB --
					 Copyright 08.11.2011 by Bochkanov Sergey
			*************************************************************************/
			public static double hqrndcontinuous(hqrndstate state,
					double[] x,
					int n)
			{
				double result = 0;
				double mx = 0;
				double mn = 0;
				int i = 0;

				alglib.ap.assert(n > 0, "HQRNDContinuous: N<=0");
				alglib.ap.assert(n <= alglib.ap.len(x), "HQRNDContinuous: Length(X)<N");
				if (n == 1)
				{
					result = x[0];
					return result;
				}
				i = hqrnduniformi(state, n - 1);
				mn = x[i];
				mx = x[i + 1];
				alglib.ap.assert((double)(mx) >= (double)(mn), "HQRNDDiscrete: X is not sorted by ascending");
				if ((double)(mx) != (double)(mn))
				{
					result = (mx - mn) * hqrnduniformr(state) + mn;
				}
				else
				{
					result = mn;
				}
				return result;
			}


			/*************************************************************************
			This function returns random integer in [0,HQRNDMax]

			L'Ecuyer, Efficient and portable combined random number generators
			*************************************************************************/
			private static int hqrndintegerbase(hqrndstate state)
			{
				int result = 0;
				int k = 0;

				alglib.ap.assert(state.magicv == hqrndmagic, "HQRNDIntegerBase: State is not correctly initialized!");
				k = state.s1 / 53668;
				state.s1 = 40014 * (state.s1 - k * 53668) - k * 12211;
				if (state.s1 < 0)
				{
					state.s1 = state.s1 + 2147483563;
				}
				k = state.s2 / 52774;
				state.s2 = 40692 * (state.s2 - k * 52774) - k * 3791;
				if (state.s2 < 0)
				{
					state.s2 = state.s2 + 2147483399;
				}

				//
				// Result
				//
				result = state.s1 - state.s2;
				if (result < 1)
				{
					result = result + 2147483562;
				}
				result = result - 1;
				return result;
			}


		}
		public class apserv
		{
			/*************************************************************************
			Buffers for internal functions which need buffers:
			* check for size of the buffer you want to use.
			* if buffer is too small, resize it; leave unchanged, if it is larger than
				needed.
			* use it.

			We can pass this structure to multiple functions;  after first run through
			functions buffer sizes will be finally determined,  and  on  a next run no
			allocation will be required.
			*************************************************************************/
			public class apbuffers : apobject
			{
				public int[] ia0;
				public int[] ia1;
				public int[] ia2;
				public int[] ia3;
				public double[] ra0;
				public double[] ra1;
				public double[] ra2;
				public double[] ra3;
				public apbuffers()
				{
					init();
				}
				public override void init()
				{
					ia0 = new int[0];
					ia1 = new int[0];
					ia2 = new int[0];
					ia3 = new int[0];
					ra0 = new double[0];
					ra1 = new double[0];
					ra2 = new double[0];
					ra3 = new double[0];
				}
				public override alglib.apobject make_copy()
				{
					apbuffers _result = new apbuffers();
					_result.ia0 = (int[])ia0.Clone();
					_result.ia1 = (int[])ia1.Clone();
					_result.ia2 = (int[])ia2.Clone();
					_result.ia3 = (int[])ia3.Clone();
					_result.ra0 = (double[])ra0.Clone();
					_result.ra1 = (double[])ra1.Clone();
					_result.ra2 = (double[])ra2.Clone();
					_result.ra3 = (double[])ra3.Clone();
					return _result;
				}
			};


			/*************************************************************************
			Structure which is used to workaround limitations of ALGLIB parallellization
			environment.

				-- ALGLIB --
					 Copyright 12.04.2009 by Bochkanov Sergey
			*************************************************************************/
			public class sboolean : apobject
			{
				public bool val;
				public sboolean()
				{
					init();
				}
				public override void init()
				{
				}
				public override alglib.apobject make_copy()
				{
					sboolean _result = new sboolean();
					_result.val = val;
					return _result;
				}
			};


			/*************************************************************************
			Structure which is used to workaround limitations of ALGLIB parallellization
			environment.

				-- ALGLIB --
					 Copyright 12.04.2009 by Bochkanov Sergey
			*************************************************************************/
			public class sbooleanarray : apobject
			{
				public bool[] val;
				public sbooleanarray()
				{
					init();
				}
				public override void init()
				{
					val = new bool[0];
				}
				public override alglib.apobject make_copy()
				{
					sbooleanarray _result = new sbooleanarray();
					_result.val = (bool[])val.Clone();
					return _result;
				}
			};


			/*************************************************************************
			Structure which is used to workaround limitations of ALGLIB parallellization
			environment.

				-- ALGLIB --
					 Copyright 12.04.2009 by Bochkanov Sergey
			*************************************************************************/
			public class sinteger : apobject
			{
				public int val;
				public sinteger()
				{
					init();
				}
				public override void init()
				{
				}
				public override alglib.apobject make_copy()
				{
					sinteger _result = new sinteger();
					_result.val = val;
					return _result;
				}
			};


			/*************************************************************************
			Structure which is used to workaround limitations of ALGLIB parallellization
			environment.

				-- ALGLIB --
					 Copyright 12.04.2009 by Bochkanov Sergey
			*************************************************************************/
			public class sintegerarray : apobject
			{
				public int[] val;
				public sintegerarray()
				{
					init();
				}
				public override void init()
				{
					val = new int[0];
				}
				public override alglib.apobject make_copy()
				{
					sintegerarray _result = new sintegerarray();
					_result.val = (int[])val.Clone();
					return _result;
				}
			};


			/*************************************************************************
			Structure which is used to workaround limitations of ALGLIB parallellization
			environment.

				-- ALGLIB --
					 Copyright 12.04.2009 by Bochkanov Sergey
			*************************************************************************/
			public class sreal : apobject
			{
				public double val;
				public sreal()
				{
					init();
				}
				public override void init()
				{
				}
				public override alglib.apobject make_copy()
				{
					sreal _result = new sreal();
					_result.val = val;
					return _result;
				}
			};


			/*************************************************************************
			Structure which is used to workaround limitations of ALGLIB parallellization
			environment.

				-- ALGLIB --
					 Copyright 12.04.2009 by Bochkanov Sergey
			*************************************************************************/
			public class srealarray : apobject
			{
				public double[] val;
				public srealarray()
				{
					init();
				}
				public override void init()
				{
					val = new double[0];
				}
				public override alglib.apobject make_copy()
				{
					srealarray _result = new srealarray();
					_result.val = (double[])val.Clone();
					return _result;
				}
			};


			/*************************************************************************
			Structure which is used to workaround limitations of ALGLIB parallellization
			environment.

				-- ALGLIB --
					 Copyright 12.04.2009 by Bochkanov Sergey
			*************************************************************************/
			public class scomplex : apobject
			{
				public complex val;
				public scomplex()
				{
					init();
				}
				public override void init()
				{
				}
				public override alglib.apobject make_copy()
				{
					scomplex _result = new scomplex();
					_result.val = val;
					return _result;
				}
			};


			/*************************************************************************
			Structure which is used to workaround limitations of ALGLIB parallellization
			environment.

				-- ALGLIB --
					 Copyright 12.04.2009 by Bochkanov Sergey
			*************************************************************************/
			public class scomplexarray : apobject
			{
				public complex[] val;
				public scomplexarray()
				{
					init();
				}
				public override void init()
				{
					val = new complex[0];
				}
				public override alglib.apobject make_copy()
				{
					scomplexarray _result = new scomplexarray();
					_result.val = (alglib.complex[])val.Clone();
					return _result;
				}
			};




			/*************************************************************************
			This function is used to set error flags  during  unit  tests.  When  COND
			parameter is True, FLAG variable is  set  to  True.  When  COND is  False,
			FLAG is unchanged.

			The purpose of this function is to have single  point  where  failures  of
			unit tests can be detected.

			This function returns value of COND.
			*************************************************************************/
			public static bool seterrorflag(ref bool flag,
					bool cond)
			{
				bool result = new bool();

				if (cond)
				{
					flag = true;
				}
				result = cond;
				return result;
			}


			/*************************************************************************
			Internally calls SetErrorFlag() with condition:

					Abs(Val-RefVal)>Tol*Max(Abs(RefVal),S)
            
			This function is used to test relative error in Val against  RefVal,  with
			relative error being replaced by absolute when scale  of  RefVal  is  less
			than S.

			This function returns value of COND.
			*************************************************************************/
			public static bool seterrorflagdiff(ref bool flag,
					double val,
					double refval,
					double tol,
					double s)
			{
				bool result = new bool();

				result = seterrorflag(ref flag, (double)(Math.Abs(val - refval)) > (double)(tol * Math.Max(Math.Abs(refval), s)));
				return result;
			}


			/*************************************************************************
			The function "touches" integer - it is used  to  avoid  compiler  messages
			about unused variables (in rare cases when we do NOT want to remove  these
			variables).

				-- ALGLIB --
					 Copyright 17.09.2012 by Bochkanov Sergey
			*************************************************************************/
			public static void touchint(ref int a)
			{
			}


			/*************************************************************************
			The function "touches" real   -  it is used  to  avoid  compiler  messages
			about unused variables (in rare cases when we do NOT want to remove  these
			variables).

				-- ALGLIB --
					 Copyright 17.09.2012 by Bochkanov Sergey
			*************************************************************************/
			public static void touchreal(ref double a)
			{
			}


			/*************************************************************************
			The function convert integer value to real value.

				-- ALGLIB --
					 Copyright 17.09.2012 by Bochkanov Sergey
			*************************************************************************/
			public static double inttoreal(int a)
			{
				double result = 0;

				result = a;
				return result;
			}


			/*************************************************************************
			The function calculates binary logarithm.

			NOTE: it costs twice as much as Ln(x)

				-- ALGLIB --
					 Copyright 17.09.2012 by Bochkanov Sergey
			*************************************************************************/
			public static double logbase2(double x)
			{
				double result = 0;

				result = (double)(Math.Log(x) / Math.Log(2));
				return result;
			}


			/*************************************************************************
			This function compares two numbers for approximate equality, with tolerance
			to errors as large as max(|a|,|b|)*tol.


				-- ALGLIB --
					 Copyright 02.12.2009 by Bochkanov Sergey
			*************************************************************************/
			public static bool approxequalrel(double a,
					double b,
					double tol)
			{
				bool result = new bool();

				result = (double)(Math.Abs(a - b)) <= (double)(Math.Max(Math.Abs(a), Math.Abs(b)) * tol);
				return result;
			}


			/*************************************************************************
			This  function  generates  1-dimensional  general  interpolation task with
			moderate Lipshitz constant (close to 1.0f)

			If N=1 then suborutine generates only one point at the middle of [A,B]

				-- ALGLIB --
					 Copyright 02.12.2009 by Bochkanov Sergey
			*************************************************************************/
			public static void taskgenint1d(double a,
					double b,
					int n,
					ref double[] x,
					ref double[] y)
			{
				int i = 0;
				double h = 0;

				x = new double[0];
				y = new double[0];

				alglib.ap.assert(n >= 1, "TaskGenInterpolationEqdist1D: N<1!");
				x = new double[n];
				y = new double[n];
				if (n > 1)
				{
					x[0] = a;
					y[0] = 2 * math.randomreal() - 1;
					h = (b - a) / (n - 1);
					for (i = 1; i <= n - 1; i++)
					{
						if (i != n - 1)
						{
							x[i] = (double)(a + (i + 0.2 * (2 * math.randomreal() - 1)) * h);
						}
						else
						{
							x[i] = b;
						}
						y[i] = y[i - 1] + (2 * math.randomreal() - 1) * (x[i] - x[i - 1]);
					}
				}
				else
				{
					x[0] = 0.5f * (a + b);
					y[0] = 2 * math.randomreal() - 1;
				}
			}


			/*************************************************************************
			This function generates  1-dimensional equidistant interpolation task with
			moderate Lipshitz constant (close to 1.0f)

			If N=1 then suborutine generates only one point at the middle of [A,B]

				-- ALGLIB --
					 Copyright 02.12.2009 by Bochkanov Sergey
			*************************************************************************/
			public static void taskgenint1dequidist(double a,
					double b,
					int n,
					ref double[] x,
					ref double[] y)
			{
				int i = 0;
				double h = 0;

				x = new double[0];
				y = new double[0];

				alglib.ap.assert(n >= 1, "TaskGenInterpolationEqdist1D: N<1!");
				x = new double[n];
				y = new double[n];
				if (n > 1)
				{
					x[0] = a;
					y[0] = 2 * math.randomreal() - 1;
					h = (b - a) / (n - 1);
					for (i = 1; i <= n - 1; i++)
					{
						x[i] = a + i * h;
						y[i] = y[i - 1] + (2 * math.randomreal() - 1) * h;
					}
				}
				else
				{
					x[0] = 0.5f * (a + b);
					y[0] = 2 * math.randomreal() - 1;
				}
			}


			/*************************************************************************
			This function generates  1-dimensional Chebyshev-1 interpolation task with
			moderate Lipshitz constant (close to 1.0f)

			If N=1 then suborutine generates only one point at the middle of [A,B]

				-- ALGLIB --
					 Copyright 02.12.2009 by Bochkanov Sergey
			*************************************************************************/
			public static void taskgenint1dcheb1(double a,
					double b,
					int n,
					ref double[] x,
					ref double[] y)
			{
				int i = 0;

				x = new double[0];
				y = new double[0];

				alglib.ap.assert(n >= 1, "TaskGenInterpolation1DCheb1: N<1!");
				x = new double[n];
				y = new double[n];
				if (n > 1)
				{
					for (i = 0; i <= n - 1; i++)
					{
						x[i] = (double)(0.5f * (b + a) + 0.5f * (b - a) * Math.Cos(Math.PI * (2 * i + 1) / (2 * n)));
						if (i == 0)
						{
							y[i] = 2 * math.randomreal() - 1;
						}
						else
						{
							y[i] = y[i - 1] + (2 * math.randomreal() - 1) * (x[i] - x[i - 1]);
						}
					}
				}
				else
				{
					x[0] = 0.5f * (a + b);
					y[0] = 2 * math.randomreal() - 1;
				}
			}


			/*************************************************************************
			This function generates  1-dimensional Chebyshev-2 interpolation task with
			moderate Lipshitz constant (close to 1.0f)

			If N=1 then suborutine generates only one point at the middle of [A,B]

				-- ALGLIB --
					 Copyright 02.12.2009 by Bochkanov Sergey
			*************************************************************************/
			public static void taskgenint1dcheb2(double a,
					double b,
					int n,
					ref double[] x,
					ref double[] y)
			{
				int i = 0;

				x = new double[0];
				y = new double[0];

				alglib.ap.assert(n >= 1, "TaskGenInterpolation1DCheb2: N<1!");
				x = new double[n];
				y = new double[n];
				if (n > 1)
				{
					for (i = 0; i <= n - 1; i++)
					{
						x[i] = (double)(0.5f * (b + a) + 0.5f * (b - a) * Math.Cos(Math.PI * i / (n - 1)));
						if (i == 0)
						{
							y[i] = 2 * math.randomreal() - 1;
						}
						else
						{
							y[i] = y[i - 1] + (2 * math.randomreal() - 1) * (x[i] - x[i - 1]);
						}
					}
				}
				else
				{
					x[0] = 0.5f * (a + b);
					y[0] = 2 * math.randomreal() - 1;
				}
			}


			/*************************************************************************
			This function checks that all values from X[] are distinct. It does more
			than just usual doubleing point comparison:
			* first, it calculates max(X) and min(X)
			* second, it maps X[] from [min,max] to [1,2]
			* only at this stage actual comparison is done

			The meaning of such check is to ensure that all values are "distinct enough"
			and will not cause interpolation subroutine to fail.

			NOTE:
					X[] must be sorted by ascending (subroutine ASSERT's it)

				-- ALGLIB --
					 Copyright 02.12.2009 by Bochkanov Sergey
			*************************************************************************/
			public static bool aredistinct(double[] x,
					int n)
			{
				bool result = new bool();
				double a = 0;
				double b = 0;
				int i = 0;
				bool nonsorted = new bool();

				alglib.ap.assert(n >= 1, "APSERVAreDistinct: internal error (N<1)");
				if (n == 1)
				{

					//
					// everything is alright, it is up to caller to decide whether it
					// can interpolate something with just one point
					//
					result = true;
					return result;
				}
				a = x[0];
				b = x[0];
				nonsorted = false;
				for (i = 1; i <= n - 1; i++)
				{
					a = Math.Min(a, x[i]);
					b = Math.Max(b, x[i]);
					nonsorted = nonsorted || (double)(x[i - 1]) >= (double)(x[i]);
				}
				alglib.ap.assert(!nonsorted, "APSERVAreDistinct: internal error (not sorted)");
				for (i = 1; i <= n - 1; i++)
				{
					if ((double)((x[i] - a) / (b - a) + 1) == (double)((x[i - 1] - a) / (b - a) + 1))
					{
						result = false;
						return result;
					}
				}
				result = true;
				return result;
			}


			/*************************************************************************
			This function checks that two boolean values are the same (both  are  True 
			or both are False).

				-- ALGLIB --
					 Copyright 02.12.2009 by Bochkanov Sergey
			*************************************************************************/
			public static bool aresameboolean(bool v1,
					bool v2)
			{
				bool result = new bool();

				result = (v1 && v2) || (!v1 && !v2);
				return result;
			}


			/*************************************************************************
			If Length(X)<N, resizes X

				-- ALGLIB --
					 Copyright 20.03.2009 by Bochkanov Sergey
			*************************************************************************/
			public static void bvectorsetlengthatleast(ref bool[] x,
					int n)
			{
				if (alglib.ap.len(x) < n)
				{
					x = new bool[n];
				}
			}


			/*************************************************************************
			If Length(X)<N, resizes X

				-- ALGLIB --
					 Copyright 20.03.2009 by Bochkanov Sergey
			*************************************************************************/
			public static void ivectorsetlengthatleast(ref int[] x,
					int n)
			{
				if (alglib.ap.len(x) < n)
				{
					x = new int[n];
				}
			}


			/*************************************************************************
			If Length(X)<N, resizes X

				-- ALGLIB --
					 Copyright 20.03.2009 by Bochkanov Sergey
			*************************************************************************/
			public static void rvectorsetlengthatleast(ref double[] x,
					int n)
			{
				if (alglib.ap.len(x) < n)
				{
					x = new double[n];
				}
			}


			/*************************************************************************
			If Cols(X)<N or Rows(X)<M, resizes X

				-- ALGLIB --
					 Copyright 20.03.2009 by Bochkanov Sergey
			*************************************************************************/
			public static void rmatrixsetlengthatleast(ref double[,] x,
					int m,
					int n)
			{
				if (m > 0 && n > 0)
				{
					if (alglib.ap.rows(x) < m || alglib.ap.cols(x) < n)
					{
						x = new double[m, n];
					}
				}
			}


			/*************************************************************************
			Resizes X and:
			* preserves old contents of X
			* fills new elements by zeros

				-- ALGLIB --
					 Copyright 20.03.2009 by Bochkanov Sergey
			*************************************************************************/
			public static void rmatrixresize(ref double[,] x,
					int m,
					int n)
			{
				double[,] oldx = new double[0, 0];
				int i = 0;
				int j = 0;
				int m2 = 0;
				int n2 = 0;

				m2 = alglib.ap.rows(x);
				n2 = alglib.ap.cols(x);
				alglib.ap.swap(ref x, ref oldx);
				x = new double[m, n];
				for (i = 0; i <= m - 1; i++)
				{
					for (j = 0; j <= n - 1; j++)
					{
						if (i < m2 && j < n2)
						{
							x[i, j] = oldx[i, j];
						}
						else
						{
							x[i, j] = 0.0f;
						}
					}
				}
			}


			/*************************************************************************
			Resizes X and:
			* preserves old contents of X
			* fills new elements by zeros

				-- ALGLIB --
					 Copyright 20.03.2009 by Bochkanov Sergey
			*************************************************************************/
			public static void imatrixresize(ref int[,] x,
					int m,
					int n)
			{
				int[,] oldx = new int[0, 0];
				int i = 0;
				int j = 0;
				int m2 = 0;
				int n2 = 0;

				m2 = alglib.ap.rows(x);
				n2 = alglib.ap.cols(x);
				alglib.ap.swap(ref x, ref oldx);
				x = new int[m, n];
				for (i = 0; i <= m - 1; i++)
				{
					for (j = 0; j <= n - 1; j++)
					{
						if (i < m2 && j < n2)
						{
							x[i, j] = oldx[i, j];
						}
						else
						{
							x[i, j] = 0;
						}
					}
				}
			}


			/*************************************************************************
			This function checks that length(X) is at least N and first N values  from
			X[] are finite

				-- ALGLIB --
					 Copyright 18.06.2010 by Bochkanov Sergey
			*************************************************************************/
			public static bool isfinitevector(double[] x,
					int n)
			{
				bool result = new bool();
				int i = 0;

				alglib.ap.assert(n >= 0, "APSERVIsFiniteVector: internal error (N<0)");
				if (n == 0)
				{
					result = true;
					return result;
				}
				if (alglib.ap.len(x) < n)
				{
					result = false;
					return result;
				}
				for (i = 0; i <= n - 1; i++)
				{
					if (!math.isfinite(x[i]))
					{
						result = false;
						return result;
					}
				}
				result = true;
				return result;
			}


			/*************************************************************************
			This function checks that first N values from X[] are finite

				-- ALGLIB --
					 Copyright 18.06.2010 by Bochkanov Sergey
			*************************************************************************/
			public static bool isfinitecvector(complex[] z,
					int n)
			{
				bool result = new bool();
				int i = 0;

				alglib.ap.assert(n >= 0, "APSERVIsFiniteCVector: internal error (N<0)");
				for (i = 0; i <= n - 1; i++)
				{
					if (!math.isfinite(z[i].x) || !math.isfinite(z[i].y))
					{
						result = false;
						return result;
					}
				}
				result = true;
				return result;
			}


			/*************************************************************************
			This function checks that size of X is at least MxN and values from
			X[0..M-1,0..N-1] are finite.

				-- ALGLIB --
					 Copyright 18.06.2010 by Bochkanov Sergey
			*************************************************************************/
			public static bool apservisfinitematrix(double[,] x,
					int m,
					int n)
			{
				bool result = new bool();
				int i = 0;
				int j = 0;

				alglib.ap.assert(n >= 0, "APSERVIsFiniteMatrix: internal error (N<0)");
				alglib.ap.assert(m >= 0, "APSERVIsFiniteMatrix: internal error (M<0)");
				if (m == 0 || n == 0)
				{
					result = true;
					return result;
				}
				if (alglib.ap.rows(x) < m || alglib.ap.cols(x) < n)
				{
					result = false;
					return result;
				}
				for (i = 0; i <= m - 1; i++)
				{
					for (j = 0; j <= n - 1; j++)
					{
						if (!math.isfinite(x[i, j]))
						{
							result = false;
							return result;
						}
					}
				}
				result = true;
				return result;
			}


			/*************************************************************************
			This function checks that all values from X[0..M-1,0..N-1] are finite

				-- ALGLIB --
					 Copyright 18.06.2010 by Bochkanov Sergey
			*************************************************************************/
			public static bool apservisfinitecmatrix(complex[,] x,
					int m,
					int n)
			{
				bool result = new bool();
				int i = 0;
				int j = 0;

				alglib.ap.assert(n >= 0, "APSERVIsFiniteCMatrix: internal error (N<0)");
				alglib.ap.assert(m >= 0, "APSERVIsFiniteCMatrix: internal error (M<0)");
				for (i = 0; i <= m - 1; i++)
				{
					for (j = 0; j <= n - 1; j++)
					{
						if (!math.isfinite(x[i, j].x) || !math.isfinite(x[i, j].y))
						{
							result = false;
							return result;
						}
					}
				}
				result = true;
				return result;
			}


			/*************************************************************************
			This function checks that size of X is at least NxN and all values from
			upper/lower triangle of X[0..N-1,0..N-1] are finite

				-- ALGLIB --
					 Copyright 18.06.2010 by Bochkanov Sergey
			*************************************************************************/
			public static bool isfinitertrmatrix(double[,] x,
					int n,
					bool isupper)
			{
				bool result = new bool();
				int i = 0;
				int j1 = 0;
				int j2 = 0;
				int j = 0;

				alglib.ap.assert(n >= 0, "APSERVIsFiniteRTRMatrix: internal error (N<0)");
				if (n == 0)
				{
					result = true;
					return result;
				}
				if (alglib.ap.rows(x) < n || alglib.ap.cols(x) < n)
				{
					result = false;
					return result;
				}
				for (i = 0; i <= n - 1; i++)
				{
					if (isupper)
					{
						j1 = i;
						j2 = n - 1;
					}
					else
					{
						j1 = 0;
						j2 = i;
					}
					for (j = j1; j <= j2; j++)
					{
						if (!math.isfinite(x[i, j]))
						{
							result = false;
							return result;
						}
					}
				}
				result = true;
				return result;
			}


			/*************************************************************************
			This function checks that all values from upper/lower triangle of
			X[0..N-1,0..N-1] are finite

				-- ALGLIB --
					 Copyright 18.06.2010 by Bochkanov Sergey
			*************************************************************************/
			public static bool apservisfinitectrmatrix(complex[,] x,
					int n,
					bool isupper)
			{
				bool result = new bool();
				int i = 0;
				int j1 = 0;
				int j2 = 0;
				int j = 0;

				alglib.ap.assert(n >= 0, "APSERVIsFiniteCTRMatrix: internal error (N<0)");
				for (i = 0; i <= n - 1; i++)
				{
					if (isupper)
					{
						j1 = i;
						j2 = n - 1;
					}
					else
					{
						j1 = 0;
						j2 = i;
					}
					for (j = j1; j <= j2; j++)
					{
						if (!math.isfinite(x[i, j].x) || !math.isfinite(x[i, j].y))
						{
							result = false;
							return result;
						}
					}
				}
				result = true;
				return result;
			}


			/*************************************************************************
			This function checks that all values from X[0..M-1,0..N-1] are  finite  or
			NaN's.

				-- ALGLIB --
					 Copyright 18.06.2010 by Bochkanov Sergey
			*************************************************************************/
			public static bool apservisfiniteornanmatrix(double[,] x,
					int m,
					int n)
			{
				bool result = new bool();
				int i = 0;
				int j = 0;

				alglib.ap.assert(n >= 0, "APSERVIsFiniteOrNaNMatrix: internal error (N<0)");
				alglib.ap.assert(m >= 0, "APSERVIsFiniteOrNaNMatrix: internal error (M<0)");
				for (i = 0; i <= m - 1; i++)
				{
					for (j = 0; j <= n - 1; j++)
					{
						if (!(math.isfinite(x[i, j]) || double.IsNaN(x[i, j])))
						{
							result = false;
							return result;
						}
					}
				}
				result = true;
				return result;
			}


			/*************************************************************************
			Safe sqrt(x^2+y^2)

				-- ALGLIB --
					 Copyright by Bochkanov Sergey
			*************************************************************************/
			public static double safepythag2(double x,
					double y)
			{
				double result = 0;
				double w = 0;
				double xabs = 0;
				double yabs = 0;
				double z = 0;

				xabs = Math.Abs(x);
				yabs = Math.Abs(y);
				w = Math.Max(xabs, yabs);
				z = Math.Min(xabs, yabs);
				if ((double)(z) == (double)(0))
				{
					result = w;
				}
				else
				{
					result = (double)(w * Math.Sqrt(1 + math.sqr(z / w)));
				}
				return result;
			}


			/*************************************************************************
			Safe sqrt(x^2+y^2)

				-- ALGLIB --
					 Copyright by Bochkanov Sergey
			*************************************************************************/
			public static double safepythag3(double x,
					double y,
					double z)
			{
				double result = 0;
				double w = 0;

				w = Math.Max(Math.Abs(x), Math.Max(Math.Abs(y), Math.Abs(z)));
				if ((double)(w) == (double)(0))
				{
					result = 0;
					return result;
				}
				x = x / w;
				y = y / w;
				z = z / w;
				result = (double)(w * Math.Sqrt(math.sqr(x) + math.sqr(y) + math.sqr(z)));
				return result;
			}


			/*************************************************************************
			Safe division.

			This function attempts to calculate R=X/Y without overflow.

			It returns:
			* +1, if abs(X/Y)>=MaxRealNumber or undefined - overflow-like situation
						(no overlfow is generated, R is either NAN, PosINF, NegINF)
			*  0, if MinRealNumber<abs(X/Y)<MaxRealNumber or X=0, Y<>0
						(R contains result, may be zero)
			* -1, if 0<abs(X/Y)<MinRealNumber - underflow-like situation
						(R contains zero; it corresponds to underflow)

			No overflow is generated in any case.

				-- ALGLIB --
					 Copyright by Bochkanov Sergey
			*************************************************************************/
			public static int saferdiv(double x,
					double y,
					ref double r)
			{
				int result = 0;

				r = 0;


				//
				// Two special cases:
				// * Y=0
				// * X=0 and Y<>0
				//
				if ((double)(y) == (double)(0))
				{
					result = 1;
					if ((double)(x) == (double)(0))
					{
						r = double.NaN;
					}
					if ((double)(x) > (double)(0))
					{
						r = double.PositiveInfinity;
					}
					if ((double)(x) < (double)(0))
					{
						r = double.NegativeInfinity;
					}
					return result;
				}
				if ((double)(x) == (double)(0))
				{
					r = 0;
					result = 0;
					return result;
				}

				//
				// make Y>0
				//
				if ((double)(y) < (double)(0))
				{
					x = -x;
					y = -y;
				}

				//
				//
				//
				if ((double)(y) >= (double)(1))
				{
					r = x / y;
					if ((double)(Math.Abs(r)) <= (double)(math.minrealnumber))
					{
						result = -1;
						r = 0;
					}
					else
					{
						result = 0;
					}
				}
				else
				{
					if ((double)(Math.Abs(x)) >= (double)(math.maxrealnumber * y))
					{
						if ((double)(x) > (double)(0))
						{
							r = double.PositiveInfinity;
						}
						else
						{
							r = double.NegativeInfinity;
						}
						result = 1;
					}
					else
					{
						r = x / y;
						result = 0;
					}
				}
				return result;
			}


			/*************************************************************************
			This function calculates "safe" min(X/Y,V) for positive finite X, Y, V.
			No overflow is generated in any case.

				-- ALGLIB --
					 Copyright by Bochkanov Sergey
			*************************************************************************/
			public static double safeminposrv(double x,
					double y,
					double v)
			{
				double result = 0;
				double r = 0;

				if ((double)(y) >= (double)(1))
				{

					//
					// Y>=1, we can safely divide by Y
					//
					r = x / y;
					result = v;
					if ((double)(v) > (double)(r))
					{
						result = r;
					}
					else
					{
						result = v;
					}
				}
				else
				{

					//
					// Y<1, we can safely multiply by Y
					//
					if ((double)(x) < (double)(v * y))
					{
						result = x / y;
					}
					else
					{
						result = v;
					}
				}
				return result;
			}


			/*************************************************************************
			This function makes periodic mapping of X to [A,B].

			It accepts X, A, B (A>B). It returns T which lies in  [A,B] and integer K,
			such that X = T + K*(B-A).

			NOTES:
			* K is represented as real value, although actually it is integer
			* T is guaranteed to be in [A,B]
			* T replaces X

				-- ALGLIB --
					 Copyright by Bochkanov Sergey
			*************************************************************************/
			public static void apperiodicmap(ref double x,
					double a,
					double b,
					ref double k)
			{
				k = 0;

				alglib.ap.assert((double)(a) < (double)(b), "APPeriodicMap: internal error!");
				k = (int)Math.Floor((x - a) / (b - a));
				x = x - k * (b - a);
				while ((double)(x) < (double)(a))
				{
					x = x + (b - a);
					k = k - 1;
				}
				while ((double)(x) > (double)(b))
				{
					x = x - (b - a);
					k = k + 1;
				}
				x = Math.Max(x, a);
				x = Math.Min(x, b);
			}


			/*************************************************************************
			Returns random normal number using low-quality system-provided generator

				-- ALGLIB --
					 Copyright 20.03.2009 by Bochkanov Sergey
			*************************************************************************/
			public static double randomnormal()
			{
				double result = 0;
				double u = 0;
				double v = 0;
				double s = 0;

				while (true)
				{
					u = 2 * math.randomreal() - 1;
					v = 2 * math.randomreal() - 1;
					s = math.sqr(u) + math.sqr(v);
					if ((double)(s) > (double)(0) && (double)(s) < (double)(1))
					{

						//
						// two Sqrt's instead of one to
						// avoid overflow when S is too small
						//
						s = (double)(Math.Sqrt(-(2 * Math.Log(s))) / Math.Sqrt(s));
						result = u * s;
						return result;
					}
				}
				return result;
			}


			/*************************************************************************
			Generates random unit vector using low-quality system-provided generator.
			Reallocates array if its size is too short.

				-- ALGLIB --
					 Copyright 20.03.2009 by Bochkanov Sergey
			*************************************************************************/
			public static void randomunit(int n,
					ref double[] x)
			{
				int i = 0;
				double v = 0;
				double vv = 0;

				alglib.ap.assert(n > 0, "RandomUnit: N<=0");
				if (alglib.ap.len(x) < n)
				{
					x = new double[n];
				}
				do
				{
					v = 0.0f;
					for (i = 0; i <= n - 1; i++)
					{
						vv = randomnormal();
						x[i] = vv;
						v = v + vv * vv;
					}
				}
				while ((double)(v) <= (double)(0));
				v = (double)(1 / Math.Sqrt(v));
				for (i = 0; i <= n - 1; i++)
				{
					x[i] = x[i] * v;
				}
			}


			/*************************************************************************
			This function is used to increment value of integer variable
			*************************************************************************/
			public static void inc(ref int v)
			{
				v = v + 1;
			}


			/*************************************************************************
			This function is used to decrement value of integer variable
			*************************************************************************/
			public static void dec(ref int v)
			{
				v = v - 1;
			}


			/*************************************************************************
			This function performs two operations:
			1. decrements value of integer variable, if it is positive
			2. explicitly sets variable to zero if it is non-positive
			It is used by some algorithms to decrease value of internal counters.
			*************************************************************************/
			public static void countdown(ref int v)
			{
				if (v > 0)
				{
					v = v - 1;
				}
				else
				{
					v = 0;
				}
			}


			/*************************************************************************
			'bounds' value: maps X to [B1,B2]

				-- ALGLIB --
					 Copyright 20.03.2009 by Bochkanov Sergey
			*************************************************************************/
			public static double boundval(double x,
					double b1,
					double b2)
			{
				double result = 0;

				if ((double)(x) <= (double)(b1))
				{
					result = b1;
					return result;
				}
				if ((double)(x) >= (double)(b2))
				{
					result = b2;
					return result;
				}
				result = x;
				return result;
			}


			/*************************************************************************
			Allocation of serializer: complex value
			*************************************************************************/
			public static void alloccomplex(alglib.serializer s,
					complex v)
			{
				s.alloc_entry();
				s.alloc_entry();
			}


			/*************************************************************************
			Serialization: complex value
			*************************************************************************/
			public static void serializecomplex(alglib.serializer s,
					complex v)
			{
				s.serialize_double(v.x);
				s.serialize_double(v.y);
			}


			/*************************************************************************
			Unserialization: complex value
			*************************************************************************/
			public static complex unserializecomplex(alglib.serializer s)
			{
				complex result = 0;

				result.x = s.unserialize_double();
				result.y = s.unserialize_double();
				return result;
			}


			/*************************************************************************
			Allocation of serializer: real array
			*************************************************************************/
			public static void allocrealarray(alglib.serializer s,
					double[] v,
					int n)
			{
				int i = 0;

				if (n < 0)
				{
					n = alglib.ap.len(v);
				}
				s.alloc_entry();
				for (i = 0; i <= n - 1; i++)
				{
					s.alloc_entry();
				}
			}


			/*************************************************************************
			Serialization: complex value
			*************************************************************************/
			public static void serializerealarray(alglib.serializer s,
					double[] v,
					int n)
			{
				int i = 0;

				if (n < 0)
				{
					n = alglib.ap.len(v);
				}
				s.serialize_int(n);
				for (i = 0; i <= n - 1; i++)
				{
					s.serialize_double(v[i]);
				}
			}


			/*************************************************************************
			Unserialization: complex value
			*************************************************************************/
			public static void unserializerealarray(alglib.serializer s,
					ref double[] v)
			{
				int n = 0;
				int i = 0;
				double t = 0;

				v = new double[0];

				n = s.unserialize_int();
				if (n == 0)
				{
					return;
				}
				v = new double[n];
				for (i = 0; i <= n - 1; i++)
				{
					t = s.unserialize_double();
					v[i] = t;
				}
			}


			/*************************************************************************
			Allocation of serializer: Integer array
			*************************************************************************/
			public static void allocintegerarray(alglib.serializer s,
					int[] v,
					int n)
			{
				int i = 0;

				if (n < 0)
				{
					n = alglib.ap.len(v);
				}
				s.alloc_entry();
				for (i = 0; i <= n - 1; i++)
				{
					s.alloc_entry();
				}
			}


			/*************************************************************************
			Serialization: Integer array
			*************************************************************************/
			public static void serializeintegerarray(alglib.serializer s,
					int[] v,
					int n)
			{
				int i = 0;

				if (n < 0)
				{
					n = alglib.ap.len(v);
				}
				s.serialize_int(n);
				for (i = 0; i <= n - 1; i++)
				{
					s.serialize_int(v[i]);
				}
			}


			/*************************************************************************
			Unserialization: complex value
			*************************************************************************/
			public static void unserializeintegerarray(alglib.serializer s,
					ref int[] v)
			{
				int n = 0;
				int i = 0;
				int t = 0;

				v = new int[0];

				n = s.unserialize_int();
				if (n == 0)
				{
					return;
				}
				v = new int[n];
				for (i = 0; i <= n - 1; i++)
				{
					t = s.unserialize_int();
					v[i] = t;
				}
			}


			/*************************************************************************
			Allocation of serializer: real matrix
			*************************************************************************/
			public static void allocrealmatrix(alglib.serializer s,
					double[,] v,
					int n0,
					int n1)
			{
				int i = 0;
				int j = 0;

				if (n0 < 0)
				{
					n0 = alglib.ap.rows(v);
				}
				if (n1 < 0)
				{
					n1 = alglib.ap.cols(v);
				}
				s.alloc_entry();
				s.alloc_entry();
				for (i = 0; i <= n0 - 1; i++)
				{
					for (j = 0; j <= n1 - 1; j++)
					{
						s.alloc_entry();
					}
				}
			}


			/*************************************************************************
			Serialization: complex value
			*************************************************************************/
			public static void serializerealmatrix(alglib.serializer s,
					double[,] v,
					int n0,
					int n1)
			{
				int i = 0;
				int j = 0;

				if (n0 < 0)
				{
					n0 = alglib.ap.rows(v);
				}
				if (n1 < 0)
				{
					n1 = alglib.ap.cols(v);
				}
				s.serialize_int(n0);
				s.serialize_int(n1);
				for (i = 0; i <= n0 - 1; i++)
				{
					for (j = 0; j <= n1 - 1; j++)
					{
						s.serialize_double(v[i, j]);
					}
				}
			}


			/*************************************************************************
			Unserialization: complex value
			*************************************************************************/
			public static void unserializerealmatrix(alglib.serializer s,
					ref double[,] v)
			{
				int i = 0;
				int j = 0;
				int n0 = 0;
				int n1 = 0;
				double t = 0;

				v = new double[0, 0];

				n0 = s.unserialize_int();
				n1 = s.unserialize_int();
				if (n0 == 0 || n1 == 0)
				{
					return;
				}
				v = new double[n0, n1];
				for (i = 0; i <= n0 - 1; i++)
				{
					for (j = 0; j <= n1 - 1; j++)
					{
						t = s.unserialize_double();
						v[i, j] = t;
					}
				}
			}


			/*************************************************************************
			Copy integer array
			*************************************************************************/
			public static void copyintegerarray(int[] src,
					ref int[] dst)
			{
				int i = 0;

				dst = new int[0];

				if (alglib.ap.len(src) > 0)
				{
					dst = new int[alglib.ap.len(src)];
					for (i = 0; i <= alglib.ap.len(src) - 1; i++)
					{
						dst[i] = src[i];
					}
				}
			}


			/*************************************************************************
			Copy real array
			*************************************************************************/
			public static void copyrealarray(double[] src,
					ref double[] dst)
			{
				int i = 0;

				dst = new double[0];

				if (alglib.ap.len(src) > 0)
				{
					dst = new double[alglib.ap.len(src)];
					for (i = 0; i <= alglib.ap.len(src) - 1; i++)
					{
						dst[i] = src[i];
					}
				}
			}


			/*************************************************************************
			Copy real matrix
			*************************************************************************/
			public static void copyrealmatrix(double[,] src,
					ref double[,] dst)
			{
				int i = 0;
				int j = 0;

				dst = new double[0, 0];

				if (alglib.ap.rows(src) > 0 && alglib.ap.cols(src) > 0)
				{
					dst = new double[alglib.ap.rows(src), alglib.ap.cols(src)];
					for (i = 0; i <= alglib.ap.rows(src) - 1; i++)
					{
						for (j = 0; j <= alglib.ap.cols(src) - 1; j++)
						{
							dst[i, j] = src[i, j];
						}
					}
				}
			}


			/*************************************************************************
			This function searches integer array. Elements in this array are actually
			records, each NRec elements wide. Each record has unique header - NHeader
			integer values, which identify it. Records are lexicographically sorted by
			header.

			Records are identified by their index, not offset (offset = NRec*index).

			This function searches A (records with indices [I0,I1)) for a record with
			header B. It returns index of this record (not offset!), or -1 on failure.

				-- ALGLIB --
					 Copyright 28.03.2011 by Bochkanov Sergey
			*************************************************************************/
			public static int recsearch(ref int[] a,
					int nrec,
					int nheader,
					int i0,
					int i1,
					int[] b)
			{
				int result = 0;
				int mididx = 0;
				int cflag = 0;
				int k = 0;
				int offs = 0;

				result = -1;
				while (true)
				{
					if (i0 >= i1)
					{
						break;
					}
					mididx = (i0 + i1) / 2;
					offs = nrec * mididx;
					cflag = 0;
					for (k = 0; k <= nheader - 1; k++)
					{
						if (a[offs + k] < b[k])
						{
							cflag = -1;
							break;
						}
						if (a[offs + k] > b[k])
						{
							cflag = 1;
							break;
						}
					}
					if (cflag == 0)
					{
						result = mididx;
						return result;
					}
					if (cflag < 0)
					{
						i0 = mididx + 1;
					}
					else
					{
						i1 = mididx;
					}
				}
				return result;
			}


			/*************************************************************************
			This function is used in parallel functions for recurrent division of large
			task into two smaller tasks.

			It has following properties:
			* it works only for TaskSize>=2 (assertion is thrown otherwise)
			* for TaskSize=2, it returns Task0=1, Task1=1
			* in case TaskSize is odd,  Task0=TaskSize-1, Task1=1
			* in case TaskSize is even, Task0 and Task1 are approximately TaskSize/2
				and both Task0 and Task1 are even, Task0>=Task1

				-- ALGLIB --
					 Copyright 07.04.2013 by Bochkanov Sergey
			*************************************************************************/
			public static void splitlengtheven(int tasksize,
					ref int task0,
					ref int task1)
			{
				task0 = 0;
				task1 = 0;

				alglib.ap.assert(tasksize >= 2, "SplitLengthEven: TaskSize<2");
				if (tasksize == 2)
				{
					task0 = 1;
					task1 = 1;
					return;
				}
				if (tasksize % 2 == 0)
				{

					//
					// Even division
					//
					task0 = tasksize / 2;
					task1 = tasksize / 2;
					if (task0 % 2 != 0)
					{
						task0 = task0 + 1;
						task1 = task1 - 1;
					}
				}
				else
				{

					//
					// Odd task size, split trailing odd part from it.
					//
					task0 = tasksize - 1;
					task1 = 1;
				}
				alglib.ap.assert(task0 >= 1, "SplitLengthEven: internal error");
				alglib.ap.assert(task1 >= 1, "SplitLengthEven: internal error");
			}


			/*************************************************************************
			This function is used in parallel functions for recurrent division of large
			task into two smaller tasks.

			It has following properties:
			* it works only for TaskSize>=2 and ChunkSize>=2
				(assertion is thrown otherwise)
			* Task0+Task1=TaskSize, Task0>0, Task1>0
			* Task0 and Task1 are close to each other
			* in case TaskSize>ChunkSize, Task0 is always divisible by ChunkSize

				-- ALGLIB --
					 Copyright 07.04.2013 by Bochkanov Sergey
			*************************************************************************/
			public static void splitlength(int tasksize,
					int chunksize,
					ref int task0,
					ref int task1)
			{
				task0 = 0;
				task1 = 0;

				alglib.ap.assert(chunksize >= 2, "SplitLength: ChunkSize<2");
				alglib.ap.assert(tasksize >= 2, "SplitLength: TaskSize<2");
				task0 = tasksize / 2;
				if (task0 > chunksize && task0 % chunksize != 0)
				{
					task0 = task0 - task0 % chunksize;
				}
				task1 = tasksize - task0;
				alglib.ap.assert(task0 >= 1, "SplitLength: internal error");
				alglib.ap.assert(task1 >= 1, "SplitLength: internal error");
			}


		}
		public class scodes
		{
			public static int getrdfserializationcode()
			{
				int result = 0;

				result = 1;
				return result;
			}


			public static int getkdtreeserializationcode()
			{
				int result = 0;

				result = 2;
				return result;
			}


			public static int getmlpserializationcode()
			{
				int result = 0;

				result = 3;
				return result;
			}


			public static int getmlpeserializationcode()
			{
				int result = 0;

				result = 4;
				return result;
			}


			public static int getrbfserializationcode()
			{
				int result = 0;

				result = 5;
				return result;
			}


		}
		public class tsort
		{
			/*************************************************************************
			This function sorts array of real keys by ascending.

			Its results are:
			* sorted array A
			* permutation tables P1, P2

			Algorithm outputs permutation tables using two formats:
			* as usual permutation of [0..N-1]. If P1[i]=j, then sorted A[i]  contains
				value which was moved there from J-th position.
			* as a sequence of pairwise permutations. Sorted A[] may  be  obtained  by
				swaping A[i] and A[P2[i]] for all i from 0 to N-1.
          
			INPUT PARAMETERS:
					A       -   unsorted array
					N       -   array size

			OUPUT PARAMETERS:
					A       -   sorted array
					P1, P2  -   permutation tables, array[N]
            
			NOTES:
					this function assumes that A[] is finite; it doesn't checks that
					condition. All other conditions (size of input arrays, etc.) are not
					checked too.

				-- ALGLIB --
					 Copyright 14.05.2008 by Bochkanov Sergey
			*************************************************************************/
			public static void tagsort(ref double[] a,
					int n,
					ref int[] p1,
					ref int[] p2)
			{
				apserv.apbuffers buf = new apserv.apbuffers();

				p1 = new int[0];
				p2 = new int[0];

				tagsortbuf(ref a, n, ref p1, ref p2, buf);
			}


			/*************************************************************************
			Buffered variant of TagSort, which accepts preallocated output arrays as
			well as special structure for buffered allocations. If arrays are too
			short, they are reallocated. If they are large enough, no memory
			allocation is done.

			It is intended to be used in the performance-critical parts of code, where
			additional allocations can lead to severe performance degradation

				-- ALGLIB --
					 Copyright 14.05.2008 by Bochkanov Sergey
			*************************************************************************/
			public static void tagsortbuf(ref double[] a,
					int n,
					ref int[] p1,
					ref int[] p2,
					apserv.apbuffers buf)
			{
				int i = 0;
				int lv = 0;
				int lp = 0;
				int rv = 0;
				int rp = 0;


				//
				// Special cases
				//
				if (n <= 0)
				{
					return;
				}
				if (n == 1)
				{
					apserv.ivectorsetlengthatleast(ref p1, 1);
					apserv.ivectorsetlengthatleast(ref p2, 1);
					p1[0] = 0;
					p2[0] = 0;
					return;
				}

				//
				// General case, N>1: prepare permutations table P1
				//
				apserv.ivectorsetlengthatleast(ref p1, n);
				for (i = 0; i <= n - 1; i++)
				{
					p1[i] = i;
				}

				//
				// General case, N>1: sort, update P1
				//
				apserv.rvectorsetlengthatleast(ref buf.ra0, n);
				apserv.ivectorsetlengthatleast(ref buf.ia0, n);
				tagsortfasti(ref a, ref p1, ref buf.ra0, ref buf.ia0, n);

				//
				// General case, N>1: fill permutations table P2
				//
				// To fill P2 we maintain two arrays:
				// * PV (Buf.IA0), Position(Value). PV[i] contains position of I-th key at the moment
				// * VP (Buf.IA1), Value(Position). VP[i] contains key which has position I at the moment
				//
				// At each step we making permutation of two items:
				//   Left, which is given by position/value pair LP/LV
				//   and Right, which is given by RP/RV
				// and updating PV[] and VP[] correspondingly.
				//
				apserv.ivectorsetlengthatleast(ref buf.ia0, n);
				apserv.ivectorsetlengthatleast(ref buf.ia1, n);
				apserv.ivectorsetlengthatleast(ref p2, n);
				for (i = 0; i <= n - 1; i++)
				{
					buf.ia0[i] = i;
					buf.ia1[i] = i;
				}
				for (i = 0; i <= n - 1; i++)
				{

					//
					// calculate LP, LV, RP, RV
					//
					lp = i;
					lv = buf.ia1[lp];
					rv = p1[i];
					rp = buf.ia0[rv];

					//
					// Fill P2
					//
					p2[i] = rp;

					//
					// update PV and VP
					//
					buf.ia1[lp] = rv;
					buf.ia1[rp] = lv;
					buf.ia0[lv] = rp;
					buf.ia0[rv] = lp;
				}
			}


			/*************************************************************************
			Same as TagSort, but optimized for real keys and integer labels.

			A is sorted, and same permutations are applied to B.

			NOTES:
			1.  this function assumes that A[] is finite; it doesn't checks that
					condition. All other conditions (size of input arrays, etc.) are not
					checked too.
			2.  this function uses two buffers, BufA and BufB, each is N elements large.
					They may be preallocated (which will save some time) or not, in which
					case function will automatically allocate memory.

				-- ALGLIB --
					 Copyright 11.12.2008 by Bochkanov Sergey
			*************************************************************************/
			public static void tagsortfasti(ref double[] a,
					ref int[] b,
					ref double[] bufa,
					ref int[] bufb,
					int n)
			{
				int i = 0;
				int j = 0;
				bool isascending = new bool();
				bool isdescending = new bool();
				double tmpr = 0;
				int tmpi = 0;


				//
				// Special case
				//
				if (n <= 1)
				{
					return;
				}

				//
				// Test for already sorted set
				//
				isascending = true;
				isdescending = true;
				for (i = 1; i <= n - 1; i++)
				{
					isascending = isascending && a[i] >= a[i - 1];
					isdescending = isdescending && a[i] <= a[i - 1];
				}
				if (isascending)
				{
					return;
				}
				if (isdescending)
				{
					for (i = 0; i <= n - 1; i++)
					{
						j = n - 1 - i;
						if (j <= i)
						{
							break;
						}
						tmpr = a[i];
						a[i] = a[j];
						a[j] = tmpr;
						tmpi = b[i];
						b[i] = b[j];
						b[j] = tmpi;
					}
					return;
				}

				//
				// General case
				//
				if (alglib.ap.len(bufa) < n)
				{
					bufa = new double[n];
				}
				if (alglib.ap.len(bufb) < n)
				{
					bufb = new int[n];
				}
				tagsortfastirec(ref a, ref b, ref bufa, ref bufb, 0, n - 1);
			}


			/*************************************************************************
			Same as TagSort, but optimized for real keys and real labels.

			A is sorted, and same permutations are applied to B.

			NOTES:
			1.  this function assumes that A[] is finite; it doesn't checks that
					condition. All other conditions (size of input arrays, etc.) are not
					checked too.
			2.  this function uses two buffers, BufA and BufB, each is N elements large.
					They may be preallocated (which will save some time) or not, in which
					case function will automatically allocate memory.

				-- ALGLIB --
					 Copyright 11.12.2008 by Bochkanov Sergey
			*************************************************************************/
			public static void tagsortfastr(ref double[] a,
					ref double[] b,
					ref double[] bufa,
					ref double[] bufb,
					int n)
			{
				int i = 0;
				int j = 0;
				bool isascending = new bool();
				bool isdescending = new bool();
				double tmpr = 0;


				//
				// Special case
				//
				if (n <= 1)
				{
					return;
				}

				//
				// Test for already sorted set
				//
				isascending = true;
				isdescending = true;
				for (i = 1; i <= n - 1; i++)
				{
					isascending = isascending && a[i] >= a[i - 1];
					isdescending = isdescending && a[i] <= a[i - 1];
				}
				if (isascending)
				{
					return;
				}
				if (isdescending)
				{
					for (i = 0; i <= n - 1; i++)
					{
						j = n - 1 - i;
						if (j <= i)
						{
							break;
						}
						tmpr = a[i];
						a[i] = a[j];
						a[j] = tmpr;
						tmpr = b[i];
						b[i] = b[j];
						b[j] = tmpr;
					}
					return;
				}

				//
				// General case
				//
				if (alglib.ap.len(bufa) < n)
				{
					bufa = new double[n];
				}
				if (alglib.ap.len(bufb) < n)
				{
					bufb = new double[n];
				}
				tagsortfastrrec(ref a, ref b, ref bufa, ref bufb, 0, n - 1);
			}


			/*************************************************************************
			Same as TagSort, but optimized for real keys without labels.

			A is sorted, and that's all.

			NOTES:
			1.  this function assumes that A[] is finite; it doesn't checks that
					condition. All other conditions (size of input arrays, etc.) are not
					checked too.
			2.  this function uses buffer, BufA, which is N elements large. It may be
					preallocated (which will save some time) or not, in which case
					function will automatically allocate memory.

				-- ALGLIB --
					 Copyright 11.12.2008 by Bochkanov Sergey
			*************************************************************************/
			public static void tagsortfast(ref double[] a,
					ref double[] bufa,
					int n)
			{
				int i = 0;
				int j = 0;
				bool isascending = new bool();
				bool isdescending = new bool();
				double tmpr = 0;


				//
				// Special case
				//
				if (n <= 1)
				{
					return;
				}

				//
				// Test for already sorted set
				//
				isascending = true;
				isdescending = true;
				for (i = 1; i <= n - 1; i++)
				{
					isascending = isascending && a[i] >= a[i - 1];
					isdescending = isdescending && a[i] <= a[i - 1];
				}
				if (isascending)
				{
					return;
				}
				if (isdescending)
				{
					for (i = 0; i <= n - 1; i++)
					{
						j = n - 1 - i;
						if (j <= i)
						{
							break;
						}
						tmpr = a[i];
						a[i] = a[j];
						a[j] = tmpr;
					}
					return;
				}

				//
				// General case
				//
				if (alglib.ap.len(bufa) < n)
				{
					bufa = new double[n];
				}
				tagsortfastrec(ref a, ref bufa, 0, n - 1);
			}


			/*************************************************************************
			Sorting function optimized for integer keys and real labels, can be used
			to sort middle of the array

			A is sorted, and same permutations are applied to B.

			NOTES:
					this function assumes that A[] is finite; it doesn't checks that
					condition. All other conditions (size of input arrays, etc.) are not
					checked too.

				-- ALGLIB --
					 Copyright 11.12.2008 by Bochkanov Sergey
			*************************************************************************/
			public static void tagsortmiddleir(ref int[] a,
					ref double[] b,
					int offset,
					int n)
			{
				int i = 0;
				int k = 0;
				int t = 0;
				int tmp = 0;
				double tmpr = 0;


				//
				// Special cases
				//
				if (n <= 1)
				{
					return;
				}

				//
				// General case, N>1: sort, update B
				//
				i = 2;
				do
				{
					t = i;
					while (t != 1)
					{
						k = t / 2;
						if (a[offset + k - 1] >= a[offset + t - 1])
						{
							t = 1;
						}
						else
						{
							tmp = a[offset + k - 1];
							a[offset + k - 1] = a[offset + t - 1];
							a[offset + t - 1] = tmp;
							tmpr = b[offset + k - 1];
							b[offset + k - 1] = b[offset + t - 1];
							b[offset + t - 1] = tmpr;
							t = k;
						}
					}
					i = i + 1;
				}
				while (i <= n);
				i = n - 1;
				do
				{
					tmp = a[offset + i];
					a[offset + i] = a[offset + 0];
					a[offset + 0] = tmp;
					tmpr = b[offset + i];
					b[offset + i] = b[offset + 0];
					b[offset + 0] = tmpr;
					t = 1;
					while (t != 0)
					{
						k = 2 * t;
						if (k > i)
						{
							t = 0;
						}
						else
						{
							if (k < i)
							{
								if (a[offset + k] > a[offset + k - 1])
								{
									k = k + 1;
								}
							}
							if (a[offset + t - 1] >= a[offset + k - 1])
							{
								t = 0;
							}
							else
							{
								tmp = a[offset + k - 1];
								a[offset + k - 1] = a[offset + t - 1];
								a[offset + t - 1] = tmp;
								tmpr = b[offset + k - 1];
								b[offset + k - 1] = b[offset + t - 1];
								b[offset + t - 1] = tmpr;
								t = k;
							}
						}
					}
					i = i - 1;
				}
				while (i >= 1);
			}


			/*************************************************************************
			Heap operations: adds element to the heap

			PARAMETERS:
					A       -   heap itself, must be at least array[0..N]
					B       -   array of integer tags, which are updated according to
											permutations in the heap
					N       -   size of the heap (without new element).
											updated on output
					VA      -   value of the element being added
					VB      -   value of the tag

				-- ALGLIB --
					 Copyright 28.02.2010 by Bochkanov Sergey
			*************************************************************************/
			public static void tagheappushi(ref double[] a,
					ref int[] b,
					ref int n,
					double va,
					int vb)
			{
				int j = 0;
				int k = 0;
				double v = 0;

				if (n < 0)
				{
					return;
				}

				//
				// N=0 is a special case
				//
				if (n == 0)
				{
					a[0] = va;
					b[0] = vb;
					n = n + 1;
					return;
				}

				//
				// add current point to the heap
				// (add to the bottom, then move up)
				//
				// we don't write point to the heap
				// until its final position is determined
				// (it allow us to reduce number of array access operations)
				//
				j = n;
				n = n + 1;
				while (j > 0)
				{
					k = (j - 1) / 2;
					v = a[k];
					if ((double)(v) < (double)(va))
					{

						//
						// swap with higher element
						//
						a[j] = v;
						b[j] = b[k];
						j = k;
					}
					else
					{

						//
						// element in its place. terminate.
						//
						break;
					}
				}
				a[j] = va;
				b[j] = vb;
			}


			/*************************************************************************
			Heap operations: replaces top element with new element
			(which is moved down)

			PARAMETERS:
					A       -   heap itself, must be at least array[0..N-1]
					B       -   array of integer tags, which are updated according to
											permutations in the heap
					N       -   size of the heap
					VA      -   value of the element which replaces top element
					VB      -   value of the tag

				-- ALGLIB --
					 Copyright 28.02.2010 by Bochkanov Sergey
			*************************************************************************/
			public static void tagheapreplacetopi(ref double[] a,
					ref int[] b,
					int n,
					double va,
					int vb)
			{
				int j = 0;
				int k1 = 0;
				int k2 = 0;
				double v = 0;
				double v1 = 0;
				double v2 = 0;

				if (n < 1)
				{
					return;
				}

				//
				// N=1 is a special case
				//
				if (n == 1)
				{
					a[0] = va;
					b[0] = vb;
					return;
				}

				//
				// move down through heap:
				// * J  -   current element
				// * K1 -   first child (always exists)
				// * K2 -   second child (may not exists)
				//
				// we don't write point to the heap
				// until its final position is determined
				// (it allow us to reduce number of array access operations)
				//
				j = 0;
				k1 = 1;
				k2 = 2;
				while (k1 < n)
				{
					if (k2 >= n)
					{

						//
						// only one child.
						//
						// swap and terminate (because this child
						// have no siblings due to heap structure)
						//
						v = a[k1];
						if ((double)(v) > (double)(va))
						{
							a[j] = v;
							b[j] = b[k1];
							j = k1;
						}
						break;
					}
					else
					{

						//
						// two childs
						//
						v1 = a[k1];
						v2 = a[k2];
						if ((double)(v1) > (double)(v2))
						{
							if ((double)(va) < (double)(v1))
							{
								a[j] = v1;
								b[j] = b[k1];
								j = k1;
							}
							else
							{
								break;
							}
						}
						else
						{
							if ((double)(va) < (double)(v2))
							{
								a[j] = v2;
								b[j] = b[k2];
								j = k2;
							}
							else
							{
								break;
							}
						}
						k1 = 2 * j + 1;
						k2 = 2 * j + 2;
					}
				}
				a[j] = va;
				b[j] = vb;
			}


			/*************************************************************************
			Heap operations: pops top element from the heap

			PARAMETERS:
					A       -   heap itself, must be at least array[0..N-1]
					B       -   array of integer tags, which are updated according to
											permutations in the heap
					N       -   size of the heap, N>=1

			On output top element is moved to A[N-1], B[N-1], heap is reordered, N is
			decreased by 1.

				-- ALGLIB --
					 Copyright 28.02.2010 by Bochkanov Sergey
			*************************************************************************/
			public static void tagheappopi(ref double[] a,
					ref int[] b,
					ref int n)
			{
				double va = 0;
				int vb = 0;

				if (n < 1)
				{
					return;
				}

				//
				// N=1 is a special case
				//
				if (n == 1)
				{
					n = 0;
					return;
				}

				//
				// swap top element and last element,
				// then reorder heap
				//
				va = a[n - 1];
				vb = b[n - 1];
				a[n - 1] = a[0];
				b[n - 1] = b[0];
				n = n - 1;
				tagheapreplacetopi(ref a, ref b, n, va, vb);
			}


			/*************************************************************************
			Search first element less than T in sorted array.

			PARAMETERS:
					A - sorted array by ascending from 0 to N-1
					N - number of elements in array
					T - the desired element

			RESULT:
					The very first element's index, which isn't less than T.
			In the case when there aren't such elements, returns N.
			*************************************************************************/
			public static int lowerbound(double[] a,
					int n,
					double t)
			{
				int result = 0;
				int l = 0;
				int half = 0;
				int first = 0;
				int middle = 0;

				l = n;
				first = 0;
				while (l > 0)
				{
					half = l / 2;
					middle = first + half;
					if ((double)(a[middle]) < (double)(t))
					{
						first = middle + 1;
						l = l - half - 1;
					}
					else
					{
						l = half;
					}
				}
				result = first;
				return result;
			}


			/*************************************************************************
			Search first element more than T in sorted array.

			PARAMETERS:
					A - sorted array by ascending from 0 to N-1
					N - number of elements in array
					T - the desired element

					RESULT:
					The very first element's index, which more than T.
			In the case when there aren't such elements, returns N.
			*************************************************************************/
			public static int upperbound(double[] a,
					int n,
					double t)
			{
				int result = 0;
				int l = 0;
				int half = 0;
				int first = 0;
				int middle = 0;

				l = n;
				first = 0;
				while (l > 0)
				{
					half = l / 2;
					middle = first + half;
					if ((double)(t) < (double)(a[middle]))
					{
						l = half;
					}
					else
					{
						first = middle + 1;
						l = l - half - 1;
					}
				}
				result = first;
				return result;
			}


			/*************************************************************************
			Internal TagSortFastI: sorts A[I1...I2] (both bounds are included),
			applies same permutations to B.

				-- ALGLIB --
					 Copyright 06.09.2010 by Bochkanov Sergey
			*************************************************************************/
			private static void tagsortfastirec(ref double[] a,
					ref int[] b,
					ref double[] bufa,
					ref int[] bufb,
					int i1,
					int i2)
			{
				int i = 0;
				int j = 0;
				int k = 0;
				int cntless = 0;
				int cnteq = 0;
				int cntgreater = 0;
				double tmpr = 0;
				int tmpi = 0;
				double v0 = 0;
				double v1 = 0;
				double v2 = 0;
				double vp = 0;


				//
				// Fast exit
				//
				if (i2 <= i1)
				{
					return;
				}

				//
				// Non-recursive sort for small arrays
				//
				if (i2 - i1 <= 16)
				{
					for (j = i1 + 1; j <= i2; j++)
					{

						//
						// Search elements [I1..J-1] for place to insert Jth element.
						//
						// This code stops immediately if we can leave A[J] at J-th position
						// (all elements have same value of A[J] larger than any of them)
						//
						tmpr = a[j];
						tmpi = j;
						for (k = j - 1; k >= i1; k--)
						{
							if (a[k] <= tmpr)
							{
								break;
							}
							tmpi = k;
						}
						k = tmpi;

						//
						// Insert Jth element into Kth position
						//
						if (k != j)
						{
							tmpr = a[j];
							tmpi = b[j];
							for (i = j - 1; i >= k; i--)
							{
								a[i + 1] = a[i];
								b[i + 1] = b[i];
							}
							a[k] = tmpr;
							b[k] = tmpi;
						}
					}
					return;
				}

				//
				// Quicksort: choose pivot
				// Here we assume that I2-I1>=2
				//
				v0 = a[i1];
				v1 = a[i1 + (i2 - i1) / 2];
				v2 = a[i2];
				if (v0 > v1)
				{
					tmpr = v1;
					v1 = v0;
					v0 = tmpr;
				}
				if (v1 > v2)
				{
					tmpr = v2;
					v2 = v1;
					v1 = tmpr;
				}
				if (v0 > v1)
				{
					tmpr = v1;
					v1 = v0;
					v0 = tmpr;
				}
				vp = v1;

				//
				// now pass through A/B and:
				// * move elements that are LESS than VP to the left of A/B
				// * move elements that are EQUAL to VP to the right of BufA/BufB (in the reverse order)
				// * move elements that are GREATER than VP to the left of BufA/BufB (in the normal order
				// * move elements from the tail of BufA/BufB to the middle of A/B (restoring normal order)
				// * move elements from the left of BufA/BufB to the end of A/B
				//
				cntless = 0;
				cnteq = 0;
				cntgreater = 0;
				for (i = i1; i <= i2; i++)
				{
					v0 = a[i];
					if (v0 < vp)
					{

						//
						// LESS
						//
						k = i1 + cntless;
						if (i != k)
						{
							a[k] = v0;
							b[k] = b[i];
						}
						cntless = cntless + 1;
						continue;
					}
					if (v0 == vp)
					{

						//
						// EQUAL
						//
						k = i2 - cnteq;
						bufa[k] = v0;
						bufb[k] = b[i];
						cnteq = cnteq + 1;
						continue;
					}

					//
					// GREATER
					//
					k = i1 + cntgreater;
					bufa[k] = v0;
					bufb[k] = b[i];
					cntgreater = cntgreater + 1;
				}
				for (i = 0; i <= cnteq - 1; i++)
				{
					j = i1 + cntless + cnteq - 1 - i;
					k = i2 + i - (cnteq - 1);
					a[j] = bufa[k];
					b[j] = bufb[k];
				}
				for (i = 0; i <= cntgreater - 1; i++)
				{
					j = i1 + cntless + cnteq + i;
					k = i1 + i;
					a[j] = bufa[k];
					b[j] = bufb[k];
				}

				//
				// Sort left and right parts of the array (ignoring middle part)
				//
				tagsortfastirec(ref a, ref b, ref bufa, ref bufb, i1, i1 + cntless - 1);
				tagsortfastirec(ref a, ref b, ref bufa, ref bufb, i1 + cntless + cnteq, i2);
			}


			/*************************************************************************
			Internal TagSortFastR: sorts A[I1...I2] (both bounds are included),
			applies same permutations to B.

				-- ALGLIB --
					 Copyright 06.09.2010 by Bochkanov Sergey
			*************************************************************************/
			private static void tagsortfastrrec(ref double[] a,
					ref double[] b,
					ref double[] bufa,
					ref double[] bufb,
					int i1,
					int i2)
			{
				int i = 0;
				int j = 0;
				int k = 0;
				double tmpr = 0;
				double tmpr2 = 0;
				int tmpi = 0;
				int cntless = 0;
				int cnteq = 0;
				int cntgreater = 0;
				double v0 = 0;
				double v1 = 0;
				double v2 = 0;
				double vp = 0;


				//
				// Fast exit
				//
				if (i2 <= i1)
				{
					return;
				}

				//
				// Non-recursive sort for small arrays
				//
				if (i2 - i1 <= 16)
				{
					for (j = i1 + 1; j <= i2; j++)
					{

						//
						// Search elements [I1..J-1] for place to insert Jth element.
						//
						// This code stops immediatly if we can leave A[J] at J-th position
						// (all elements have same value of A[J] larger than any of them)
						//
						tmpr = a[j];
						tmpi = j;
						for (k = j - 1; k >= i1; k--)
						{
							if (a[k] <= tmpr)
							{
								break;
							}
							tmpi = k;
						}
						k = tmpi;

						//
						// Insert Jth element into Kth position
						//
						if (k != j)
						{
							tmpr = a[j];
							tmpr2 = b[j];
							for (i = j - 1; i >= k; i--)
							{
								a[i + 1] = a[i];
								b[i + 1] = b[i];
							}
							a[k] = tmpr;
							b[k] = tmpr2;
						}
					}
					return;
				}

				//
				// Quicksort: choose pivot
				// Here we assume that I2-I1>=16
				//
				v0 = a[i1];
				v1 = a[i1 + (i2 - i1) / 2];
				v2 = a[i2];
				if (v0 > v1)
				{
					tmpr = v1;
					v1 = v0;
					v0 = tmpr;
				}
				if (v1 > v2)
				{
					tmpr = v2;
					v2 = v1;
					v1 = tmpr;
				}
				if (v0 > v1)
				{
					tmpr = v1;
					v1 = v0;
					v0 = tmpr;
				}
				vp = v1;

				//
				// now pass through A/B and:
				// * move elements that are LESS than VP to the left of A/B
				// * move elements that are EQUAL to VP to the right of BufA/BufB (in the reverse order)
				// * move elements that are GREATER than VP to the left of BufA/BufB (in the normal order
				// * move elements from the tail of BufA/BufB to the middle of A/B (restoring normal order)
				// * move elements from the left of BufA/BufB to the end of A/B
				//
				cntless = 0;
				cnteq = 0;
				cntgreater = 0;
				for (i = i1; i <= i2; i++)
				{
					v0 = a[i];
					if (v0 < vp)
					{

						//
						// LESS
						//
						k = i1 + cntless;
						if (i != k)
						{
							a[k] = v0;
							b[k] = b[i];
						}
						cntless = cntless + 1;
						continue;
					}
					if (v0 == vp)
					{

						//
						// EQUAL
						//
						k = i2 - cnteq;
						bufa[k] = v0;
						bufb[k] = b[i];
						cnteq = cnteq + 1;
						continue;
					}

					//
					// GREATER
					//
					k = i1 + cntgreater;
					bufa[k] = v0;
					bufb[k] = b[i];
					cntgreater = cntgreater + 1;
				}
				for (i = 0; i <= cnteq - 1; i++)
				{
					j = i1 + cntless + cnteq - 1 - i;
					k = i2 + i - (cnteq - 1);
					a[j] = bufa[k];
					b[j] = bufb[k];
				}
				for (i = 0; i <= cntgreater - 1; i++)
				{
					j = i1 + cntless + cnteq + i;
					k = i1 + i;
					a[j] = bufa[k];
					b[j] = bufb[k];
				}

				//
				// Sort left and right parts of the array (ignoring middle part)
				//
				tagsortfastrrec(ref a, ref b, ref bufa, ref bufb, i1, i1 + cntless - 1);
				tagsortfastrrec(ref a, ref b, ref bufa, ref bufb, i1 + cntless + cnteq, i2);
			}


			/*************************************************************************
			Internal TagSortFastI: sorts A[I1...I2] (both bounds are included),
			applies same permutations to B.

				-- ALGLIB --
					 Copyright 06.09.2010 by Bochkanov Sergey
			*************************************************************************/
			private static void tagsortfastrec(ref double[] a,
					ref double[] bufa,
					int i1,
					int i2)
			{
				int cntless = 0;
				int cnteq = 0;
				int cntgreater = 0;
				int i = 0;
				int j = 0;
				int k = 0;
				double tmpr = 0;
				int tmpi = 0;
				double v0 = 0;
				double v1 = 0;
				double v2 = 0;
				double vp = 0;


				//
				// Fast exit
				//
				if (i2 <= i1)
				{
					return;
				}

				//
				// Non-recursive sort for small arrays
				//
				if (i2 - i1 <= 16)
				{
					for (j = i1 + 1; j <= i2; j++)
					{

						//
						// Search elements [I1..J-1] for place to insert Jth element.
						//
						// This code stops immediatly if we can leave A[J] at J-th position
						// (all elements have same value of A[J] larger than any of them)
						//
						tmpr = a[j];
						tmpi = j;
						for (k = j - 1; k >= i1; k--)
						{
							if (a[k] <= tmpr)
							{
								break;
							}
							tmpi = k;
						}
						k = tmpi;

						//
						// Insert Jth element into Kth position
						//
						if (k != j)
						{
							tmpr = a[j];
							for (i = j - 1; i >= k; i--)
							{
								a[i + 1] = a[i];
							}
							a[k] = tmpr;
						}
					}
					return;
				}

				//
				// Quicksort: choose pivot
				// Here we assume that I2-I1>=16
				//
				v0 = a[i1];
				v1 = a[i1 + (i2 - i1) / 2];
				v2 = a[i2];
				if (v0 > v1)
				{
					tmpr = v1;
					v1 = v0;
					v0 = tmpr;
				}
				if (v1 > v2)
				{
					tmpr = v2;
					v2 = v1;
					v1 = tmpr;
				}
				if (v0 > v1)
				{
					tmpr = v1;
					v1 = v0;
					v0 = tmpr;
				}
				vp = v1;

				//
				// now pass through A/B and:
				// * move elements that are LESS than VP to the left of A/B
				// * move elements that are EQUAL to VP to the right of BufA/BufB (in the reverse order)
				// * move elements that are GREATER than VP to the left of BufA/BufB (in the normal order
				// * move elements from the tail of BufA/BufB to the middle of A/B (restoring normal order)
				// * move elements from the left of BufA/BufB to the end of A/B
				//
				cntless = 0;
				cnteq = 0;
				cntgreater = 0;
				for (i = i1; i <= i2; i++)
				{
					v0 = a[i];
					if (v0 < vp)
					{

						//
						// LESS
						//
						k = i1 + cntless;
						if (i != k)
						{
							a[k] = v0;
						}
						cntless = cntless + 1;
						continue;
					}
					if (v0 == vp)
					{

						//
						// EQUAL
						//
						k = i2 - cnteq;
						bufa[k] = v0;
						cnteq = cnteq + 1;
						continue;
					}

					//
					// GREATER
					//
					k = i1 + cntgreater;
					bufa[k] = v0;
					cntgreater = cntgreater + 1;
				}
				for (i = 0; i <= cnteq - 1; i++)
				{
					j = i1 + cntless + cnteq - 1 - i;
					k = i2 + i - (cnteq - 1);
					a[j] = bufa[k];
				}
				for (i = 0; i <= cntgreater - 1; i++)
				{
					j = i1 + cntless + cnteq + i;
					k = i1 + i;
					a[j] = bufa[k];
				}

				//
				// Sort left and right parts of the array (ignoring middle part)
				//
				tagsortfastrec(ref a, ref bufa, i1, i1 + cntless - 1);
				tagsortfastrec(ref a, ref bufa, i1 + cntless + cnteq, i2);
			}


		}
		public class basicstatops
		{
			/*************************************************************************
			Internal ranking subroutine.

			INPUT PARAMETERS:
					X       -   array to rank
					N       -   array size
					IsCentered- whether ranks are centered or not:
											* True      -   ranks are centered in such way that  their
																			sum is zero
											* False     -   ranks are not centered
					Buf     -   temporary buffers
            
			NOTE: when IsCentered is True and all X[] are equal, this  function  fills
						X by zeros (exact zeros are used, not sum which is only approximately
						equal to zero).
			*************************************************************************/
			public static void rankx(double[] x,
					int n,
					bool iscentered,
					apserv.apbuffers buf)
			{
				int i = 0;
				int j = 0;
				int k = 0;
				double tmp = 0;
				double voffs = 0;


				//
				// Prepare
				//
				if (n < 1)
				{
					return;
				}
				if (n == 1)
				{
					x[0] = 0;
					return;
				}
				if (alglib.ap.len(buf.ra1) < n)
				{
					buf.ra1 = new double[n];
				}
				if (alglib.ap.len(buf.ia1) < n)
				{
					buf.ia1 = new int[n];
				}
				for (i = 0; i <= n - 1; i++)
				{
					buf.ra1[i] = x[i];
					buf.ia1[i] = i;
				}
				tsort.tagsortfasti(ref buf.ra1, ref buf.ia1, ref buf.ra2, ref buf.ia2, n);

				//
				// Special test for all values being equal
				//
				if ((double)(buf.ra1[0]) == (double)(buf.ra1[n - 1]))
				{
					if (iscentered)
					{
						tmp = 0.0f;
					}
					else
					{
						tmp = (double)(n - 1) / (double)2;
					}
					for (i = 0; i <= n - 1; i++)
					{
						x[i] = tmp;
					}
					return;
				}

				//
				// compute tied ranks
				//
				i = 0;
				while (i <= n - 1)
				{
					j = i + 1;
					while (j <= n - 1)
					{
						if ((double)(buf.ra1[j]) != (double)(buf.ra1[i]))
						{
							break;
						}
						j = j + 1;
					}
					for (k = i; k <= j - 1; k++)
					{
						buf.ra1[k] = (double)(i + j - 1) / (double)2;
					}
					i = j;
				}

				//
				// back to x
				//
				if (iscentered)
				{
					voffs = (double)(n - 1) / (double)2;
				}
				else
				{
					voffs = 0.0f;
				}
				for (i = 0; i <= n - 1; i++)
				{
					x[buf.ia1[i]] = buf.ra1[i] - voffs;
				}
			}


		}
		public class ablasmkl
		{
			/*************************************************************************
			MKL-based kernel

				-- ALGLIB routine --
					 19.01.2010
					 Bochkanov Sergey
			*************************************************************************/
			public static bool rmatrixsyrkmkl(int n,
					int k,
					double alpha,
					double[,] a,
					int ia,
					int ja,
					int optypea,
					double beta,
					double[,] c,
					int ic,
					int jc,
					bool isupper)
			{
				bool result = new bool();

				result = false;
				return result;
			}


			/*************************************************************************
			MKL-based kernel

				-- ALGLIB routine --
					 19.01.2010
					 Bochkanov Sergey
			*************************************************************************/
			public static bool rmatrixgemmmkl(int m,
					int n,
					int k,
					double alpha,
					double[,] a,
					int ia,
					int ja,
					int optypea,
					double[,] b,
					int ib,
					int jb,
					int optypeb,
					double beta,
					double[,] c,
					int ic,
					int jc)
			{
				bool result = new bool();

				result = false;
				return result;
			}


		}
		public class blas
		{
			public static double vectornorm2(double[] x,
					int i1,
					int i2)
			{
				double result = 0;
				int n = 0;
				int ix = 0;
				double absxi = 0;
				double scl = 0;
				double ssq = 0;

				n = i2 - i1 + 1;
				if (n < 1)
				{
					result = 0;
					return result;
				}
				if (n == 1)
				{
					result = Math.Abs(x[i1]);
					return result;
				}
				scl = 0;
				ssq = 1;
				for (ix = i1; ix <= i2; ix++)
				{
					if ((double)(x[ix]) != (double)(0))
					{
						absxi = Math.Abs(x[ix]);
						if ((double)(scl) < (double)(absxi))
						{
							ssq = 1 + ssq * math.sqr(scl / absxi);
							scl = absxi;
						}
						else
						{
							ssq = ssq + math.sqr(absxi / scl);
						}
					}
				}
				result = (double)(scl * Math.Sqrt(ssq));
				return result;
			}


			public static int vectoridxabsmax(double[] x,
					int i1,
					int i2)
			{
				int result = 0;
				int i = 0;

				result = i1;
				for (i = i1 + 1; i <= i2; i++)
				{
					if ((double)(Math.Abs(x[i])) > (double)(Math.Abs(x[result])))
					{
						result = i;
					}
				}
				return result;
			}


			public static int columnidxabsmax(double[,] x,
					int i1,
					int i2,
					int j)
			{
				int result = 0;
				int i = 0;

				result = i1;
				for (i = i1 + 1; i <= i2; i++)
				{
					if ((double)(Math.Abs(x[i, j])) > (double)(Math.Abs(x[result, j])))
					{
						result = i;
					}
				}
				return result;
			}


			public static int rowidxabsmax(double[,] x,
					int j1,
					int j2,
					int i)
			{
				int result = 0;
				int j = 0;

				result = j1;
				for (j = j1 + 1; j <= j2; j++)
				{
					if ((double)(Math.Abs(x[i, j])) > (double)(Math.Abs(x[i, result])))
					{
						result = j;
					}
				}
				return result;
			}


			public static double upperhessenberg1norm(double[,] a,
					int i1,
					int i2,
					int j1,
					int j2,
					ref double[] work)
			{
				double result = 0;
				int i = 0;
				int j = 0;

				alglib.ap.assert(i2 - i1 == j2 - j1, "UpperHessenberg1Norm: I2-I1<>J2-J1!");
				for (j = j1; j <= j2; j++)
				{
					work[j] = 0;
				}
				for (i = i1; i <= i2; i++)
				{
					for (j = Math.Max(j1, j1 + i - i1 - 1); j <= j2; j++)
					{
						work[j] = work[j] + Math.Abs(a[i, j]);
					}
				}
				result = 0;
				for (j = j1; j <= j2; j++)
				{
					result = Math.Max(result, work[j]);
				}
				return result;
			}


			public static void copymatrix(double[,] a,
					int is1,
					int is2,
					int js1,
					int js2,
					ref double[,] b,
					int id1,
					int id2,
					int jd1,
					int jd2)
			{
				int isrc = 0;
				int idst = 0;
				int i_ = 0;
				int i1_ = 0;

				if (is1 > is2 || js1 > js2)
				{
					return;
				}
				alglib.ap.assert(is2 - is1 == id2 - id1, "CopyMatrix: different sizes!");
				alglib.ap.assert(js2 - js1 == jd2 - jd1, "CopyMatrix: different sizes!");
				for (isrc = is1; isrc <= is2; isrc++)
				{
					idst = isrc - is1 + id1;
					i1_ = (js1) - (jd1);
					for (i_ = jd1; i_ <= jd2; i_++)
					{
						b[idst, i_] = a[isrc, i_ + i1_];
					}
				}
			}


			public static void inplacetranspose(ref double[,] a,
					int i1,
					int i2,
					int j1,
					int j2,
					ref double[] work)
			{
				int i = 0;
				int j = 0;
				int ips = 0;
				int jps = 0;
				int l = 0;
				int i_ = 0;
				int i1_ = 0;

				if (i1 > i2 || j1 > j2)
				{
					return;
				}
				alglib.ap.assert(i1 - i2 == j1 - j2, "InplaceTranspose error: incorrect array size!");
				for (i = i1; i <= i2 - 1; i++)
				{
					j = j1 + i - i1;
					ips = i + 1;
					jps = j1 + ips - i1;
					l = i2 - i;
					i1_ = (ips) - (1);
					for (i_ = 1; i_ <= l; i_++)
					{
						work[i_] = a[i_ + i1_, j];
					}
					i1_ = (jps) - (ips);
					for (i_ = ips; i_ <= i2; i_++)
					{
						a[i_, j] = a[i, i_ + i1_];
					}
					i1_ = (1) - (jps);
					for (i_ = jps; i_ <= j2; i_++)
					{
						a[i, i_] = work[i_ + i1_];
					}
				}
			}


			public static void copyandtranspose(double[,] a,
					int is1,
					int is2,
					int js1,
					int js2,
					ref double[,] b,
					int id1,
					int id2,
					int jd1,
					int jd2)
			{
				int isrc = 0;
				int jdst = 0;
				int i_ = 0;
				int i1_ = 0;

				if (is1 > is2 || js1 > js2)
				{
					return;
				}
				alglib.ap.assert(is2 - is1 == jd2 - jd1, "CopyAndTranspose: different sizes!");
				alglib.ap.assert(js2 - js1 == id2 - id1, "CopyAndTranspose: different sizes!");
				for (isrc = is1; isrc <= is2; isrc++)
				{
					jdst = isrc - is1 + jd1;
					i1_ = (js1) - (id1);
					for (i_ = id1; i_ <= id2; i_++)
					{
						b[i_, jdst] = a[isrc, i_ + i1_];
					}
				}
			}


			public static void matrixvectormultiply(double[,] a,
					int i1,
					int i2,
					int j1,
					int j2,
					bool trans,
					double[] x,
					int ix1,
					int ix2,
					double alpha,
					ref double[] y,
					int iy1,
					int iy2,
					double beta)
			{
				int i = 0;
				double v = 0;
				int i_ = 0;
				int i1_ = 0;

				if (!trans)
				{

					//
					// y := alpha*A*x + beta*y;
					//
					if (i1 > i2 || j1 > j2)
					{
						return;
					}
					alglib.ap.assert(j2 - j1 == ix2 - ix1, "MatrixVectorMultiply: A and X dont match!");
					alglib.ap.assert(i2 - i1 == iy2 - iy1, "MatrixVectorMultiply: A and Y dont match!");

					//
					// beta*y
					//
					if ((double)(beta) == (double)(0))
					{
						for (i = iy1; i <= iy2; i++)
						{
							y[i] = 0;
						}
					}
					else
					{
						for (i_ = iy1; i_ <= iy2; i_++)
						{
							y[i_] = beta * y[i_];
						}
					}

					//
					// alpha*A*x
					//
					for (i = i1; i <= i2; i++)
					{
						i1_ = (ix1) - (j1);
						v = 0.0f;
						for (i_ = j1; i_ <= j2; i_++)
						{
							v += a[i, i_] * x[i_ + i1_];
						}
						y[iy1 + i - i1] = y[iy1 + i - i1] + alpha * v;
					}
				}
				else
				{

					//
					// y := alpha*A'*x + beta*y;
					//
					if (i1 > i2 || j1 > j2)
					{
						return;
					}
					alglib.ap.assert(i2 - i1 == ix2 - ix1, "MatrixVectorMultiply: A and X dont match!");
					alglib.ap.assert(j2 - j1 == iy2 - iy1, "MatrixVectorMultiply: A and Y dont match!");

					//
					// beta*y
					//
					if ((double)(beta) == (double)(0))
					{
						for (i = iy1; i <= iy2; i++)
						{
							y[i] = 0;
						}
					}
					else
					{
						for (i_ = iy1; i_ <= iy2; i_++)
						{
							y[i_] = beta * y[i_];
						}
					}

					//
					// alpha*A'*x
					//
					for (i = i1; i <= i2; i++)
					{
						v = alpha * x[ix1 + i - i1];
						i1_ = (j1) - (iy1);
						for (i_ = iy1; i_ <= iy2; i_++)
						{
							y[i_] = y[i_] + v * a[i, i_ + i1_];
						}
					}
				}
			}


			public static double pythag2(double x,
					double y)
			{
				double result = 0;
				double w = 0;
				double xabs = 0;
				double yabs = 0;
				double z = 0;

				xabs = Math.Abs(x);
				yabs = Math.Abs(y);
				w = Math.Max(xabs, yabs);
				z = Math.Min(xabs, yabs);
				if ((double)(z) == (double)(0))
				{
					result = w;
				}
				else
				{
					result = (double)(w * Math.Sqrt(1 + math.sqr(z / w)));
				}
				return result;
			}


			public static void matrixmatrixmultiply(double[,] a,
					int ai1,
					int ai2,
					int aj1,
					int aj2,
					bool transa,
					double[,] b,
					int bi1,
					int bi2,
					int bj1,
					int bj2,
					bool transb,
					double alpha,
					ref double[,] c,
					int ci1,
					int ci2,
					int cj1,
					int cj2,
					double beta,
					ref double[] work)
			{
				int arows = 0;
				int acols = 0;
				int brows = 0;
				int bcols = 0;
				int crows = 0;
				int i = 0;
				int j = 0;
				int k = 0;
				int l = 0;
				int r = 0;
				double v = 0;
				int i_ = 0;
				int i1_ = 0;


				//
				// Setup
				//
				if (!transa)
				{
					arows = ai2 - ai1 + 1;
					acols = aj2 - aj1 + 1;
				}
				else
				{
					arows = aj2 - aj1 + 1;
					acols = ai2 - ai1 + 1;
				}
				if (!transb)
				{
					brows = bi2 - bi1 + 1;
					bcols = bj2 - bj1 + 1;
				}
				else
				{
					brows = bj2 - bj1 + 1;
					bcols = bi2 - bi1 + 1;
				}
				alglib.ap.assert(acols == brows, "MatrixMatrixMultiply: incorrect matrix sizes!");
				if (((arows <= 0 || acols <= 0) || brows <= 0) || bcols <= 0)
				{
					return;
				}
				crows = arows;

				//
				// Test WORK
				//
				i = Math.Max(arows, acols);
				i = Math.Max(brows, i);
				i = Math.Max(i, bcols);
				work[1] = 0;
				work[i] = 0;

				//
				// Prepare C
				//
				if ((double)(beta) == (double)(0))
				{
					for (i = ci1; i <= ci2; i++)
					{
						for (j = cj1; j <= cj2; j++)
						{
							c[i, j] = 0;
						}
					}
				}
				else
				{
					for (i = ci1; i <= ci2; i++)
					{
						for (i_ = cj1; i_ <= cj2; i_++)
						{
							c[i, i_] = beta * c[i, i_];
						}
					}
				}

				//
				// A*B
				//
				if (!transa && !transb)
				{
					for (l = ai1; l <= ai2; l++)
					{
						for (r = bi1; r <= bi2; r++)
						{
							v = alpha * a[l, aj1 + r - bi1];
							k = ci1 + l - ai1;
							i1_ = (bj1) - (cj1);
							for (i_ = cj1; i_ <= cj2; i_++)
							{
								c[k, i_] = c[k, i_] + v * b[r, i_ + i1_];
							}
						}
					}
					return;
				}

				//
				// A*B'
				//
				if (!transa && transb)
				{
					if (arows * acols < brows * bcols)
					{
						for (r = bi1; r <= bi2; r++)
						{
							for (l = ai1; l <= ai2; l++)
							{
								i1_ = (bj1) - (aj1);
								v = 0.0f;
								for (i_ = aj1; i_ <= aj2; i_++)
								{
									v += a[l, i_] * b[r, i_ + i1_];
								}
								c[ci1 + l - ai1, cj1 + r - bi1] = c[ci1 + l - ai1, cj1 + r - bi1] + alpha * v;
							}
						}
						return;
					}
					else
					{
						for (l = ai1; l <= ai2; l++)
						{
							for (r = bi1; r <= bi2; r++)
							{
								i1_ = (bj1) - (aj1);
								v = 0.0f;
								for (i_ = aj1; i_ <= aj2; i_++)
								{
									v += a[l, i_] * b[r, i_ + i1_];
								}
								c[ci1 + l - ai1, cj1 + r - bi1] = c[ci1 + l - ai1, cj1 + r - bi1] + alpha * v;
							}
						}
						return;
					}
				}

				//
				// A'*B
				//
				if (transa && !transb)
				{
					for (l = aj1; l <= aj2; l++)
					{
						for (r = bi1; r <= bi2; r++)
						{
							v = alpha * a[ai1 + r - bi1, l];
							k = ci1 + l - aj1;
							i1_ = (bj1) - (cj1);
							for (i_ = cj1; i_ <= cj2; i_++)
							{
								c[k, i_] = c[k, i_] + v * b[r, i_ + i1_];
							}
						}
					}
					return;
				}

				//
				// A'*B'
				//
				if (transa && transb)
				{
					if (arows * acols < brows * bcols)
					{
						for (r = bi1; r <= bi2; r++)
						{
							k = cj1 + r - bi1;
							for (i = 1; i <= crows; i++)
							{
								work[i] = 0.0f;
							}
							for (l = ai1; l <= ai2; l++)
							{
								v = alpha * b[r, bj1 + l - ai1];
								i1_ = (aj1) - (1);
								for (i_ = 1; i_ <= crows; i_++)
								{
									work[i_] = work[i_] + v * a[l, i_ + i1_];
								}
							}
							i1_ = (1) - (ci1);
							for (i_ = ci1; i_ <= ci2; i_++)
							{
								c[i_, k] = c[i_, k] + work[i_ + i1_];
							}
						}
						return;
					}
					else
					{
						for (l = aj1; l <= aj2; l++)
						{
							k = ai2 - ai1 + 1;
							i1_ = (ai1) - (1);
							for (i_ = 1; i_ <= k; i_++)
							{
								work[i_] = a[i_ + i1_, l];
							}
							for (r = bi1; r <= bi2; r++)
							{
								i1_ = (bj1) - (1);
								v = 0.0f;
								for (i_ = 1; i_ <= k; i_++)
								{
									v += work[i_] * b[r, i_ + i1_];
								}
								c[ci1 + l - aj1, cj1 + r - bi1] = c[ci1 + l - aj1, cj1 + r - bi1] + alpha * v;
							}
						}
						return;
					}
				}
			}


		}
		public class hblas
		{
			public static void hermitianmatrixvectormultiply(complex[,] a,
					bool isupper,
					int i1,
					int i2,
					complex[] x,
					complex alpha,
					ref complex[] y)
			{
				int i = 0;
				int ba1 = 0;
				int by1 = 0;
				int by2 = 0;
				int bx1 = 0;
				int bx2 = 0;
				int n = 0;
				complex v = 0;
				int i_ = 0;
				int i1_ = 0;

				n = i2 - i1 + 1;
				if (n <= 0)
				{
					return;
				}

				//
				// Let A = L + D + U, where
				//  L is strictly lower triangular (main diagonal is zero)
				//  D is diagonal
				//  U is strictly upper triangular (main diagonal is zero)
				//
				// A*x = L*x + D*x + U*x
				//
				// Calculate D*x first
				//
				for (i = i1; i <= i2; i++)
				{
					y[i - i1 + 1] = a[i, i] * x[i - i1 + 1];
				}

				//
				// Add L*x + U*x
				//
				if (isupper)
				{
					for (i = i1; i <= i2 - 1; i++)
					{

						//
						// Add L*x to the result
						//
						v = x[i - i1 + 1];
						by1 = i - i1 + 2;
						by2 = n;
						ba1 = i + 1;
						i1_ = (ba1) - (by1);
						for (i_ = by1; i_ <= by2; i_++)
						{
							y[i_] = y[i_] + v * math.conj(a[i, i_ + i1_]);
						}

						//
						// Add U*x to the result
						//
						bx1 = i - i1 + 2;
						bx2 = n;
						ba1 = i + 1;
						i1_ = (ba1) - (bx1);
						v = 0.0f;
						for (i_ = bx1; i_ <= bx2; i_++)
						{
							v += x[i_] * a[i, i_ + i1_];
						}
						y[i - i1 + 1] = y[i - i1 + 1] + v;
					}
				}
				else
				{
					for (i = i1 + 1; i <= i2; i++)
					{

						//
						// Add L*x to the result
						//
						bx1 = 1;
						bx2 = i - i1;
						ba1 = i1;
						i1_ = (ba1) - (bx1);
						v = 0.0f;
						for (i_ = bx1; i_ <= bx2; i_++)
						{
							v += x[i_] * a[i, i_ + i1_];
						}
						y[i - i1 + 1] = y[i - i1 + 1] + v;

						//
						// Add U*x to the result
						//
						v = x[i - i1 + 1];
						by1 = 1;
						by2 = i - i1;
						ba1 = i1;
						i1_ = (ba1) - (by1);
						for (i_ = by1; i_ <= by2; i_++)
						{
							y[i_] = y[i_] + v * math.conj(a[i, i_ + i1_]);
						}
					}
				}
				for (i_ = 1; i_ <= n; i_++)
				{
					y[i_] = alpha * y[i_];
				}
			}


			public static void hermitianrank2update(ref complex[,] a,
					bool isupper,
					int i1,
					int i2,
					complex[] x,
					complex[] y,
					ref complex[] t,
					complex alpha)
			{
				int i = 0;
				int tp1 = 0;
				int tp2 = 0;
				complex v = 0;
				int i_ = 0;
				int i1_ = 0;

				if (isupper)
				{
					for (i = i1; i <= i2; i++)
					{
						tp1 = i + 1 - i1;
						tp2 = i2 - i1 + 1;
						v = alpha * x[i + 1 - i1];
						for (i_ = tp1; i_ <= tp2; i_++)
						{
							t[i_] = v * math.conj(y[i_]);
						}
						v = math.conj(alpha) * y[i + 1 - i1];
						for (i_ = tp1; i_ <= tp2; i_++)
						{
							t[i_] = t[i_] + v * math.conj(x[i_]);
						}
						i1_ = (tp1) - (i);
						for (i_ = i; i_ <= i2; i_++)
						{
							a[i, i_] = a[i, i_] + t[i_ + i1_];
						}
					}
				}
				else
				{
					for (i = i1; i <= i2; i++)
					{
						tp1 = 1;
						tp2 = i + 1 - i1;
						v = alpha * x[i + 1 - i1];
						for (i_ = tp1; i_ <= tp2; i_++)
						{
							t[i_] = v * math.conj(y[i_]);
						}
						v = math.conj(alpha) * y[i + 1 - i1];
						for (i_ = tp1; i_ <= tp2; i_++)
						{
							t[i_] = t[i_] + v * math.conj(x[i_]);
						}
						i1_ = (tp1) - (i1);
						for (i_ = i1; i_ <= i; i_++)
						{
							a[i, i_] = a[i, i_] + t[i_ + i1_];
						}
					}
				}
			}


		}
		public class reflections
		{
			/*************************************************************************
			Generation of an elementary reflection transformation

			The subroutine generates elementary reflection H of order N, so that, for
			a given X, the following equality holds true:

					( X(1) )   ( Beta )
			H * (  ..  ) = (  0   )
					( X(n) )   (  0   )

			where
										( V(1) )
			H = 1 - Tau * (  ..  ) * ( V(1), ..., V(n) )
										( V(n) )

			where the first component of vector V equals 1.

			Input parameters:
					X   -   vector. Array whose index ranges within [1..N].
					N   -   reflection order.

			Output parameters:
					X   -   components from 2 to N are replaced with vector V.
									The first component is replaced with parameter Beta.
					Tau -   scalar value Tau. If X is a null vector, Tau equals 0,
									otherwise 1 <= Tau <= 2.

			This subroutine is the modification of the DLARFG subroutines from
			the LAPACK library.

			MODIFICATIONS:
					24.12.2005 sign(Alpha) was replaced with an analogous to the Fortran SIGN code.

				-- LAPACK auxiliary routine (version 3.0) --
					 Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
					 Courant Institute, Argonne National Lab, and Rice University
					 September 30, 1994
			*************************************************************************/
			public static void generatereflection(ref double[] x,
					int n,
					ref double tau)
			{
				int j = 0;
				double alpha = 0;
				double xnorm = 0;
				double v = 0;
				double beta = 0;
				double mx = 0;
				double s = 0;
				int i_ = 0;

				tau = 0;

				if (n <= 1)
				{
					tau = 0;
					return;
				}

				//
				// Scale if needed (to avoid overflow/underflow during intermediate
				// calculations).
				//
				mx = 0;
				for (j = 1; j <= n; j++)
				{
					mx = Math.Max(Math.Abs(x[j]), mx);
				}
				s = 1;
				if ((double)(mx) != (double)(0))
				{
					if ((double)(mx) <= (double)(math.minrealnumber / math.machineepsilon))
					{
						s = math.minrealnumber / math.machineepsilon;
						v = 1 / s;
						for (i_ = 1; i_ <= n; i_++)
						{
							x[i_] = v * x[i_];
						}
						mx = mx * v;
					}
					else
					{
						if ((double)(mx) >= (double)(math.maxrealnumber * math.machineepsilon))
						{
							s = math.maxrealnumber * math.machineepsilon;
							v = 1 / s;
							for (i_ = 1; i_ <= n; i_++)
							{
								x[i_] = v * x[i_];
							}
							mx = mx * v;
						}
					}
				}

				//
				// XNORM = DNRM2( N-1, X, INCX )
				//
				alpha = x[1];
				xnorm = 0;
				if ((double)(mx) != (double)(0))
				{
					for (j = 2; j <= n; j++)
					{
						xnorm = xnorm + math.sqr(x[j] / mx);
					}
					xnorm = (double)Math.Sqrt(xnorm) * mx;
				}
				if ((double)(xnorm) == (double)(0))
				{

					//
					// H  =  I
					//
					tau = 0;
					x[1] = x[1] * s;
					return;
				}

				//
				// general case
				//
				mx = Math.Max(Math.Abs(alpha), Math.Abs(xnorm));
				beta = (double)(-(mx * Math.Sqrt(math.sqr(alpha / mx) + math.sqr(xnorm / mx))));
				if ((double)(alpha) < (double)(0))
				{
					beta = -beta;
				}
				tau = (beta - alpha) / beta;
				v = 1 / (alpha - beta);
				for (i_ = 2; i_ <= n; i_++)
				{
					x[i_] = v * x[i_];
				}
				x[1] = beta;

				//
				// Scale back outputs
				//
				x[1] = x[1] * s;
			}


			/*************************************************************************
			Application of an elementary reflection to a rectangular matrix of size MxN

			The algorithm pre-multiplies the matrix by an elementary reflection transformation
			which is given by column V and scalar Tau (see the description of the
			GenerateReflection procedure). Not the whole matrix but only a part of it
			is transformed (rows from M1 to M2, columns from N1 to N2). Only the elements
			of this submatrix are changed.

			Input parameters:
					C       -   matrix to be transformed.
					Tau     -   scalar defining the transformation.
					V       -   column defining the transformation.
											Array whose index ranges within [1..M2-M1+1].
					M1, M2  -   range of rows to be transformed.
					N1, N2  -   range of columns to be transformed.
					WORK    -   working array whose indexes goes from N1 to N2.

			Output parameters:
					C       -   the result of multiplying the input matrix C by the
											transformation matrix which is given by Tau and V.
											If N1>N2 or M1>M2, C is not modified.

				-- LAPACK auxiliary routine (version 3.0) --
					 Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
					 Courant Institute, Argonne National Lab, and Rice University
					 September 30, 1994
			*************************************************************************/
			public static void applyreflectionfromtheleft(ref double[,] c,
					double tau,
					double[] v,
					int m1,
					int m2,
					int n1,
					int n2,
					ref double[] work)
			{
				double t = 0;
				int i = 0;
				int i_ = 0;

				if (((double)(tau) == (double)(0) || n1 > n2) || m1 > m2)
				{
					return;
				}

				//
				// w := C' * v
				//
				for (i = n1; i <= n2; i++)
				{
					work[i] = 0;
				}
				for (i = m1; i <= m2; i++)
				{
					t = v[i + 1 - m1];
					for (i_ = n1; i_ <= n2; i_++)
					{
						work[i_] = work[i_] + t * c[i, i_];
					}
				}

				//
				// C := C - tau * v * w'
				//
				for (i = m1; i <= m2; i++)
				{
					t = v[i - m1 + 1] * tau;
					for (i_ = n1; i_ <= n2; i_++)
					{
						c[i, i_] = c[i, i_] - t * work[i_];
					}
				}
			}


			/*************************************************************************
			Application of an elementary reflection to a rectangular matrix of size MxN

			The algorithm post-multiplies the matrix by an elementary reflection transformation
			which is given by column V and scalar Tau (see the description of the
			GenerateReflection procedure). Not the whole matrix but only a part of it
			is transformed (rows from M1 to M2, columns from N1 to N2). Only the
			elements of this submatrix are changed.

			Input parameters:
					C       -   matrix to be transformed.
					Tau     -   scalar defining the transformation.
					V       -   column defining the transformation.
											Array whose index ranges within [1..N2-N1+1].
					M1, M2  -   range of rows to be transformed.
					N1, N2  -   range of columns to be transformed.
					WORK    -   working array whose indexes goes from M1 to M2.

			Output parameters:
					C       -   the result of multiplying the input matrix C by the
											transformation matrix which is given by Tau and V.
											If N1>N2 or M1>M2, C is not modified.

				-- LAPACK auxiliary routine (version 3.0) --
					 Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
					 Courant Institute, Argonne National Lab, and Rice University
					 September 30, 1994
			*************************************************************************/
			public static void applyreflectionfromtheright(ref double[,] c,
					double tau,
					double[] v,
					int m1,
					int m2,
					int n1,
					int n2,
					ref double[] work)
			{
				double t = 0;
				int i = 0;
				int vm = 0;
				int i_ = 0;
				int i1_ = 0;

				if (((double)(tau) == (double)(0) || n1 > n2) || m1 > m2)
				{
					return;
				}
				vm = n2 - n1 + 1;
				for (i = m1; i <= m2; i++)
				{
					i1_ = (1) - (n1);
					t = 0.0f;
					for (i_ = n1; i_ <= n2; i_++)
					{
						t += c[i, i_] * v[i_ + i1_];
					}
					t = t * tau;
					i1_ = (1) - (n1);
					for (i_ = n1; i_ <= n2; i_++)
					{
						c[i, i_] = c[i, i_] - t * v[i_ + i1_];
					}
				}

				//
				// This line is necessary to avoid spurious compiler warnings
				//
				apserv.touchint(ref vm);
			}


		}
		public class creflections
		{
			/*************************************************************************
			Generation of an elementary complex reflection transformation

			The subroutine generates elementary complex reflection H of  order  N,  so
			that, for a given X, the following equality holds true:

					 ( X(1) )   ( Beta )
			H' * (  ..  ) = (  0   ),   H'*H = I,   Beta is a real number
					 ( X(n) )   (  0   )

			where

										( V(1) )
			H = 1 - Tau * (  ..  ) * ( conj(V(1)), ..., conj(V(n)) )
										( V(n) )

			where the first component of vector V equals 1.

			Input parameters:
					X   -   vector. Array with elements [1..N].
					N   -   reflection order.

			Output parameters:
					X   -   components from 2 to N are replaced by vector V.
									The first component is replaced with parameter Beta.
					Tau -   scalar value Tau.

			This subroutine is the modification of CLARFG subroutines  from the LAPACK
			library. It has similar functionality except for the fact that it  doesn’t
			handle errors when intermediate results cause an overflow.

				-- LAPACK auxiliary routine (version 3.0) --
					 Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
					 Courant Institute, Argonne National Lab, and Rice University
					 September 30, 1994
			*************************************************************************/
			public static void complexgeneratereflection(ref complex[] x,
					int n,
					ref complex tau)
			{
				int j = 0;
				complex alpha = 0;
				double alphi = 0;
				double alphr = 0;
				double beta = 0;
				double xnorm = 0;
				double mx = 0;
				complex t = 0;
				double s = 0;
				complex v = 0;
				int i_ = 0;

				tau = 0;

				if (n <= 0)
				{
					tau = 0;
					return;
				}

				//
				// Scale if needed (to avoid overflow/underflow during intermediate
				// calculations).
				//
				mx = 0;
				for (j = 1; j <= n; j++)
				{
					mx = Math.Max(math.abscomplex(x[j]), mx);
				}
				s = 1;
				if ((double)(mx) != (double)(0))
				{
					if ((double)(mx) < (double)(1))
					{
						s = (double)Math.Sqrt(math.minrealnumber);
						v = 1 / s;
						for (i_ = 1; i_ <= n; i_++)
						{
							x[i_] = v * x[i_];
						}
					}
					else
					{
						s = (double)Math.Sqrt(math.maxrealnumber);
						v = 1 / s;
						for (i_ = 1; i_ <= n; i_++)
						{
							x[i_] = v * x[i_];
						}
					}
				}

				//
				// calculate
				//
				alpha = x[1];
				mx = 0;
				for (j = 2; j <= n; j++)
				{
					mx = Math.Max(math.abscomplex(x[j]), mx);
				}
				xnorm = 0;
				if ((double)(mx) != (double)(0))
				{
					for (j = 2; j <= n; j++)
					{
						t = x[j] / mx;
						xnorm = xnorm + (t * math.conj(t)).x;
					}
					xnorm = (double)(Math.Sqrt(xnorm) * mx);
				}
				alphr = alpha.x;
				alphi = alpha.y;
				if ((double)(xnorm) == (double)(0) && (double)(alphi) == (double)(0))
				{
					tau = 0;
					x[1] = x[1] * s;
					return;
				}
				mx = Math.Max(Math.Abs(alphr), Math.Abs(alphi));
				mx = Math.Max(mx, Math.Abs(xnorm));
				beta = (double)(-(mx * Math.Sqrt(math.sqr(alphr / mx) + math.sqr(alphi / mx) + math.sqr(xnorm / mx))));
				if ((double)(alphr) < (double)(0))
				{
					beta = -beta;
				}
				tau.x = (beta - alphr) / beta;
				tau.y = -(alphi / beta);
				alpha = 1 / (alpha - beta);
				if (n > 1)
				{
					for (i_ = 2; i_ <= n; i_++)
					{
						x[i_] = alpha * x[i_];
					}
				}
				alpha = beta;
				x[1] = alpha;

				//
				// Scale back
				//
				x[1] = x[1] * s;
			}


			/*************************************************************************
			Application of an elementary reflection to a rectangular matrix of size MxN

			The  algorithm  pre-multiplies  the  matrix  by  an  elementary reflection
			transformation  which  is  given  by  column  V  and  scalar  Tau (see the
			description of the GenerateReflection). Not the whole matrix  but  only  a
			part of it is transformed (rows from M1 to M2, columns from N1 to N2). Only
			the elements of this submatrix are changed.

			Note: the matrix is multiplied by H, not by H'.   If  it  is  required  to
			multiply the matrix by H', it is necessary to pass Conj(Tau) instead of Tau.

			Input parameters:
					C       -   matrix to be transformed.
					Tau     -   scalar defining transformation.
					V       -   column defining transformation.
											Array whose index ranges within [1..M2-M1+1]
					M1, M2  -   range of rows to be transformed.
					N1, N2  -   range of columns to be transformed.
					WORK    -   working array whose index goes from N1 to N2.

			Output parameters:
					C       -   the result of multiplying the input matrix C by the
											transformation matrix which is given by Tau and V.
											If N1>N2 or M1>M2, C is not modified.

				-- LAPACK auxiliary routine (version 3.0) --
					 Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
					 Courant Institute, Argonne National Lab, and Rice University
					 September 30, 1994
			*************************************************************************/
			public static void complexapplyreflectionfromtheleft(ref complex[,] c,
					complex tau,
					complex[] v,
					int m1,
					int m2,
					int n1,
					int n2,
					ref complex[] work)
			{
				complex t = 0;
				int i = 0;
				int i_ = 0;

				if ((tau == 0 || n1 > n2) || m1 > m2)
				{
					return;
				}

				//
				// w := C^T * conj(v)
				//
				for (i = n1; i <= n2; i++)
				{
					work[i] = 0;
				}
				for (i = m1; i <= m2; i++)
				{
					t = math.conj(v[i + 1 - m1]);
					for (i_ = n1; i_ <= n2; i_++)
					{
						work[i_] = work[i_] + t * c[i, i_];
					}
				}

				//
				// C := C - tau * v * w^T
				//
				for (i = m1; i <= m2; i++)
				{
					t = v[i - m1 + 1] * tau;
					for (i_ = n1; i_ <= n2; i_++)
					{
						c[i, i_] = c[i, i_] - t * work[i_];
					}
				}
			}


			/*************************************************************************
			Application of an elementary reflection to a rectangular matrix of size MxN

			The  algorithm  post-multiplies  the  matrix  by  an elementary reflection
			transformation  which  is  given  by  column  V  and  scalar  Tau (see the
			description  of  the  GenerateReflection). Not the whole matrix but only a
			part  of  it  is  transformed (rows from M1 to M2, columns from N1 to N2).
			Only the elements of this submatrix are changed.

			Input parameters:
					C       -   matrix to be transformed.
					Tau     -   scalar defining transformation.
					V       -   column defining transformation.
											Array whose index ranges within [1..N2-N1+1]
					M1, M2  -   range of rows to be transformed.
					N1, N2  -   range of columns to be transformed.
					WORK    -   working array whose index goes from M1 to M2.

			Output parameters:
					C       -   the result of multiplying the input matrix C by the
											transformation matrix which is given by Tau and V.
											If N1>N2 or M1>M2, C is not modified.

				-- LAPACK auxiliary routine (version 3.0) --
					 Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
					 Courant Institute, Argonne National Lab, and Rice University
					 September 30, 1994
			*************************************************************************/
			public static void complexapplyreflectionfromtheright(ref complex[,] c,
					complex tau,
					ref complex[] v,
					int m1,
					int m2,
					int n1,
					int n2,
					ref complex[] work)
			{
				complex t = 0;
				int i = 0;
				int vm = 0;
				int i_ = 0;
				int i1_ = 0;

				if ((tau == 0 || n1 > n2) || m1 > m2)
				{
					return;
				}

				//
				// w := C * v
				//
				vm = n2 - n1 + 1;
				for (i = m1; i <= m2; i++)
				{
					i1_ = (1) - (n1);
					t = 0.0f;
					for (i_ = n1; i_ <= n2; i_++)
					{
						t += c[i, i_] * v[i_ + i1_];
					}
					work[i] = t;
				}

				//
				// C := C - w * conj(v^T)
				//
				for (i_ = 1; i_ <= vm; i_++)
				{
					v[i_] = math.conj(v[i_]);
				}
				for (i = m1; i <= m2; i++)
				{
					t = work[i] * tau;
					i1_ = (1) - (n1);
					for (i_ = n1; i_ <= n2; i_++)
					{
						c[i, i_] = c[i, i_] - t * v[i_ + i1_];
					}
				}
				for (i_ = 1; i_ <= vm; i_++)
				{
					v[i_] = math.conj(v[i_]);
				}
			}


		}
		public class sblas
		{
			public static void symmetricmatrixvectormultiply(double[,] a,
					bool isupper,
					int i1,
					int i2,
					double[] x,
					double alpha,
					ref double[] y)
			{
				int i = 0;
				int ba1 = 0;
				int ba2 = 0;
				int by1 = 0;
				int by2 = 0;
				int bx1 = 0;
				int bx2 = 0;
				int n = 0;
				double v = 0;
				int i_ = 0;
				int i1_ = 0;

				n = i2 - i1 + 1;
				if (n <= 0)
				{
					return;
				}

				//
				// Let A = L + D + U, where
				//  L is strictly lower triangular (main diagonal is zero)
				//  D is diagonal
				//  U is strictly upper triangular (main diagonal is zero)
				//
				// A*x = L*x + D*x + U*x
				//
				// Calculate D*x first
				//
				for (i = i1; i <= i2; i++)
				{
					y[i - i1 + 1] = a[i, i] * x[i - i1 + 1];
				}

				//
				// Add L*x + U*x
				//
				if (isupper)
				{
					for (i = i1; i <= i2 - 1; i++)
					{

						//
						// Add L*x to the result
						//
						v = x[i - i1 + 1];
						by1 = i - i1 + 2;
						by2 = n;
						ba1 = i + 1;
						ba2 = i2;
						i1_ = (ba1) - (by1);
						for (i_ = by1; i_ <= by2; i_++)
						{
							y[i_] = y[i_] + v * a[i, i_ + i1_];
						}

						//
						// Add U*x to the result
						//
						bx1 = i - i1 + 2;
						bx2 = n;
						ba1 = i + 1;
						ba2 = i2;
						i1_ = (ba1) - (bx1);
						v = 0.0f;
						for (i_ = bx1; i_ <= bx2; i_++)
						{
							v += x[i_] * a[i, i_ + i1_];
						}
						y[i - i1 + 1] = y[i - i1 + 1] + v;
					}
				}
				else
				{
					for (i = i1 + 1; i <= i2; i++)
					{

						//
						// Add L*x to the result
						//
						bx1 = 1;
						bx2 = i - i1;
						ba1 = i1;
						ba2 = i - 1;
						i1_ = (ba1) - (bx1);
						v = 0.0f;
						for (i_ = bx1; i_ <= bx2; i_++)
						{
							v += x[i_] * a[i, i_ + i1_];
						}
						y[i - i1 + 1] = y[i - i1 + 1] + v;

						//
						// Add U*x to the result
						//
						v = x[i - i1 + 1];
						by1 = 1;
						by2 = i - i1;
						ba1 = i1;
						ba2 = i - 1;
						i1_ = (ba1) - (by1);
						for (i_ = by1; i_ <= by2; i_++)
						{
							y[i_] = y[i_] + v * a[i, i_ + i1_];
						}
					}
				}
				for (i_ = 1; i_ <= n; i_++)
				{
					y[i_] = alpha * y[i_];
				}
				apserv.touchint(ref ba2);
			}


			public static void symmetricrank2update(ref double[,] a,
					bool isupper,
					int i1,
					int i2,
					double[] x,
					double[] y,
					ref double[] t,
					double alpha)
			{
				int i = 0;
				int tp1 = 0;
				int tp2 = 0;
				double v = 0;
				int i_ = 0;
				int i1_ = 0;

				if (isupper)
				{
					for (i = i1; i <= i2; i++)
					{
						tp1 = i + 1 - i1;
						tp2 = i2 - i1 + 1;
						v = x[i + 1 - i1];
						for (i_ = tp1; i_ <= tp2; i_++)
						{
							t[i_] = v * y[i_];
						}
						v = y[i + 1 - i1];
						for (i_ = tp1; i_ <= tp2; i_++)
						{
							t[i_] = t[i_] + v * x[i_];
						}
						for (i_ = tp1; i_ <= tp2; i_++)
						{
							t[i_] = alpha * t[i_];
						}
						i1_ = (tp1) - (i);
						for (i_ = i; i_ <= i2; i_++)
						{
							a[i, i_] = a[i, i_] + t[i_ + i1_];
						}
					}
				}
				else
				{
					for (i = i1; i <= i2; i++)
					{
						tp1 = 1;
						tp2 = i + 1 - i1;
						v = x[i + 1 - i1];
						for (i_ = tp1; i_ <= tp2; i_++)
						{
							t[i_] = v * y[i_];
						}
						v = y[i + 1 - i1];
						for (i_ = tp1; i_ <= tp2; i_++)
						{
							t[i_] = t[i_] + v * x[i_];
						}
						for (i_ = tp1; i_ <= tp2; i_++)
						{
							t[i_] = alpha * t[i_];
						}
						i1_ = (tp1) - (i1);
						for (i_ = i1; i_ <= i; i_++)
						{
							a[i, i_] = a[i, i_] + t[i_ + i1_];
						}
					}
				}
			}


		}
		public class rotations
		{
			/*************************************************************************
			Application of a sequence of  elementary rotations to a matrix

			The algorithm pre-multiplies the matrix by a sequence of rotation
			transformations which is given by arrays C and S. Depending on the value
			of the IsForward parameter either 1 and 2, 3 and 4 and so on (if IsForward=true)
			rows are rotated, or the rows N and N-1, N-2 and N-3 and so on, are rotated.

			Not the whole matrix but only a part of it is transformed (rows from M1 to
			M2, columns from N1 to N2). Only the elements of this submatrix are changed.

			Input parameters:
					IsForward   -   the sequence of the rotation application.
					M1,M2       -   the range of rows to be transformed.
					N1, N2      -   the range of columns to be transformed.
					C,S         -   transformation coefficients.
													Array whose index ranges within [1..M2-M1].
					A           -   processed matrix.
					WORK        -   working array whose index ranges within [N1..N2].

			Output parameters:
					A           -   transformed matrix.

			Utility subroutine.
			*************************************************************************/
			public static void applyrotationsfromtheleft(bool isforward,
					int m1,
					int m2,
					int n1,
					int n2,
					double[] c,
					double[] s,
					ref double[,] a,
					ref double[] work)
			{
				int j = 0;
				int jp1 = 0;
				double ctemp = 0;
				double stemp = 0;
				double temp = 0;
				int i_ = 0;

				if (m1 > m2 || n1 > n2)
				{
					return;
				}

				//
				// Form  P * A
				//
				if (isforward)
				{
					if (n1 != n2)
					{

						//
						// Common case: N1<>N2
						//
						for (j = m1; j <= m2 - 1; j++)
						{
							ctemp = c[j - m1 + 1];
							stemp = s[j - m1 + 1];
							if ((double)(ctemp) != (double)(1) || (double)(stemp) != (double)(0))
							{
								jp1 = j + 1;
								for (i_ = n1; i_ <= n2; i_++)
								{
									work[i_] = ctemp * a[jp1, i_];
								}
								for (i_ = n1; i_ <= n2; i_++)
								{
									work[i_] = work[i_] - stemp * a[j, i_];
								}
								for (i_ = n1; i_ <= n2; i_++)
								{
									a[j, i_] = ctemp * a[j, i_];
								}
								for (i_ = n1; i_ <= n2; i_++)
								{
									a[j, i_] = a[j, i_] + stemp * a[jp1, i_];
								}
								for (i_ = n1; i_ <= n2; i_++)
								{
									a[jp1, i_] = work[i_];
								}
							}
						}
					}
					else
					{

						//
						// Special case: N1=N2
						//
						for (j = m1; j <= m2 - 1; j++)
						{
							ctemp = c[j - m1 + 1];
							stemp = s[j - m1 + 1];
							if ((double)(ctemp) != (double)(1) || (double)(stemp) != (double)(0))
							{
								temp = a[j + 1, n1];
								a[j + 1, n1] = ctemp * temp - stemp * a[j, n1];
								a[j, n1] = stemp * temp + ctemp * a[j, n1];
							}
						}
					}
				}
				else
				{
					if (n1 != n2)
					{

						//
						// Common case: N1<>N2
						//
						for (j = m2 - 1; j >= m1; j--)
						{
							ctemp = c[j - m1 + 1];
							stemp = s[j - m1 + 1];
							if ((double)(ctemp) != (double)(1) || (double)(stemp) != (double)(0))
							{
								jp1 = j + 1;
								for (i_ = n1; i_ <= n2; i_++)
								{
									work[i_] = ctemp * a[jp1, i_];
								}
								for (i_ = n1; i_ <= n2; i_++)
								{
									work[i_] = work[i_] - stemp * a[j, i_];
								}
								for (i_ = n1; i_ <= n2; i_++)
								{
									a[j, i_] = ctemp * a[j, i_];
								}
								for (i_ = n1; i_ <= n2; i_++)
								{
									a[j, i_] = a[j, i_] + stemp * a[jp1, i_];
								}
								for (i_ = n1; i_ <= n2; i_++)
								{
									a[jp1, i_] = work[i_];
								}
							}
						}
					}
					else
					{

						//
						// Special case: N1=N2
						//
						for (j = m2 - 1; j >= m1; j--)
						{
							ctemp = c[j - m1 + 1];
							stemp = s[j - m1 + 1];
							if ((double)(ctemp) != (double)(1) || (double)(stemp) != (double)(0))
							{
								temp = a[j + 1, n1];
								a[j + 1, n1] = ctemp * temp - stemp * a[j, n1];
								a[j, n1] = stemp * temp + ctemp * a[j, n1];
							}
						}
					}
				}
			}


			/*************************************************************************
			Application of a sequence of  elementary rotations to a matrix

			The algorithm post-multiplies the matrix by a sequence of rotation
			transformations which is given by arrays C and S. Depending on the value
			of the IsForward parameter either 1 and 2, 3 and 4 and so on (if IsForward=true)
			rows are rotated, or the rows N and N-1, N-2 and N-3 and so on are rotated.

			Not the whole matrix but only a part of it is transformed (rows from M1
			to M2, columns from N1 to N2). Only the elements of this submatrix are changed.

			Input parameters:
					IsForward   -   the sequence of the rotation application.
					M1,M2       -   the range of rows to be transformed.
					N1, N2      -   the range of columns to be transformed.
					C,S         -   transformation coefficients.
													Array whose index ranges within [1..N2-N1].
					A           -   processed matrix.
					WORK        -   working array whose index ranges within [M1..M2].

			Output parameters:
					A           -   transformed matrix.

			Utility subroutine.
			*************************************************************************/
			public static void applyrotationsfromtheright(bool isforward,
					int m1,
					int m2,
					int n1,
					int n2,
					double[] c,
					double[] s,
					ref double[,] a,
					ref double[] work)
			{
				int j = 0;
				int jp1 = 0;
				double ctemp = 0;
				double stemp = 0;
				double temp = 0;
				int i_ = 0;


				//
				// Form A * P'
				//
				if (isforward)
				{
					if (m1 != m2)
					{

						//
						// Common case: M1<>M2
						//
						for (j = n1; j <= n2 - 1; j++)
						{
							ctemp = c[j - n1 + 1];
							stemp = s[j - n1 + 1];
							if ((double)(ctemp) != (double)(1) || (double)(stemp) != (double)(0))
							{
								jp1 = j + 1;
								for (i_ = m1; i_ <= m2; i_++)
								{
									work[i_] = ctemp * a[i_, jp1];
								}
								for (i_ = m1; i_ <= m2; i_++)
								{
									work[i_] = work[i_] - stemp * a[i_, j];
								}
								for (i_ = m1; i_ <= m2; i_++)
								{
									a[i_, j] = ctemp * a[i_, j];
								}
								for (i_ = m1; i_ <= m2; i_++)
								{
									a[i_, j] = a[i_, j] + stemp * a[i_, jp1];
								}
								for (i_ = m1; i_ <= m2; i_++)
								{
									a[i_, jp1] = work[i_];
								}
							}
						}
					}
					else
					{

						//
						// Special case: M1=M2
						//
						for (j = n1; j <= n2 - 1; j++)
						{
							ctemp = c[j - n1 + 1];
							stemp = s[j - n1 + 1];
							if ((double)(ctemp) != (double)(1) || (double)(stemp) != (double)(0))
							{
								temp = a[m1, j + 1];
								a[m1, j + 1] = ctemp * temp - stemp * a[m1, j];
								a[m1, j] = stemp * temp + ctemp * a[m1, j];
							}
						}
					}
				}
				else
				{
					if (m1 != m2)
					{

						//
						// Common case: M1<>M2
						//
						for (j = n2 - 1; j >= n1; j--)
						{
							ctemp = c[j - n1 + 1];
							stemp = s[j - n1 + 1];
							if ((double)(ctemp) != (double)(1) || (double)(stemp) != (double)(0))
							{
								jp1 = j + 1;
								for (i_ = m1; i_ <= m2; i_++)
								{
									work[i_] = ctemp * a[i_, jp1];
								}
								for (i_ = m1; i_ <= m2; i_++)
								{
									work[i_] = work[i_] - stemp * a[i_, j];
								}
								for (i_ = m1; i_ <= m2; i_++)
								{
									a[i_, j] = ctemp * a[i_, j];
								}
								for (i_ = m1; i_ <= m2; i_++)
								{
									a[i_, j] = a[i_, j] + stemp * a[i_, jp1];
								}
								for (i_ = m1; i_ <= m2; i_++)
								{
									a[i_, jp1] = work[i_];
								}
							}
						}
					}
					else
					{

						//
						// Special case: M1=M2
						//
						for (j = n2 - 1; j >= n1; j--)
						{
							ctemp = c[j - n1 + 1];
							stemp = s[j - n1 + 1];
							if ((double)(ctemp) != (double)(1) || (double)(stemp) != (double)(0))
							{
								temp = a[m1, j + 1];
								a[m1, j + 1] = ctemp * temp - stemp * a[m1, j];
								a[m1, j] = stemp * temp + ctemp * a[m1, j];
							}
						}
					}
				}
			}


			/*************************************************************************
			The subroutine generates the elementary rotation, so that:

			[  CS  SN  ]  .  [ F ]  =  [ R ]
			[ -SN  CS  ]     [ G ]     [ 0 ]

			CS**2 + SN**2 = 1
			*************************************************************************/
			public static void generaterotation(double f,
					double g,
					ref double cs,
					ref double sn,
					ref double r)
			{
				double f1 = 0;
				double g1 = 0;

				cs = 0;
				sn = 0;
				r = 0;

				if ((double)(g) == (double)(0))
				{
					cs = 1;
					sn = 0;
					r = f;
				}
				else
				{
					if ((double)(f) == (double)(0))
					{
						cs = 0;
						sn = 1;
						r = g;
					}
					else
					{
						f1 = f;
						g1 = g;
						if ((double)(Math.Abs(f1)) > (double)(Math.Abs(g1)))
						{
							r = (double)(Math.Abs(f1) * Math.Sqrt(1 + math.sqr(g1 / f1)));
						}
						else
						{
							r = (double)(Math.Abs(g1) * Math.Sqrt(1 + math.sqr(f1 / g1)));
						}
						cs = f1 / r;
						sn = g1 / r;
						if ((double)(Math.Abs(f)) > (double)(Math.Abs(g)) && (double)(cs) < (double)(0))
						{
							cs = -cs;
							sn = -sn;
							r = -r;
						}
					}
				}
			}


		}
		public class hsschur
		{
			/*************************************************************************
			Subroutine performing  the  Schur  decomposition  of  a  matrix  in  upper
			Hessenberg form using the QR algorithm with multiple shifts.

			The  source matrix  H  is  represented as  S'*H*S = T, where H - matrix in
			upper Hessenberg form,  S - orthogonal matrix (Schur vectors),   T - upper
			quasi-triangular matrix (with blocks of sizes  1x1  and  2x2  on  the main
			diagonal).

			Input parameters:
					H   -   matrix to be decomposed.
									Array whose indexes range within [1..N, 1..N].
					N   -   size of H, N>=0.


			Output parameters:
					H   –   contains the matrix T.
									Array whose indexes range within [1..N, 1..N].
									All elements below the blocks on the main diagonal are equal
									to 0.
					S   -   contains Schur vectors.
									Array whose indexes range within [1..N, 1..N].

			Note 1:
					The block structure of matrix T could be easily recognized: since  all
					the elements  below  the blocks are zeros, the elements a[i+1,i] which
					are equal to 0 show the block border.

			Note 2:
					the algorithm  performance  depends  on  the  value  of  the  internal
					parameter NS of InternalSchurDecomposition  subroutine  which  defines
					the number of shifts in the QR algorithm (analog of  the  block  width
					in block matrix algorithms in linear algebra). If you require  maximum
					performance  on  your  machine,  it  is  recommended  to  adjust  this
					parameter manually.

			Result:
					True, if the algorithm has converged and the parameters H and S contain
							the result.
					False, if the algorithm has not converged.

			Algorithm implemented on the basis of subroutine DHSEQR (LAPACK 3.0 library).
			*************************************************************************/
			public static bool upperhessenbergschurdecomposition(ref double[,] h,
					int n,
					ref double[,] s)
			{
				bool result = new bool();
				double[] wi = new double[0];
				double[] wr = new double[0];
				int info = 0;

				s = new double[0, 0];

				internalschurdecomposition(ref h, n, 1, 2, ref wr, ref wi, ref s, ref info);
				result = info == 0;
				return result;
			}


			public static void internalschurdecomposition(ref double[,] h,
					int n,
					int tneeded,
					int zneeded,
					ref double[] wr,
					ref double[] wi,
					ref double[,] z,
					ref int info)
			{
				double[] work = new double[0];
				int i = 0;
				int i1 = 0;
				int i2 = 0;
				int ierr = 0;
				int ii = 0;
				int itemp = 0;
				int itn = 0;
				int its = 0;
				int j = 0;
				int k = 0;
				int l = 0;
				int maxb = 0;
				int nr = 0;
				int ns = 0;
				int nv = 0;
				double absw = 0;
				double smlnum = 0;
				double tau = 0;
				double temp = 0;
				double tst1 = 0;
				double ulp = 0;
				double unfl = 0;
				double[,] s = new double[0, 0];
				double[] v = new double[0];
				double[] vv = new double[0];
				double[] workc1 = new double[0];
				double[] works1 = new double[0];
				double[] workv3 = new double[0];
				double[] tmpwr = new double[0];
				double[] tmpwi = new double[0];
				bool initz = new bool();
				bool wantt = new bool();
				bool wantz = new bool();
				double cnst = 0;
				bool failflag = new bool();
				int p1 = 0;
				int p2 = 0;
				double vt = 0;
				int i_ = 0;
				int i1_ = 0;

				wr = new double[0];
				wi = new double[0];
				info = 0;


				//
				// Set the order of the multi-shift QR algorithm to be used.
				// If you want to tune algorithm, change this values
				//
				ns = 12;
				maxb = 50;

				//
				// Now 2 < NS <= MAXB < NH.
				//
				maxb = Math.Max(3, maxb);
				ns = Math.Min(maxb, ns);

				//
				// Initialize
				//
				cnst = 1.5f;
				work = new double[Math.Max(n, 1) + 1];
				s = new double[ns + 1, ns + 1];
				v = new double[ns + 1 + 1];
				vv = new double[ns + 1 + 1];
				wr = new double[Math.Max(n, 1) + 1];
				wi = new double[Math.Max(n, 1) + 1];
				workc1 = new double[1 + 1];
				works1 = new double[1 + 1];
				workv3 = new double[3 + 1];
				tmpwr = new double[Math.Max(n, 1) + 1];
				tmpwi = new double[Math.Max(n, 1) + 1];
				alglib.ap.assert(n >= 0, "InternalSchurDecomposition: incorrect N!");
				alglib.ap.assert(tneeded == 0 || tneeded == 1, "InternalSchurDecomposition: incorrect TNeeded!");
				alglib.ap.assert((zneeded == 0 || zneeded == 1) || zneeded == 2, "InternalSchurDecomposition: incorrect ZNeeded!");
				wantt = tneeded == 1;
				initz = zneeded == 2;
				wantz = zneeded != 0;
				info = 0;

				//
				// Initialize Z, if necessary
				//
				if (initz)
				{
					z = new double[n + 1, n + 1];
					for (i = 1; i <= n; i++)
					{
						for (j = 1; j <= n; j++)
						{
							if (i == j)
							{
								z[i, j] = 1;
							}
							else
							{
								z[i, j] = 0;
							}
						}
					}
				}

				//
				// Quick return if possible
				//
				if (n == 0)
				{
					return;
				}
				if (n == 1)
				{
					wr[1] = h[1, 1];
					wi[1] = 0;
					return;
				}

				//
				// Set rows and columns 1 to N to zero below the first
				// subdiagonal.
				//
				for (j = 1; j <= n - 2; j++)
				{
					for (i = j + 2; i <= n; i++)
					{
						h[i, j] = 0;
					}
				}

				//
				// Test if N is sufficiently small
				//
				if ((ns <= 2 || ns > n) || maxb >= n)
				{

					//
					// Use the standard double-shift algorithm
					//
					internalauxschur(wantt, wantz, n, 1, n, ref h, ref wr, ref wi, 1, n, ref z, ref work, ref workv3, ref workc1, ref works1, ref info);

					//
					// fill entries under diagonal blocks of T with zeros
					//
					if (wantt)
					{
						j = 1;
						while (j <= n)
						{
							if ((double)(wi[j]) == (double)(0))
							{
								for (i = j + 1; i <= n; i++)
								{
									h[i, j] = 0;
								}
								j = j + 1;
							}
							else
							{
								for (i = j + 2; i <= n; i++)
								{
									h[i, j] = 0;
									h[i, j + 1] = 0;
								}
								j = j + 2;
							}
						}
					}
					return;
				}
				unfl = math.minrealnumber;
				ulp = 2 * math.machineepsilon;
				smlnum = unfl * (n / ulp);

				//
				// I1 and I2 are the indices of the first row and last column of H
				// to which transformations must be applied. If eigenvalues only are
				// being computed, I1 and I2 are set inside the main loop.
				//
				i1 = 1;
				i2 = n;

				//
				// ITN is the total number of multiple-shift QR iterations allowed.
				//
				itn = 30 * n;

				//
				// The main loop begins here. I is the loop index and decreases from
				// IHI to ILO in steps of at most MAXB. Each iteration of the loop
				// works with the active submatrix in rows and columns L to I.
				// Eigenvalues I+1 to IHI have already converged. Either L = ILO or
				// H(L,L-1) is negligible so that the matrix splits.
				//
				i = n;
				while (true)
				{
					l = 1;
					if (i < 1)
					{

						//
						// fill entries under diagonal blocks of T with zeros
						//
						if (wantt)
						{
							j = 1;
							while (j <= n)
							{
								if ((double)(wi[j]) == (double)(0))
								{
									for (i = j + 1; i <= n; i++)
									{
										h[i, j] = 0;
									}
									j = j + 1;
								}
								else
								{
									for (i = j + 2; i <= n; i++)
									{
										h[i, j] = 0;
										h[i, j + 1] = 0;
									}
									j = j + 2;
								}
							}
						}

						//
						// Exit
						//
						return;
					}

					//
					// Perform multiple-shift QR iterations on rows and columns ILO to I
					// until a submatrix of order at most MAXB splits off at the bottom
					// because a subdiagonal element has become negligible.
					//
					failflag = true;
					for (its = 0; its <= itn; its++)
					{

						//
						// Look for a single small subdiagonal element.
						//
						for (k = i; k >= l + 1; k--)
						{
							tst1 = Math.Abs(h[k - 1, k - 1]) + Math.Abs(h[k, k]);
							if ((double)(tst1) == (double)(0))
							{
								tst1 = blas.upperhessenberg1norm(h, l, i, l, i, ref work);
							}
							if ((double)(Math.Abs(h[k, k - 1])) <= (double)(Math.Max(ulp * tst1, smlnum)))
							{
								break;
							}
						}
						l = k;
						if (l > 1)
						{

							//
							// H(L,L-1) is negligible.
							//
							h[l, l - 1] = 0;
						}

						//
						// Exit from loop if a submatrix of order <= MAXB has split off.
						//
						if (l >= i - maxb + 1)
						{
							failflag = false;
							break;
						}

						//
						// Now the active submatrix is in rows and columns L to I. If
						// eigenvalues only are being computed, only the active submatrix
						// need be transformed.
						//
						if (its == 20 || its == 30)
						{

							//
							// Exceptional shifts.
							//
							for (ii = i - ns + 1; ii <= i; ii++)
							{
								wr[ii] = cnst * (Math.Abs(h[ii, ii - 1]) + Math.Abs(h[ii, ii]));
								wi[ii] = 0;
							}
						}
						else
						{

							//
							// Use eigenvalues of trailing submatrix of order NS as shifts.
							//
							blas.copymatrix(h, i - ns + 1, i, i - ns + 1, i, ref s, 1, ns, 1, ns);
							internalauxschur(false, false, ns, 1, ns, ref s, ref tmpwr, ref tmpwi, 1, ns, ref z, ref work, ref workv3, ref workc1, ref works1, ref ierr);
							for (p1 = 1; p1 <= ns; p1++)
							{
								wr[i - ns + p1] = tmpwr[p1];
								wi[i - ns + p1] = tmpwi[p1];
							}
							if (ierr > 0)
							{

								//
								// If DLAHQR failed to compute all NS eigenvalues, use the
								// unconverged diagonal elements as the remaining shifts.
								//
								for (ii = 1; ii <= ierr; ii++)
								{
									wr[i - ns + ii] = s[ii, ii];
									wi[i - ns + ii] = 0;
								}
							}
						}

						//
						// Form the first column of (G-w(1)) (G-w(2)) . . . (G-w(ns))
						// where G is the Hessenberg submatrix H(L:I,L:I) and w is
						// the vector of shifts (stored in WR and WI). The result is
						// stored in the local array V.
						//
						v[1] = 1;
						for (ii = 2; ii <= ns + 1; ii++)
						{
							v[ii] = 0;
						}
						nv = 1;
						for (j = i - ns + 1; j <= i; j++)
						{
							if ((double)(wi[j]) >= (double)(0))
							{
								if ((double)(wi[j]) == (double)(0))
								{

									//
									// real shift
									//
									p1 = nv + 1;
									for (i_ = 1; i_ <= p1; i_++)
									{
										vv[i_] = v[i_];
									}
									blas.matrixvectormultiply(h, l, l + nv, l, l + nv - 1, false, vv, 1, nv, 1.0f, ref v, 1, nv + 1, -wr[j]);
									nv = nv + 1;
								}
								else
								{
									if ((double)(wi[j]) > (double)(0))
									{

										//
										// complex conjugate pair of shifts
										//
										p1 = nv + 1;
										for (i_ = 1; i_ <= p1; i_++)
										{
											vv[i_] = v[i_];
										}
										blas.matrixvectormultiply(h, l, l + nv, l, l + nv - 1, false, v, 1, nv, 1.0f, ref vv, 1, nv + 1, -(2 * wr[j]));
										itemp = blas.vectoridxabsmax(vv, 1, nv + 1);
										temp = 1 / Math.Max(Math.Abs(vv[itemp]), smlnum);
										p1 = nv + 1;
										for (i_ = 1; i_ <= p1; i_++)
										{
											vv[i_] = temp * vv[i_];
										}
										absw = blas.pythag2(wr[j], wi[j]);
										temp = temp * absw * absw;
										blas.matrixvectormultiply(h, l, l + nv + 1, l, l + nv, false, vv, 1, nv + 1, 1.0f, ref v, 1, nv + 2, temp);
										nv = nv + 2;
									}
								}

								//
								// Scale V(1:NV) so that max(abs(V(i))) = 1. If V is zero,
								// reset it to the unit vector.
								//
								itemp = blas.vectoridxabsmax(v, 1, nv);
								temp = Math.Abs(v[itemp]);
								if ((double)(temp) == (double)(0))
								{
									v[1] = 1;
									for (ii = 2; ii <= nv; ii++)
									{
										v[ii] = 0;
									}
								}
								else
								{
									temp = Math.Max(temp, smlnum);
									vt = 1 / temp;
									for (i_ = 1; i_ <= nv; i_++)
									{
										v[i_] = vt * v[i_];
									}
								}
							}
						}

						//
						// Multiple-shift QR step
						//
						for (k = l; k <= i - 1; k++)
						{

							//
							// The first iteration of this loop determines a reflection G
							// from the vector V and applies it from left and right to H,
							// thus creating a nonzero bulge below the subdiagonal.
							//
							// Each subsequent iteration determines a reflection G to
							// restore the Hessenberg form in the (K-1)th column, and thus
							// chases the bulge one step toward the bottom of the active
							// submatrix. NR is the order of G.
							//
							nr = Math.Min(ns + 1, i - k + 1);
							if (k > l)
							{
								p1 = k - 1;
								p2 = k + nr - 1;
								i1_ = (k) - (1);
								for (i_ = 1; i_ <= nr; i_++)
								{
									v[i_] = h[i_ + i1_, p1];
								}
								apserv.touchint(ref p2);
							}
							reflections.generatereflection(ref v, nr, ref tau);
							if (k > l)
							{
								h[k, k - 1] = v[1];
								for (ii = k + 1; ii <= i; ii++)
								{
									h[ii, k - 1] = 0;
								}
							}
							v[1] = 1;

							//
							// Apply G from the left to transform the rows of the matrix in
							// columns K to I2.
							//
							reflections.applyreflectionfromtheleft(ref h, tau, v, k, k + nr - 1, k, i2, ref work);

							//
							// Apply G from the right to transform the columns of the
							// matrix in rows I1 to min(K+NR,I).
							//
							reflections.applyreflectionfromtheright(ref h, tau, v, i1, Math.Min(k + nr, i), k, k + nr - 1, ref work);
							if (wantz)
							{

								//
								// Accumulate transformations in the matrix Z
								//
								reflections.applyreflectionfromtheright(ref z, tau, v, 1, n, k, k + nr - 1, ref work);
							}
						}
					}

					//
					// Failure to converge in remaining number of iterations
					//
					if (failflag)
					{
						info = i;
						return;
					}

					//
					// A submatrix of order <= MAXB in rows and columns L to I has split
					// off. Use the double-shift QR algorithm to handle it.
					//
					internalauxschur(wantt, wantz, n, l, i, ref h, ref wr, ref wi, 1, n, ref z, ref work, ref workv3, ref workc1, ref works1, ref info);
					if (info > 0)
					{
						return;
					}

					//
					// Decrement number of remaining iterations, and return to start of
					// the main loop with a new value of I.
					//
					itn = itn - its;
					i = l - 1;
				}
			}


			private static void internalauxschur(bool wantt,
					bool wantz,
					int n,
					int ilo,
					int ihi,
					ref double[,] h,
					ref double[] wr,
					ref double[] wi,
					int iloz,
					int ihiz,
					ref double[,] z,
					ref double[] work,
					ref double[] workv3,
					ref double[] workc1,
					ref double[] works1,
					ref int info)
			{
				int i = 0;
				int i1 = 0;
				int i2 = 0;
				int itn = 0;
				int its = 0;
				int j = 0;
				int k = 0;
				int l = 0;
				int m = 0;
				int nh = 0;
				int nr = 0;
				int nz = 0;
				double ave = 0;
				double cs = 0;
				double disc = 0;
				double h00 = 0;
				double h10 = 0;
				double h11 = 0;
				double h12 = 0;
				double h21 = 0;
				double h22 = 0;
				double h33 = 0;
				double h33s = 0;
				double h43h34 = 0;
				double h44 = 0;
				double h44s = 0;
				double s = 0;
				double smlnum = 0;
				double sn = 0;
				double sum = 0;
				double t1 = 0;
				double t2 = 0;
				double t3 = 0;
				double tst1 = 0;
				double unfl = 0;
				double v1 = 0;
				double v2 = 0;
				double v3 = 0;
				bool failflag = new bool();
				double dat1 = 0;
				double dat2 = 0;
				int p1 = 0;
				double him1im1 = 0;
				double him1i = 0;
				double hiim1 = 0;
				double hii = 0;
				double wrim1 = 0;
				double wri = 0;
				double wiim1 = 0;
				double wii = 0;
				double ulp = 0;

				info = 0;

				info = 0;
				dat1 = 0.75f;
				dat2 = -0.4375f;
				ulp = math.machineepsilon;

				//
				// Quick return if possible
				//
				if (n == 0)
				{
					return;
				}
				if (ilo == ihi)
				{
					wr[ilo] = h[ilo, ilo];
					wi[ilo] = 0;
					return;
				}
				nh = ihi - ilo + 1;
				nz = ihiz - iloz + 1;

				//
				// Set machine-dependent constants for the stopping criterion.
				// If norm(H) <= sqrt(MaxRealNumber), overflow should not occur.
				//
				unfl = math.minrealnumber;
				smlnum = unfl * (nh / ulp);

				//
				// I1 and I2 are the indices of the first row and last column of H
				// to which transformations must be applied. If eigenvalues only are
				// being computed, I1 and I2 are set inside the main loop.
				//
				i1 = 1;
				i2 = n;

				//
				// ITN is the total number of QR iterations allowed.
				//
				itn = 30 * nh;

				//
				// The main loop begins here. I is the loop index and decreases from
				// IHI to ILO in steps of 1 or 2. Each iteration of the loop works
				// with the active submatrix in rows and columns L to I.
				// Eigenvalues I+1 to IHI have already converged. Either L = ILO or
				// H(L,L-1) is negligible so that the matrix splits.
				//
				i = ihi;
				while (true)
				{
					l = ilo;
					if (i < ilo)
					{
						return;
					}

					//
					// Perform QR iterations on rows and columns ILO to I until a
					// submatrix of order 1 or 2 splits off at the bottom because a
					// subdiagonal element has become negligible.
					//
					failflag = true;
					for (its = 0; its <= itn; its++)
					{

						//
						// Look for a single small subdiagonal element.
						//
						for (k = i; k >= l + 1; k--)
						{
							tst1 = Math.Abs(h[k - 1, k - 1]) + Math.Abs(h[k, k]);
							if ((double)(tst1) == (double)(0))
							{
								tst1 = blas.upperhessenberg1norm(h, l, i, l, i, ref work);
							}
							if ((double)(Math.Abs(h[k, k - 1])) <= (double)(Math.Max(ulp * tst1, smlnum)))
							{
								break;
							}
						}
						l = k;
						if (l > ilo)
						{

							//
							// H(L,L-1) is negligible
							//
							h[l, l - 1] = 0;
						}

						//
						// Exit from loop if a submatrix of order 1 or 2 has split off.
						//
						if (l >= i - 1)
						{
							failflag = false;
							break;
						}

						//
						// Now the active submatrix is in rows and columns L to I. If
						// eigenvalues only are being computed, only the active submatrix
						// need be transformed.
						//
						if (its == 10 || its == 20)
						{

							//
							// Exceptional shift.
							//
							s = Math.Abs(h[i, i - 1]) + Math.Abs(h[i - 1, i - 2]);
							h44 = dat1 * s + h[i, i];
							h33 = h44;
							h43h34 = dat2 * s * s;
						}
						else
						{

							//
							// Prepare to use Francis' double shift
							// (i.e. 2nd degree generalized Rayleigh quotient)
							//
							h44 = h[i, i];
							h33 = h[i - 1, i - 1];
							h43h34 = h[i, i - 1] * h[i - 1, i];
							s = h[i - 1, i - 2] * h[i - 1, i - 2];
							disc = (h33 - h44) * 0.5f;
							disc = disc * disc + h43h34;
							if ((double)(disc) > (double)(0))
							{

								//
								// Real roots: use Wilkinson's shift twice
								//
								disc = (double)Math.Sqrt(disc);
								ave = 0.5f * (h33 + h44);
								if ((double)(Math.Abs(h33) - Math.Abs(h44)) > (double)(0))
								{
									h33 = h33 * h44 - h43h34;
									h44 = h33 / (extschursign(disc, ave) + ave);
								}
								else
								{
									h44 = extschursign(disc, ave) + ave;
								}
								h33 = h44;
								h43h34 = 0;
							}
						}

						//
						// Look for two consecutive small subdiagonal elements.
						//
						for (m = i - 2; m >= l; m--)
						{

							//
							// Determine the effect of starting the double-shift QR
							// iteration at row M, and see if this would make H(M,M-1)
							// negligible.
							//
							h11 = h[m, m];
							h22 = h[m + 1, m + 1];
							h21 = h[m + 1, m];
							h12 = h[m, m + 1];
							h44s = h44 - h11;
							h33s = h33 - h11;
							v1 = (h33s * h44s - h43h34) / h21 + h12;
							v2 = h22 - h11 - h33s - h44s;
							v3 = h[m + 2, m + 1];
							s = Math.Abs(v1) + Math.Abs(v2) + Math.Abs(v3);
							v1 = v1 / s;
							v2 = v2 / s;
							v3 = v3 / s;
							workv3[1] = v1;
							workv3[2] = v2;
							workv3[3] = v3;
							if (m == l)
							{
								break;
							}
							h00 = h[m - 1, m - 1];
							h10 = h[m, m - 1];
							tst1 = Math.Abs(v1) * (Math.Abs(h00) + Math.Abs(h11) + Math.Abs(h22));
							if ((double)(Math.Abs(h10) * (Math.Abs(v2) + Math.Abs(v3))) <= (double)(ulp * tst1))
							{
								break;
							}
						}

						//
						// double-shift QR step
						//
						for (k = m; k <= i - 1; k++)
						{

							//
							// The first iteration of this loop determines a reflection G
							// from the vector V and applies it from left and right to H,
							// thus creating a nonzero bulge below the subdiagonal.
							//
							// Each subsequent iteration determines a reflection G to
							// restore the Hessenberg form in the (K-1)th column, and thus
							// chases the bulge one step toward the bottom of the active
							// submatrix. NR is the order of G.
							//
							nr = Math.Min(3, i - k + 1);
							if (k > m)
							{
								for (p1 = 1; p1 <= nr; p1++)
								{
									workv3[p1] = h[k + p1 - 1, k - 1];
								}
							}
							reflections.generatereflection(ref workv3, nr, ref t1);
							if (k > m)
							{
								h[k, k - 1] = workv3[1];
								h[k + 1, k - 1] = 0;
								if (k < i - 1)
								{
									h[k + 2, k - 1] = 0;
								}
							}
							else
							{
								if (m > l)
								{
									h[k, k - 1] = -h[k, k - 1];
								}
							}
							v2 = workv3[2];
							t2 = t1 * v2;
							if (nr == 3)
							{
								v3 = workv3[3];
								t3 = t1 * v3;

								//
								// Apply G from the left to transform the rows of the matrix
								// in columns K to I2.
								//
								for (j = k; j <= i2; j++)
								{
									sum = h[k, j] + v2 * h[k + 1, j] + v3 * h[k + 2, j];
									h[k, j] = h[k, j] - sum * t1;
									h[k + 1, j] = h[k + 1, j] - sum * t2;
									h[k + 2, j] = h[k + 2, j] - sum * t3;
								}

								//
								// Apply G from the right to transform the columns of the
								// matrix in rows I1 to min(K+3,I).
								//
								for (j = i1; j <= Math.Min(k + 3, i); j++)
								{
									sum = h[j, k] + v2 * h[j, k + 1] + v3 * h[j, k + 2];
									h[j, k] = h[j, k] - sum * t1;
									h[j, k + 1] = h[j, k + 1] - sum * t2;
									h[j, k + 2] = h[j, k + 2] - sum * t3;
								}
								if (wantz)
								{

									//
									// Accumulate transformations in the matrix Z
									//
									for (j = iloz; j <= ihiz; j++)
									{
										sum = z[j, k] + v2 * z[j, k + 1] + v3 * z[j, k + 2];
										z[j, k] = z[j, k] - sum * t1;
										z[j, k + 1] = z[j, k + 1] - sum * t2;
										z[j, k + 2] = z[j, k + 2] - sum * t3;
									}
								}
							}
							else
							{
								if (nr == 2)
								{

									//
									// Apply G from the left to transform the rows of the matrix
									// in columns K to I2.
									//
									for (j = k; j <= i2; j++)
									{
										sum = h[k, j] + v2 * h[k + 1, j];
										h[k, j] = h[k, j] - sum * t1;
										h[k + 1, j] = h[k + 1, j] - sum * t2;
									}

									//
									// Apply G from the right to transform the columns of the
									// matrix in rows I1 to min(K+3,I).
									//
									for (j = i1; j <= i; j++)
									{
										sum = h[j, k] + v2 * h[j, k + 1];
										h[j, k] = h[j, k] - sum * t1;
										h[j, k + 1] = h[j, k + 1] - sum * t2;
									}
									if (wantz)
									{

										//
										// Accumulate transformations in the matrix Z
										//
										for (j = iloz; j <= ihiz; j++)
										{
											sum = z[j, k] + v2 * z[j, k + 1];
											z[j, k] = z[j, k] - sum * t1;
											z[j, k + 1] = z[j, k + 1] - sum * t2;
										}
									}
								}
							}
						}
					}
					if (failflag)
					{

						//
						// Failure to converge in remaining number of iterations
						//
						info = i;
						return;
					}
					if (l == i)
					{

						//
						// H(I,I-1) is negligible: one eigenvalue has converged.
						//
						wr[i] = h[i, i];
						wi[i] = 0;
					}
					else
					{
						if (l == i - 1)
						{

							//
							// H(I-1,I-2) is negligible: a pair of eigenvalues have converged.
							//
							//        Transform the 2-by-2 submatrix to standard Schur form,
							//        and compute and store the eigenvalues.
							//
							him1im1 = h[i - 1, i - 1];
							him1i = h[i - 1, i];
							hiim1 = h[i, i - 1];
							hii = h[i, i];
							aux2x2schur(ref him1im1, ref him1i, ref hiim1, ref hii, ref wrim1, ref wiim1, ref wri, ref wii, ref cs, ref sn);
							wr[i - 1] = wrim1;
							wi[i - 1] = wiim1;
							wr[i] = wri;
							wi[i] = wii;
							h[i - 1, i - 1] = him1im1;
							h[i - 1, i] = him1i;
							h[i, i - 1] = hiim1;
							h[i, i] = hii;
							if (wantt)
							{

								//
								// Apply the transformation to the rest of H.
								//
								if (i2 > i)
								{
									workc1[1] = cs;
									works1[1] = sn;
									rotations.applyrotationsfromtheleft(true, i - 1, i, i + 1, i2, workc1, works1, ref h, ref work);
								}
								workc1[1] = cs;
								works1[1] = sn;
								rotations.applyrotationsfromtheright(true, i1, i - 2, i - 1, i, workc1, works1, ref h, ref work);
							}
							if (wantz)
							{

								//
								// Apply the transformation to Z.
								//
								workc1[1] = cs;
								works1[1] = sn;
								rotations.applyrotationsfromtheright(true, iloz, iloz + nz - 1, i - 1, i, workc1, works1, ref z, ref work);
							}
						}
					}

					//
					// Decrement number of remaining iterations, and return to start of
					// the main loop with new value of I.
					//
					itn = itn - its;
					i = l - 1;
				}
			}


			private static void aux2x2schur(ref double a,
					ref double b,
					ref double c,
					ref double d,
					ref double rt1r,
					ref double rt1i,
					ref double rt2r,
					ref double rt2i,
					ref double cs,
					ref double sn)
			{
				double multpl = 0;
				double aa = 0;
				double bb = 0;
				double bcmax = 0;
				double bcmis = 0;
				double cc = 0;
				double cs1 = 0;
				double dd = 0;
				double eps = 0;
				double p = 0;
				double sab = 0;
				double sac = 0;
				double scl = 0;
				double sigma = 0;
				double sn1 = 0;
				double tau = 0;
				double temp = 0;
				double z = 0;

				rt1r = 0;
				rt1i = 0;
				rt2r = 0;
				rt2i = 0;
				cs = 0;
				sn = 0;

				multpl = 4.0f;
				eps = math.machineepsilon;
				if ((double)(c) == (double)(0))
				{
					cs = 1;
					sn = 0;
				}
				else
				{
					if ((double)(b) == (double)(0))
					{

						//
						// Swap rows and columns
						//
						cs = 0;
						sn = 1;
						temp = d;
						d = a;
						a = temp;
						b = -c;
						c = 0;
					}
					else
					{
						if ((double)(a - d) == (double)(0) && extschursigntoone(b) != extschursigntoone(c))
						{
							cs = 1;
							sn = 0;
						}
						else
						{
							temp = a - d;
							p = 0.5f * temp;
							bcmax = Math.Max(Math.Abs(b), Math.Abs(c));
							bcmis = Math.Min(Math.Abs(b), Math.Abs(c)) * extschursigntoone(b) * extschursigntoone(c);
							scl = Math.Max(Math.Abs(p), bcmax);
							z = p / scl * p + bcmax / scl * bcmis;

							//
							// If Z is of the order of the machine accuracy, postpone the
							// decision on the nature of eigenvalues
							//
							if ((double)(z) >= (double)(multpl * eps))
							{

								//
								// Real eigenvalues. Compute A and D.
								//
								z = p + extschursign((double)(Math.Sqrt(scl) * Math.Sqrt(z)), p);
								a = d + z;
								d = d - bcmax / z * bcmis;

								//
								// Compute B and the rotation matrix
								//
								tau = blas.pythag2(c, z);
								cs = z / tau;
								sn = c / tau;
								b = b - c;
								c = 0;
							}
							else
							{

								//
								// Complex eigenvalues, or real (almost) equal eigenvalues.
								// Make diagonal elements equal.
								//
								sigma = b + c;
								tau = blas.pythag2(sigma, temp);
								cs = (double)(Math.Sqrt(0.5f * (1 + Math.Abs(sigma) / tau)));
								sn = -(p / (tau * cs) * extschursign(1, sigma));

								//
								// Compute [ AA  BB ] = [ A  B ] [ CS -SN ]
								//         [ CC  DD ]   [ C  D ] [ SN  CS ]
								//
								aa = a * cs + b * sn;
								bb = -(a * sn) + b * cs;
								cc = c * cs + d * sn;
								dd = -(c * sn) + d * cs;

								//
								// Compute [ A  B ] = [ CS  SN ] [ AA  BB ]
								//         [ C  D ]   [-SN  CS ] [ CC  DD ]
								//
								a = aa * cs + cc * sn;
								b = bb * cs + dd * sn;
								c = -(aa * sn) + cc * cs;
								d = -(bb * sn) + dd * cs;
								temp = 0.5f * (a + d);
								a = temp;
								d = temp;
								if ((double)(c) != (double)(0))
								{
									if ((double)(b) != (double)(0))
									{
										if (extschursigntoone(b) == extschursigntoone(c))
										{

											//
											// Real eigenvalues: reduce to upper triangular form
											//
											sab = (double)Math.Sqrt(Math.Abs(b));
											sac = (double)Math.Sqrt(Math.Abs(c));
											p = extschursign(sab * sac, c);
											tau = (double)(1 / Math.Sqrt(Math.Abs(b + c)));
											a = temp + p;
											d = temp - p;
											b = b - c;
											c = 0;
											cs1 = sab * tau;
											sn1 = sac * tau;
											temp = cs * cs1 - sn * sn1;
											sn = cs * sn1 + sn * cs1;
											cs = temp;
										}
									}
									else
									{
										b = -c;
										c = 0;
										temp = cs;
										cs = -sn;
										sn = temp;
									}
								}
							}
						}
					}
				}

				//
				// Store eigenvalues in (RT1R,RT1I) and (RT2R,RT2I).
				//
				rt1r = a;
				rt2r = d;
				if ((double)(c) == (double)(0))
				{
					rt1i = 0;
					rt2i = 0;
				}
				else
				{
					rt1i = (double)(Math.Sqrt(Math.Abs(b)) * Math.Sqrt(Math.Abs(c)));
					rt2i = -rt1i;
				}
			}


			private static double extschursign(double a,
					double b)
			{
				double result = 0;

				if ((double)(b) >= (double)(0))
				{
					result = Math.Abs(a);
				}
				else
				{
					result = -Math.Abs(a);
				}
				return result;
			}


			private static int extschursigntoone(double b)
			{
				int result = 0;

				if ((double)(b) >= (double)(0))
				{
					result = 1;
				}
				else
				{
					result = -1;
				}
				return result;
			}


		}
		public class trlinsolve
		{
			/*************************************************************************
			Utility subroutine performing the "safe" solution of system of linear
			equations with triangular coefficient matrices.

			The subroutine uses scaling and solves the scaled system A*x=s*b (where  s
			is  a  scalar  value)  instead  of  A*x=b,  choosing  s  so  that x can be
			represented by a doubleing-point number. The closer the system  gets  to  a
			singular, the less s is. If the system is singular, s=0 and x contains the
			non-trivial solution of equation A*x=0.

			The feature of an algorithm is that it could not cause an  overflow  or  a
			division by zero regardless of the matrix used as the input.

			The algorithm can solve systems of equations with  upper/lower  triangular
			matrices,  with/without unit diagonal, and systems of type A*x=b or A'*x=b
			(where A' is a transposed matrix A).

			Input parameters:
					A       -   system matrix. Array whose indexes range within [0..N-1, 0..N-1].
					N       -   size of matrix A.
					X       -   right-hand member of a system.
											Array whose index ranges within [0..N-1].
					IsUpper -   matrix type. If it is True, the system matrix is the upper
											triangular and is located in  the  corresponding  part  of
											matrix A.
					Trans   -   problem type. If it is True, the problem to be  solved  is
											A'*x=b, otherwise it is A*x=b.
					Isunit  -   matrix type. If it is True, the system matrix has  a  unit
											diagonal (the elements on the main diagonal are  not  used
											in the calculation process), otherwise the matrix is considered
											to be a general triangular matrix.

			Output parameters:
					X       -   solution. Array whose index ranges within [0..N-1].
					S       -   scaling factor.

				-- LAPACK auxiliary routine (version 3.0) --
					 Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
					 Courant Institute, Argonne National Lab, and Rice University
					 June 30, 1992
			*************************************************************************/
			public static void rmatrixtrsafesolve(double[,] a,
					int n,
					ref double[] x,
					ref double s,
					bool isupper,
					bool istrans,
					bool isunit)
			{
				bool normin = new bool();
				double[] cnorm = new double[0];
				double[,] a1 = new double[0, 0];
				double[] x1 = new double[0];
				int i = 0;
				int i_ = 0;
				int i1_ = 0;

				s = 0;


				//
				// From 0-based to 1-based
				//
				normin = false;
				a1 = new double[n + 1, n + 1];
				x1 = new double[n + 1];
				for (i = 1; i <= n; i++)
				{
					i1_ = (0) - (1);
					for (i_ = 1; i_ <= n; i_++)
					{
						a1[i, i_] = a[i - 1, i_ + i1_];
					}
				}
				i1_ = (0) - (1);
				for (i_ = 1; i_ <= n; i_++)
				{
					x1[i_] = x[i_ + i1_];
				}

				//
				// Solve 1-based
				//
				safesolvetriangular(a1, n, ref x1, ref s, isupper, istrans, isunit, normin, ref cnorm);

				//
				// From 1-based to 0-based
				//
				i1_ = (1) - (0);
				for (i_ = 0; i_ <= n - 1; i_++)
				{
					x[i_] = x1[i_ + i1_];
				}
			}


			/*************************************************************************
			Obsolete 1-based subroutine.
			See RMatrixTRSafeSolve for 0-based replacement.
			*************************************************************************/
			public static void safesolvetriangular(double[,] a,
					int n,
					ref double[] x,
					ref double s,
					bool isupper,
					bool istrans,
					bool isunit,
					bool normin,
					ref double[] cnorm)
			{
				int i = 0;
				int imax = 0;
				int j = 0;
				int jfirst = 0;
				int jinc = 0;
				int jlast = 0;
				int jm1 = 0;
				int jp1 = 0;
				int ip1 = 0;
				int im1 = 0;
				int k = 0;
				int flg = 0;
				double v = 0;
				double vd = 0;
				double bignum = 0;
				double grow = 0;
				double rec = 0;
				double smlnum = 0;
				double sumj = 0;
				double tjj = 0;
				double tjjs = 0;
				double tmax = 0;
				double tscal = 0;
				double uscal = 0;
				double xbnd = 0;
				double xj = 0;
				double xmax = 0;
				bool notran = new bool();
				bool upper = new bool();
				bool nounit = new bool();
				int i_ = 0;

				s = 0;

				upper = isupper;
				notran = !istrans;
				nounit = !isunit;

				//
				// these initializers are not really necessary,
				// but without them compiler complains about uninitialized locals
				//
				tjjs = 0;

				//
				// Quick return if possible
				//
				if (n == 0)
				{
					return;
				}

				//
				// Determine machine dependent parameters to control overflow.
				//
				smlnum = math.minrealnumber / (math.machineepsilon * 2);
				bignum = 1 / smlnum;
				s = 1;
				if (!normin)
				{
					cnorm = new double[n + 1];

					//
					// Compute the 1-norm of each column, not including the diagonal.
					//
					if (upper)
					{

						//
						// A is upper triangular.
						//
						for (j = 1; j <= n; j++)
						{
							v = 0;
							for (k = 1; k <= j - 1; k++)
							{
								v = v + Math.Abs(a[k, j]);
							}
							cnorm[j] = v;
						}
					}
					else
					{

						//
						// A is lower triangular.
						//
						for (j = 1; j <= n - 1; j++)
						{
							v = 0;
							for (k = j + 1; k <= n; k++)
							{
								v = v + Math.Abs(a[k, j]);
							}
							cnorm[j] = v;
						}
						cnorm[n] = 0;
					}
				}

				//
				// Scale the column norms by TSCAL if the maximum element in CNORM is
				// greater than BIGNUM.
				//
				imax = 1;
				for (k = 2; k <= n; k++)
				{
					if ((double)(cnorm[k]) > (double)(cnorm[imax]))
					{
						imax = k;
					}
				}
				tmax = cnorm[imax];
				if ((double)(tmax) <= (double)(bignum))
				{
					tscal = 1;
				}
				else
				{
					tscal = 1 / (smlnum * tmax);
					for (i_ = 1; i_ <= n; i_++)
					{
						cnorm[i_] = tscal * cnorm[i_];
					}
				}

				//
				// Compute a bound on the computed solution vector to see if the
				// Level 2 BLAS routine DTRSV can be used.
				//
				j = 1;
				for (k = 2; k <= n; k++)
				{
					if ((double)(Math.Abs(x[k])) > (double)(Math.Abs(x[j])))
					{
						j = k;
					}
				}
				xmax = Math.Abs(x[j]);
				xbnd = xmax;
				if (notran)
				{

					//
					// Compute the growth in A * x = b.
					//
					if (upper)
					{
						jfirst = n;
						jlast = 1;
						jinc = -1;
					}
					else
					{
						jfirst = 1;
						jlast = n;
						jinc = 1;
					}
					if ((double)(tscal) != (double)(1))
					{
						grow = 0;
					}
					else
					{
						if (nounit)
						{

							//
							// A is non-unit triangular.
							//
							// Compute GROW = 1/G(j) and XBND = 1/M(j).
							// Initially, G(0) = max{x(i), i=1,...,n}.
							//
							grow = 1 / Math.Max(xbnd, smlnum);
							xbnd = grow;
							j = jfirst;
							while ((jinc > 0 && j <= jlast) || (jinc < 0 && j >= jlast))
							{

								//
								// Exit the loop if the growth factor is too small.
								//
								if ((double)(grow) <= (double)(smlnum))
								{
									break;
								}

								//
								// M(j) = G(j-1) / abs(A(j,j))
								//
								tjj = Math.Abs(a[j, j]);
								xbnd = Math.Min(xbnd, Math.Min(1, tjj) * grow);
								if ((double)(tjj + cnorm[j]) >= (double)(smlnum))
								{

									//
									// G(j) = G(j-1)*( 1 + CNORM(j) / abs(A(j,j)) )
									//
									grow = grow * (tjj / (tjj + cnorm[j]));
								}
								else
								{

									//
									// G(j) could overflow, set GROW to 0.
									//
									grow = 0;
								}
								if (j == jlast)
								{
									grow = xbnd;
								}
								j = j + jinc;
							}
						}
						else
						{

							//
							// A is unit triangular.
							//
							// Compute GROW = 1/G(j), where G(0) = max{x(i), i=1,...,n}.
							//
							grow = Math.Min(1, 1 / Math.Max(xbnd, smlnum));
							j = jfirst;
							while ((jinc > 0 && j <= jlast) || (jinc < 0 && j >= jlast))
							{

								//
								// Exit the loop if the growth factor is too small.
								//
								if ((double)(grow) <= (double)(smlnum))
								{
									break;
								}

								//
								// G(j) = G(j-1)*( 1 + CNORM(j) )
								//
								grow = grow * (1 / (1 + cnorm[j]));
								j = j + jinc;
							}
						}
					}
				}
				else
				{

					//
					// Compute the growth in A' * x = b.
					//
					if (upper)
					{
						jfirst = 1;
						jlast = n;
						jinc = 1;
					}
					else
					{
						jfirst = n;
						jlast = 1;
						jinc = -1;
					}
					if ((double)(tscal) != (double)(1))
					{
						grow = 0;
					}
					else
					{
						if (nounit)
						{

							//
							// A is non-unit triangular.
							//
							// Compute GROW = 1/G(j) and XBND = 1/M(j).
							// Initially, M(0) = max{x(i), i=1,...,n}.
							//
							grow = 1 / Math.Max(xbnd, smlnum);
							xbnd = grow;
							j = jfirst;
							while ((jinc > 0 && j <= jlast) || (jinc < 0 && j >= jlast))
							{

								//
								// Exit the loop if the growth factor is too small.
								//
								if ((double)(grow) <= (double)(smlnum))
								{
									break;
								}

								//
								// G(j) = max( G(j-1), M(j-1)*( 1 + CNORM(j) ) )
								//
								xj = 1 + cnorm[j];
								grow = Math.Min(grow, xbnd / xj);

								//
								// M(j) = M(j-1)*( 1 + CNORM(j) ) / abs(A(j,j))
								//
								tjj = Math.Abs(a[j, j]);
								if ((double)(xj) > (double)(tjj))
								{
									xbnd = xbnd * (tjj / xj);
								}
								if (j == jlast)
								{
									grow = Math.Min(grow, xbnd);
								}
								j = j + jinc;
							}
						}
						else
						{

							//
							// A is unit triangular.
							//
							// Compute GROW = 1/G(j), where G(0) = max{x(i), i=1,...,n}.
							//
							grow = Math.Min(1, 1 / Math.Max(xbnd, smlnum));
							j = jfirst;
							while ((jinc > 0 && j <= jlast) || (jinc < 0 && j >= jlast))
							{

								//
								// Exit the loop if the growth factor is too small.
								//
								if ((double)(grow) <= (double)(smlnum))
								{
									break;
								}

								//
								// G(j) = ( 1 + CNORM(j) )*G(j-1)
								//
								xj = 1 + cnorm[j];
								grow = grow / xj;
								j = j + jinc;
							}
						}
					}
				}
				if ((double)(grow * tscal) > (double)(smlnum))
				{

					//
					// Use the Level 2 BLAS solve if the reciprocal of the bound on
					// elements of X is not too small.
					//
					if ((upper && notran) || (!upper && !notran))
					{
						if (nounit)
						{
							vd = a[n, n];
						}
						else
						{
							vd = 1;
						}
						x[n] = x[n] / vd;
						for (i = n - 1; i >= 1; i--)
						{
							ip1 = i + 1;
							if (upper)
							{
								v = 0.0f;
								for (i_ = ip1; i_ <= n; i_++)
								{
									v += a[i, i_] * x[i_];
								}
							}
							else
							{
								v = 0.0f;
								for (i_ = ip1; i_ <= n; i_++)
								{
									v += a[i_, i] * x[i_];
								}
							}
							if (nounit)
							{
								vd = a[i, i];
							}
							else
							{
								vd = 1;
							}
							x[i] = (x[i] - v) / vd;
						}
					}
					else
					{
						if (nounit)
						{
							vd = a[1, 1];
						}
						else
						{
							vd = 1;
						}
						x[1] = x[1] / vd;
						for (i = 2; i <= n; i++)
						{
							im1 = i - 1;
							if (upper)
							{
								v = 0.0f;
								for (i_ = 1; i_ <= im1; i_++)
								{
									v += a[i_, i] * x[i_];
								}
							}
							else
							{
								v = 0.0f;
								for (i_ = 1; i_ <= im1; i_++)
								{
									v += a[i, i_] * x[i_];
								}
							}
							if (nounit)
							{
								vd = a[i, i];
							}
							else
							{
								vd = 1;
							}
							x[i] = (x[i] - v) / vd;
						}
					}
				}
				else
				{

					//
					// Use a Level 1 BLAS solve, scaling intermediate results.
					//
					if ((double)(xmax) > (double)(bignum))
					{

						//
						// Scale X so that its components are less than or equal to
						// BIGNUM in absolute value.
						//
						s = bignum / xmax;
						for (i_ = 1; i_ <= n; i_++)
						{
							x[i_] = s * x[i_];
						}
						xmax = bignum;
					}
					if (notran)
					{

						//
						// Solve A * x = b
						//
						j = jfirst;
						while ((jinc > 0 && j <= jlast) || (jinc < 0 && j >= jlast))
						{

							//
							// Compute x(j) = b(j) / A(j,j), scaling x if necessary.
							//
							xj = Math.Abs(x[j]);
							flg = 0;
							if (nounit)
							{
								tjjs = a[j, j] * tscal;
							}
							else
							{
								tjjs = tscal;
								if ((double)(tscal) == (double)(1))
								{
									flg = 100;
								}
							}
							if (flg != 100)
							{
								tjj = Math.Abs(tjjs);
								if ((double)(tjj) > (double)(smlnum))
								{

									//
									// abs(A(j,j)) > SMLNUM:
									//
									if ((double)(tjj) < (double)(1))
									{
										if ((double)(xj) > (double)(tjj * bignum))
										{

											//
											// Scale x by 1/b(j).
											//
											rec = 1 / xj;
											for (i_ = 1; i_ <= n; i_++)
											{
												x[i_] = rec * x[i_];
											}
											s = s * rec;
											xmax = xmax * rec;
										}
									}
									x[j] = x[j] / tjjs;
									xj = Math.Abs(x[j]);
								}
								else
								{
									if ((double)(tjj) > (double)(0))
									{

										//
										// 0 < abs(A(j,j)) <= SMLNUM:
										//
										if ((double)(xj) > (double)(tjj * bignum))
										{

											//
											// Scale x by (1/abs(x(j)))*abs(A(j,j))*BIGNUM
											// to avoid overflow when dividing by A(j,j).
											//
											rec = tjj * bignum / xj;
											if ((double)(cnorm[j]) > (double)(1))
											{

												//
												// Scale by 1/CNORM(j) to avoid overflow when
												// multiplying x(j) times column j.
												//
												rec = rec / cnorm[j];
											}
											for (i_ = 1; i_ <= n; i_++)
											{
												x[i_] = rec * x[i_];
											}
											s = s * rec;
											xmax = xmax * rec;
										}
										x[j] = x[j] / tjjs;
										xj = Math.Abs(x[j]);
									}
									else
									{

										//
										// A(j,j) = 0:  Set x(1:n) = 0, x(j) = 1, and
										// scale = 0, and compute a solution to A*x = 0.
										//
										for (i = 1; i <= n; i++)
										{
											x[i] = 0;
										}
										x[j] = 1;
										xj = 1;
										s = 0;
										xmax = 0;
									}
								}
							}

							//
							// Scale x if necessary to avoid overflow when adding a
							// multiple of column j of A.
							//
							if ((double)(xj) > (double)(1))
							{
								rec = 1 / xj;
								if ((double)(cnorm[j]) > (double)((bignum - xmax) * rec))
								{

									//
									// Scale x by 1/(2*abs(x(j))).
									//
									rec = rec * 0.5f;
									for (i_ = 1; i_ <= n; i_++)
									{
										x[i_] = rec * x[i_];
									}
									s = s * rec;
								}
							}
							else
							{
								if ((double)(xj * cnorm[j]) > (double)(bignum - xmax))
								{

									//
									// Scale x by 1/2.
									//
									for (i_ = 1; i_ <= n; i_++)
									{
										x[i_] = 0.5f * x[i_];
									}
									s = s * 0.5f;
								}
							}
							if (upper)
							{
								if (j > 1)
								{

									//
									// Compute the update
									// x(1:j-1) := x(1:j-1) - x(j) * A(1:j-1,j)
									//
									v = x[j] * tscal;
									jm1 = j - 1;
									for (i_ = 1; i_ <= jm1; i_++)
									{
										x[i_] = x[i_] - v * a[i_, j];
									}
									i = 1;
									for (k = 2; k <= j - 1; k++)
									{
										if ((double)(Math.Abs(x[k])) > (double)(Math.Abs(x[i])))
										{
											i = k;
										}
									}
									xmax = Math.Abs(x[i]);
								}
							}
							else
							{
								if (j < n)
								{

									//
									// Compute the update
									// x(j+1:n) := x(j+1:n) - x(j) * A(j+1:n,j)
									//
									jp1 = j + 1;
									v = x[j] * tscal;
									for (i_ = jp1; i_ <= n; i_++)
									{
										x[i_] = x[i_] - v * a[i_, j];
									}
									i = j + 1;
									for (k = j + 2; k <= n; k++)
									{
										if ((double)(Math.Abs(x[k])) > (double)(Math.Abs(x[i])))
										{
											i = k;
										}
									}
									xmax = Math.Abs(x[i]);
								}
							}
							j = j + jinc;
						}
					}
					else
					{

						//
						// Solve A' * x = b
						//
						j = jfirst;
						while ((jinc > 0 && j <= jlast) || (jinc < 0 && j >= jlast))
						{

							//
							// Compute x(j) = b(j) - sum A(k,j)*x(k).
							//   k<>j
							//
							xj = Math.Abs(x[j]);
							uscal = tscal;
							rec = 1 / Math.Max(xmax, 1);
							if ((double)(cnorm[j]) > (double)((bignum - xj) * rec))
							{

								//
								// If x(j) could overflow, scale x by 1/(2*XMAX).
								//
								rec = rec * 0.5f;
								if (nounit)
								{
									tjjs = a[j, j] * tscal;
								}
								else
								{
									tjjs = tscal;
								}
								tjj = Math.Abs(tjjs);
								if ((double)(tjj) > (double)(1))
								{

									//
									// Divide by A(j,j) when scaling x if A(j,j) > 1.
									//
									rec = Math.Min(1, rec * tjj);
									uscal = uscal / tjjs;
								}
								if ((double)(rec) < (double)(1))
								{
									for (i_ = 1; i_ <= n; i_++)
									{
										x[i_] = rec * x[i_];
									}
									s = s * rec;
									xmax = xmax * rec;
								}
							}
							sumj = 0;
							if ((double)(uscal) == (double)(1))
							{

								//
								// If the scaling needed for A in the dot product is 1,
								// call DDOT to perform the dot product.
								//
								if (upper)
								{
									if (j > 1)
									{
										jm1 = j - 1;
										sumj = 0.0f;
										for (i_ = 1; i_ <= jm1; i_++)
										{
											sumj += a[i_, j] * x[i_];
										}
									}
									else
									{
										sumj = 0;
									}
								}
								else
								{
									if (j < n)
									{
										jp1 = j + 1;
										sumj = 0.0f;
										for (i_ = jp1; i_ <= n; i_++)
										{
											sumj += a[i_, j] * x[i_];
										}
									}
								}
							}
							else
							{

								//
								// Otherwise, use in-line code for the dot product.
								//
								if (upper)
								{
									for (i = 1; i <= j - 1; i++)
									{
										v = a[i, j] * uscal;
										sumj = sumj + v * x[i];
									}
								}
								else
								{
									if (j < n)
									{
										for (i = j + 1; i <= n; i++)
										{
											v = a[i, j] * uscal;
											sumj = sumj + v * x[i];
										}
									}
								}
							}
							if ((double)(uscal) == (double)(tscal))
							{

								//
								// Compute x(j) := ( x(j) - sumj ) / A(j,j) if 1/A(j,j)
								// was not used to scale the dotproduct.
								//
								x[j] = x[j] - sumj;
								xj = Math.Abs(x[j]);
								flg = 0;
								if (nounit)
								{
									tjjs = a[j, j] * tscal;
								}
								else
								{
									tjjs = tscal;
									if ((double)(tscal) == (double)(1))
									{
										flg = 150;
									}
								}

								//
								// Compute x(j) = x(j) / A(j,j), scaling if necessary.
								//
								if (flg != 150)
								{
									tjj = Math.Abs(tjjs);
									if ((double)(tjj) > (double)(smlnum))
									{

										//
										// abs(A(j,j)) > SMLNUM:
										//
										if ((double)(tjj) < (double)(1))
										{
											if ((double)(xj) > (double)(tjj * bignum))
											{

												//
												// Scale X by 1/abs(x(j)).
												//
												rec = 1 / xj;
												for (i_ = 1; i_ <= n; i_++)
												{
													x[i_] = rec * x[i_];
												}
												s = s * rec;
												xmax = xmax * rec;
											}
										}
										x[j] = x[j] / tjjs;
									}
									else
									{
										if ((double)(tjj) > (double)(0))
										{

											//
											// 0 < abs(A(j,j)) <= SMLNUM:
											//
											if ((double)(xj) > (double)(tjj * bignum))
											{

												//
												// Scale x by (1/abs(x(j)))*abs(A(j,j))*BIGNUM.
												//
												rec = tjj * bignum / xj;
												for (i_ = 1; i_ <= n; i_++)
												{
													x[i_] = rec * x[i_];
												}
												s = s * rec;
												xmax = xmax * rec;
											}
											x[j] = x[j] / tjjs;
										}
										else
										{

											//
											// A(j,j) = 0:  Set x(1:n) = 0, x(j) = 1, and
											// scale = 0, and compute a solution to A'*x = 0.
											//
											for (i = 1; i <= n; i++)
											{
												x[i] = 0;
											}
											x[j] = 1;
											s = 0;
											xmax = 0;
										}
									}
								}
							}
							else
							{

								//
								// Compute x(j) := x(j) / A(j,j)  - sumj if the dot
								// product has already been divided by 1/A(j,j).
								//
								x[j] = x[j] / tjjs - sumj;
							}
							xmax = Math.Max(xmax, Math.Abs(x[j]));
							j = j + jinc;
						}
					}
					s = s / tscal;
				}

				//
				// Scale the column norms by 1/TSCAL for return.
				//
				if ((double)(tscal) != (double)(1))
				{
					v = 1 / tscal;
					for (i_ = 1; i_ <= n; i_++)
					{
						cnorm[i_] = v * cnorm[i_];
					}
				}
			}


		}
		public class safesolve
		{
			/*************************************************************************
			Real implementation of CMatrixScaledTRSafeSolve

				-- ALGLIB routine --
					 21.01.2010
					 Bochkanov Sergey
			*************************************************************************/
			public static bool rmatrixscaledtrsafesolve(double[,] a,
					double sa,
					int n,
					ref double[] x,
					bool isupper,
					int trans,
					bool isunit,
					double maxgrowth)
			{
				bool result = new bool();
				double lnmax = 0;
				double nrmb = 0;
				double nrmx = 0;
				int i = 0;
				complex alpha = 0;
				complex beta = 0;
				double vr = 0;
				complex cx = 0;
				double[] tmp = new double[0];
				int i_ = 0;

				alglib.ap.assert(n > 0, "RMatrixTRSafeSolve: incorrect N!");
				alglib.ap.assert(trans == 0 || trans == 1, "RMatrixTRSafeSolve: incorrect Trans!");
				result = true;
				lnmax = (double)Math.Log(math.maxrealnumber);

				//
				// Quick return if possible
				//
				if (n <= 0)
				{
					return result;
				}

				//
				// Load norms: right part and X
				//
				nrmb = 0;
				for (i = 0; i <= n - 1; i++)
				{
					nrmb = Math.Max(nrmb, Math.Abs(x[i]));
				}
				nrmx = 0;

				//
				// Solve
				//
				tmp = new double[n];
				result = true;
				if (isupper && trans == 0)
				{

					//
					// U*x = b
					//
					for (i = n - 1; i >= 0; i--)
					{

						//
						// Task is reduced to alpha*x[i] = beta
						//
						if (isunit)
						{
							alpha = sa;
						}
						else
						{
							alpha = a[i, i] * sa;
						}
						if (i < n - 1)
						{
							for (i_ = i + 1; i_ <= n - 1; i_++)
							{
								tmp[i_] = sa * a[i, i_];
							}
							vr = 0.0f;
							for (i_ = i + 1; i_ <= n - 1; i_++)
							{
								vr += tmp[i_] * x[i_];
							}
							beta = x[i] - vr;
						}
						else
						{
							beta = x[i];
						}

						//
						// solve alpha*x[i] = beta
						//
						result = cbasicsolveandupdate(alpha, beta, lnmax, nrmb, maxgrowth, ref nrmx, ref cx);
						if (!result)
						{
							return result;
						}
						x[i] = cx.x;
					}
					return result;
				}
				if (!isupper && trans == 0)
				{

					//
					// L*x = b
					//
					for (i = 0; i <= n - 1; i++)
					{

						//
						// Task is reduced to alpha*x[i] = beta
						//
						if (isunit)
						{
							alpha = sa;
						}
						else
						{
							alpha = a[i, i] * sa;
						}
						if (i > 0)
						{
							for (i_ = 0; i_ <= i - 1; i_++)
							{
								tmp[i_] = sa * a[i, i_];
							}
							vr = 0.0f;
							for (i_ = 0; i_ <= i - 1; i_++)
							{
								vr += tmp[i_] * x[i_];
							}
							beta = x[i] - vr;
						}
						else
						{
							beta = x[i];
						}

						//
						// solve alpha*x[i] = beta
						//
						result = cbasicsolveandupdate(alpha, beta, lnmax, nrmb, maxgrowth, ref nrmx, ref cx);
						if (!result)
						{
							return result;
						}
						x[i] = cx.x;
					}
					return result;
				}
				if (isupper && trans == 1)
				{

					//
					// U^T*x = b
					//
					for (i = 0; i <= n - 1; i++)
					{

						//
						// Task is reduced to alpha*x[i] = beta
						//
						if (isunit)
						{
							alpha = sa;
						}
						else
						{
							alpha = a[i, i] * sa;
						}
						beta = x[i];

						//
						// solve alpha*x[i] = beta
						//
						result = cbasicsolveandupdate(alpha, beta, lnmax, nrmb, maxgrowth, ref nrmx, ref cx);
						if (!result)
						{
							return result;
						}
						x[i] = cx.x;

						//
						// update the rest of right part
						//
						if (i < n - 1)
						{
							vr = cx.x;
							for (i_ = i + 1; i_ <= n - 1; i_++)
							{
								tmp[i_] = sa * a[i, i_];
							}
							for (i_ = i + 1; i_ <= n - 1; i_++)
							{
								x[i_] = x[i_] - vr * tmp[i_];
							}
						}
					}
					return result;
				}
				if (!isupper && trans == 1)
				{

					//
					// L^T*x = b
					//
					for (i = n - 1; i >= 0; i--)
					{

						//
						// Task is reduced to alpha*x[i] = beta
						//
						if (isunit)
						{
							alpha = sa;
						}
						else
						{
							alpha = a[i, i] * sa;
						}
						beta = x[i];

						//
						// solve alpha*x[i] = beta
						//
						result = cbasicsolveandupdate(alpha, beta, lnmax, nrmb, maxgrowth, ref nrmx, ref cx);
						if (!result)
						{
							return result;
						}
						x[i] = cx.x;

						//
						// update the rest of right part
						//
						if (i > 0)
						{
							vr = cx.x;
							for (i_ = 0; i_ <= i - 1; i_++)
							{
								tmp[i_] = sa * a[i, i_];
							}
							for (i_ = 0; i_ <= i - 1; i_++)
							{
								x[i_] = x[i_] - vr * tmp[i_];
							}
						}
					}
					return result;
				}
				result = false;
				return result;
			}


			/*************************************************************************
			Internal subroutine for safe solution of

					SA*op(A)=b
            
			where  A  is  NxN  upper/lower  triangular/unitriangular  matrix, op(A) is
			either identity transform, transposition or Hermitian transposition, SA is
			a scaling factor such that max(|SA*A[i,j]|) is close to 1.0f in magnutude.

			This subroutine  limits  relative  growth  of  solution  (in inf-norm)  by
			MaxGrowth,  returning  False  if  growth  exceeds MaxGrowth. Degenerate or
			near-degenerate matrices are handled correctly (False is returned) as long
			as MaxGrowth is significantly less than MaxRealNumber/norm(b).

				-- ALGLIB routine --
					 21.01.2010
					 Bochkanov Sergey
			*************************************************************************/
			public static bool cmatrixscaledtrsafesolve(complex[,] a,
					double sa,
					int n,
					ref complex[] x,
					bool isupper,
					int trans,
					bool isunit,
					double maxgrowth)
			{
				bool result = new bool();
				double lnmax = 0;
				double nrmb = 0;
				double nrmx = 0;
				int i = 0;
				complex alpha = 0;
				complex beta = 0;
				complex vc = 0;
				complex[] tmp = new complex[0];
				int i_ = 0;

				alglib.ap.assert(n > 0, "CMatrixTRSafeSolve: incorrect N!");
				alglib.ap.assert((trans == 0 || trans == 1) || trans == 2, "CMatrixTRSafeSolve: incorrect Trans!");
				result = true;
				lnmax = (double)Math.Log(math.maxrealnumber);

				//
				// Quick return if possible
				//
				if (n <= 0)
				{
					return result;
				}

				//
				// Load norms: right part and X
				//
				nrmb = 0;
				for (i = 0; i <= n - 1; i++)
				{
					nrmb = Math.Max(nrmb, math.abscomplex(x[i]));
				}
				nrmx = 0;

				//
				// Solve
				//
				tmp = new complex[n];
				result = true;
				if (isupper && trans == 0)
				{

					//
					// U*x = b
					//
					for (i = n - 1; i >= 0; i--)
					{

						//
						// Task is reduced to alpha*x[i] = beta
						//
						if (isunit)
						{
							alpha = sa;
						}
						else
						{
							alpha = a[i, i] * sa;
						}
						if (i < n - 1)
						{
							for (i_ = i + 1; i_ <= n - 1; i_++)
							{
								tmp[i_] = sa * a[i, i_];
							}
							vc = 0.0f;
							for (i_ = i + 1; i_ <= n - 1; i_++)
							{
								vc += tmp[i_] * x[i_];
							}
							beta = x[i] - vc;
						}
						else
						{
							beta = x[i];
						}

						//
						// solve alpha*x[i] = beta
						//
						result = cbasicsolveandupdate(alpha, beta, lnmax, nrmb, maxgrowth, ref nrmx, ref vc);
						if (!result)
						{
							return result;
						}
						x[i] = vc;
					}
					return result;
				}
				if (!isupper && trans == 0)
				{

					//
					// L*x = b
					//
					for (i = 0; i <= n - 1; i++)
					{

						//
						// Task is reduced to alpha*x[i] = beta
						//
						if (isunit)
						{
							alpha = sa;
						}
						else
						{
							alpha = a[i, i] * sa;
						}
						if (i > 0)
						{
							for (i_ = 0; i_ <= i - 1; i_++)
							{
								tmp[i_] = sa * a[i, i_];
							}
							vc = 0.0f;
							for (i_ = 0; i_ <= i - 1; i_++)
							{
								vc += tmp[i_] * x[i_];
							}
							beta = x[i] - vc;
						}
						else
						{
							beta = x[i];
						}

						//
						// solve alpha*x[i] = beta
						//
						result = cbasicsolveandupdate(alpha, beta, lnmax, nrmb, maxgrowth, ref nrmx, ref vc);
						if (!result)
						{
							return result;
						}
						x[i] = vc;
					}
					return result;
				}
				if (isupper && trans == 1)
				{

					//
					// U^T*x = b
					//
					for (i = 0; i <= n - 1; i++)
					{

						//
						// Task is reduced to alpha*x[i] = beta
						//
						if (isunit)
						{
							alpha = sa;
						}
						else
						{
							alpha = a[i, i] * sa;
						}
						beta = x[i];

						//
						// solve alpha*x[i] = beta
						//
						result = cbasicsolveandupdate(alpha, beta, lnmax, nrmb, maxgrowth, ref nrmx, ref vc);
						if (!result)
						{
							return result;
						}
						x[i] = vc;

						//
						// update the rest of right part
						//
						if (i < n - 1)
						{
							for (i_ = i + 1; i_ <= n - 1; i_++)
							{
								tmp[i_] = sa * a[i, i_];
							}
							for (i_ = i + 1; i_ <= n - 1; i_++)
							{
								x[i_] = x[i_] - vc * tmp[i_];
							}
						}
					}
					return result;
				}
				if (!isupper && trans == 1)
				{

					//
					// L^T*x = b
					//
					for (i = n - 1; i >= 0; i--)
					{

						//
						// Task is reduced to alpha*x[i] = beta
						//
						if (isunit)
						{
							alpha = sa;
						}
						else
						{
							alpha = a[i, i] * sa;
						}
						beta = x[i];

						//
						// solve alpha*x[i] = beta
						//
						result = cbasicsolveandupdate(alpha, beta, lnmax, nrmb, maxgrowth, ref nrmx, ref vc);
						if (!result)
						{
							return result;
						}
						x[i] = vc;

						//
						// update the rest of right part
						//
						if (i > 0)
						{
							for (i_ = 0; i_ <= i - 1; i_++)
							{
								tmp[i_] = sa * a[i, i_];
							}
							for (i_ = 0; i_ <= i - 1; i_++)
							{
								x[i_] = x[i_] - vc * tmp[i_];
							}
						}
					}
					return result;
				}
				if (isupper && trans == 2)
				{

					//
					// U^H*x = b
					//
					for (i = 0; i <= n - 1; i++)
					{

						//
						// Task is reduced to alpha*x[i] = beta
						//
						if (isunit)
						{
							alpha = sa;
						}
						else
						{
							alpha = math.conj(a[i, i]) * sa;
						}
						beta = x[i];

						//
						// solve alpha*x[i] = beta
						//
						result = cbasicsolveandupdate(alpha, beta, lnmax, nrmb, maxgrowth, ref nrmx, ref vc);
						if (!result)
						{
							return result;
						}
						x[i] = vc;

						//
						// update the rest of right part
						//
						if (i < n - 1)
						{
							for (i_ = i + 1; i_ <= n - 1; i_++)
							{
								tmp[i_] = sa * math.conj(a[i, i_]);
							}
							for (i_ = i + 1; i_ <= n - 1; i_++)
							{
								x[i_] = x[i_] - vc * tmp[i_];
							}
						}
					}
					return result;
				}
				if (!isupper && trans == 2)
				{

					//
					// L^T*x = b
					//
					for (i = n - 1; i >= 0; i--)
					{

						//
						// Task is reduced to alpha*x[i] = beta
						//
						if (isunit)
						{
							alpha = sa;
						}
						else
						{
							alpha = math.conj(a[i, i]) * sa;
						}
						beta = x[i];

						//
						// solve alpha*x[i] = beta
						//
						result = cbasicsolveandupdate(alpha, beta, lnmax, nrmb, maxgrowth, ref nrmx, ref vc);
						if (!result)
						{
							return result;
						}
						x[i] = vc;

						//
						// update the rest of right part
						//
						if (i > 0)
						{
							for (i_ = 0; i_ <= i - 1; i_++)
							{
								tmp[i_] = sa * math.conj(a[i, i_]);
							}
							for (i_ = 0; i_ <= i - 1; i_++)
							{
								x[i_] = x[i_] - vc * tmp[i_];
							}
						}
					}
					return result;
				}
				result = false;
				return result;
			}


			/*************************************************************************
			complex basic solver-updater for reduced linear system

					alpha*x[i] = beta

			solves this equation and updates it in overlfow-safe manner (keeping track
			of relative growth of solution).

			Parameters:
					Alpha   -   alpha
					Beta    -   beta
					LnMax   -   precomputed Ln(MaxRealNumber)
					BNorm   -   inf-norm of b (right part of original system)
					MaxGrowth-  maximum growth of norm(x) relative to norm(b)
					XNorm   -   inf-norm of other components of X (which are already processed)
											it is updated by CBasicSolveAndUpdate.
					X       -   solution

				-- ALGLIB routine --
					 26.01.2009
					 Bochkanov Sergey
			*************************************************************************/
			private static bool cbasicsolveandupdate(complex alpha,
					complex beta,
					double lnmax,
					double bnorm,
					double maxgrowth,
					ref double xnorm,
					ref complex x)
			{
				bool result = new bool();
				double v = 0;

				x = 0;

				result = false;
				if (alpha == 0)
				{
					return result;
				}
				if (beta != 0)
				{

					//
					// alpha*x[i]=beta
					//
					v = (double)(Math.Log(math.abscomplex(beta)) - Math.Log(math.abscomplex(alpha)));
					if ((double)(v) > (double)(lnmax))
					{
						return result;
					}
					x = beta / alpha;
				}
				else
				{

					//
					// alpha*x[i]=0
					//
					x = 0;
				}

				//
				// update NrmX, test growth limit
				//
				xnorm = Math.Max(xnorm, math.abscomplex(x));
				if ((double)(xnorm) > (double)(maxgrowth * bnorm))
				{
					return result;
				}
				result = true;
				return result;
			}


		}
		public class hpccores
		{
			/*************************************************************************
			This structure stores  temporary  buffers  used  by  gradient  calculation
			functions for neural networks.
			*************************************************************************/
			public class mlpbuffers : apobject
			{
				public int chunksize;
				public int ntotal;
				public int nin;
				public int nout;
				public int wcount;
				public double[] batch4buf;
				public double[] hpcbuf;
				public double[,] xy;
				public double[,] xy2;
				public double[] xyrow;
				public double[] x;
				public double[] y;
				public double[] desiredy;
				public double e;
				public double[] g;
				public double[] tmp0;
				public mlpbuffers()
				{
					init();
				}
				public override void init()
				{
					batch4buf = new double[0];
					hpcbuf = new double[0];
					xy = new double[0, 0];
					xy2 = new double[0, 0];
					xyrow = new double[0];
					x = new double[0];
					y = new double[0];
					desiredy = new double[0];
					g = new double[0];
					tmp0 = new double[0];
				}
				public override alglib.apobject make_copy()
				{
					mlpbuffers _result = new mlpbuffers();
					_result.chunksize = chunksize;
					_result.ntotal = ntotal;
					_result.nin = nin;
					_result.nout = nout;
					_result.wcount = wcount;
					_result.batch4buf = (double[])batch4buf.Clone();
					_result.hpcbuf = (double[])hpcbuf.Clone();
					_result.xy = (double[,])xy.Clone();
					_result.xy2 = (double[,])xy2.Clone();
					_result.xyrow = (double[])xyrow.Clone();
					_result.x = (double[])x.Clone();
					_result.y = (double[])y.Clone();
					_result.desiredy = (double[])desiredy.Clone();
					_result.e = e;
					_result.g = (double[])g.Clone();
					_result.tmp0 = (double[])tmp0.Clone();
					return _result;
				}
			};




			/*************************************************************************
			Prepares HPC compuations  of  chunked  gradient with HPCChunkedGradient().
			You  have to call this function  before  calling  HPCChunkedGradient() for
			a new set of weights. You have to call it only once, see example below:

			HOW TO PROCESS DATASET WITH THIS FUNCTION:
					Grad:=0
					HPCPrepareChunkedGradient(Weights, WCount, NTotal, NOut, Buf)
					foreach chunk-of-dataset do
							HPCChunkedGradient(...)
					HPCFinalizeChunkedGradient(Buf, Grad)

			*************************************************************************/
			public static void hpcpreparechunkedgradient(double[] weights,
					int wcount,
					int ntotal,
					int nin,
					int nout,
					mlpbuffers buf)
			{
				int i = 0;
				int batch4size = 0;
				int chunksize = 0;

				chunksize = 4;
				batch4size = 3 * chunksize * ntotal + chunksize * (2 * nout + 1);
				if (alglib.ap.rows(buf.xy) < chunksize || alglib.ap.cols(buf.xy) < nin + nout)
				{
					buf.xy = new double[chunksize, nin + nout];
				}
				if (alglib.ap.rows(buf.xy2) < chunksize || alglib.ap.cols(buf.xy2) < nin + nout)
				{
					buf.xy2 = new double[chunksize, nin + nout];
				}
				if (alglib.ap.len(buf.xyrow) < nin + nout)
				{
					buf.xyrow = new double[nin + nout];
				}
				if (alglib.ap.len(buf.x) < nin)
				{
					buf.x = new double[nin];
				}
				if (alglib.ap.len(buf.y) < nout)
				{
					buf.y = new double[nout];
				}
				if (alglib.ap.len(buf.desiredy) < nout)
				{
					buf.desiredy = new double[nout];
				}
				if (alglib.ap.len(buf.batch4buf) < batch4size)
				{
					buf.batch4buf = new double[batch4size];
				}
				if (alglib.ap.len(buf.hpcbuf) < wcount)
				{
					buf.hpcbuf = new double[wcount];
				}
				if (alglib.ap.len(buf.g) < wcount)
				{
					buf.g = new double[wcount];
				}
				if (!hpcpreparechunkedgradientx(weights, wcount, buf.hpcbuf))
				{
					for (i = 0; i <= wcount - 1; i++)
					{
						buf.hpcbuf[i] = 0.0f;
					}
				}
				buf.wcount = wcount;
				buf.ntotal = ntotal;
				buf.nin = nin;
				buf.nout = nout;
				buf.chunksize = chunksize;
			}


			/*************************************************************************
			Finalizes HPC compuations  of  chunked gradient with HPCChunkedGradient().
			You  have to call this function  after  calling  HPCChunkedGradient()  for
			a new set of weights. You have to call it only once, see example below:

			HOW TO PROCESS DATASET WITH THIS FUNCTION:
					Grad:=0
					HPCPrepareChunkedGradient(Weights, WCount, NTotal, NOut, Buf)
					foreach chunk-of-dataset do
							HPCChunkedGradient(...)
					HPCFinalizeChunkedGradient(Buf, Grad)

			*************************************************************************/
			public static void hpcfinalizechunkedgradient(mlpbuffers buf,
					double[] grad)
			{
				int i = 0;

				if (!hpcfinalizechunkedgradientx(buf.hpcbuf, buf.wcount, grad))
				{
					for (i = 0; i <= buf.wcount - 1; i++)
					{
						grad[i] = grad[i] + buf.hpcbuf[i];
					}
				}
			}


			/*************************************************************************
			Fast kernel for chunked gradient.

			*************************************************************************/
			public static bool hpcchunkedgradient(double[] weights,
					int[] structinfo,
					double[] columnmeans,
					double[] columnsigmas,
					double[,] xy,
					int cstart,
					int csize,
					double[] batch4buf,
					double[] hpcbuf,
					ref double e,
					bool naturalerrorfunc)
			{
				bool result = new bool();

				result = false;
				return result;
			}


			/*************************************************************************
			Fast kernel for chunked processing.

			*************************************************************************/
			public static bool hpcchunkedprocess(double[] weights,
					int[] structinfo,
					double[] columnmeans,
					double[] columnsigmas,
					double[,] xy,
					int cstart,
					int csize,
					double[] batch4buf,
					double[] hpcbuf)
			{
				bool result = new bool();

				result = false;
				return result;
			}


			/*************************************************************************
			Stub function.

				-- ALGLIB routine --
					 14.06.2013
					 Bochkanov Sergey
			*************************************************************************/
			private static bool hpcpreparechunkedgradientx(double[] weights,
					int wcount,
					double[] hpcbuf)
			{
				bool result = new bool();

				result = false;
				return result;
			}


			/*************************************************************************
			Stub function.

				-- ALGLIB routine --
					 14.06.2013
					 Bochkanov Sergey
			*************************************************************************/
			private static bool hpcfinalizechunkedgradientx(double[] buf,
					int wcount,
					double[] grad)
			{
				bool result = new bool();

				result = false;
				return result;
			}


		}
		public class xblas
		{
			/*************************************************************************
			More precise dot-product. Absolute error of  subroutine  result  is  about
			1 ulp of max(MX,V), where:
					MX = max( |a[i]*b[i]| )
					V  = |(a,b)|

			INPUT PARAMETERS
					A       -   array[0..N-1], vector 1
					B       -   array[0..N-1], vector 2
					N       -   vectors length, N<2^29.
					Temp    -   array[0..N-1], pre-allocated temporary storage

			OUTPUT PARAMETERS
					R       -   (A,B)
					RErr    -   estimate of error. This estimate accounts for both  errors
											during  calculation  of  (A,B)  and  errors  introduced by
											rounding of A and B to fit in double (about 1 ulp).

				-- ALGLIB --
					 Copyright 24.08.2009 by Bochkanov Sergey
			*************************************************************************/
			public static void xdot(double[] a,
					double[] b,
					int n,
					ref double[] temp,
					ref double r,
					ref double rerr)
			{
				int i = 0;
				double mx = 0;
				double v = 0;

				r = 0;
				rerr = 0;


				//
				// special cases:
				// * N=0
				//
				if (n == 0)
				{
					r = 0;
					rerr = 0;
					return;
				}
				mx = 0;
				for (i = 0; i <= n - 1; i++)
				{
					v = a[i] * b[i];
					temp[i] = v;
					mx = Math.Max(mx, Math.Abs(v));
				}
				if ((double)(mx) == (double)(0))
				{
					r = 0;
					rerr = 0;
					return;
				}
				xsum(ref temp, mx, n, ref r, ref rerr);
			}


			/*************************************************************************
			More precise complex dot-product. Absolute error of  subroutine  result is
			about 1 ulp of max(MX,V), where:
					MX = max( |a[i]*b[i]| )
					V  = |(a,b)|

			INPUT PARAMETERS
					A       -   array[0..N-1], vector 1
					B       -   array[0..N-1], vector 2
					N       -   vectors length, N<2^29.
					Temp    -   array[0..2*N-1], pre-allocated temporary storage

			OUTPUT PARAMETERS
					R       -   (A,B)
					RErr    -   estimate of error. This estimate accounts for both  errors
											during  calculation  of  (A,B)  and  errors  introduced by
											rounding of A and B to fit in double (about 1 ulp).

				-- ALGLIB --
					 Copyright 27.01.2010 by Bochkanov Sergey
			*************************************************************************/
			public static void xcdot(complex[] a,
					complex[] b,
					int n,
					ref double[] temp,
					ref complex r,
					ref double rerr)
			{
				int i = 0;
				double mx = 0;
				double v = 0;
				double rerrx = 0;
				double rerry = 0;

				r = 0;
				rerr = 0;


				//
				// special cases:
				// * N=0
				//
				if (n == 0)
				{
					r = 0;
					rerr = 0;
					return;
				}

				//
				// calculate real part
				//
				mx = 0;
				for (i = 0; i <= n - 1; i++)
				{
					v = a[i].x * b[i].x;
					temp[2 * i + 0] = v;
					mx = Math.Max(mx, Math.Abs(v));
					v = -(a[i].y * b[i].y);
					temp[2 * i + 1] = v;
					mx = Math.Max(mx, Math.Abs(v));
				}
				if ((double)(mx) == (double)(0))
				{
					r.x = 0;
					rerrx = 0;
				}
				else
				{
					xsum(ref temp, mx, 2 * n, ref r.x, ref rerrx);
				}

				//
				// calculate imaginary part
				//
				mx = 0;
				for (i = 0; i <= n - 1; i++)
				{
					v = a[i].x * b[i].y;
					temp[2 * i + 0] = v;
					mx = Math.Max(mx, Math.Abs(v));
					v = a[i].y * b[i].x;
					temp[2 * i + 1] = v;
					mx = Math.Max(mx, Math.Abs(v));
				}
				if ((double)(mx) == (double)(0))
				{
					r.y = 0;
					rerry = 0;
				}
				else
				{
					xsum(ref temp, mx, 2 * n, ref r.y, ref rerry);
				}

				//
				// total error
				//
				if ((double)(rerrx) == (double)(0) && (double)(rerry) == (double)(0))
				{
					rerr = 0;
				}
				else
				{
					rerr =(double)( Math.Max(rerrx, rerry) * Math.Sqrt(1 + math.sqr(Math.Min(rerrx, rerry) / Math.Max(rerrx, rerry))));
				}
			}


			/*************************************************************************
			Internal subroutine for extra-precise calculation of SUM(w[i]).

			INPUT PARAMETERS:
					W   -   array[0..N-1], values to be added
									W is modified during calculations.
					MX  -   max(W[i])
					N   -   array size
            
			OUTPUT PARAMETERS:
					R   -   SUM(w[i])
					RErr-   error estimate for R

				-- ALGLIB --
					 Copyright 24.08.2009 by Bochkanov Sergey
			*************************************************************************/
			private static void xsum(ref double[] w,
					double mx,
					int n,
					ref double r,
					ref double rerr)
			{
				int i = 0;
				int k = 0;
				int ks = 0;
				double v = 0;
				double s = 0;
				double ln2 = 0;
				double chunk = 0;
				double invchunk = 0;
				bool allzeros = new bool();
				int i_ = 0;

				r = 0;
				rerr = 0;


				//
				// special cases:
				// * N=0
				// * N is too large to use integer arithmetics
				//
				if (n == 0)
				{
					r = 0;
					rerr = 0;
					return;
				}
				if ((double)(mx) == (double)(0))
				{
					r = 0;
					rerr = 0;
					return;
				}
				alglib.ap.assert(n < 536870912, "XDot: N is too large!");

				//
				// Prepare
				//
				ln2 = (double)Math.Log(2);
				rerr = mx * math.machineepsilon;

				//
				// 1. find S such that 0.5f<=S*MX<1
				// 2. multiply W by S, so task is normalized in some sense
				// 3. S:=1/S so we can obtain original vector multiplying by S
				//
				k = (int)Math.Round(Math.Log(mx) / ln2);
				s = xfastpow(2, -k);
				while ((double)(s * mx) >= (double)(1))
				{
					s = 0.5f * s;
				}
				while ((double)(s * mx) < (double)(0.5f))
				{
					s = 2 * s;
				}
				for (i_ = 0; i_ <= n - 1; i_++)
				{
					w[i_] = s * w[i_];
				}
				s = 1 / s;

				//
				// find Chunk=2^M such that N*Chunk<2^29
				//
				// we have chosen upper limit (2^29) with enough space left
				// to tolerate possible problems with rounding and N's close
				// to the limit, so we don't want to be very strict here.
				//
				k = (int)(Math.Log((double)536870912 / (double)n) / ln2);
				chunk = xfastpow(2, k);
				if ((double)(chunk) < (double)(2))
				{
					chunk = 2;
				}
				invchunk = 1 / chunk;

				//
				// calculate result
				//
				r = 0;
				for (i_ = 0; i_ <= n - 1; i_++)
				{
					w[i_] = chunk * w[i_];
				}
				while (true)
				{
					s = s * invchunk;
					allzeros = true;
					ks = 0;
					for (i = 0; i <= n - 1; i++)
					{
						v = w[i];
						k = (int)(v);
						if ((double)(v) != (double)(k))
						{
							allzeros = false;
						}
						w[i] = chunk * (v - k);
						ks = ks + k;
					}
					r = r + s * ks;
					v = Math.Abs(r);
					if (allzeros || (double)(s * n + mx) == (double)(mx))
					{
						break;
					}
				}

				//
				// correct error
				//
				rerr = Math.Max(rerr, Math.Abs(r) * math.machineepsilon);
			}


			/*************************************************************************
			Fast Pow

				-- ALGLIB --
					 Copyright 24.08.2009 by Bochkanov Sergey
			*************************************************************************/
			private static double xfastpow(double r,
					int n)
			{
				double result = 0;

				result = 0;
				if (n > 0)
				{
					if (n % 2 == 0)
					{
						result = math.sqr(xfastpow(r, n / 2));
					}
					else
					{
						result = r * xfastpow(r, n - 1);
					}
					return result;
				}
				if (n == 0)
				{
					result = 1;
				}
				if (n < 0)
				{
					result = xfastpow(1 / r, -n);
				}
				return result;
			}


		}
		public class linmin
		{
			public class linminstate : apobject
			{
				public bool brackt;
				public bool stage1;
				public int infoc;
				public double dg;
				public double dgm;
				public double dginit;
				public double dgtest;
				public double dgx;
				public double dgxm;
				public double dgy;
				public double dgym;
				public double finit;
				public double ftest1;
				public double fm;
				public double fx;
				public double fxm;
				public double fy;
				public double fym;
				public double stx;
				public double sty;
				public double stmin;
				public double stmax;
				public double width;
				public double width1;
				public double xtrapf;
				public linminstate()
				{
					init();
				}
				public override void init()
				{
				}
				public override alglib.apobject make_copy()
				{
					linminstate _result = new linminstate();
					_result.brackt = brackt;
					_result.stage1 = stage1;
					_result.infoc = infoc;
					_result.dg = dg;
					_result.dgm = dgm;
					_result.dginit = dginit;
					_result.dgtest = dgtest;
					_result.dgx = dgx;
					_result.dgxm = dgxm;
					_result.dgy = dgy;
					_result.dgym = dgym;
					_result.finit = finit;
					_result.ftest1 = ftest1;
					_result.fm = fm;
					_result.fx = fx;
					_result.fxm = fxm;
					_result.fy = fy;
					_result.fym = fym;
					_result.stx = stx;
					_result.sty = sty;
					_result.stmin = stmin;
					_result.stmax = stmax;
					_result.width = width;
					_result.width1 = width1;
					_result.xtrapf = xtrapf;
					return _result;
				}
			};


			public class armijostate : apobject
			{
				public bool needf;
				public double[] x;
				public double f;
				public int n;
				public double[] xbase;
				public double[] s;
				public double stplen;
				public double fcur;
				public double stpmax;
				public int fmax;
				public int nfev;
				public int info;
				public rcommstate rstate;
				public armijostate()
				{
					init();
				}
				public override void init()
				{
					x = new double[0];
					xbase = new double[0];
					s = new double[0];
					rstate = new rcommstate();
				}
				public override alglib.apobject make_copy()
				{
					armijostate _result = new armijostate();
					_result.needf = needf;
					_result.x = (double[])x.Clone();
					_result.f = f;
					_result.n = n;
					_result.xbase = (double[])xbase.Clone();
					_result.s = (double[])s.Clone();
					_result.stplen = stplen;
					_result.fcur = fcur;
					_result.stpmax = stpmax;
					_result.fmax = fmax;
					_result.nfev = nfev;
					_result.info = info;
					_result.rstate = (rcommstate)rstate.make_copy();
					return _result;
				}
			};




			public const double ftol = (double)(0.001);
			public const double xtol = (double)(100 * math.machineepsilon);
			public const int maxfev = 20;
			public const double stpmin = (double)(1.0E-50);
			public const double defstpmax = (double)(1.0E+50);
			public const double armijofactor = 1.3f;


			/*************************************************************************
			Normalizes direction/step pair: makes |D|=1, scales Stp.
			If |D|=0, it returns, leavind D/Stp unchanged.

				-- ALGLIB --
					 Copyright 01.04.2010 by Bochkanov Sergey
			*************************************************************************/
			public static void linminnormalized(ref double[] d,
					ref double stp,
					int n)
			{
				double mx = 0;
				double s = 0;
				int i = 0;
				int i_ = 0;


				//
				// first, scale D to avoid underflow/overflow durng squaring
				//
				mx = 0;
				for (i = 0; i <= n - 1; i++)
				{
					mx = Math.Max(mx, Math.Abs(d[i]));
				}
				if ((double)(mx) == (double)(0))
				{
					return;
				}
				s = 1 / mx;
				for (i_ = 0; i_ <= n - 1; i_++)
				{
					d[i_] = s * d[i_];
				}
				stp = stp / s;

				//
				// normalize D
				//
				s = 0.0f;
				for (i_ = 0; i_ <= n - 1; i_++)
				{
					s += d[i_] * d[i_];
				}
				s = (double)(1 / Math.Sqrt(s));
				for (i_ = 0; i_ <= n - 1; i_++)
				{
					d[i_] = s * d[i_];
				}
				stp = stp / s;
			}


			/*************************************************************************
			THE  PURPOSE  OF  MCSRCH  IS  TO  FIND A STEP WHICH SATISFIES A SUFFICIENT
			DECREASE CONDITION AND A CURVATURE CONDITION.

			AT EACH STAGE THE SUBROUTINE  UPDATES  AN  INTERVAL  OF  UNCERTAINTY  WITH
			ENDPOINTS  STX  AND  STY.  THE INTERVAL OF UNCERTAINTY IS INITIALLY CHOSEN
			SO THAT IT CONTAINS A MINIMIZER OF THE MODIFIED FUNCTION

					F(X+STP*S) - F(X) - FTOL*STP*(GRADF(X)'S).

			IF  A STEP  IS OBTAINED FOR  WHICH THE MODIFIED FUNCTION HAS A NONPOSITIVE
			FUNCTION  VALUE  AND  NONNEGATIVE  DERIVATIVE,   THEN   THE   INTERVAL  OF
			UNCERTAINTY IS CHOSEN SO THAT IT CONTAINS A MINIMIZER OF F(X+STP*S).

			THE  ALGORITHM  IS  DESIGNED TO FIND A STEP WHICH SATISFIES THE SUFFICIENT
			DECREASE CONDITION

					F(X+STP*S) .LE. F(X) + FTOL*STP*(GRADF(X)'S),

			AND THE CURVATURE CONDITION

					ABS(GRADF(X+STP*S)'S)) .LE. GTOL*ABS(GRADF(X)'S).

			IF  FTOL  IS  LESS  THAN GTOL AND IF, FOR EXAMPLE, THE FUNCTION IS BOUNDED
			BELOW,  THEN  THERE  IS  ALWAYS  A  STEP  WHICH SATISFIES BOTH CONDITIONS.
			IF  NO  STEP  CAN BE FOUND  WHICH  SATISFIES  BOTH  CONDITIONS,  THEN  THE
			ALGORITHM  USUALLY STOPS  WHEN  ROUNDING ERRORS  PREVENT FURTHER PROGRESS.
			IN THIS CASE STP ONLY SATISFIES THE SUFFICIENT DECREASE CONDITION.


			:::::::::::::IMPORTANT NOTES:::::::::::::

			NOTE 1:

			This routine  guarantees that it will stop at the last point where function
			value was calculated. It won't make several additional function evaluations
			after finding good point. So if you store function evaluations requested by
			this routine, you can be sure that last one is the point where we've stopped.

			NOTE 2:

			when 0<StpMax<StpMin, algorithm will terminate with INFO=5 and Stp=StpMax
			:::::::::::::::::::::::::::::::::::::::::


			PARAMETERS DESCRIPRION

			STAGE IS ZERO ON FIRST CALL, ZERO ON FINAL EXIT

			N IS A POSITIVE INTEGER INPUT VARIABLE SET TO THE NUMBER OF VARIABLES.

			X IS  AN  ARRAY  OF  LENGTH N. ON INPUT IT MUST CONTAIN THE BASE POINT FOR
			THE LINE SEARCH. ON OUTPUT IT CONTAINS X+STP*S.

			F IS  A  VARIABLE. ON INPUT IT MUST CONTAIN THE VALUE OF F AT X. ON OUTPUT
			IT CONTAINS THE VALUE OF F AT X + STP*S.

			G IS AN ARRAY OF LENGTH N. ON INPUT IT MUST CONTAIN THE GRADIENT OF F AT X.
			ON OUTPUT IT CONTAINS THE GRADIENT OF F AT X + STP*S.

			S IS AN INPUT ARRAY OF LENGTH N WHICH SPECIFIES THE SEARCH DIRECTION.

			STP  IS  A NONNEGATIVE VARIABLE. ON INPUT STP CONTAINS AN INITIAL ESTIMATE
			OF A SATISFACTORY STEP. ON OUTPUT STP CONTAINS THE FINAL ESTIMATE.

			FTOL AND GTOL ARE NONNEGATIVE INPUT VARIABLES. TERMINATION OCCURS WHEN THE
			SUFFICIENT DECREASE CONDITION AND THE DIRECTIONAL DERIVATIVE CONDITION ARE
			SATISFIED.

			XTOL IS A NONNEGATIVE INPUT VARIABLE. TERMINATION OCCURS WHEN THE RELATIVE
			WIDTH OF THE INTERVAL OF UNCERTAINTY IS AT MOST XTOL.

			STPMIN AND STPMAX ARE NONNEGATIVE INPUT VARIABLES WHICH SPECIFY LOWER  AND
			UPPER BOUNDS FOR THE STEP.

			MAXFEV IS A POSITIVE INTEGER INPUT VARIABLE. TERMINATION OCCURS WHEN THE
			NUMBER OF CALLS TO FCN IS AT LEAST MAXFEV BY THE END OF AN ITERATION.

			INFO IS AN INTEGER OUTPUT VARIABLE SET AS FOLLOWS:
					INFO = 0  IMPROPER INPUT PARAMETERS.

					INFO = 1  THE SUFFICIENT DECREASE CONDITION AND THE
										DIRECTIONAL DERIVATIVE CONDITION HOLD.

					INFO = 2  RELATIVE WIDTH OF THE INTERVAL OF UNCERTAINTY
										IS AT MOST XTOL.

					INFO = 3  NUMBER OF CALLS TO FCN HAS REACHED MAXFEV.

					INFO = 4  THE STEP IS AT THE LOWER BOUND STPMIN.

					INFO = 5  THE STEP IS AT THE UPPER BOUND STPMAX.

					INFO = 6  ROUNDING ERRORS PREVENT FURTHER PROGRESS.
										THERE MAY NOT BE A STEP WHICH SATISFIES THE
										SUFFICIENT DECREASE AND CURVATURE CONDITIONS.
										TOLERANCES MAY BE TOO SMALL.

			NFEV IS AN INTEGER OUTPUT VARIABLE SET TO THE NUMBER OF CALLS TO FCN.

			WA IS A WORK ARRAY OF LENGTH N.

			ARGONNE NATIONAL LABORATORY. MINPACK PROJECT. JUNE 1983
			JORGE J. MORE', DAVID J. THUENTE
			*************************************************************************/
			public static void mcsrch(int n,
					ref double[] x,
					ref double f,
					ref double[] g,
					double[] s,
					ref double stp,
					double stpmax,
					double gtol,
					ref int info,
					ref int nfev,
					ref double[] wa,
					linminstate state,
					ref int stage)
			{
				double v = 0;
				double p5 = 0;
				double p66 = 0;
				double zero = 0;
				int i_ = 0;


				//
				// init
				//
				p5 = 0.5f;
				p66 = 0.66f;
				state.xtrapf = 4.0f;
				zero = 0;
				if ((double)(stpmax) == (double)(0))
				{
					stpmax = defstpmax;
				}
				if ((double)(stp) < (double)(stpmin))
				{
					stp = stpmin;
				}
				if ((double)(stp) > (double)(stpmax))
				{
					stp = stpmax;
				}

				//
				// Main cycle
				//
				while (true)
				{
					if (stage == 0)
					{

						//
						// NEXT
						//
						stage = 2;
						continue;
					}
					if (stage == 2)
					{
						state.infoc = 1;
						info = 0;

						//
						//     CHECK THE INPUT PARAMETERS FOR ERRORS.
						//
						if ((double)(stpmax) < (double)(stpmin) && (double)(stpmax) > (double)(0))
						{
							info = 5;
							stp = stpmax;
							stage = 0;
							return;
						}
						if (((((((n <= 0 || (double)(stp) <= (double)(0)) || (double)(ftol) < (double)(0)) || (double)(gtol) < (double)(zero)) || (double)(xtol) < (double)(zero)) || (double)(stpmin) < (double)(zero)) || (double)(stpmax) < (double)(stpmin)) || maxfev <= 0)
						{
							stage = 0;
							return;
						}

						//
						//     COMPUTE THE INITIAL GRADIENT IN THE SEARCH DIRECTION
						//     AND CHECK THAT S IS A DESCENT DIRECTION.
						//
						v = 0.0f;
						for (i_ = 0; i_ <= n - 1; i_++)
						{
							v += g[i_] * s[i_];
						}
						state.dginit = v;
						if ((double)(state.dginit) >= (double)(0))
						{
							stage = 0;
							return;
						}

						//
						//     INITIALIZE LOCAL VARIABLES.
						//
						state.brackt = false;
						state.stage1 = true;
						nfev = 0;
						state.finit = f;
						state.dgtest = ftol * state.dginit;
						state.width = stpmax - stpmin;
						state.width1 = state.width / p5;
						for (i_ = 0; i_ <= n - 1; i_++)
						{
							wa[i_] = x[i_];
						}

						//
						//     THE VARIABLES STX, FX, DGX CONTAIN THE VALUES OF THE STEP,
						//     FUNCTION, AND DIRECTIONAL DERIVATIVE AT THE BEST STEP.
						//     THE VARIABLES STY, FY, DGY CONTAIN THE VALUE OF THE STEP,
						//     FUNCTION, AND DERIVATIVE AT THE OTHER ENDPOINT OF
						//     THE INTERVAL OF UNCERTAINTY.
						//     THE VARIABLES STP, F, DG CONTAIN THE VALUES OF THE STEP,
						//     FUNCTION, AND DERIVATIVE AT THE CURRENT STEP.
						//
						state.stx = 0;
						state.fx = state.finit;
						state.dgx = state.dginit;
						state.sty = 0;
						state.fy = state.finit;
						state.dgy = state.dginit;

						//
						// NEXT
						//
						stage = 3;
						continue;
					}
					if (stage == 3)
					{

						//
						//     START OF ITERATION.
						//
						//     SET THE MINIMUM AND MAXIMUM STEPS TO CORRESPOND
						//     TO THE PRESENT INTERVAL OF UNCERTAINTY.
						//
						if (state.brackt)
						{
							if ((double)(state.stx) < (double)(state.sty))
							{
								state.stmin = state.stx;
								state.stmax = state.sty;
							}
							else
							{
								state.stmin = state.sty;
								state.stmax = state.stx;
							}
						}
						else
						{
							state.stmin = state.stx;
							state.stmax = stp + state.xtrapf * (stp - state.stx);
						}

						//
						//        FORCE THE STEP TO BE WITHIN THE BOUNDS STPMAX AND STPMIN.
						//
						if ((double)(stp) > (double)(stpmax))
						{
							stp = stpmax;
						}
						if ((double)(stp) < (double)(stpmin))
						{
							stp = stpmin;
						}

						//
						//        IF AN UNUSUAL TERMINATION IS TO OCCUR THEN LET
						//        STP BE THE LOWEST POINT OBTAINED SO FAR.
						//
						if ((((state.brackt && ((double)(stp) <= (double)(state.stmin) || (double)(stp) >= (double)(state.stmax))) || nfev >= maxfev - 1) || state.infoc == 0) || (state.brackt && (double)(state.stmax - state.stmin) <= (double)(xtol * state.stmax)))
						{
							stp = state.stx;
						}

						//
						//        EVALUATE THE FUNCTION AND GRADIENT AT STP
						//        AND COMPUTE THE DIRECTIONAL DERIVATIVE.
						//
						for (i_ = 0; i_ <= n - 1; i_++)
						{
							x[i_] = wa[i_];
						}
						for (i_ = 0; i_ <= n - 1; i_++)
						{
							x[i_] = x[i_] + stp * s[i_];
						}

						//
						// NEXT
						//
						stage = 4;
						return;
					}
					if (stage == 4)
					{
						info = 0;
						nfev = nfev + 1;
						v = 0.0f;
						for (i_ = 0; i_ <= n - 1; i_++)
						{
							v += g[i_] * s[i_];
						}
						state.dg = v;
						state.ftest1 = state.finit + stp * state.dgtest;

						//
						//        TEST FOR CONVERGENCE.
						//
						if ((state.brackt && ((double)(stp) <= (double)(state.stmin) || (double)(stp) >= (double)(state.stmax))) || state.infoc == 0)
						{
							info = 6;
						}
						if (((double)(stp) == (double)(stpmax) && (double)(f) <= (double)(state.ftest1)) && (double)(state.dg) <= (double)(state.dgtest))
						{
							info = 5;
						}
						if ((double)(stp) == (double)(stpmin) && ((double)(f) > (double)(state.ftest1) || (double)(state.dg) >= (double)(state.dgtest)))
						{
							info = 4;
						}
						if (nfev >= maxfev)
						{
							info = 3;
						}
						if (state.brackt && (double)(state.stmax - state.stmin) <= (double)(xtol * state.stmax))
						{
							info = 2;
						}
						if ((double)(f) <= (double)(state.ftest1) && (double)(Math.Abs(state.dg)) <= (double)(-(gtol * state.dginit)))
						{
							info = 1;
						}

						//
						//        CHECK FOR TERMINATION.
						//
						if (info != 0)
						{
							stage = 0;
							return;
						}

						//
						//        IN THE FIRST STAGE WE SEEK A STEP FOR WHICH THE MODIFIED
						//        FUNCTION HAS A NONPOSITIVE VALUE AND NONNEGATIVE DERIVATIVE.
						//
						if ((state.stage1 && (double)(f) <= (double)(state.ftest1)) && (double)(state.dg) >= (double)(Math.Min(ftol, gtol) * state.dginit))
						{
							state.stage1 = false;
						}

						//
						//        A MODIFIED FUNCTION IS USED TO PREDICT THE STEP ONLY IF
						//        WE HAVE NOT OBTAINED A STEP FOR WHICH THE MODIFIED
						//        FUNCTION HAS A NONPOSITIVE FUNCTION VALUE AND NONNEGATIVE
						//        DERIVATIVE, AND IF A LOWER FUNCTION VALUE HAS BEEN
						//        OBTAINED BUT THE DECREASE IS NOT SUFFICIENT.
						//
						if ((state.stage1 && (double)(f) <= (double)(state.fx)) && (double)(f) > (double)(state.ftest1))
						{

							//
							//           DEFINE THE MODIFIED FUNCTION AND DERIVATIVE VALUES.
							//
							state.fm = f - stp * state.dgtest;
							state.fxm = state.fx - state.stx * state.dgtest;
							state.fym = state.fy - state.sty * state.dgtest;
							state.dgm = state.dg - state.dgtest;
							state.dgxm = state.dgx - state.dgtest;
							state.dgym = state.dgy - state.dgtest;

							//
							//           CALL CSTEP TO UPDATE THE INTERVAL OF UNCERTAINTY
							//           AND TO COMPUTE THE NEW STEP.
							//
							mcstep(ref state.stx, ref state.fxm, ref state.dgxm, ref state.sty, ref state.fym, ref state.dgym, ref stp, state.fm, state.dgm, ref state.brackt, state.stmin, state.stmax, ref state.infoc);

							//
							//           RESET THE FUNCTION AND GRADIENT VALUES FOR F.
							//
							state.fx = state.fxm + state.stx * state.dgtest;
							state.fy = state.fym + state.sty * state.dgtest;
							state.dgx = state.dgxm + state.dgtest;
							state.dgy = state.dgym + state.dgtest;
						}
						else
						{

							//
							//           CALL MCSTEP TO UPDATE THE INTERVAL OF UNCERTAINTY
							//           AND TO COMPUTE THE NEW STEP.
							//
							mcstep(ref state.stx, ref state.fx, ref state.dgx, ref state.sty, ref state.fy, ref state.dgy, ref stp, f, state.dg, ref state.brackt, state.stmin, state.stmax, ref state.infoc);
						}

						//
						//        FORCE A SUFFICIENT DECREASE IN THE SIZE OF THE
						//        INTERVAL OF UNCERTAINTY.
						//
						if (state.brackt)
						{
							if ((double)(Math.Abs(state.sty - state.stx)) >= (double)(p66 * state.width1))
							{
								stp = state.stx + p5 * (state.sty - state.stx);
							}
							state.width1 = state.width;
							state.width = Math.Abs(state.sty - state.stx);
						}

						//
						//  NEXT.
						//
						stage = 3;
						continue;
					}
				}
			}


			/*************************************************************************
			These functions perform Armijo line search using  at  most  FMAX  function
			evaluations.  It  doesn't  enforce  some  kind  of  " sufficient decrease"
			criterion - it just tries different Armijo steps and returns optimum found
			so far.

			Optimization is done using F-rcomm interface:
			* ArmijoCreate initializes State structure
				(reusing previously allocated buffers)
			* ArmijoIteration is subsequently called
			* ArmijoResults returns results

			INPUT PARAMETERS:
					N       -   problem size
					X       -   array[N], starting point
					F       -   F(X+S*STP)
					S       -   step direction, S>0
					STP     -   step length
					STPMAX  -   maximum value for STP or zero (if no limit is imposed)
					FMAX    -   maximum number of function evaluations
					State   -   optimization state

				-- ALGLIB --
					 Copyright 05.10.2010 by Bochkanov Sergey
			*************************************************************************/
			public static void armijocreate(int n,
					double[] x,
					double f,
					double[] s,
					double stp,
					double stpmax,
					int fmax,
					armijostate state)
			{
				int i_ = 0;

				if (alglib.ap.len(state.x) < n)
				{
					state.x = new double[n];
				}
				if (alglib.ap.len(state.xbase) < n)
				{
					state.xbase = new double[n];
				}
				if (alglib.ap.len(state.s) < n)
				{
					state.s = new double[n];
				}
				state.stpmax = stpmax;
				state.fmax = fmax;
				state.stplen = stp;
				state.fcur = f;
				state.n = n;
				for (i_ = 0; i_ <= n - 1; i_++)
				{
					state.xbase[i_] = x[i_];
				}
				for (i_ = 0; i_ <= n - 1; i_++)
				{
					state.s[i_] = s[i_];
				}
				state.rstate.ia = new int[0 + 1];
				state.rstate.ra = new double[0 + 1];
				state.rstate.stage = -1;
			}


			/*************************************************************************
			This is rcomm-based search function

				-- ALGLIB --
					 Copyright 05.10.2010 by Bochkanov Sergey
			*************************************************************************/
			public static bool armijoiteration(armijostate state)
			{
				bool result = new bool();
				double v = 0;
				int n = 0;
				int i_ = 0;


				//
				// Reverse communication preparations
				// I know it looks ugly, but it works the same way
				// anywhere from C++ to Python.
				//
				// This code initializes locals by:
				// * random values determined during code
				//   generation - on first subroutine call
				// * values from previous call - on subsequent calls
				//
				if (state.rstate.stage >= 0)
				{
					n = state.rstate.ia[0];
					v = state.rstate.ra[0];
				}
				else
				{
					n = -983;
					v = -989;
				}
				if (state.rstate.stage == 0)
				{
					goto lbl_0;
				}
				if (state.rstate.stage == 1)
				{
					goto lbl_1;
				}
				if (state.rstate.stage == 2)
				{
					goto lbl_2;
				}
				if (state.rstate.stage == 3)
				{
					goto lbl_3;
				}

				//
				// Routine body
				//
				if (((double)(state.stplen) <= (double)(0) || (double)(state.stpmax) < (double)(0)) || state.fmax < 2)
				{
					state.info = 0;
					result = false;
					return result;
				}
				if ((double)(state.stplen) <= (double)(stpmin))
				{
					state.info = 4;
					result = false;
					return result;
				}
				n = state.n;
				state.nfev = 0;

				//
				// We always need F
				//
				state.needf = true;

				//
				// Bound StpLen
				//
				if ((double)(state.stplen) > (double)(state.stpmax) && (double)(state.stpmax) != (double)(0))
				{
					state.stplen = state.stpmax;
				}

				//
				// Increase length
				//
				v = state.stplen * armijofactor;
				if ((double)(v) > (double)(state.stpmax) && (double)(state.stpmax) != (double)(0))
				{
					v = state.stpmax;
				}
				for (i_ = 0; i_ <= n - 1; i_++)
				{
					state.x[i_] = state.xbase[i_];
				}
				for (i_ = 0; i_ <= n - 1; i_++)
				{
					state.x[i_] = state.x[i_] + v * state.s[i_];
				}
				state.rstate.stage = 0;
				goto lbl_rcomm;
			lbl_0:
				state.nfev = state.nfev + 1;
				if ((double)(state.f) >= (double)(state.fcur))
				{
					goto lbl_4;
				}
				state.stplen = v;
				state.fcur = state.f;
			lbl_6:
				if (false)
				{
					goto lbl_7;
				}

				//
				// test stopping conditions
				//
				if (state.nfev >= state.fmax)
				{
					state.info = 3;
					result = false;
					return result;
				}
				if ((double)(state.stplen) >= (double)(state.stpmax))
				{
					state.info = 5;
					result = false;
					return result;
				}

				//
				// evaluate F
				//
				v = state.stplen * armijofactor;
				if ((double)(v) > (double)(state.stpmax) && (double)(state.stpmax) != (double)(0))
				{
					v = state.stpmax;
				}
				for (i_ = 0; i_ <= n - 1; i_++)
				{
					state.x[i_] = state.xbase[i_];
				}
				for (i_ = 0; i_ <= n - 1; i_++)
				{
					state.x[i_] = state.x[i_] + v * state.s[i_];
				}
				state.rstate.stage = 1;
				goto lbl_rcomm;
			lbl_1:
				state.nfev = state.nfev + 1;

				//
				// make decision
				//
				if ((double)(state.f) < (double)(state.fcur))
				{
					state.stplen = v;
					state.fcur = state.f;
				}
				else
				{
					state.info = 1;
					result = false;
					return result;
				}
				goto lbl_6;
			lbl_7:
			lbl_4:

				//
				// Decrease length
				//
				v = state.stplen / armijofactor;
				for (i_ = 0; i_ <= n - 1; i_++)
				{
					state.x[i_] = state.xbase[i_];
				}
				for (i_ = 0; i_ <= n - 1; i_++)
				{
					state.x[i_] = state.x[i_] + v * state.s[i_];
				}
				state.rstate.stage = 2;
				goto lbl_rcomm;
			lbl_2:
				state.nfev = state.nfev + 1;
				if ((double)(state.f) >= (double)(state.fcur))
				{
					goto lbl_8;
				}
				state.stplen = state.stplen / armijofactor;
				state.fcur = state.f;
			lbl_10:
				if (false)
				{
					goto lbl_11;
				}

				//
				// test stopping conditions
				//
				if (state.nfev >= state.fmax)
				{
					state.info = 3;
					result = false;
					return result;
				}
				if ((double)(state.stplen) <= (double)(stpmin))
				{
					state.info = 4;
					result = false;
					return result;
				}

				//
				// evaluate F
				//
				v = state.stplen / armijofactor;
				for (i_ = 0; i_ <= n - 1; i_++)
				{
					state.x[i_] = state.xbase[i_];
				}
				for (i_ = 0; i_ <= n - 1; i_++)
				{
					state.x[i_] = state.x[i_] + v * state.s[i_];
				}
				state.rstate.stage = 3;
				goto lbl_rcomm;
			lbl_3:
				state.nfev = state.nfev + 1;

				//
				// make decision
				//
				if ((double)(state.f) < (double)(state.fcur))
				{
					state.stplen = state.stplen / armijofactor;
					state.fcur = state.f;
				}
				else
				{
					state.info = 1;
					result = false;
					return result;
				}
				goto lbl_10;
			lbl_11:
			lbl_8:

				//
				// Nothing to be done
				//
				state.info = 1;
				result = false;
				return result;

					//
			// Saving state
			//
			lbl_rcomm:
				result = true;
				state.rstate.ia[0] = n;
				state.rstate.ra[0] = v;
				return result;
			}


			/*************************************************************************
			Results of Armijo search

			OUTPUT PARAMETERS:
					INFO    -   on output it is set to one of the return codes:
											* 0     improper input params
											* 1     optimum step is found with at most FMAX evaluations
											* 3     FMAX evaluations were used,
															X contains optimum found so far
											* 4     step is at lower bound STPMIN
											* 5     step is at upper bound
					STP     -   step length (in case of failure it is still returned)
					F       -   function value (in case of failure it is still returned)

				-- ALGLIB --
					 Copyright 05.10.2010 by Bochkanov Sergey
			*************************************************************************/
			public static void armijoresults(armijostate state,
					ref int info,
					ref double stp,
					ref double f)
			{
				info = state.info;
				stp = state.stplen;
				f = state.fcur;
			}


			private static void mcstep(ref double stx,
					ref double fx,
					ref double dx,
					ref double sty,
					ref double fy,
					ref double dy,
					ref double stp,
					double fp,
					double dp,
					ref bool brackt,
					double stmin,
					double stmax,
					ref int info)
			{
				bool bound = new bool();
				double gamma = 0;
				double p = 0;
				double q = 0;
				double r = 0;
				double s = 0;
				double sgnd = 0;
				double stpc = 0;
				double stpf = 0;
				double stpq = 0;
				double theta = 0;

				info = 0;

				//
				//     CHECK THE INPUT PARAMETERS FOR ERRORS.
				//
				if (((brackt && ((double)(stp) <= (double)(Math.Min(stx, sty)) || (double)(stp) >= (double)(Math.Max(stx, sty)))) || (double)(dx * (stp - stx)) >= (double)(0)) || (double)(stmax) < (double)(stmin))
				{
					return;
				}

				//
				//     DETERMINE IF THE DERIVATIVES HAVE OPPOSITE SIGN.
				//
				sgnd = dp * (dx / Math.Abs(dx));

				//
				//     FIRST CASE. A HIGHER FUNCTION VALUE.
				//     THE MINIMUM IS BRACKETED. IF THE CUBIC STEP IS CLOSER
				//     TO STX THAN THE QUADRATIC STEP, THE CUBIC STEP IS TAKEN,
				//     ELSE THE AVERAGE OF THE CUBIC AND QUADRATIC STEPS IS TAKEN.
				//
				if ((double)(fp) > (double)(fx))
				{
					info = 1;
					bound = true;
					theta = 3 * (fx - fp) / (stp - stx) + dx + dp;
					s = Math.Max(Math.Abs(theta), Math.Max(Math.Abs(dx), Math.Abs(dp)));
					gamma = (double)(s * Math.Sqrt(math.sqr(theta / s) - dx / s * (dp / s)));
					if ((double)(stp) < (double)(stx))
					{
						gamma = -gamma;
					}
					p = gamma - dx + theta;
					q = gamma - dx + gamma + dp;
					r = p / q;
					stpc = stx + r * (stp - stx);
					stpq = stx + dx / ((fx - fp) / (stp - stx) + dx) / 2 * (stp - stx);
					if ((double)(Math.Abs(stpc - stx)) < (double)(Math.Abs(stpq - stx)))
					{
						stpf = stpc;
					}
					else
					{
						stpf = stpc + (stpq - stpc) / 2;
					}
					brackt = true;
				}
				else
				{
					if ((double)(sgnd) < (double)(0))
					{

						//
						//     SECOND CASE. A LOWER FUNCTION VALUE AND DERIVATIVES OF
						//     OPPOSITE SIGN. THE MINIMUM IS BRACKETED. IF THE CUBIC
						//     STEP IS CLOSER TO STX THAN THE QUADRATIC (SECANT) STEP,
						//     THE CUBIC STEP IS TAKEN, ELSE THE QUADRATIC STEP IS TAKEN.
						//
						info = 2;
						bound = false;
						theta = 3 * (fx - fp) / (stp - stx) + dx + dp;
						s = Math.Max(Math.Abs(theta), Math.Max(Math.Abs(dx), Math.Abs(dp)));
						gamma = (double)(s * Math.Sqrt(math.sqr(theta / s) - dx / s * (dp / s)));
						if ((double)(stp) > (double)(stx))
						{
							gamma = -gamma;
						}
						p = gamma - dp + theta;
						q = gamma - dp + gamma + dx;
						r = p / q;
						stpc = stp + r * (stx - stp);
						stpq = stp + dp / (dp - dx) * (stx - stp);
						if ((double)(Math.Abs(stpc - stp)) > (double)(Math.Abs(stpq - stp)))
						{
							stpf = stpc;
						}
						else
						{
							stpf = stpq;
						}
						brackt = true;
					}
					else
					{
						if ((double)(Math.Abs(dp)) < (double)(Math.Abs(dx)))
						{

							//
							//     THIRD CASE. A LOWER FUNCTION VALUE, DERIVATIVES OF THE
							//     SAME SIGN, AND THE MAGNITUDE OF THE DERIVATIVE DECREASES.
							//     THE CUBIC STEP IS ONLY USED IF THE CUBIC TENDS TO INFINITY
							//     IN THE DIRECTION OF THE STEP OR IF THE MINIMUM OF THE CUBIC
							//     IS BEYOND STP. OTHERWISE THE CUBIC STEP IS DEFINED TO BE
							//     EITHER STPMIN OR STPMAX. THE QUADRATIC (SECANT) STEP IS ALSO
							//     COMPUTED AND IF THE MINIMUM IS BRACKETED THEN THE THE STEP
							//     CLOSEST TO STX IS TAKEN, ELSE THE STEP FARTHEST AWAY IS TAKEN.
							//
							info = 3;
							bound = true;
							theta = 3 * (fx - fp) / (stp - stx) + dx + dp;
							s = Math.Max(Math.Abs(theta), Math.Max(Math.Abs(dx), Math.Abs(dp)));

							//
							//        THE CASE GAMMA = 0 ONLY ARISES IF THE CUBIC DOES NOT TEND
							//        TO INFINITY IN THE DIRECTION OF THE STEP.
							//
							gamma = (double)(s * Math.Sqrt(Math.Max(0, math.sqr(theta / s) - dx / s * (dp / s))));
							if ((double)(stp) > (double)(stx))
							{
								gamma = -gamma;
							}
							p = gamma - dp + theta;
							q = gamma + (dx - dp) + gamma;
							r = p / q;
							if ((double)(r) < (double)(0) && (double)(gamma) != (double)(0))
							{
								stpc = stp + r * (stx - stp);
							}
							else
							{
								if ((double)(stp) > (double)(stx))
								{
									stpc = stmax;
								}
								else
								{
									stpc = stmin;
								}
							}
							stpq = stp + dp / (dp - dx) * (stx - stp);
							if (brackt)
							{
								if ((double)(Math.Abs(stp - stpc)) < (double)(Math.Abs(stp - stpq)))
								{
									stpf = stpc;
								}
								else
								{
									stpf = stpq;
								}
							}
							else
							{
								if ((double)(Math.Abs(stp - stpc)) > (double)(Math.Abs(stp - stpq)))
								{
									stpf = stpc;
								}
								else
								{
									stpf = stpq;
								}
							}
						}
						else
						{

							//
							//     FOURTH CASE. A LOWER FUNCTION VALUE, DERIVATIVES OF THE
							//     SAME SIGN, AND THE MAGNITUDE OF THE DERIVATIVE DOES
							//     NOT DECREASE. IF THE MINIMUM IS NOT BRACKETED, THE STEP
							//     IS EITHER STPMIN OR STPMAX, ELSE THE CUBIC STEP IS TAKEN.
							//
							info = 4;
							bound = false;
							if (brackt)
							{
								theta = 3 * (fp - fy) / (sty - stp) + dy + dp;
								s = Math.Max(Math.Abs(theta), Math.Max(Math.Abs(dy), Math.Abs(dp)));
								gamma = (double)(s * Math.Sqrt(math.sqr(theta / s) - dy / s * (dp / s)));
								if ((double)(stp) > (double)(sty))
								{
									gamma = -gamma;
								}
								p = gamma - dp + theta;
								q = gamma - dp + gamma + dy;
								r = p / q;
								stpc = stp + r * (sty - stp);
								stpf = stpc;
							}
							else
							{
								if ((double)(stp) > (double)(stx))
								{
									stpf = stmax;
								}
								else
								{
									stpf = stmin;
								}
							}
						}
					}
				}

				//
				//     UPDATE THE INTERVAL OF UNCERTAINTY. THIS UPDATE DOES NOT
				//     DEPEND ON THE NEW STEP OR THE CASE ANALYSIS ABOVE.
				//
				if ((double)(fp) > (double)(fx))
				{
					sty = stp;
					fy = fp;
					dy = dp;
				}
				else
				{
					if ((double)(sgnd) < (double)(0.0f))
					{
						sty = stx;
						fy = fx;
						dy = dx;
					}
					stx = stp;
					fx = fp;
					dx = dp;
				}

				//
				//     COMPUTE THE NEW STEP AND SAFEGUARD IT.
				//
				stpf = Math.Min(stmax, stpf);
				stpf = Math.Max(stmin, stpf);
				stp = stpf;
				if (brackt && bound)
				{
					if ((double)(sty) > (double)(stx))
					{
						stp = (double)(Math.Min(stx + 0.66 * (sty - stx), stp));
					}
					else
					{
						stp = (double)(Math.Max(stx + 0.66 * (sty - stx), stp));
					}
				}
			}


		}
		public class ntheory
		{
			public static void findprimitiverootandinverse(int n,
					ref int proot,
					ref int invproot)
			{
				int candroot = 0;
				int phin = 0;
				int q = 0;
				int f = 0;
				bool allnonone = new bool();
				int x = 0;
				int lastx = 0;
				int y = 0;
				int lasty = 0;
				int a = 0;
				int b = 0;
				int t = 0;
				int n2 = 0;

				proot = 0;
				invproot = 0;

				alglib.ap.assert(n >= 3, "FindPrimitiveRootAndInverse: N<3");
				proot = 0;
				invproot = 0;

				//
				// check that N is prime
				//
				alglib.ap.assert(isprime(n), "FindPrimitiveRoot: N is not prime");

				//
				// Because N is prime, Euler totient function is equal to N-1
				//
				phin = n - 1;

				//
				// Test different values of PRoot - from 2 to N-1.
				// One of these values MUST be primitive root.
				//
				// For testing we use algorithm from Wiki (Primitive root modulo n):
				// * compute phi(N)
				// * determine the different prime factors of phi(N), say p1, ..., pk
				// * for every element m of Zn*, compute m^(phi(N)/pi) mod N for i=1..k
				//   using a fast algorithm for modular exponentiation.
				// * a number m for which these k results are all different from 1 is a
				//   primitive root.
				//
				for (candroot = 2; candroot <= n - 1; candroot++)
				{

					//
					// We have current candidate root in CandRoot.
					//
					// Scan different prime factors of PhiN. Here:
					// * F is a current candidate factor
					// * Q is a current quotient - amount which was left after dividing PhiN
					//   by all previous factors
					//
					// For each factor, perform test mentioned above.
					//
					q = phin;
					f = 2;
					allnonone = true;
					while (q > 1)
					{
						if (q % f == 0)
						{
							t = modexp(candroot, phin / f, n);
							if (t == 1)
							{
								allnonone = false;
								break;
							}
							while (q % f == 0)
							{
								q = q / f;
							}
						}
						f = f + 1;
					}
					if (allnonone)
					{
						proot = candroot;
						break;
					}
				}
				alglib.ap.assert(proot >= 2, "FindPrimitiveRoot: internal error (root not found)");

				//
				// Use extended Euclidean algorithm to find multiplicative inverse of primitive root
				//
				x = 0;
				lastx = 1;
				y = 1;
				lasty = 0;
				a = proot;
				b = n;
				while (b != 0)
				{
					q = a / b;
					t = a % b;
					a = b;
					b = t;
					t = lastx - q * x;
					lastx = x;
					x = t;
					t = lasty - q * y;
					lasty = y;
					y = t;
				}
				while (lastx < 0)
				{
					lastx = lastx + n;
				}
				invproot = lastx;

				//
				// Check that it is safe to perform multiplication modulo N.
				// Check results for consistency.
				//
				n2 = (n - 1) * (n - 1);
				alglib.ap.assert(n2 / (n - 1) == n - 1, "FindPrimitiveRoot: internal error");
				alglib.ap.assert(proot * invproot / proot == invproot, "FindPrimitiveRoot: internal error");
				alglib.ap.assert(proot * invproot / invproot == proot, "FindPrimitiveRoot: internal error");
				alglib.ap.assert(proot * invproot % n == 1, "FindPrimitiveRoot: internal error");
			}


			private static bool isprime(int n)
			{
				bool result = new bool();
				int p = 0;

				result = false;
				p = 2;
				while (p * p <= n)
				{
					if (n % p == 0)
					{
						return result;
					}
					p = p + 1;
				}
				result = true;
				return result;
			}


			private static int modmul(int a,
					int b,
					int n)
			{
				int result = 0;
				int t = 0;
				double ra = 0;
				double rb = 0;

				alglib.ap.assert(a >= 0 && a < n, "ModMul: A<0 or A>=N");
				alglib.ap.assert(b >= 0 && b < n, "ModMul: B<0 or B>=N");

				//
				// Base cases
				//
				ra = a;
				rb = b;
				if (b == 0 || a == 0)
				{
					result = 0;
					return result;
				}
				if (b == 1 || a == 1)
				{
					result = a * b;
					return result;
				}
				if ((double)(ra * rb) == (double)(a * b))
				{
					result = a * b % n;
					return result;
				}

				//
				// Non-base cases
				//
				if (b % 2 == 0)
				{

					//
					// A*B = (A*(B/2)) * 2
					//
					// Product T=A*(B/2) is calculated recursively, product T*2 is
					// calculated as follows:
					// * result:=T-N
					// * result:=result+T
					// * if result<0 then result:=result+N
					//
					// In case integer result overflows, we generate exception
					//
					t = modmul(a, b / 2, n);
					result = t - n;
					result = result + t;
					if (result < 0)
					{
						result = result + n;
					}
				}
				else
				{

					//
					// A*B = (A*(B div 2)) * 2 + A
					//
					// Product T=A*(B/2) is calculated recursively, product T*2 is
					// calculated as follows:
					// * result:=T-N
					// * result:=result+T
					// * if result<0 then result:=result+N
					//
					// In case integer result overflows, we generate exception
					//
					t = modmul(a, b / 2, n);
					result = t - n;
					result = result + t;
					if (result < 0)
					{
						result = result + n;
					}
					result = result - n;
					result = result + a;
					if (result < 0)
					{
						result = result + n;
					}
				}
				return result;
			}


			private static int modexp(int a,
					int b,
					int n)
			{
				int result = 0;
				int t = 0;

				alglib.ap.assert(a >= 0 && a < n, "ModExp: A<0 or A>=N");
				alglib.ap.assert(b >= 0, "ModExp: B<0");

				//
				// Base cases
				//
				if (b == 0)
				{
					result = 1;
					return result;
				}
				if (b == 1)
				{
					result = a;
					return result;
				}

				//
				// Non-base cases
				//
				if (b % 2 == 0)
				{
					t = modmul(a, a, n);
					result = modexp(t, b / 2, n);
				}
				else
				{
					t = modmul(a, a, n);
					result = modexp(t, b / 2, n);
					result = modmul(result, a, n);
				}
				return result;
			}


		}
		public class ftbase
		{
			/*************************************************************************
			This record stores execution plan for the fast transformation  along  with
			preallocated temporary buffers and precalculated values.

			FIELDS:
					Entries         -   plan entries, one row = one entry (see below for
															description).
					Buf0,Buf1,Buf2  -   global temporary buffers; some of them are allocated,
															some of them are not (as decided by plan generation
															subroutine).
					Buffer          -   global buffer whose size is equal to plan size.
															There is one-to-one correspondence between elements
															of global buffer and elements of array transformed.
															Because of it global buffer can be used as temporary
															thread-safe storage WITHOUT ACQUIRING LOCK - each
															worker thread works with its part of input array,
															and each part of input array corresponds to distinct
															part of buffer.
            
			FORMAT OF THE ENTRIES TABLE:

			Entries table is 2D array which stores one entry per row. Row format is:
					row[0]      operation type:
											*  0 for "end of plan/subplan"
											* +1 for "reference O(N^2) complex FFT"
											* -1 for complex transposition
											* -2 for multiplication by twiddle factors of complex FFT
											* -3 for "start of plan/subplan"
					row[1]      repetition count, >=1
					row[2]      base operand size (number of microvectors), >=1
					row[3]      microvector size (measured in real numbers), >=1
					row[4]      parameter0, meaning depends on row[0]
					row[5]      parameter1, meaning depends on row[0]

			FORMAT OF THE DATA:

			Transformation plan works with row[1]*row[2]*row[3]  real  numbers,  which
			are (in most cases) interpreted as sequence of complex numbers. These data
			are grouped as follows:
			* we have row[1] contiguous OPERANDS, which can be treated separately
			* each operand includes row[2] contiguous MICROVECTORS
			* each microvector includes row[3] COMPONENTS, which can be treated separately
			* pair of components form complex number, so in most cases row[3] will be even

			Say, if you want to perform complex FFT of length 3, then:
			* you have 1 operand: row[1]=1
			* operand consists of 3 microvectors:   row[2]=3
			* each microvector has two components:  row[3]=2
			* a pair of subsequent components is treated as complex number

			if you want to perform TWO simultaneous complex FFT's of length 3, then you
			can choose between two representations:
			* 1 operand, 3 microvectors, 4 components; storage format is given below:
				[ A0X A0Y B0X B0Y A1X A1Y B1X B1Y ... ]
				(here A denotes first sequence, B - second one).
			* 2 operands, 3 microvectors, 2 components; storage format is given below:
				[ A0X A0Y A1X A2Y ... B0X B0Y B1X B1Y ... ]
			Most FFT operations are supported only for the second format, but you
			should remember that first format sometimes can be used too.

			SUPPORTED OPERATIONS:

			row[0]=0:
			* "end of plan/subplan"
			* in case we meet entry with such type,  FFT  transformation  is  finished
				(or we return from recursive FFT subplan, in case it was subplan).

			row[0]=+1:
			* "reference 1D complex FFT"
			* we perform reference O(N^2) complex FFT on input data, which are treated
				as row[1] arrays, each of row[2] complex numbers, and row[3] must be
				equal to 2
			* transformation is performed using temporary buffer

			row[0]=opBluesteinsFFT:
			* input array is handled with Bluestein's algorithm (by zero-padding to
				Param0 complex numbers).
			* this plan calls Param0-point subplan which is located at offset Param1
				(offset is measured with respect to location of the calling entry)
			* this plan uses precomputed quantities stored in Plan.PrecR at
				offset Param2.
			* transformation is performed using 4 temporary buffers, which are
				retrieved from Plan.BluesteinPool.

			row[0]=+3:
			* "optimized 1D complex FFT"
			* this function supports only several operand sizes: from 1 to 5.
				These transforms are hard-coded and performed very efficiently

			row[0]=opRadersFFT:
			* input array is handled with Rader's algorithm (permutation and
				reduction to N-1-point FFT)
			* this plan calls N-1-point subplan which is located at offset Param0
				(offset is measured with respect to location of the calling entry)
			* this plan uses precomputed primitive root and its inverse (modulo N)
				which are stored in Param1 and Param2.
			* Param3 stores offset of the precomputed data for the plan
			* plan length must be prime, (N-1)*(N-1) must fit into integer variable

			row[0]=-1
			* "complex transposition"
			* input data are treated as row[1] independent arrays, which are processed
				separately
			* each of operands is treated as matrix with row[4] rows and row[2]/row[4]
				columns. Each element of the matrix is microvector with row[3] components.
			* transposition is performed using temporary buffer

			row[0]=-2
			* "multiplication by twiddle factors of complex FFT"
			* input data are treated as row[1] independent arrays, which are processed
				separately
			* row[4] contains N1 - length of the "first FFT"  in  a  Cooley-Tukey  FFT
				algorithm
			* this function does not require temporary buffers

			row[0]=-3
			* "start of the plan"
			* each subplan must start from this entry
			* param0 is ignored
			* param1 stores approximate (optimistic) estimate of KFLOPs required to
				transform one operand of the plan. Total cost of the plan is approximately
				equal to row[1]*param1 KFLOPs.
			* this function does not require temporary buffers

			row[0]=-4
			* "jump"
			* param0 stores relative offset of the jump site
				(+1 corresponds to the next entry)

			row[0]=-5
			* "parallel call"
			* input data are treated as row[1] independent arrays
			* child subplan is applied independently for each of arrays - row[1] times
			* subplan length must be equal to row[2]*row[3]
			* param0 stores relative offset of the child subplan site
				(+1 corresponds to the next entry)
			* param1 stores approximate total cost of plan, measured in UNITS
				(1 UNIT = 100 KFLOPs). Plan cost must be rounded DOWN to nearest integer.


            
			TODO 
					 2. from KFLOPs to UNITs, 1 UNIT = 100 000 FLOP!!!!!!!!!!!

					 3. from IsRoot to TaskType = {0, -1, +1}; or maybe, add IsSeparatePlan
							to distinguish root of child subplan from global root which uses
							separate buffer
                
					 4. child subplans in parallel call must NOT use buffer provided by parent plan;
							they must allocate their own local buffer
			*************************************************************************/
			public class fasttransformplan : apobject
			{
				public int[,] entries;
				public double[] buffer;
				public double[] precr;
				public double[] preci;
				public alglib.smp.shared_pool bluesteinpool;
				public fasttransformplan()
				{
					init();
				}
				public override void init()
				{
					entries = new int[0, 0];
					buffer = new double[0];
					precr = new double[0];
					preci = new double[0];
					bluesteinpool = new alglib.smp.shared_pool();
				}
				public override alglib.apobject make_copy()
				{
					fasttransformplan _result = new fasttransformplan();
					_result.entries = (int[,])entries.Clone();
					_result.buffer = (double[])buffer.Clone();
					_result.precr = (double[])precr.Clone();
					_result.preci = (double[])preci.Clone();
					_result.bluesteinpool = (alglib.smp.shared_pool)bluesteinpool.make_copy();
					return _result;
				}
			};




			public const int coltype = 0;
			public const int coloperandscnt = 1;
			public const int coloperandsize = 2;
			public const int colmicrovectorsize = 3;
			public const int colparam0 = 4;
			public const int colparam1 = 5;
			public const int colparam2 = 6;
			public const int colparam3 = 7;
			public const int colscnt = 8;
			public const int opend = 0;
			public const int opcomplexreffft = 1;
			public const int opbluesteinsfft = 2;
			public const int opcomplexcodeletfft = 3;
			public const int opcomplexcodelettwfft = 4;
			public const int opradersfft = 5;
			public const int opcomplextranspose = -1;
			public const int opcomplexfftfactors = -2;
			public const int opstart = -3;
			public const int opjmp = -4;
			public const int opparallelcall = -5;
			public const int maxradix = 6;
			public const int updatetw = 16;
			public const int recursivethreshold = 1024;
			public const int raderthreshold = 19;
			public const int ftbasecodeletrecommended = 5;
			public const double ftbaseinefficiencyfactor = 1.3f;
			public const int ftbasemaxsmoothfactor = 5;


			/*************************************************************************
			This subroutine generates FFT plan for K complex FFT's with length N each.

			INPUT PARAMETERS:
					N           -   FFT length (in complex numbers), N>=1
					K           -   number of repetitions, K>=1
            
			OUTPUT PARAMETERS:
					Plan        -   plan

				-- ALGLIB --
					 Copyright 05.04.2013 by Bochkanov Sergey
			*************************************************************************/
			public static void ftcomplexfftplan(int n,
					int k,
					fasttransformplan plan)
			{
				apserv.srealarray bluesteinbuf = new apserv.srealarray();
				int rowptr = 0;
				int bluesteinsize = 0;
				int precrptr = 0;
				int preciptr = 0;
				int precrsize = 0;
				int precisize = 0;


				//
				// Initial check for parameters
				//
				alglib.ap.assert(n > 0, "FTComplexFFTPlan: N<=0");
				alglib.ap.assert(k > 0, "FTComplexFFTPlan: K<=0");

				//
				// Determine required sizes of precomputed real and integer
				// buffers. This stage of code is highly dependent on internals
				// of FTComplexFFTPlanRec() and must be kept synchronized with
				// possible changes in internals of plan generation function.
				//
				// Buffer size is determined as follows:
				// * N is factorized
				// * we factor out anything which is less or equal to MaxRadix
				// * prime factor F>RaderThreshold requires 4*FTBaseFindSmooth(2*F-1)
				//   real entries to store precomputed Quantities for Bluestein's
				//   transformation
				// * prime factor F<=RaderThreshold does NOT require
				//   precomputed storage
				//
				precrsize = 0;
				precisize = 0;
				ftdeterminespacerequirements(n, ref precrsize, ref precisize);
				if (precrsize > 0)
				{
					plan.precr = new double[precrsize];
				}
				if (precisize > 0)
				{
					plan.preci = new double[precisize];
				}

				//
				// Generate plan
				//
				rowptr = 0;
				precrptr = 0;
				preciptr = 0;
				bluesteinsize = 1;
				plan.buffer = new double[2 * n * k];
				ftcomplexfftplanrec(n, k, true, true, ref rowptr, ref bluesteinsize, ref precrptr, ref preciptr, plan);
				bluesteinbuf.val = new double[bluesteinsize];
				alglib.smp.ae_shared_pool_set_seed(plan.bluesteinpool, bluesteinbuf);

				//
				// Check that actual amount of precomputed space used by transformation
				// plan is EXACTLY equal to amount of space allocated by us.
				//
				alglib.ap.assert(precrptr == precrsize, "FTComplexFFTPlan: internal error (PrecRPtr<>PrecRSize)");
				alglib.ap.assert(preciptr == precisize, "FTComplexFFTPlan: internal error (PrecRPtr<>PrecRSize)");
			}


			/*************************************************************************
			This subroutine applies transformation plan to input/output array A.

			INPUT PARAMETERS:
					Plan        -   transformation plan
					A           -   array, must be large enough for plan to work
					OffsA       -   offset of the subarray to process
					RepCnt      -   repetition count (transformation is repeatedly applied
													to subsequent subarrays)
            
			OUTPUT PARAMETERS:
					Plan        -   plan (temporary buffers can be modified, plan itself
													is unchanged and can be reused)
					A           -   transformed array

				-- ALGLIB --
					 Copyright 05.04.2013 by Bochkanov Sergey
			*************************************************************************/
			public static void ftapplyplan(fasttransformplan plan,
					double[] a,
					int offsa,
					int repcnt)
			{
				int plansize = 0;
				int i = 0;

				plansize = plan.entries[0, coloperandscnt] * plan.entries[0, coloperandsize] * plan.entries[0, colmicrovectorsize];
				for (i = 0; i <= repcnt - 1; i++)
				{
					ftapplysubplan(plan, 0, a, offsa + plansize * i, 0, plan.buffer, 1);
				}
			}


			/*************************************************************************
			Returns good factorization N=N1*N2.

			Usually N1<=N2 (but not always - small N's may be exception).
			if N1<>1 then N2<>1.

			Factorization is chosen depending on task type and codelets we have.

				-- ALGLIB --
					 Copyright 01.05.2009 by Bochkanov Sergey
			*************************************************************************/
			public static void ftbasefactorize(int n,
					int tasktype,
					ref int n1,
					ref int n2)
			{
				int j = 0;

				n1 = 0;
				n2 = 0;

				n1 = 0;
				n2 = 0;

				//
				// try to find good codelet
				//
				if (n1 * n2 != n)
				{
					for (j = ftbasecodeletrecommended; j >= 2; j--)
					{
						if (n % j == 0)
						{
							n1 = j;
							n2 = n / j;
							break;
						}
					}
				}

				//
				// try to factorize N
				//
				if (n1 * n2 != n)
				{
					for (j = ftbasecodeletrecommended + 1; j <= n - 1; j++)
					{
						if (n % j == 0)
						{
							n1 = j;
							n2 = n / j;
							break;
						}
					}
				}

				//
				// looks like N is prime :(
				//
				if (n1 * n2 != n)
				{
					n1 = 1;
					n2 = n;
				}

				//
				// normalize
				//
				if (n2 == 1 && n1 != 1)
				{
					n2 = n1;
					n1 = 1;
				}
			}


			/*************************************************************************
			Is number smooth?

				-- ALGLIB --
					 Copyright 01.05.2009 by Bochkanov Sergey
			*************************************************************************/
			public static bool ftbaseissmooth(int n)
			{
				bool result = new bool();
				int i = 0;

				for (i = 2; i <= ftbasemaxsmoothfactor; i++)
				{
					while (n % i == 0)
					{
						n = n / i;
					}
				}
				result = n == 1;
				return result;
			}


			/*************************************************************************
			Returns smallest smooth (divisible only by 2, 3, 5) number that is greater
			than or equal to max(N,2)

				-- ALGLIB --
					 Copyright 01.05.2009 by Bochkanov Sergey
			*************************************************************************/
			public static int ftbasefindsmooth(int n)
			{
				int result = 0;
				int best = 0;

				best = 2;
				while (best < n)
				{
					best = 2 * best;
				}
				ftbasefindsmoothrec(n, 1, 2, ref best);
				result = best;
				return result;
			}


			/*************************************************************************
			Returns  smallest  smooth  (divisible only by 2, 3, 5) even number that is
			greater than or equal to max(N,2)

				-- ALGLIB --
					 Copyright 01.05.2009 by Bochkanov Sergey
			*************************************************************************/
			public static int ftbasefindsmootheven(int n)
			{
				int result = 0;
				int best = 0;

				best = 2;
				while (best < n)
				{
					best = 2 * best;
				}
				ftbasefindsmoothrec(n, 2, 2, ref best);
				result = best;
				return result;
			}


			/*************************************************************************
			Returns estimate of FLOP count for the FFT.

			It is only an estimate based on operations count for the PERFECT FFT
			and relative inefficiency of the algorithm actually used.

			N should be power of 2, estimates are badly wrong for non-power-of-2 N's.

				-- ALGLIB --
					 Copyright 01.05.2009 by Bochkanov Sergey
			*************************************************************************/
			public static double ftbasegetflopestimate(int n)
			{
				double result = 0;

				result = (double)(ftbaseinefficiencyfactor * (4 * n * Math.Log(n) / Math.Log(2) - 6 * n + 8));
				return result;
			}


			/*************************************************************************
			This function returns EXACT estimate of the space requirements for N-point
			FFT. Internals of this function are highly dependent on details of different
			FFTs employed by this unit, so every time algorithm is changed this function
			has to be rewritten.

			INPUT PARAMETERS:
					N           -   transform length
					PrecRSize   -   must be set to zero
					PrecISize   -   must be set to zero
            
			OUTPUT PARAMETERS:
					PrecRSize   -   number of real temporaries required for transformation
					PrecISize   -   number of integer temporaries required for transformation

            
				-- ALGLIB --
					 Copyright 05.04.2013 by Bochkanov Sergey
			*************************************************************************/
			private static void ftdeterminespacerequirements(int n,
					ref int precrsize,
					ref int precisize)
			{
				int ncur = 0;
				int f = 0;
				int i = 0;


				//
				// Determine required sizes of precomputed real and integer
				// buffers. This stage of code is highly dependent on internals
				// of FTComplexFFTPlanRec() and must be kept synchronized with
				// possible changes in internals of plan generation function.
				//
				// Buffer size is determined as follows:
				// * N is factorized
				// * we factor out anything which is less or equal to MaxRadix
				// * prime factor F>RaderThreshold requires 4*FTBaseFindSmooth(2*F-1)
				//   real entries to store precomputed Quantities for Bluestein's
				//   transformation
				// * prime factor F<=RaderThreshold requires 2*(F-1)+ESTIMATE(F-1)
				//   precomputed storage
				//
				ncur = n;
				for (i = 2; i <= maxradix; i++)
				{
					while (ncur % i == 0)
					{
						ncur = ncur / i;
					}
				}
				f = 2;
				while (f <= ncur)
				{
					while (ncur % f == 0)
					{
						if (f > raderthreshold)
						{
							precrsize = precrsize + 4 * ftbasefindsmooth(2 * f - 1);
						}
						else
						{
							precrsize = precrsize + 2 * (f - 1);
							ftdeterminespacerequirements(f - 1, ref precrsize, ref precisize);
						}
						ncur = ncur / f;
					}
					f = f + 1;
				}
			}


			/*************************************************************************
			Recurrent function called by FTComplexFFTPlan() and other functions. It
			recursively builds transformation plan

			INPUT PARAMETERS:
					N           -   FFT length (in complex numbers), N>=1
					K           -   number of repetitions, K>=1
					ChildPlan   -   if True, plan generator inserts OpStart/opEnd in the
													plan header/footer.
					TopmostPlan -   if True, plan generator assumes that it is topmost plan:
													* it may use global buffer for transpositions
													and there is no other plan which executes in parallel
					RowPtr      -   index which points to past-the-last entry generated so far
					BluesteinSize-  amount of storage (in real numbers) required for Bluestein buffer
					PrecRPtr    -   pointer to unused part of precomputed real buffer (Plan.PrecR):
													* when this function stores some data to precomputed buffer,
														it advances pointer.
													* it is responsibility of the function to assert that
														Plan.PrecR has enough space to store data before actually
														writing to buffer.
													* it is responsibility of the caller to allocate enough
														space before calling this function
					PrecIPtr    -   pointer to unused part of precomputed integer buffer (Plan.PrecI):
													* when this function stores some data to precomputed buffer,
														it advances pointer.
													* it is responsibility of the function to assert that
														Plan.PrecR has enough space to store data before actually
														writing to buffer.
													* it is responsibility of the caller to allocate enough
														space before calling this function
					Plan        -   plan (generated so far)
            
			OUTPUT PARAMETERS:
					RowPtr      -   updated pointer (advanced by number of entries generated
													by function)
					BluesteinSize-  updated amount
													(may be increased, but may never be decreased)
                
			NOTE: in case TopmostPlan is True, ChildPlan is also must be True.
            
				-- ALGLIB --
					 Copyright 05.04.2013 by Bochkanov Sergey
			*************************************************************************/
			private static void ftcomplexfftplanrec(int n,
					int k,
					bool childplan,
					bool topmostplan,
					ref int rowptr,
					ref int bluesteinsize,
					ref int precrptr,
					ref int preciptr,
					fasttransformplan plan)
			{
				apserv.srealarray localbuf = new apserv.srealarray();
				int m = 0;
				int n1 = 0;
				int n2 = 0;
				int gq = 0;
				int giq = 0;
				int row0 = 0;
				int row1 = 0;
				int row2 = 0;
				int row3 = 0;

				alglib.ap.assert(n > 0, "FTComplexFFTPlan: N<=0");
				alglib.ap.assert(k > 0, "FTComplexFFTPlan: K<=0");
				alglib.ap.assert(!topmostplan || childplan, "FTComplexFFTPlan: ChildPlan is inconsistent with TopmostPlan");

				//
				// Try to generate "topmost" plan
				//
				if (topmostplan && n > recursivethreshold)
				{
					ftfactorize(n, false, ref n1, ref n2);
					if (n1 * n2 == 0)
					{

						//
						// Handle prime-factor FFT with Bluestein's FFT.
						// Determine size of Bluestein's buffer.
						//
						m = ftbasefindsmooth(2 * n - 1);
						bluesteinsize = Math.Max(2 * m, bluesteinsize);

						//
						// Generate plan
						//
						ftpushentry2(plan, ref rowptr, opstart, k, n, 2, -1, ftoptimisticestimate(n));
						ftpushentry4(plan, ref rowptr, opbluesteinsfft, k, n, 2, m, 2, precrptr, 0);
						row0 = rowptr;
						ftpushentry(plan, ref rowptr, opjmp, 0, 0, 0, 0);
						ftcomplexfftplanrec(m, 1, true, true, ref rowptr, ref bluesteinsize, ref precrptr, ref preciptr, plan);
						row1 = rowptr;
						plan.entries[row0, colparam0] = row1 - row0;
						ftpushentry(plan, ref rowptr, opend, k, n, 2, 0);

						//
						// Fill precomputed buffer
						//
						ftprecomputebluesteinsfft(n, m, plan.precr, precrptr);

						//
						// Update pointer to the precomputed area
						//
						precrptr = precrptr + 4 * m;
					}
					else
					{

						//
						// Handle composite FFT with recursive Cooley-Tukey which
						// uses global buffer instead of local one.
						//
						ftpushentry2(plan, ref rowptr, opstart, k, n, 2, -1, ftoptimisticestimate(n));
						ftpushentry(plan, ref rowptr, opcomplextranspose, k, n, 2, n1);
						row0 = rowptr;
						ftpushentry2(plan, ref rowptr, opparallelcall, k * n2, n1, 2, 0, ftoptimisticestimate(n));
						ftpushentry(plan, ref rowptr, opcomplexfftfactors, k, n, 2, n1);
						ftpushentry(plan, ref rowptr, opcomplextranspose, k, n, 2, n2);
						row2 = rowptr;
						ftpushentry2(plan, ref rowptr, opparallelcall, k * n1, n2, 2, 0, ftoptimisticestimate(n));
						ftpushentry(plan, ref rowptr, opcomplextranspose, k, n, 2, n1);
						ftpushentry(plan, ref rowptr, opend, k, n, 2, 0);
						row1 = rowptr;
						ftcomplexfftplanrec(n1, 1, true, false, ref rowptr, ref bluesteinsize, ref precrptr, ref preciptr, plan);
						plan.entries[row0, colparam0] = row1 - row0;
						row3 = rowptr;
						ftcomplexfftplanrec(n2, 1, true, false, ref rowptr, ref bluesteinsize, ref precrptr, ref preciptr, plan);
						plan.entries[row2, colparam0] = row3 - row2;
					}
					return;
				}

				//
				// Prepare "non-topmost" plan:
				// * calculate factorization
				// * use local (shared) buffer
				// * update buffer size - ANY plan will need at least
				//   2*N temporaries, additional requirements can be
				//   applied later
				//
				ftfactorize(n, false, ref n1, ref n2);

				//
				// Handle FFT's with N1*N2=0: either small-N or prime-factor
				//
				if (n1 * n2 == 0)
				{
					if (n <= maxradix)
					{

						//
						// Small-N FFT
						//
						if (childplan)
						{
							ftpushentry2(plan, ref rowptr, opstart, k, n, 2, -1, ftoptimisticestimate(n));
						}
						ftpushentry(plan, ref rowptr, opcomplexcodeletfft, k, n, 2, 0);
						if (childplan)
						{
							ftpushentry(plan, ref rowptr, opend, k, n, 2, 0);
						}
						return;
					}
					if (n <= raderthreshold)
					{

						//
						// Handle prime-factor FFT's with Rader's FFT
						//
						m = n - 1;
						if (childplan)
						{
							ftpushentry2(plan, ref rowptr, opstart, k, n, 2, -1, ftoptimisticestimate(n));
						}
						ntheory.findprimitiverootandinverse(n, ref gq, ref giq);
						ftpushentry4(plan, ref rowptr, opradersfft, k, n, 2, 2, gq, giq, precrptr);
						ftprecomputeradersfft(n, gq, giq, plan.precr, precrptr);
						precrptr = precrptr + 2 * (n - 1);
						row0 = rowptr;
						ftpushentry(plan, ref rowptr, opjmp, 0, 0, 0, 0);
						ftcomplexfftplanrec(m, 1, true, false, ref rowptr, ref bluesteinsize, ref precrptr, ref preciptr, plan);
						row1 = rowptr;
						plan.entries[row0, colparam0] = row1 - row0;
						if (childplan)
						{
							ftpushentry(plan, ref rowptr, opend, k, n, 2, 0);
						}
					}
					else
					{

						//
						// Handle prime-factor FFT's with Bluestein's FFT
						//
						m = ftbasefindsmooth(2 * n - 1);
						bluesteinsize = Math.Max(2 * m, bluesteinsize);
						if (childplan)
						{
							ftpushentry2(plan, ref rowptr, opstart, k, n, 2, -1, ftoptimisticestimate(n));
						}
						ftpushentry4(plan, ref rowptr, opbluesteinsfft, k, n, 2, m, 2, precrptr, 0);
						ftprecomputebluesteinsfft(n, m, plan.precr, precrptr);
						precrptr = precrptr + 4 * m;
						row0 = rowptr;
						ftpushentry(plan, ref rowptr, opjmp, 0, 0, 0, 0);
						ftcomplexfftplanrec(m, 1, true, false, ref rowptr, ref bluesteinsize, ref precrptr, ref preciptr, plan);
						row1 = rowptr;
						plan.entries[row0, colparam0] = row1 - row0;
						if (childplan)
						{
							ftpushentry(plan, ref rowptr, opend, k, n, 2, 0);
						}
					}
					return;
				}

				//
				// Handle Cooley-Tukey FFT with small N1
				//
				if (n1 <= maxradix)
				{

					//
					// Specialized transformation for small N1:
					// * N2 short inplace FFT's, each N1-point, with integrated twiddle factors
					// * N1 long FFT's
					// * final transposition
					//
					if (childplan)
					{
						ftpushentry2(plan, ref rowptr, opstart, k, n, 2, -1, ftoptimisticestimate(n));
					}
					ftpushentry(plan, ref rowptr, opcomplexcodelettwfft, k, n1, 2 * n2, 0);
					ftcomplexfftplanrec(n2, k * n1, false, false, ref rowptr, ref bluesteinsize, ref precrptr, ref preciptr, plan);
					ftpushentry(plan, ref rowptr, opcomplextranspose, k, n, 2, n1);
					if (childplan)
					{
						ftpushentry(plan, ref rowptr, opend, k, n, 2, 0);
					}
					return;
				}

				//
				// Handle general Cooley-Tukey FFT, either "flat" or "recursive"
				//
				if (n <= recursivethreshold)
				{

					//
					// General code for large N1/N2, "flat" version without explicit recurrence
					// (nested subplans are inserted directly into the body of the plan)
					//
					if (childplan)
					{
						ftpushentry2(plan, ref rowptr, opstart, k, n, 2, -1, ftoptimisticestimate(n));
					}
					ftpushentry(plan, ref rowptr, opcomplextranspose, k, n, 2, n1);
					ftcomplexfftplanrec(n1, k * n2, false, false, ref rowptr, ref bluesteinsize, ref precrptr, ref preciptr, plan);
					ftpushentry(plan, ref rowptr, opcomplexfftfactors, k, n, 2, n1);
					ftpushentry(plan, ref rowptr, opcomplextranspose, k, n, 2, n2);
					ftcomplexfftplanrec(n2, k * n1, false, false, ref rowptr, ref bluesteinsize, ref precrptr, ref preciptr, plan);
					ftpushentry(plan, ref rowptr, opcomplextranspose, k, n, 2, n1);
					if (childplan)
					{
						ftpushentry(plan, ref rowptr, opend, k, n, 2, 0);
					}
				}
				else
				{

					//
					// General code for large N1/N2, "recursive" version - nested subplans
					// are separated from the plan body.
					//
					// Generate parent plan.
					//
					if (childplan)
					{
						ftpushentry2(plan, ref rowptr, opstart, k, n, 2, -1, ftoptimisticestimate(n));
					}
					ftpushentry(plan, ref rowptr, opcomplextranspose, k, n, 2, n1);
					row0 = rowptr;
					ftpushentry2(plan, ref rowptr, opparallelcall, k * n2, n1, 2, 0, ftoptimisticestimate(n));
					ftpushentry(plan, ref rowptr, opcomplexfftfactors, k, n, 2, n1);
					ftpushentry(plan, ref rowptr, opcomplextranspose, k, n, 2, n2);
					row2 = rowptr;
					ftpushentry2(plan, ref rowptr, opparallelcall, k * n1, n2, 2, 0, ftoptimisticestimate(n));
					ftpushentry(plan, ref rowptr, opcomplextranspose, k, n, 2, n1);
					if (childplan)
					{
						ftpushentry(plan, ref rowptr, opend, k, n, 2, 0);
					}

					//
					// Generate child subplans, insert refence to parent plans
					//
					row1 = rowptr;
					ftcomplexfftplanrec(n1, 1, true, false, ref rowptr, ref bluesteinsize, ref precrptr, ref preciptr, plan);
					plan.entries[row0, colparam0] = row1 - row0;
					row3 = rowptr;
					ftcomplexfftplanrec(n2, 1, true, false, ref rowptr, ref bluesteinsize, ref precrptr, ref preciptr, plan);
					plan.entries[row2, colparam0] = row3 - row2;
				}
			}


			/*************************************************************************
			This function pushes one more entry to the plan. It resizes Entries matrix
			if needed.

			INPUT PARAMETERS:
					Plan        -   plan (generated so far)
					RowPtr      -   index which points to past-the-last entry generated so far
					EType       -   entry type
					EOpCnt      -   operands count
					EOpSize     -   operand size
					EMcvSize    -   microvector size
					EParam0     -   parameter 0
            
			OUTPUT PARAMETERS:
					Plan        -   updated plan    
					RowPtr      -   updated pointer

			NOTE: Param1 is set to -1.
            
				-- ALGLIB --
					 Copyright 05.04.2013 by Bochkanov Sergey
			*************************************************************************/
			private static void ftpushentry(fasttransformplan plan,
					ref int rowptr,
					int etype,
					int eopcnt,
					int eopsize,
					int emcvsize,
					int eparam0)
			{
				ftpushentry2(plan, ref rowptr, etype, eopcnt, eopsize, emcvsize, eparam0, -1);
			}


			/*************************************************************************
			Same as FTPushEntry(), but sets Param0 AND Param1.
			This function pushes one more entry to the plan. It resized Entries matrix
			if needed.

			INPUT PARAMETERS:
					Plan        -   plan (generated so far)
					RowPtr      -   index which points to past-the-last entry generated so far
					EType       -   entry type
					EOpCnt      -   operands count
					EOpSize     -   operand size
					EMcvSize    -   microvector size
					EParam0     -   parameter 0
					EParam1     -   parameter 1
            
			OUTPUT PARAMETERS:
					Plan        -   updated plan    
					RowPtr      -   updated pointer

				-- ALGLIB --
					 Copyright 05.04.2013 by Bochkanov Sergey
			*************************************************************************/
			private static void ftpushentry2(fasttransformplan plan,
					ref int rowptr,
					int etype,
					int eopcnt,
					int eopsize,
					int emcvsize,
					int eparam0,
					int eparam1)
			{
				if (rowptr >= alglib.ap.rows(plan.entries))
				{
					apserv.imatrixresize(ref plan.entries, Math.Max(2 * alglib.ap.rows(plan.entries), 1), colscnt);
				}
				plan.entries[rowptr, coltype] = etype;
				plan.entries[rowptr, coloperandscnt] = eopcnt;
				plan.entries[rowptr, coloperandsize] = eopsize;
				plan.entries[rowptr, colmicrovectorsize] = emcvsize;
				plan.entries[rowptr, colparam0] = eparam0;
				plan.entries[rowptr, colparam1] = eparam1;
				plan.entries[rowptr, colparam2] = 0;
				plan.entries[rowptr, colparam3] = 0;
				rowptr = rowptr + 1;
			}


			/*************************************************************************
			Same as FTPushEntry(), but sets Param0, Param1, Param2 and Param3.
			This function pushes one more entry to the plan. It resized Entries matrix
			if needed.

			INPUT PARAMETERS:
					Plan        -   plan (generated so far)
					RowPtr      -   index which points to past-the-last entry generated so far
					EType       -   entry type
					EOpCnt      -   operands count
					EOpSize     -   operand size
					EMcvSize    -   microvector size
					EParam0     -   parameter 0
					EParam1     -   parameter 1
					EParam2     -   parameter 2
					EParam3     -   parameter 3
            
			OUTPUT PARAMETERS:
					Plan        -   updated plan    
					RowPtr      -   updated pointer

				-- ALGLIB --
					 Copyright 05.04.2013 by Bochkanov Sergey
			*************************************************************************/
			private static void ftpushentry4(fasttransformplan plan,
					ref int rowptr,
					int etype,
					int eopcnt,
					int eopsize,
					int emcvsize,
					int eparam0,
					int eparam1,
					int eparam2,
					int eparam3)
			{
				if (rowptr >= alglib.ap.rows(plan.entries))
				{
					apserv.imatrixresize(ref plan.entries, Math.Max(2 * alglib.ap.rows(plan.entries), 1), colscnt);
				}
				plan.entries[rowptr, coltype] = etype;
				plan.entries[rowptr, coloperandscnt] = eopcnt;
				plan.entries[rowptr, coloperandsize] = eopsize;
				plan.entries[rowptr, colmicrovectorsize] = emcvsize;
				plan.entries[rowptr, colparam0] = eparam0;
				plan.entries[rowptr, colparam1] = eparam1;
				plan.entries[rowptr, colparam2] = eparam2;
				plan.entries[rowptr, colparam3] = eparam3;
				rowptr = rowptr + 1;
			}


			/*************************************************************************
			This subroutine applies subplan to input/output array A.

			INPUT PARAMETERS:
					Plan        -   transformation plan
					SubPlan     -   subplan index
					A           -   array, must be large enough for plan to work
					ABase       -   base offset in array A, this value points to start of
													subarray whose length is equal to length of the plan
					AOffset     -   offset with respect to ABase, 0<=AOffset<PlanLength.
													This is an offset within large PlanLength-subarray of
													the chunk to process.
					Buf         -   temporary buffer whose length is equal to plan length
													(without taking into account RepCnt) or larger.
					OffsBuf     -   offset in the buffer array
					RepCnt      -   repetition count (transformation is repeatedly applied
													to subsequent subarrays)
            
			OUTPUT PARAMETERS:
					Plan        -   plan (temporary buffers can be modified, plan itself
													is unchanged and can be reused)
					A           -   transformed array

				-- ALGLIB --
					 Copyright 05.04.2013 by Bochkanov Sergey
			*************************************************************************/
			private static void ftapplysubplan(fasttransformplan plan,
					int subplan,
					double[] a,
					int abase,
					int aoffset,
					double[] buf,
					int repcnt)
			{
				int rowidx = 0;
				int i = 0;
				int n1 = 0;
				int n2 = 0;
				int operation = 0;
				int operandscnt = 0;
				int operandsize = 0;
				int microvectorsize = 0;
				int param0 = 0;
				int param1 = 0;
				int parentsize = 0;
				int childsize = 0;
				int chunksize = 0;
				int lastchunksize = 0;
				apserv.srealarray bufa = null;
				apserv.srealarray bufb = null;
				apserv.srealarray bufc = null;
				apserv.srealarray bufd = null;

				alglib.ap.assert(plan.entries[subplan, coltype] == opstart, "FTApplySubPlan: incorrect subplan header");
				rowidx = subplan + 1;
				while (plan.entries[rowidx, coltype] != opend)
				{
					operation = plan.entries[rowidx, coltype];
					operandscnt = repcnt * plan.entries[rowidx, coloperandscnt];
					operandsize = plan.entries[rowidx, coloperandsize];
					microvectorsize = plan.entries[rowidx, colmicrovectorsize];
					param0 = plan.entries[rowidx, colparam0];
					param1 = plan.entries[rowidx, colparam1];
					apserv.touchint(ref param1);

					//
					// Process "jump" operation
					//
					if (operation == opjmp)
					{
						rowidx = rowidx + plan.entries[rowidx, colparam0];
						continue;
					}

					//
					// Process "parallel call" operation:
					// * we perform initial check for consistency between parent and child plans
					// * we call FTSplitAndApplyParallelPlan(), which splits parallel plan into
					//   several parallel tasks
					//
					if (operation == opparallelcall)
					{
						parentsize = operandsize * microvectorsize;
						childsize = plan.entries[rowidx + param0, coloperandscnt] * plan.entries[rowidx + param0, coloperandsize] * plan.entries[rowidx + param0, colmicrovectorsize];
						alglib.ap.assert(plan.entries[rowidx + param0, coltype] == opstart, "FTApplySubPlan: incorrect child subplan header");
						alglib.ap.assert(parentsize == childsize, "FTApplySubPlan: incorrect child subplan header");
						chunksize = Math.Max(recursivethreshold / childsize, 1);
						lastchunksize = operandscnt % chunksize;
						if (lastchunksize == 0)
						{
							lastchunksize = chunksize;
						}
						i = 0;
						while (i < operandscnt)
						{
							chunksize = Math.Min(chunksize, operandscnt - i);
							ftapplysubplan(plan, rowidx + param0, a, abase, aoffset + i * childsize, buf, chunksize);
							i = i + chunksize;
						}
						rowidx = rowidx + 1;
						continue;
					}

					//
					// Process "reference complex FFT" operation
					//
					if (operation == opcomplexreffft)
					{
						ftapplycomplexreffft(a, abase + aoffset, operandscnt, operandsize, microvectorsize, buf);
						rowidx = rowidx + 1;
						continue;
					}

					//
					// Process "codelet FFT" operation
					//
					if (operation == opcomplexcodeletfft)
					{
						ftapplycomplexcodeletfft(a, abase + aoffset, operandscnt, operandsize, microvectorsize);
						rowidx = rowidx + 1;
						continue;
					}

					//
					// Process "integrated codelet FFT" operation
					//
					if (operation == opcomplexcodelettwfft)
					{
						ftapplycomplexcodelettwfft(a, abase + aoffset, operandscnt, operandsize, microvectorsize);
						rowidx = rowidx + 1;
						continue;
					}

					//
					// Process Bluestein's FFT operation
					//
					if (operation == opbluesteinsfft)
					{
						alglib.ap.assert(microvectorsize == 2, "FTApplySubPlan: microvectorsize!=2 for Bluesteins FFT");
						alglib.smp.ae_shared_pool_retrieve(plan.bluesteinpool, ref bufa);
						alglib.smp.ae_shared_pool_retrieve(plan.bluesteinpool, ref bufb);
						alglib.smp.ae_shared_pool_retrieve(plan.bluesteinpool, ref bufc);
						alglib.smp.ae_shared_pool_retrieve(plan.bluesteinpool, ref bufd);
						ftbluesteinsfft(plan, a, abase, aoffset, operandscnt, operandsize, plan.entries[rowidx, colparam0], plan.entries[rowidx, colparam2], rowidx + plan.entries[rowidx, colparam1], bufa.val, bufb.val, bufc.val, bufd.val);
						alglib.smp.ae_shared_pool_recycle(plan.bluesteinpool, ref bufa);
						alglib.smp.ae_shared_pool_recycle(plan.bluesteinpool, ref bufb);
						alglib.smp.ae_shared_pool_recycle(plan.bluesteinpool, ref bufc);
						alglib.smp.ae_shared_pool_recycle(plan.bluesteinpool, ref bufd);
						rowidx = rowidx + 1;
						continue;
					}

					//
					// Process Rader's FFT
					//
					if (operation == opradersfft)
					{
						ftradersfft(plan, a, abase, aoffset, operandscnt, operandsize, rowidx + plan.entries[rowidx, colparam0], plan.entries[rowidx, colparam1], plan.entries[rowidx, colparam2], plan.entries[rowidx, colparam3], buf);
						rowidx = rowidx + 1;
						continue;
					}

					//
					// Process "complex twiddle factors" operation
					//
					if (operation == opcomplexfftfactors)
					{
						alglib.ap.assert(microvectorsize == 2, "FTApplySubPlan: MicrovectorSize<>1");
						n1 = plan.entries[rowidx, colparam0];
						n2 = operandsize / n1;
						for (i = 0; i <= operandscnt - 1; i++)
						{
							ffttwcalc(a, abase + aoffset + i * operandsize * 2, n1, n2);
						}
						rowidx = rowidx + 1;
						continue;
					}

					//
					// Process "complex transposition" operation
					//
					if (operation == opcomplextranspose)
					{
						alglib.ap.assert(microvectorsize == 2, "FTApplySubPlan: MicrovectorSize<>1");
						n1 = plan.entries[rowidx, colparam0];
						n2 = operandsize / n1;
						for (i = 0; i <= operandscnt - 1; i++)
						{
							internalcomplexlintranspose(a, n1, n2, abase + aoffset + i * operandsize * 2, buf);
						}
						rowidx = rowidx + 1;
						continue;
					}

					//
					// Error
					//
					alglib.ap.assert(false, "FTApplySubPlan: unexpected plan type");
				}
			}


			/*************************************************************************
			This subroutine applies complex reference FFT to input/output array A.

			VERY SLOW OPERATION, do not use it in real life plans :)

			INPUT PARAMETERS:
					A           -   array, must be large enough for plan to work
					Offs        -   offset of the subarray to process
					OperandsCnt -   operands count (see description of FastTransformPlan)
					OperandSize -   operand size (see description of FastTransformPlan)
					MicrovectorSize-microvector size (see description of FastTransformPlan)
					Buf         -   temporary array, must be at least OperandsCnt*OperandSize*MicrovectorSize
            
			OUTPUT PARAMETERS:
					A           -   transformed array

				-- ALGLIB --
					 Copyright 05.04.2013 by Bochkanov Sergey
			*************************************************************************/
			private static void ftapplycomplexreffft(double[] a,
					int offs,
					int operandscnt,
					int operandsize,
					int microvectorsize,
					double[] buf)
			{
				int opidx = 0;
				int i = 0;
				int k = 0;
				double hre = 0;
				double him = 0;
				double c = 0;
				double s = 0;
				double re = 0;
				double im = 0;
				int n = 0;

				alglib.ap.assert(operandscnt >= 1, "FTApplyComplexRefFFT: OperandsCnt<1");
				alglib.ap.assert(operandsize >= 1, "FTApplyComplexRefFFT: OperandSize<1");
				alglib.ap.assert(microvectorsize == 2, "FTApplyComplexRefFFT: MicrovectorSize<>2");
				n = operandsize;
				for (opidx = 0; opidx <= operandscnt - 1; opidx++)
				{
					for (i = 0; i <= n - 1; i++)
					{
						hre = 0;
						him = 0;
						for (k = 0; k <= n - 1; k++)
						{
							re = a[offs + opidx * operandsize * 2 + 2 * k + 0];
							im = a[offs + opidx * operandsize * 2 + 2 * k + 1];
							c = (double)(Math.Cos(-(2 * Math.PI * k * i / n)));
							s = (double)(Math.Sin(-(2 * Math.PI * k * i / n)));
							hre = hre + c * re - s * im;
							him = him + c * im + s * re;
						}
						buf[2 * i + 0] = hre;
						buf[2 * i + 1] = him;
					}
					for (i = 0; i <= operandsize * 2 - 1; i++)
					{
						a[offs + opidx * operandsize * 2 + i] = buf[i];
					}
				}
			}


			/*************************************************************************
			This subroutine applies complex codelet FFT to input/output array A.

			INPUT PARAMETERS:
					A           -   array, must be large enough for plan to work
					Offs        -   offset of the subarray to process
					OperandsCnt -   operands count (see description of FastTransformPlan)
					OperandSize -   operand size (see description of FastTransformPlan)
					MicrovectorSize-microvector size, must be 2
            
			OUTPUT PARAMETERS:
					A           -   transformed array

				-- ALGLIB --
					 Copyright 05.04.2013 by Bochkanov Sergey
			*************************************************************************/
			private static void ftapplycomplexcodeletfft(double[] a,
					int offs,
					int operandscnt,
					int operandsize,
					int microvectorsize)
			{
				int opidx = 0;
				int n = 0;
				int aoffset = 0;
				double a0x = 0;
				double a0y = 0;
				double a1x = 0;
				double a1y = 0;
				double a2x = 0;
				double a2y = 0;
				double a3x = 0;
				double a3y = 0;
				double a4x = 0;
				double a4y = 0;
				double a5x = 0;
				double a5y = 0;
				double v0 = 0;
				double v1 = 0;
				double v2 = 0;
				double v3 = 0;
				double t1x = 0;
				double t1y = 0;
				double t2x = 0;
				double t2y = 0;
				double t3x = 0;
				double t3y = 0;
				double t4x = 0;
				double t4y = 0;
				double t5x = 0;
				double t5y = 0;
				double m1x = 0;
				double m1y = 0;
				double m2x = 0;
				double m2y = 0;
				double m3x = 0;
				double m3y = 0;
				double m4x = 0;
				double m4y = 0;
				double m5x = 0;
				double m5y = 0;
				double s1x = 0;
				double s1y = 0;
				double s2x = 0;
				double s2y = 0;
				double s3x = 0;
				double s3y = 0;
				double s4x = 0;
				double s4y = 0;
				double s5x = 0;
				double s5y = 0;
				double c1 = 0;
				double c2 = 0;
				double c3 = 0;
				double c4 = 0;
				double c5 = 0;
				double v = 0;

				alglib.ap.assert(operandscnt >= 1, "FTApplyComplexCodeletFFT: OperandsCnt<1");
				alglib.ap.assert(operandsize >= 1, "FTApplyComplexCodeletFFT: OperandSize<1");
				alglib.ap.assert(microvectorsize == 2, "FTApplyComplexCodeletFFT: MicrovectorSize<>2");
				n = operandsize;

				//
				// Hard-coded transforms for different N's
				//
				alglib.ap.assert(n <= maxradix, "FTApplyComplexCodeletFFT: N>MaxRadix");
				if (n == 2)
				{
					for (opidx = 0; opidx <= operandscnt - 1; opidx++)
					{
						aoffset = offs + opidx * operandsize * 2;
						a0x = a[aoffset + 0];
						a0y = a[aoffset + 1];
						a1x = a[aoffset + 2];
						a1y = a[aoffset + 3];
						v0 = a0x + a1x;
						v1 = a0y + a1y;
						v2 = a0x - a1x;
						v3 = a0y - a1y;
						a[aoffset + 0] = v0;
						a[aoffset + 1] = v1;
						a[aoffset + 2] = v2;
						a[aoffset + 3] = v3;
					}
					return;
				}
				if (n == 3)
				{
					c1 = (double)(Math.Cos(2 * Math.PI / 3) - 1);
					c2 = (double)(Math.Sin(2 * Math.PI / 3));
					for (opidx = 0; opidx <= operandscnt - 1; opidx++)
					{
						aoffset = offs + opidx * operandsize * 2;
						a0x = a[aoffset + 0];
						a0y = a[aoffset + 1];
						a1x = a[aoffset + 2];
						a1y = a[aoffset + 3];
						a2x = a[aoffset + 4];
						a2y = a[aoffset + 5];
						t1x = a1x + a2x;
						t1y = a1y + a2y;
						a0x = a0x + t1x;
						a0y = a0y + t1y;
						m1x = c1 * t1x;
						m1y = c1 * t1y;
						m2x = c2 * (a1y - a2y);
						m2y = c2 * (a2x - a1x);
						s1x = a0x + m1x;
						s1y = a0y + m1y;
						a1x = s1x + m2x;
						a1y = s1y + m2y;
						a2x = s1x - m2x;
						a2y = s1y - m2y;
						a[aoffset + 0] = a0x;
						a[aoffset + 1] = a0y;
						a[aoffset + 2] = a1x;
						a[aoffset + 3] = a1y;
						a[aoffset + 4] = a2x;
						a[aoffset + 5] = a2y;
					}
					return;
				}
				if (n == 4)
				{
					for (opidx = 0; opidx <= operandscnt - 1; opidx++)
					{
						aoffset = offs + opidx * operandsize * 2;
						a0x = a[aoffset + 0];
						a0y = a[aoffset + 1];
						a1x = a[aoffset + 2];
						a1y = a[aoffset + 3];
						a2x = a[aoffset + 4];
						a2y = a[aoffset + 5];
						a3x = a[aoffset + 6];
						a3y = a[aoffset + 7];
						t1x = a0x + a2x;
						t1y = a0y + a2y;
						t2x = a1x + a3x;
						t2y = a1y + a3y;
						m2x = a0x - a2x;
						m2y = a0y - a2y;
						m3x = a1y - a3y;
						m3y = a3x - a1x;
						a[aoffset + 0] = t1x + t2x;
						a[aoffset + 1] = t1y + t2y;
						a[aoffset + 4] = t1x - t2x;
						a[aoffset + 5] = t1y - t2y;
						a[aoffset + 2] = m2x + m3x;
						a[aoffset + 3] = m2y + m3y;
						a[aoffset + 6] = m2x - m3x;
						a[aoffset + 7] = m2y - m3y;
					}
					return;
				}
				if (n == 5)
				{
					v = (double)(2 * Math.PI / 5);
					c1 = (double)((Math.Cos(v) + Math.Cos(2 * v)) / 2 - 1);
					c2 = (double)((Math.Cos(v) - Math.Cos(2 * v)) / 2);
					c3 = (double)(-Math.Sin(v));
					c4 = (double)(-(Math.Sin(v) + Math.Sin(2 * v)));
					c5 = (double)(Math.Sin(v) - Math.Sin(2 * v));
					for (opidx = 0; opidx <= operandscnt - 1; opidx++)
					{
						aoffset = offs + opidx * operandsize * 2;
						t1x = a[aoffset + 2] + a[aoffset + 8];
						t1y = a[aoffset + 3] + a[aoffset + 9];
						t2x = a[aoffset + 4] + a[aoffset + 6];
						t2y = a[aoffset + 5] + a[aoffset + 7];
						t3x = a[aoffset + 2] - a[aoffset + 8];
						t3y = a[aoffset + 3] - a[aoffset + 9];
						t4x = a[aoffset + 6] - a[aoffset + 4];
						t4y = a[aoffset + 7] - a[aoffset + 5];
						t5x = t1x + t2x;
						t5y = t1y + t2y;
						a[aoffset + 0] = a[aoffset + 0] + t5x;
						a[aoffset + 1] = a[aoffset + 1] + t5y;
						m1x = c1 * t5x;
						m1y = c1 * t5y;
						m2x = c2 * (t1x - t2x);
						m2y = c2 * (t1y - t2y);
						m3x = -(c3 * (t3y + t4y));
						m3y = c3 * (t3x + t4x);
						m4x = -(c4 * t4y);
						m4y = c4 * t4x;
						m5x = -(c5 * t3y);
						m5y = c5 * t3x;
						s3x = m3x - m4x;
						s3y = m3y - m4y;
						s5x = m3x + m5x;
						s5y = m3y + m5y;
						s1x = a[aoffset + 0] + m1x;
						s1y = a[aoffset + 1] + m1y;
						s2x = s1x + m2x;
						s2y = s1y + m2y;
						s4x = s1x - m2x;
						s4y = s1y - m2y;
						a[aoffset + 2] = s2x + s3x;
						a[aoffset + 3] = s2y + s3y;
						a[aoffset + 4] = s4x + s5x;
						a[aoffset + 5] = s4y + s5y;
						a[aoffset + 6] = s4x - s5x;
						a[aoffset + 7] = s4y - s5y;
						a[aoffset + 8] = s2x - s3x;
						a[aoffset + 9] = s2y - s3y;
					}
					return;
				}
				if (n == 6)
				{
					c1 = (double)(Math.Cos(2 * Math.PI / 3) - 1);
					c2 = (double)(Math.Sin(2 * Math.PI / 3));
					c3 = (double)(Math.Cos(-(Math.PI / 3)));
					c4 = (double)(Math.Sin(-(Math.PI / 3)));
					for (opidx = 0; opidx <= operandscnt - 1; opidx++)
					{
						aoffset = offs + opidx * operandsize * 2;
						a0x = a[aoffset + 0];
						a0y = a[aoffset + 1];
						a1x = a[aoffset + 2];
						a1y = a[aoffset + 3];
						a2x = a[aoffset + 4];
						a2y = a[aoffset + 5];
						a3x = a[aoffset + 6];
						a3y = a[aoffset + 7];
						a4x = a[aoffset + 8];
						a4y = a[aoffset + 9];
						a5x = a[aoffset + 10];
						a5y = a[aoffset + 11];
						v0 = a0x;
						v1 = a0y;
						a0x = a0x + a3x;
						a0y = a0y + a3y;
						a3x = v0 - a3x;
						a3y = v1 - a3y;
						v0 = a1x;
						v1 = a1y;
						a1x = a1x + a4x;
						a1y = a1y + a4y;
						a4x = v0 - a4x;
						a4y = v1 - a4y;
						v0 = a2x;
						v1 = a2y;
						a2x = a2x + a5x;
						a2y = a2y + a5y;
						a5x = v0 - a5x;
						a5y = v1 - a5y;
						t4x = a4x * c3 - a4y * c4;
						t4y = a4x * c4 + a4y * c3;
						a4x = t4x;
						a4y = t4y;
						t5x = -(a5x * c3) - a5y * c4;
						t5y = a5x * c4 - a5y * c3;
						a5x = t5x;
						a5y = t5y;
						t1x = a1x + a2x;
						t1y = a1y + a2y;
						a0x = a0x + t1x;
						a0y = a0y + t1y;
						m1x = c1 * t1x;
						m1y = c1 * t1y;
						m2x = c2 * (a1y - a2y);
						m2y = c2 * (a2x - a1x);
						s1x = a0x + m1x;
						s1y = a0y + m1y;
						a1x = s1x + m2x;
						a1y = s1y + m2y;
						a2x = s1x - m2x;
						a2y = s1y - m2y;
						t1x = a4x + a5x;
						t1y = a4y + a5y;
						a3x = a3x + t1x;
						a3y = a3y + t1y;
						m1x = c1 * t1x;
						m1y = c1 * t1y;
						m2x = c2 * (a4y - a5y);
						m2y = c2 * (a5x - a4x);
						s1x = a3x + m1x;
						s1y = a3y + m1y;
						a4x = s1x + m2x;
						a4y = s1y + m2y;
						a5x = s1x - m2x;
						a5y = s1y - m2y;
						a[aoffset + 0] = a0x;
						a[aoffset + 1] = a0y;
						a[aoffset + 2] = a3x;
						a[aoffset + 3] = a3y;
						a[aoffset + 4] = a1x;
						a[aoffset + 5] = a1y;
						a[aoffset + 6] = a4x;
						a[aoffset + 7] = a4y;
						a[aoffset + 8] = a2x;
						a[aoffset + 9] = a2y;
						a[aoffset + 10] = a5x;
						a[aoffset + 11] = a5y;
					}
					return;
				}
			}


			/*************************************************************************
			This subroutine applies complex "integrated" codelet FFT  to  input/output
			array A. "Integrated" codelet differs from "normal" one in following ways:
			* it can work with MicrovectorSize>1
			* hence, it can be used in Cooley-Tukey FFT without transpositions
			* it performs inlined multiplication by twiddle factors of Cooley-Tukey
				FFT with N2=MicrovectorSize/2.

			INPUT PARAMETERS:
					A           -   array, must be large enough for plan to work
					Offs        -   offset of the subarray to process
					OperandsCnt -   operands count (see description of FastTransformPlan)
					OperandSize -   operand size (see description of FastTransformPlan)
					MicrovectorSize-microvector size, must be 1
            
			OUTPUT PARAMETERS:
					A           -   transformed array

				-- ALGLIB --
					 Copyright 05.04.2013 by Bochkanov Sergey
			*************************************************************************/
			private static void ftapplycomplexcodelettwfft(double[] a,
					int offs,
					int operandscnt,
					int operandsize,
					int microvectorsize)
			{
				int opidx = 0;
				int mvidx = 0;
				int n = 0;
				int m = 0;
				int aoffset0 = 0;
				int aoffset2 = 0;
				int aoffset4 = 0;
				int aoffset6 = 0;
				int aoffset8 = 0;
				int aoffset10 = 0;
				double a0x = 0;
				double a0y = 0;
				double a1x = 0;
				double a1y = 0;
				double a2x = 0;
				double a2y = 0;
				double a3x = 0;
				double a3y = 0;
				double a4x = 0;
				double a4y = 0;
				double a5x = 0;
				double a5y = 0;
				double v0 = 0;
				double v1 = 0;
				double v2 = 0;
				double v3 = 0;
				double q0x = 0;
				double q0y = 0;
				double t1x = 0;
				double t1y = 0;
				double t2x = 0;
				double t2y = 0;
				double t3x = 0;
				double t3y = 0;
				double t4x = 0;
				double t4y = 0;
				double t5x = 0;
				double t5y = 0;
				double m1x = 0;
				double m1y = 0;
				double m2x = 0;
				double m2y = 0;
				double m3x = 0;
				double m3y = 0;
				double m4x = 0;
				double m4y = 0;
				double m5x = 0;
				double m5y = 0;
				double s1x = 0;
				double s1y = 0;
				double s2x = 0;
				double s2y = 0;
				double s3x = 0;
				double s3y = 0;
				double s4x = 0;
				double s4y = 0;
				double s5x = 0;
				double s5y = 0;
				double c1 = 0;
				double c2 = 0;
				double c3 = 0;
				double c4 = 0;
				double c5 = 0;
				double v = 0;
				double tw0 = 0;
				double tw1 = 0;
				double twx = 0;
				double twxm1 = 0;
				double twy = 0;
				double tw2x = 0;
				double tw2y = 0;
				double tw3x = 0;
				double tw3y = 0;
				double tw4x = 0;
				double tw4y = 0;
				double tw5x = 0;
				double tw5y = 0;

				alglib.ap.assert(operandscnt >= 1, "FTApplyComplexCodeletFFT: OperandsCnt<1");
				alglib.ap.assert(operandsize >= 1, "FTApplyComplexCodeletFFT: OperandSize<1");
				alglib.ap.assert(microvectorsize >= 1, "FTApplyComplexCodeletFFT: MicrovectorSize<>1");
				alglib.ap.assert(microvectorsize % 2 == 0, "FTApplyComplexCodeletFFT: MicrovectorSize is not even");
				n = operandsize;
				m = microvectorsize / 2;

				//
				// Hard-coded transforms for different N's
				//
				alglib.ap.assert(n <= maxradix, "FTApplyComplexCodeletTwFFT: N>MaxRadix");
				if (n == 2)
				{
					v = (double)(-(2 * Math.PI / (n * m)));
					tw0 = (double)(-(2 * math.sqr((double)(Math.Sin(0.5f * v)))));
					tw1 = (double)(Math.Sin(v));
					for (opidx = 0; opidx <= operandscnt - 1; opidx++)
					{
						aoffset0 = offs + opidx * operandsize * microvectorsize;
						aoffset2 = aoffset0 + microvectorsize;
						twxm1 = 0.0f;
						twy = 0.0f;
						for (mvidx = 0; mvidx <= m - 1; mvidx++)
						{
							a0x = a[aoffset0];
							a0y = a[aoffset0 + 1];
							a1x = a[aoffset2];
							a1y = a[aoffset2 + 1];
							v0 = a0x + a1x;
							v1 = a0y + a1y;
							v2 = a0x - a1x;
							v3 = a0y - a1y;
							a[aoffset0] = v0;
							a[aoffset0 + 1] = v1;
							a[aoffset2] = v2 * (1 + twxm1) - v3 * twy;
							a[aoffset2 + 1] = v3 * (1 + twxm1) + v2 * twy;
							aoffset0 = aoffset0 + 2;
							aoffset2 = aoffset2 + 2;
							if ((mvidx + 1) % updatetw == 0)
							{
								v = (double)(-(2 * Math.PI * (mvidx + 1) / (n * m)));
								twxm1 = (double)Math.Sin(0.5f * v);
								twxm1 = -(2 * twxm1 * twxm1);
								twy = (double)Math.Sin(v);
							}
							else
							{
								v = twxm1 + tw0 + twxm1 * tw0 - twy * tw1;
								twy = twy + tw1 + twxm1 * tw1 + twy * tw0;
								twxm1 = v;
							}
						}
					}
					return;
				}
				if (n == 3)
				{
					v = (double)(-(2 * Math.PI / (n * m)));
					tw0 = -(2 * math.sqr((double)Math.Sin(0.5f * v)));
					tw1 = (double)Math.Sin(v);
					c1 = (double)Math.Cos(2 * Math.PI / 3) - 1;
					c2 = (double)Math.Sin(2 * Math.PI / 3);
					for (opidx = 0; opidx <= operandscnt - 1; opidx++)
					{
						aoffset0 = offs + opidx * operandsize * microvectorsize;
						aoffset2 = aoffset0 + microvectorsize;
						aoffset4 = aoffset2 + microvectorsize;
						twx = 1.0f;
						twxm1 = 0.0f;
						twy = 0.0f;
						for (mvidx = 0; mvidx <= m - 1; mvidx++)
						{
							a0x = a[aoffset0];
							a0y = a[aoffset0 + 1];
							a1x = a[aoffset2];
							a1y = a[aoffset2 + 1];
							a2x = a[aoffset4];
							a2y = a[aoffset4 + 1];
							t1x = a1x + a2x;
							t1y = a1y + a2y;
							a0x = a0x + t1x;
							a0y = a0y + t1y;
							m1x = c1 * t1x;
							m1y = c1 * t1y;
							m2x = c2 * (a1y - a2y);
							m2y = c2 * (a2x - a1x);
							s1x = a0x + m1x;
							s1y = a0y + m1y;
							a1x = s1x + m2x;
							a1y = s1y + m2y;
							a2x = s1x - m2x;
							a2y = s1y - m2y;
							tw2x = twx * twx - twy * twy;
							tw2y = 2 * twx * twy;
							a[aoffset0] = a0x;
							a[aoffset0 + 1] = a0y;
							a[aoffset2] = a1x * twx - a1y * twy;
							a[aoffset2 + 1] = a1y * twx + a1x * twy;
							a[aoffset4] = a2x * tw2x - a2y * tw2y;
							a[aoffset4 + 1] = a2y * tw2x + a2x * tw2y;
							aoffset0 = aoffset0 + 2;
							aoffset2 = aoffset2 + 2;
							aoffset4 = aoffset4 + 2;
							if ((mvidx + 1) % updatetw == 0)
							{
								v = (double)(-(2 * Math.PI * (mvidx + 1) / (n * m)));
								twxm1 = (double)Math.Sin(0.5f * v);
								twxm1 = -(2 * twxm1 * twxm1);
								twy = (double)Math.Sin(v);
								twx = twxm1 + 1;
							}
							else
							{
								v = twxm1 + tw0 + twxm1 * tw0 - twy * tw1;
								twy = twy + tw1 + twxm1 * tw1 + twy * tw0;
								twxm1 = v;
								twx = v + 1;
							}
						}
					}
					return;
				}
				if (n == 4)
				{
					v = (double)(-(2 * Math.PI / (n * m)));
					tw0 = (double)(-(2 * math.sqr((double)Math.Sin(0.5f * v))));
					tw1 = (double)Math.Sin(v);
					for (opidx = 0; opidx <= operandscnt - 1; opidx++)
					{
						aoffset0 = offs + opidx * operandsize * microvectorsize;
						aoffset2 = aoffset0 + microvectorsize;
						aoffset4 = aoffset2 + microvectorsize;
						aoffset6 = aoffset4 + microvectorsize;
						twx = 1.0f;
						twxm1 = 0.0f;
						twy = 0.0f;
						for (mvidx = 0; mvidx <= m - 1; mvidx++)
						{
							a0x = a[aoffset0];
							a0y = a[aoffset0 + 1];
							a1x = a[aoffset2];
							a1y = a[aoffset2 + 1];
							a2x = a[aoffset4];
							a2y = a[aoffset4 + 1];
							a3x = a[aoffset6];
							a3y = a[aoffset6 + 1];
							t1x = a0x + a2x;
							t1y = a0y + a2y;
							t2x = a1x + a3x;
							t2y = a1y + a3y;
							m2x = a0x - a2x;
							m2y = a0y - a2y;
							m3x = a1y - a3y;
							m3y = a3x - a1x;
							tw2x = twx * twx - twy * twy;
							tw2y = 2 * twx * twy;
							tw3x = twx * tw2x - twy * tw2y;
							tw3y = twx * tw2y + twy * tw2x;
							a1x = m2x + m3x;
							a1y = m2y + m3y;
							a2x = t1x - t2x;
							a2y = t1y - t2y;
							a3x = m2x - m3x;
							a3y = m2y - m3y;
							a[aoffset0] = t1x + t2x;
							a[aoffset0 + 1] = t1y + t2y;
							a[aoffset2] = a1x * twx - a1y * twy;
							a[aoffset2 + 1] = a1y * twx + a1x * twy;
							a[aoffset4] = a2x * tw2x - a2y * tw2y;
							a[aoffset4 + 1] = a2y * tw2x + a2x * tw2y;
							a[aoffset6] = a3x * tw3x - a3y * tw3y;
							a[aoffset6 + 1] = a3y * tw3x + a3x * tw3y;
							aoffset0 = aoffset0 + 2;
							aoffset2 = aoffset2 + 2;
							aoffset4 = aoffset4 + 2;
							aoffset6 = aoffset6 + 2;
							if ((mvidx + 1) % updatetw == 0)
							{
								v = (double)(-(2 * Math.PI * (mvidx + 1) / (n * m)));
								twxm1 = (double)Math.Sin(0.5f * v);
								twxm1 = -(2 * twxm1 * twxm1);
								twy = (double)Math.Sin(v);
								twx = twxm1 + 1;
							}
							else
							{
								v = twxm1 + tw0 + twxm1 * tw0 - twy * tw1;
								twy = twy + tw1 + twxm1 * tw1 + twy * tw0;
								twxm1 = v;
								twx = v + 1;
							}
						}
					}
					return;
				}
				if (n == 5)
				{
					v = (double)(-(2 * Math.PI / (n * m)));
					tw0 = (double)(-(2 * math.sqr((double)Math.Sin(0.5f * v))));
					tw1 = (double)(Math.Sin(v));
					v = (double)(2 * Math.PI / 5);
					c1 = (double)((Math.Cos(v) + Math.Cos(2 * v)) / 2 - 1);
					c2 = (double)((Math.Cos(v) - Math.Cos(2 * v)) / 2);
					c3 = (double)(-Math.Sin(v));
					c4 = (double)(-(Math.Sin(v) + Math.Sin(2 * v)));
					c5 = (double)(Math.Sin(v) - Math.Sin(2 * v));
					for (opidx = 0; opidx <= operandscnt - 1; opidx++)
					{
						aoffset0 = offs + opidx * operandsize * microvectorsize;
						aoffset2 = aoffset0 + microvectorsize;
						aoffset4 = aoffset2 + microvectorsize;
						aoffset6 = aoffset4 + microvectorsize;
						aoffset8 = aoffset6 + microvectorsize;
						twx = 1.0f;
						twxm1 = 0.0f;
						twy = 0.0f;
						for (mvidx = 0; mvidx <= m - 1; mvidx++)
						{
							a0x = a[aoffset0];
							a0y = a[aoffset0 + 1];
							a1x = a[aoffset2];
							a1y = a[aoffset2 + 1];
							a2x = a[aoffset4];
							a2y = a[aoffset4 + 1];
							a3x = a[aoffset6];
							a3y = a[aoffset6 + 1];
							a4x = a[aoffset8];
							a4y = a[aoffset8 + 1];
							t1x = a1x + a4x;
							t1y = a1y + a4y;
							t2x = a2x + a3x;
							t2y = a2y + a3y;
							t3x = a1x - a4x;
							t3y = a1y - a4y;
							t4x = a3x - a2x;
							t4y = a3y - a2y;
							t5x = t1x + t2x;
							t5y = t1y + t2y;
							q0x = a0x + t5x;
							q0y = a0y + t5y;
							m1x = c1 * t5x;
							m1y = c1 * t5y;
							m2x = c2 * (t1x - t2x);
							m2y = c2 * (t1y - t2y);
							m3x = -(c3 * (t3y + t4y));
							m3y = c3 * (t3x + t4x);
							m4x = -(c4 * t4y);
							m4y = c4 * t4x;
							m5x = -(c5 * t3y);
							m5y = c5 * t3x;
							s3x = m3x - m4x;
							s3y = m3y - m4y;
							s5x = m3x + m5x;
							s5y = m3y + m5y;
							s1x = q0x + m1x;
							s1y = q0y + m1y;
							s2x = s1x + m2x;
							s2y = s1y + m2y;
							s4x = s1x - m2x;
							s4y = s1y - m2y;
							tw2x = twx * twx - twy * twy;
							tw2y = 2 * twx * twy;
							tw3x = twx * tw2x - twy * tw2y;
							tw3y = twx * tw2y + twy * tw2x;
							tw4x = tw2x * tw2x - tw2y * tw2y;
							tw4y = tw2x * tw2y + tw2y * tw2x;
							a1x = s2x + s3x;
							a1y = s2y + s3y;
							a2x = s4x + s5x;
							a2y = s4y + s5y;
							a3x = s4x - s5x;
							a3y = s4y - s5y;
							a4x = s2x - s3x;
							a4y = s2y - s3y;
							a[aoffset0] = q0x;
							a[aoffset0 + 1] = q0y;
							a[aoffset2] = a1x * twx - a1y * twy;
							a[aoffset2 + 1] = a1x * twy + a1y * twx;
							a[aoffset4] = a2x * tw2x - a2y * tw2y;
							a[aoffset4 + 1] = a2x * tw2y + a2y * tw2x;
							a[aoffset6] = a3x * tw3x - a3y * tw3y;
							a[aoffset6 + 1] = a3x * tw3y + a3y * tw3x;
							a[aoffset8] = a4x * tw4x - a4y * tw4y;
							a[aoffset8 + 1] = a4x * tw4y + a4y * tw4x;
							aoffset0 = aoffset0 + 2;
							aoffset2 = aoffset2 + 2;
							aoffset4 = aoffset4 + 2;
							aoffset6 = aoffset6 + 2;
							aoffset8 = aoffset8 + 2;
							if ((mvidx + 1) % updatetw == 0)
							{
								v = (double)(-(2 * Math.PI * (mvidx + 1) / (n * m)));
								twxm1 = (double)Math.Sin(0.5f * v);
								twxm1 = -(2 * twxm1 * twxm1);
								twy = (double)Math.Sin(v);
								twx = twxm1 + 1;
							}
							else
							{
								v = twxm1 + tw0 + twxm1 * tw0 - twy * tw1;
								twy = twy + tw1 + twxm1 * tw1 + twy * tw0;
								twxm1 = v;
								twx = v + 1;
							}
						}
					}
					return;
				}
				if (n == 6)
				{
					c1 = (double)(Math.Cos(2 * Math.PI / 3) - 1);
					c2 = (double)(Math.Sin(2 * Math.PI / 3));
					c3 = (double)(Math.Cos(-(Math.PI / 3)));
					c4 = (double)(Math.Sin(-(Math.PI / 3)));
					v = (double)(-(2 * Math.PI / (n * m)));
					tw0 = (double)(-(2 * math.sqr((double)Math.Sin(0.5f * v))));
					tw1 = (double)(Math.Sin(v));
					for (opidx = 0; opidx <= operandscnt - 1; opidx++)
					{
						aoffset0 = offs + opidx * operandsize * microvectorsize;
						aoffset2 = aoffset0 + microvectorsize;
						aoffset4 = aoffset2 + microvectorsize;
						aoffset6 = aoffset4 + microvectorsize;
						aoffset8 = aoffset6 + microvectorsize;
						aoffset10 = aoffset8 + microvectorsize;
						twx = 1.0f;
						twxm1 = 0.0f;
						twy = 0.0f;
						for (mvidx = 0; mvidx <= m - 1; mvidx++)
						{
							a0x = a[aoffset0 + 0];
							a0y = a[aoffset0 + 1];
							a1x = a[aoffset2 + 0];
							a1y = a[aoffset2 + 1];
							a2x = a[aoffset4 + 0];
							a2y = a[aoffset4 + 1];
							a3x = a[aoffset6 + 0];
							a3y = a[aoffset6 + 1];
							a4x = a[aoffset8 + 0];
							a4y = a[aoffset8 + 1];
							a5x = a[aoffset10 + 0];
							a5y = a[aoffset10 + 1];
							v0 = a0x;
							v1 = a0y;
							a0x = a0x + a3x;
							a0y = a0y + a3y;
							a3x = v0 - a3x;
							a3y = v1 - a3y;
							v0 = a1x;
							v1 = a1y;
							a1x = a1x + a4x;
							a1y = a1y + a4y;
							a4x = v0 - a4x;
							a4y = v1 - a4y;
							v0 = a2x;
							v1 = a2y;
							a2x = a2x + a5x;
							a2y = a2y + a5y;
							a5x = v0 - a5x;
							a5y = v1 - a5y;
							t4x = a4x * c3 - a4y * c4;
							t4y = a4x * c4 + a4y * c3;
							a4x = t4x;
							a4y = t4y;
							t5x = -(a5x * c3) - a5y * c4;
							t5y = a5x * c4 - a5y * c3;
							a5x = t5x;
							a5y = t5y;
							t1x = a1x + a2x;
							t1y = a1y + a2y;
							a0x = a0x + t1x;
							a0y = a0y + t1y;
							m1x = c1 * t1x;
							m1y = c1 * t1y;
							m2x = c2 * (a1y - a2y);
							m2y = c2 * (a2x - a1x);
							s1x = a0x + m1x;
							s1y = a0y + m1y;
							a1x = s1x + m2x;
							a1y = s1y + m2y;
							a2x = s1x - m2x;
							a2y = s1y - m2y;
							t1x = a4x + a5x;
							t1y = a4y + a5y;
							a3x = a3x + t1x;
							a3y = a3y + t1y;
							m1x = c1 * t1x;
							m1y = c1 * t1y;
							m2x = c2 * (a4y - a5y);
							m2y = c2 * (a5x - a4x);
							s1x = a3x + m1x;
							s1y = a3y + m1y;
							a4x = s1x + m2x;
							a4y = s1y + m2y;
							a5x = s1x - m2x;
							a5y = s1y - m2y;
							tw2x = twx * twx - twy * twy;
							tw2y = 2 * twx * twy;
							tw3x = twx * tw2x - twy * tw2y;
							tw3y = twx * tw2y + twy * tw2x;
							tw4x = tw2x * tw2x - tw2y * tw2y;
							tw4y = 2 * tw2x * tw2y;
							tw5x = tw3x * tw2x - tw3y * tw2y;
							tw5y = tw3x * tw2y + tw3y * tw2x;
							a[aoffset0 + 0] = a0x;
							a[aoffset0 + 1] = a0y;
							a[aoffset2 + 0] = a3x * twx - a3y * twy;
							a[aoffset2 + 1] = a3y * twx + a3x * twy;
							a[aoffset4 + 0] = a1x * tw2x - a1y * tw2y;
							a[aoffset4 + 1] = a1y * tw2x + a1x * tw2y;
							a[aoffset6 + 0] = a4x * tw3x - a4y * tw3y;
							a[aoffset6 + 1] = a4y * tw3x + a4x * tw3y;
							a[aoffset8 + 0] = a2x * tw4x - a2y * tw4y;
							a[aoffset8 + 1] = a2y * tw4x + a2x * tw4y;
							a[aoffset10 + 0] = a5x * tw5x - a5y * tw5y;
							a[aoffset10 + 1] = a5y * tw5x + a5x * tw5y;
							aoffset0 = aoffset0 + 2;
							aoffset2 = aoffset2 + 2;
							aoffset4 = aoffset4 + 2;
							aoffset6 = aoffset6 + 2;
							aoffset8 = aoffset8 + 2;
							aoffset10 = aoffset10 + 2;
							if ((mvidx + 1) % updatetw == 0)
							{
								v = (double)(-(2 * Math.PI * (mvidx + 1) / (n * m)));
								twxm1 = (double)Math.Sin(0.5f * v);
								twxm1 = -(2 * twxm1 * twxm1);
								twy = (double)Math.Sin(v);
								twx = twxm1 + 1;
							}
							else
							{
								v = twxm1 + tw0 + twxm1 * tw0 - twy * tw1;
								twy = twy + tw1 + twxm1 * tw1 + twy * tw0;
								twxm1 = v;
								twx = v + 1;
							}
						}
					}
					return;
				}
			}


			/*************************************************************************
			This subroutine precomputes data for complex Bluestein's  FFT  and  writes
			them to array PrecR[] at specified offset. It  is  responsibility  of  the
			caller to make sure that PrecR[] is large enough.

			INPUT PARAMETERS:
					N           -   original size of the transform
					M           -   size of the "padded" Bluestein's transform
					PrecR       -   preallocated array
					Offs        -   offset
            
			OUTPUT PARAMETERS:
					PrecR       -   data at Offs:Offs+4*M-1 are modified:
													* PrecR[Offs:Offs+2*M-1] stores Z[k]=exp(i*pi*k^2/N)
													* PrecR[Offs+2*M:Offs+4*M-1] stores FFT of the Z
													Other parts of PrecR are unchanged.
                            
			NOTE: this function performs internal M-point FFT. It allocates temporary
						plan which is destroyed after leaving this function.

				-- ALGLIB --
					 Copyright 08.05.2013 by Bochkanov Sergey
			*************************************************************************/
			private static void ftprecomputebluesteinsfft(int n,
					int m,
					double[] precr,
					int offs)
			{
				int i = 0;
				double bx = 0;
				double by = 0;
				fasttransformplan plan = new fasttransformplan();


				//
				// Fill first half of PrecR with b[k] = exp(i*pi*k^2/N)
				//
				for (i = 0; i <= 2 * m - 1; i++)
				{
					precr[offs + i] = 0;
				}
				for (i = 0; i <= n - 1; i++)
				{
					bx = (double)Math.Cos(Math.PI / n * i * i);
					by = (double)Math.Sin(Math.PI / n * i * i);
					precr[offs + 2 * i + 0] = bx;
					precr[offs + 2 * i + 1] = by;
					precr[offs + 2 * ((m - i) % m) + 0] = bx;
					precr[offs + 2 * ((m - i) % m) + 1] = by;
				}

				//
				// Precomputed FFT
				//
				ftcomplexfftplan(m, 1, plan);
				for (i = 0; i <= 2 * m - 1; i++)
				{
					precr[offs + 2 * m + i] = precr[offs + i];
				}
				ftapplysubplan(plan, 0, precr, offs + 2 * m, 0, plan.buffer, 1);
			}


			/*************************************************************************
			This subroutine applies complex Bluestein's FFT to input/output array A.

			INPUT PARAMETERS:
					Plan        -   transformation plan
					A           -   array, must be large enough for plan to work
					ABase       -   base offset in array A, this value points to start of
													subarray whose length is equal to length of the plan
					AOffset     -   offset with respect to ABase, 0<=AOffset<PlanLength.
													This is an offset within large PlanLength-subarray of
													the chunk to process.
					OperandsCnt -   number of repeated operands (length N each)
					N           -   original data length (measured in complex numbers)
					M           -   padded data length (measured in complex numbers)
					PrecOffs    -   offset of the precomputed data for the plan
					SubPlan     -   position of the length-M FFT subplan which is used by
													transformation
					BufA        -   temporary buffer, at least 2*M elements
					BufB        -   temporary buffer, at least 2*M elements
					BufC        -   temporary buffer, at least 2*M elements
					BufD        -   temporary buffer, at least 2*M elements
            
			OUTPUT PARAMETERS:
					A           -   transformed array

				-- ALGLIB --
					 Copyright 05.04.2013 by Bochkanov Sergey
			*************************************************************************/
			private static void ftbluesteinsfft(fasttransformplan plan,
					double[] a,
					int abase,
					int aoffset,
					int operandscnt,
					int n,
					int m,
					int precoffs,
					int subplan,
					double[] bufa,
					double[] bufb,
					double[] bufc,
					double[] bufd)
			{
				int op = 0;
				int i = 0;
				double x = 0;
				double y = 0;
				double bx = 0;
				double by = 0;
				double ax = 0;
				double ay = 0;
				double rx = 0;
				double ry = 0;
				int p0 = 0;
				int p1 = 0;
				int p2 = 0;

				for (op = 0; op <= operandscnt - 1; op++)
				{

					//
					// Multiply A by conj(Z), store to buffer.
					// Pad A by zeros.
					//
					// NOTE: Z[k]=exp(i*pi*k^2/N)
					//
					p0 = abase + aoffset + op * 2 * n;
					p1 = precoffs;
					for (i = 0; i <= n - 1; i++)
					{
						x = a[p0 + 0];
						y = a[p0 + 1];
						bx = plan.precr[p1 + 0];
						by = -plan.precr[p1 + 1];
						bufa[2 * i + 0] = x * bx - y * by;
						bufa[2 * i + 1] = x * by + y * bx;
						p0 = p0 + 2;
						p1 = p1 + 2;
					}
					for (i = 2 * n; i <= 2 * m - 1; i++)
					{
						bufa[i] = 0;
					}

					//
					// Perform convolution of A and Z (using precomputed
					// FFT of Z stored in Plan structure).
					//
					ftapplysubplan(plan, subplan, bufa, 0, 0, bufc, 1);
					p0 = 0;
					p1 = precoffs + 2 * m;
					for (i = 0; i <= m - 1; i++)
					{
						ax = bufa[p0 + 0];
						ay = bufa[p0 + 1];
						bx = plan.precr[p1 + 0];
						by = plan.precr[p1 + 1];
						bufa[p0 + 0] = ax * bx - ay * by;
						bufa[p0 + 1] = -(ax * by + ay * bx);
						p0 = p0 + 2;
						p1 = p1 + 2;
					}
					ftapplysubplan(plan, subplan, bufa, 0, 0, bufc, 1);

					//
					// Post processing:
					//     A:=conj(Z)*conj(A)/M
					// Here conj(A)/M corresponds to last stage of inverse DFT,
					// and conj(Z) comes from Bluestein's FFT algorithm.
					//
					p0 = precoffs;
					p1 = 0;
					p2 = abase + aoffset + op * 2 * n;
					for (i = 0; i <= n - 1; i++)
					{
						bx = plan.precr[p0 + 0];
						by = plan.precr[p0 + 1];
						rx = bufa[p1 + 0] / m;
						ry = -(bufa[p1 + 1] / m);
						a[p2 + 0] = rx * bx - ry * -by;
						a[p2 + 1] = rx * -by + ry * bx;
						p0 = p0 + 2;
						p1 = p1 + 2;
						p2 = p2 + 2;
					}
				}
			}


			/*************************************************************************
			This subroutine precomputes data for complex Rader's FFT and  writes  them
			to array PrecR[] at specified offset. It  is  responsibility of the caller
			to make sure that PrecR[] is large enough.

			INPUT PARAMETERS:
					N           -   original size of the transform (before reduction to N-1)
					RQ          -   primitive root modulo N
					RIQ         -   inverse of primitive root modulo N
					PrecR       -   preallocated array
					Offs        -   offset
            
			OUTPUT PARAMETERS:
					PrecR       -   data at Offs:Offs+2*(N-1)-1 store FFT of Rader's factors,
													other parts of PrecR are unchanged.
                            
			NOTE: this function performs internal (N-1)-point FFT. It allocates temporary
						plan which is destroyed after leaving this function.

				-- ALGLIB --
					 Copyright 08.05.2013 by Bochkanov Sergey
			*************************************************************************/
			private static void ftprecomputeradersfft(int n,
					int rq,
					int riq,
					double[] precr,
					int offs)
			{
				int q = 0;
				fasttransformplan plan = new fasttransformplan();
				int kiq = 0;
				double v = 0;


				//
				// Fill PrecR with Rader factors, perform FFT
				//
				kiq = 1;
				for (q = 0; q <= n - 2; q++)
				{
					v = (double)(-(2 * Math.PI * kiq / n));
					precr[offs + 2 * q + 0] = (double)Math.Cos(v);
					precr[offs + 2 * q + 1] = (double)Math.Sin(v);
					kiq = kiq * riq % n;
				}
				ftcomplexfftplan(n - 1, 1, plan);
				ftapplysubplan(plan, 0, precr, offs, 0, plan.buffer, 1);
			}


			/*************************************************************************
			This subroutine applies complex Rader's FFT to input/output array A.

			INPUT PARAMETERS:
					A           -   array, must be large enough for plan to work
					ABase       -   base offset in array A, this value points to start of
													subarray whose length is equal to length of the plan
					AOffset     -   offset with respect to ABase, 0<=AOffset<PlanLength.
													This is an offset within large PlanLength-subarray of
													the chunk to process.
					OperandsCnt -   number of repeated operands (length N each)
					N           -   original data length (measured in complex numbers)
					SubPlan     -   position of the (N-1)-point FFT subplan which is used
													by transformation
					RQ          -   primitive root modulo N
					RIQ         -   inverse of primitive root modulo N
					PrecOffs    -   offset of the precomputed data for the plan
					Buf         -   temporary array
            
			OUTPUT PARAMETERS:
					A           -   transformed array

				-- ALGLIB --
					 Copyright 05.04.2013 by Bochkanov Sergey
			*************************************************************************/
			private static void ftradersfft(fasttransformplan plan,
					double[] a,
					int abase,
					int aoffset,
					int operandscnt,
					int n,
					int subplan,
					int rq,
					int riq,
					int precoffs,
					double[] buf)
			{
				int opidx = 0;
				int i = 0;
				int q = 0;
				int kq = 0;
				int kiq = 0;
				double x0 = 0;
				double y0 = 0;
				int p0 = 0;
				int p1 = 0;
				double ax = 0;
				double ay = 0;
				double bx = 0;
				double by = 0;
				double rx = 0;
				double ry = 0;

				alglib.ap.assert(operandscnt >= 1, "FTApplyComplexRefFFT: OperandsCnt<1");

				//
				// Process operands
				//
				for (opidx = 0; opidx <= operandscnt - 1; opidx++)
				{

					//
					// fill QA
					//
					kq = 1;
					p0 = abase + aoffset + opidx * n * 2;
					p1 = aoffset + opidx * n * 2;
					rx = a[p0 + 0];
					ry = a[p0 + 1];
					x0 = rx;
					y0 = ry;
					for (q = 0; q <= n - 2; q++)
					{
						ax = a[p0 + 2 * kq + 0];
						ay = a[p0 + 2 * kq + 1];
						buf[p1 + 0] = ax;
						buf[p1 + 1] = ay;
						rx = rx + ax;
						ry = ry + ay;
						kq = kq * rq % n;
						p1 = p1 + 2;
					}
					p0 = abase + aoffset + opidx * n * 2;
					p1 = aoffset + opidx * n * 2;
					for (q = 0; q <= n - 2; q++)
					{
						a[p0] = buf[p1];
						a[p0 + 1] = buf[p1 + 1];
						p0 = p0 + 2;
						p1 = p1 + 2;
					}

					//
					// Convolution
					//
					ftapplysubplan(plan, subplan, a, abase, aoffset + opidx * n * 2, buf, 1);
					p0 = abase + aoffset + opidx * n * 2;
					p1 = precoffs;
					for (i = 0; i <= n - 2; i++)
					{
						ax = a[p0 + 0];
						ay = a[p0 + 1];
						bx = plan.precr[p1 + 0];
						by = plan.precr[p1 + 1];
						a[p0 + 0] = ax * bx - ay * by;
						a[p0 + 1] = -(ax * by + ay * bx);
						p0 = p0 + 2;
						p1 = p1 + 2;
					}
					ftapplysubplan(plan, subplan, a, abase, aoffset + opidx * n * 2, buf, 1);
					p0 = abase + aoffset + opidx * n * 2;
					for (i = 0; i <= n - 2; i++)
					{
						a[p0 + 0] = a[p0 + 0] / (n - 1);
						a[p0 + 1] = -(a[p0 + 1] / (n - 1));
						p0 = p0 + 2;
					}

					//
					// Result
					//
					buf[aoffset + opidx * n * 2 + 0] = rx;
					buf[aoffset + opidx * n * 2 + 1] = ry;
					kiq = 1;
					p0 = aoffset + opidx * n * 2;
					p1 = abase + aoffset + opidx * n * 2;
					for (q = 0; q <= n - 2; q++)
					{
						buf[p0 + 2 * kiq + 0] = x0 + a[p1 + 0];
						buf[p0 + 2 * kiq + 1] = y0 + a[p1 + 1];
						kiq = kiq * riq % n;
						p1 = p1 + 2;
					}
					p0 = abase + aoffset + opidx * n * 2;
					p1 = aoffset + opidx * n * 2;
					for (q = 0; q <= n - 1; q++)
					{
						a[p0] = buf[p1];
						a[p0 + 1] = buf[p1 + 1];
						p0 = p0 + 2;
						p1 = p1 + 2;
					}
				}
			}


			/*************************************************************************
			Factorizes task size N into product of two smaller sizes N1 and N2

			INPUT PARAMETERS:
					N       -   task size, N>0
					IsRoot  -   whether taks is root task (first one in a sequence)
            
			OUTPUT PARAMETERS:
					N1, N2  -   such numbers that:
											* for prime N:                  N1=N2=0
											* for composite N<=MaxRadix:    N1=N2=0
											* for composite N>MaxRadix:     1<=N1<=N2, N1*N2=N

				-- ALGLIB --
					 Copyright 08.04.2013 by Bochkanov Sergey
			*************************************************************************/
			private static void ftfactorize(int n,
					bool isroot,
					ref int n1,
					ref int n2)
			{
				int j = 0;
				int k = 0;

				n1 = 0;
				n2 = 0;

				alglib.ap.assert(n > 0, "FTFactorize: N<=0");
				n1 = 0;
				n2 = 0;

				//
				// Small N
				//
				if (n <= maxradix)
				{
					return;
				}

				//
				// Large N, recursive split
				//
				if (n > recursivethreshold)
				{
					k = (int)Math.Ceiling(Math.Sqrt(n)) + 1;
					alglib.ap.assert(k * k >= n, "FTFactorize: internal error during recursive factorization");
					for (j = k; j >= 2; j--)
					{
						if (n % j == 0)
						{
							n1 = Math.Min(n / j, j);
							n2 = Math.Max(n / j, j);
							return;
						}
					}
				}

				//
				// N>MaxRadix, try to find good codelet
				//
				for (j = maxradix; j >= 2; j--)
				{
					if (n % j == 0)
					{
						n1 = j;
						n2 = n / j;
						break;
					}
				}

				//
				// In case no good codelet was found,
				// try to factorize N into product of ANY primes.
				//
				if (n1 * n2 != n)
				{
					for (j = 2; j <= n - 1; j++)
					{
						if (n % j == 0)
						{
							n1 = j;
							n2 = n / j;
							break;
						}
						if (j * j > n)
						{
							break;
						}
					}
				}

				//
				// normalize
				//
				if (n1 > n2)
				{
					j = n1;
					n1 = n2;
					n2 = j;
				}
			}


			/*************************************************************************
			Returns optimistic estimate of the FFT cost, in UNITs (1 UNIT = 100 KFLOPs)

			INPUT PARAMETERS:
					N       -   task size, N>0
            
			RESULU:
					cost in UNITs, rounded down to nearest integer

			NOTE: If FFT cost is less than 1 UNIT, it will return 0 as result.

				-- ALGLIB --
					 Copyright 08.04.2013 by Bochkanov Sergey
			*************************************************************************/
			private static int ftoptimisticestimate(int n)
			{
				int result = 0;

				alglib.ap.assert(n > 0, "FTOptimisticEstimate: N<=0");
				result = (int)Math.Floor(1.0E-5 * 5 * n * Math.Log(n) / Math.Log(2));
				return result;
			}


			/*************************************************************************
			Twiddle factors calculation

				-- ALGLIB --
					 Copyright 01.05.2009 by Bochkanov Sergey
			*************************************************************************/
			private static void ffttwcalc(double[] a,
					int aoffset,
					int n1,
					int n2)
			{
				int i = 0;
				int j2 = 0;
				int n = 0;
				int halfn1 = 0;
				int offs = 0;
				double x = 0;
				double y = 0;
				double twxm1 = 0;
				double twy = 0;
				double twbasexm1 = 0;
				double twbasey = 0;
				double twrowxm1 = 0;
				double twrowy = 0;
				double tmpx = 0;
				double tmpy = 0;
				double v = 0;
				int updatetw2 = 0;


				//
				// Multiplication by twiddle factors for complex Cooley-Tukey FFT
				// with N factorized as N1*N2.
				//
				// Naive solution to this problem is given below:
				//
				//     > for K:=1 to N2-1 do
				//     >     for J:=1 to N1-1 do
				//     >     begin
				//     >         Idx:=K*N1+J;
				//     >         X:=A[AOffset+2*Idx+0];
				//     >         Y:=A[AOffset+2*Idx+1];
				//     >         TwX:=Cos(-2*Pi()*K*J/(N1*N2));
				//     >         TwY:=Sin(-2*Pi()*K*J/(N1*N2));
				//     >         A[AOffset+2*Idx+0]:=X*TwX-Y*TwY;
				//     >         A[AOffset+2*Idx+1]:=X*TwY+Y*TwX;
				//     >     end;
				//
				// However, there are exist more efficient solutions.
				//
				// Each pass of the inner cycle corresponds to multiplication of one
				// entry of A by W[k,j]=exp(-I*2*pi*k*j/N). This factor can be rewritten
				// as exp(-I*2*pi*k/N)^j. So we can replace costly exponentiation by
				// repeated multiplication: W[k,j+1]=W[k,j]*exp(-I*2*pi*k/N), with
				// second factor being computed once in the beginning of the iteration.
				//
				// Also, exp(-I*2*pi*k/N) can be represented as exp(-I*2*pi/N)^k, i.e.
				// we have W[K+1,1]=W[K,1]*W[1,1].
				//
				// In our loop we use following variables:
				// * [TwBaseXM1,TwBaseY] =   [cos(2*pi/N)-1,     sin(2*pi/N)]
				// * [TwRowXM1, TwRowY]  =   [cos(2*pi*I/N)-1,   sin(2*pi*I/N)]
				// * [TwXM1,    TwY]     =   [cos(2*pi*I*J/N)-1, sin(2*pi*I*J/N)]
				//
				// Meaning of the variables:
				// * [TwXM1,TwY] is current twiddle factor W[I,J]
				// * [TwRowXM1, TwRowY] is W[I,1]
				// * [TwBaseXM1,TwBaseY] is W[1,1]
				//
				// During inner loop we multiply current twiddle factor by W[I,1],
				// during outer loop we update W[I,1].
				//
				//
				alglib.ap.assert(updatetw >= 2, "FFTTwCalc: internal error - UpdateTw<2");
				updatetw2 = updatetw / 2;
				halfn1 = n1 / 2;
				n = n1 * n2;
				v = -(double)((2 * Math.PI / n));
				twbasexm1 = (double)(-(2 * math.sqr((double)Math.Sin(0.5f * v))));
				twbasey = (double)Math.Sin(v);
				twrowxm1 = 0;
				twrowy = 0;
				offs = aoffset;
				for (i = 0; i <= n2 - 1; i++)
				{

					//
					// Initialize twiddle factor for current row
					//
					twxm1 = 0;
					twy = 0;

					//
					// N1-point block is separated into 2-point chunks and residual 1-point chunk
					// (in case N1 is odd). Unrolled loop is several times faster.
					//
					for (j2 = 0; j2 <= halfn1 - 1; j2++)
					{

						//
						// Processing:
						// * process first element in a chunk.
						// * update twiddle factor (unconditional update)
						// * process second element
						// * conditional update of the twiddle factor
						//
						x = a[offs + 0];
						y = a[offs + 1];
						tmpx = x * (1 + twxm1) - y * twy;
						tmpy = x * twy + y * (1 + twxm1);
						a[offs + 0] = tmpx;
						a[offs + 1] = tmpy;
						tmpx = (1 + twxm1) * twrowxm1 - twy * twrowy;
						twy = twy + (1 + twxm1) * twrowy + twy * twrowxm1;
						twxm1 = twxm1 + tmpx;
						x = a[offs + 2];
						y = a[offs + 3];
						tmpx = x * (1 + twxm1) - y * twy;
						tmpy = x * twy + y * (1 + twxm1);
						a[offs + 2] = tmpx;
						a[offs + 3] = tmpy;
						offs = offs + 4;
						if ((j2 + 1) % updatetw2 == 0 && j2 < halfn1 - 1)
						{

							//
							// Recalculate twiddle factor
							//
							v = (double)(-(2 * Math.PI * i * 2 * (j2 + 1) / n));
							twxm1 = (double)(Math.Sin(0.5f * v));
							twxm1 = -(2 * twxm1 * twxm1);
							twy = (double)(Math.Sin(v));
						}
						else
						{

							//
							// Update twiddle factor
							//
							tmpx = (1 + twxm1) * twrowxm1 - twy * twrowy;
							twy = twy + (1 + twxm1) * twrowy + twy * twrowxm1;
							twxm1 = twxm1 + tmpx;
						}
					}
					if (n1 % 2 == 1)
					{

						//
						// Handle residual chunk
						//
						x = a[offs + 0];
						y = a[offs + 1];
						tmpx = x * (1 + twxm1) - y * twy;
						tmpy = x * twy + y * (1 + twxm1);
						a[offs + 0] = tmpx;
						a[offs + 1] = tmpy;
						offs = offs + 2;
					}

					//
					// update TwRow: TwRow(new) = TwRow(old)*TwBase
					//
					if (i < n2 - 1)
					{
						if ((i + 1) % updatetw == 0)
						{
							v = (double)(-(2 * Math.PI * (i + 1) / n));
							twrowxm1 = (double)(Math.Sin(0.5f * v));
							twrowxm1 = -(2 * twrowxm1 * twrowxm1);
							twrowy = (double)(Math.Sin(v));
						}
						else
						{
							tmpx = twbasexm1 + twrowxm1 * twbasexm1 - twrowy * twbasey;
							tmpy = twbasey + twrowxm1 * twbasey + twrowy * twbasexm1;
							twrowxm1 = twrowxm1 + tmpx;
							twrowy = twrowy + tmpy;
						}
					}
				}
			}


			/*************************************************************************
			Linear transpose: transpose complex matrix stored in 1-dimensional array

				-- ALGLIB --
					 Copyright 01.05.2009 by Bochkanov Sergey
			*************************************************************************/
			private static void internalcomplexlintranspose(double[] a,
					int m,
					int n,
					int astart,
					double[] buf)
			{
				int i_ = 0;
				int i1_ = 0;

				ffticltrec(a, astart, n, buf, 0, m, m, n);
				i1_ = (0) - (astart);
				for (i_ = astart; i_ <= astart + 2 * m * n - 1; i_++)
				{
					a[i_] = buf[i_ + i1_];
				}
			}


			/*************************************************************************
			Recurrent subroutine for a InternalComplexLinTranspose

			Write A^T to B, where:
			* A is m*n complex matrix stored in array A as pairs of real/image values,
				beginning from AStart position, with AStride stride
			* B is n*m complex matrix stored in array B as pairs of real/image values,
				beginning from BStart position, with BStride stride
			stride is measured in complex numbers, i.e. in real/image pairs.

				-- ALGLIB --
					 Copyright 01.05.2009 by Bochkanov Sergey
			*************************************************************************/
			private static void ffticltrec(double[] a,
					int astart,
					int astride,
					double[] b,
					int bstart,
					int bstride,
					int m,
					int n)
			{
				int i = 0;
				int j = 0;
				int idx1 = 0;
				int idx2 = 0;
				int m2 = 0;
				int m1 = 0;
				int n1 = 0;

				if (m == 0 || n == 0)
				{
					return;
				}
				if (Math.Max(m, n) <= 8)
				{
					m2 = 2 * bstride;
					for (i = 0; i <= m - 1; i++)
					{
						idx1 = bstart + 2 * i;
						idx2 = astart + 2 * i * astride;
						for (j = 0; j <= n - 1; j++)
						{
							b[idx1 + 0] = a[idx2 + 0];
							b[idx1 + 1] = a[idx2 + 1];
							idx1 = idx1 + m2;
							idx2 = idx2 + 2;
						}
					}
					return;
				}
				if (n > m)
				{

					//
					// New partition:
					//
					// "A^T -> B" becomes "(A1 A2)^T -> ( B1 )
					//                                  ( B2 )
					//
					n1 = n / 2;
					if (n - n1 >= 8 && n1 % 8 != 0)
					{
						n1 = n1 + (8 - n1 % 8);
					}
					alglib.ap.assert(n - n1 > 0);
					ffticltrec(a, astart, astride, b, bstart, bstride, m, n1);
					ffticltrec(a, astart + 2 * n1, astride, b, bstart + 2 * n1 * bstride, bstride, m, n - n1);
				}
				else
				{

					//
					// New partition:
					//
					// "A^T -> B" becomes "( A1 )^T -> ( B1 B2 )
					//                     ( A2 )
					//
					m1 = m / 2;
					if (m - m1 >= 8 && m1 % 8 != 0)
					{
						m1 = m1 + (8 - m1 % 8);
					}
					alglib.ap.assert(m - m1 > 0);
					ffticltrec(a, astart, astride, b, bstart, bstride, m1, n);
					ffticltrec(a, astart + 2 * m1 * astride, astride, b, bstart + 2 * m1, bstride, m - m1, n);
				}
			}


			/*************************************************************************
			Recurrent subroutine for a InternalRealLinTranspose


				-- ALGLIB --
					 Copyright 01.05.2009 by Bochkanov Sergey
			*************************************************************************/
			private static void fftirltrec(ref double[] a,
					int astart,
					int astride,
					ref double[] b,
					int bstart,
					int bstride,
					int m,
					int n)
			{
				int i = 0;
				int j = 0;
				int idx1 = 0;
				int idx2 = 0;
				int m1 = 0;
				int n1 = 0;

				if (m == 0 || n == 0)
				{
					return;
				}
				if (Math.Max(m, n) <= 8)
				{
					for (i = 0; i <= m - 1; i++)
					{
						idx1 = bstart + i;
						idx2 = astart + i * astride;
						for (j = 0; j <= n - 1; j++)
						{
							b[idx1] = a[idx2];
							idx1 = idx1 + bstride;
							idx2 = idx2 + 1;
						}
					}
					return;
				}
				if (n > m)
				{

					//
					// New partition:
					//
					// "A^T -> B" becomes "(A1 A2)^T -> ( B1 )
					//                                  ( B2 )
					//
					n1 = n / 2;
					if (n - n1 >= 8 && n1 % 8 != 0)
					{
						n1 = n1 + (8 - n1 % 8);
					}
					alglib.ap.assert(n - n1 > 0);
					fftirltrec(ref a, astart, astride, ref b, bstart, bstride, m, n1);
					fftirltrec(ref a, astart + n1, astride, ref b, bstart + n1 * bstride, bstride, m, n - n1);
				}
				else
				{

					//
					// New partition:
					//
					// "A^T -> B" becomes "( A1 )^T -> ( B1 B2 )
					//                     ( A2 )
					//
					m1 = m / 2;
					if (m - m1 >= 8 && m1 % 8 != 0)
					{
						m1 = m1 + (8 - m1 % 8);
					}
					alglib.ap.assert(m - m1 > 0);
					fftirltrec(ref a, astart, astride, ref b, bstart, bstride, m1, n);
					fftirltrec(ref a, astart + m1 * astride, astride, ref b, bstart + m1, bstride, m - m1, n);
				}
			}


			/*************************************************************************
			recurrent subroutine for FFTFindSmoothRec

				-- ALGLIB --
					 Copyright 01.05.2009 by Bochkanov Sergey
			*************************************************************************/
			private static void ftbasefindsmoothrec(int n,
					int seed,
					int leastfactor,
					ref int best)
			{
				alglib.ap.assert(ftbasemaxsmoothfactor <= 5, "FTBaseFindSmoothRec: internal error!");
				if (seed >= n)
				{
					best = Math.Min(best, seed);
					return;
				}
				if (leastfactor <= 2)
				{
					ftbasefindsmoothrec(n, seed * 2, 2, ref best);
				}
				if (leastfactor <= 3)
				{
					ftbasefindsmoothrec(n, seed * 3, 3, ref best);
				}
				if (leastfactor <= 5)
				{
					ftbasefindsmoothrec(n, seed * 5, 5, ref best);
				}
			}


		}
		public class nearunityunit
		{
			public static double nulog1p(double x)
			{
				double result = 0;
				double z = 0;
				double lp = 0;
				double lq = 0;

				z = 1.0f + x;
				if ((double)(z) < (double)(0.70710678118654752440) || (double)(z) > (double)(1.41421356237309504880))
				{
					result = (double)Math.Log(z);
					return result;
				}
				z = x * x;
				lp = (double)(4.5270000862445199635215E-5);
				lp = (double)(lp * x + 4.9854102823193375972212E-1);
				lp = (double)(lp * x + 6.5787325942061044846969E0);
				lp = (double)(lp * x + 2.9911919328553073277375E1);
				lp = (double)(lp * x + 6.0949667980987787057556E1);
				lp = (double)(lp * x + 5.7112963590585538103336E1);
				lp = (double)(lp * x + 2.0039553499201281259648E1);
				lq = (double)(1.0000000000000000000000E0);
				lq = (double)(lq * x + 1.5062909083469192043167E1);
				lq = (double)(lq * x + 8.3047565967967209469434E1);
				lq = (double)(lq * x + 2.2176239823732856465394E2);
				lq = (double)(lq * x + 3.0909872225312059774938E2);
				lq = (double)(lq * x + 2.1642788614495947685003E2);
				lq = (double)(lq * x + 6.0118660497603843919306E1);
				z = -(0.5f * z) + x * (z * lp / lq);
				result = x + z;
				return result;
			}


			public static double nuexpm1(double x)
			{
				double result = 0;
				double r = 0;
				double xx = 0;
				double ep = 0;
				double eq = 0;

				if ((double)(x) < (double)(-0.5f) || (double)(x) > (double)(0.5f))
				{
					result = (double)(Math.Exp(x) - 1.0f);
					return result;
				}
				xx = x * x;
				ep = (double)(1.2617719307481059087798E-4);
				ep = (double)(ep * xx + 3.0299440770744196129956E-2);
				ep = (double)(ep * xx + 9.9999999999999999991025E-1);
				eq = (double)(3.0019850513866445504159E-6);
				eq = (double)(eq * xx + 2.5244834034968410419224E-3);
				eq = (double)(eq * xx + 2.2726554820815502876593E-1);
				eq = (double)(eq * xx + 2.0000000000000000000897E0);
				r = x * ep;
				r = r / (eq - r);
				result = r + r;
				return result;
			}


			public static double nucosm1(double x)
			{
				double result = 0;
				double xx = 0;
				double c = 0;

				if ((double)(x) < (double)(-(0.25 * Math.PI)) || (double)(x) > (double)(0.25 * Math.PI))
				{
					result = (double)Math.Cos(x) - 1;
					return result;
				}
				xx = x * x;
				c = (double)(4.7377507964246204691685E-14);
				c = (double)(c * xx - 1.1470284843425359765671E-11);
				c = (double)(c * xx + 2.0876754287081521758361E-9);
				c = (double)(c * xx - 2.7557319214999787979814E-7);
				c = (double)(c * xx + 2.4801587301570552304991E-5);
				c = (double)(c * xx - 1.3888888888888872993737E-3);
				c = (double)(c * xx + 4.1666666666666666609054E-2);
				result = -(0.5f * xx) + xx * xx * c;
				return result;
			}


		}
		public class alglibbasics
		{


		}
	}
	#endregion
}
